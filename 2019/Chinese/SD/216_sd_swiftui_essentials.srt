1
00:00:01,176 --> 00:00:04,500
[音乐]


2
00:00:08,321 --> 00:00:10,321
[掌声]


3
00:00:10,626 --> 00:00:15,736
>> 早上好 [掌声]


4
00:00:16,236 --> 00:00:18,316
早上好 欢迎来到 SwiftUI


5
00:00:18,436 --> 00:00:19,136
Essentials 项目


6
00:00:19,696 --> 00:00:21,376
我是 Matt Ricketson


7
00:00:21,376 --> 00:00:23,276
我目前在做 SwiftUI 项目 稍后


8
00:00:23,276 --> 00:00:24,676
我的同事 Taylor 也会为大家讲解


9
00:00:25,276 --> 00:00:26,906
那么目前大家觉得 SwiftUI 怎么样呢


10
00:00:27,516 --> 00:00:32,396
[掌声]


11
00:00:32,896 --> 00:00:34,566
我也是 今天我非常激动


12
00:00:34,566 --> 00:00:36,436
能和各位聊一聊 SwiftUI


13
00:00:37,266 --> 00:00:38,126
我们要讲很多内容


14
00:00:38,126 --> 00:00:39,846
所以让我们开始吧


15
00:00:42,036 --> 00:00:44,606
SwiftUI 是一个新框架


16
00:00:45,066 --> 00:00:46,876
旨在为大家构建优秀


17
00:00:46,876 --> 00:00:49,686
App 提供最优捷径


18
00:00:50,456 --> 00:00:51,736
这意味着为你提供构建


19
00:00:51,736 --> 00:00:55,026
优秀用户界面的最短路径


20
00:00:55,886 --> 00:00:57,876
虽然 SwiftUI 是一个


21
00:00:57,876 --> 00:00:59,846
新框架 但其中的很多内容


22
00:00:59,846 --> 00:01:01,156
对你来说已经很熟悉了


23
00:01:01,766 --> 00:01:04,056
这是因为它包含了


24
00:01:04,056 --> 00:01:05,626
UI 框架的


25
00:01:05,626 --> 00:01:06,916
所有基本组件


26
00:01:07,846 --> 00:01:10,966
它有按钮和文本字段等控件


27
00:01:11,856 --> 00:01:13,896
它有像栈和列表


28
00:01:13,896 --> 00:01:15,236
这样的布局容器


29
00:01:15,886 --> 00:01:19,106
它有绘图 动画和手势


30
00:01:19,476 --> 00:01:21,236
SwiftUI 甚至支持


31
00:01:21,536 --> 00:01:23,586
特定于平台的概念


32
00:01:23,586 --> 00:01:25,756
比如 Mac 上的菜单


33
00:01:25,756 --> 00:01:27,946
Apple Watch 上的数字表冠


34
00:01:27,946 --> 00:01:29,596
和 Apple TV 上的 Siri Remote 遥控器


35
00:01:29,596 --> 00:01:33,066
因此 我们要记住的是


36
00:01:33,066 --> 00:01:34,596
我们并非试图利用


37
00:01:34,596 --> 00:01:35,546
SwiftUI 重新发明轮子


38
00:01:36,776 --> 00:01:39,196
但我们都知道 事实是


39
00:01:39,196 --> 00:01:40,666
仅仅知道如何使用


40
00:01:40,666 --> 00:01:42,906
这些组件并不足以构建


41
00:01:42,906 --> 00:01:45,026
一个出色的 App


42
00:01:45,916 --> 00:01:48,186
因为一个出色的 App


43
00:01:48,186 --> 00:01:50,636
也需要考虑以下这些因素


44
00:01:51,346 --> 00:01:53,326
它必须要易于使用


45
00:01:53,326 --> 00:01:55,246
并且支持动态类型


46
00:01:56,366 --> 00:01:57,546
它需要适用于不同设备


47
00:01:57,546 --> 00:02:00,936
屏幕大小和输入类型


48
00:02:01,366 --> 00:02:03,216
它还需要像交互式动画


49
00:02:03,466 --> 00:02:08,066
这样的东西和对深色模式和拖放等


50
00:02:08,526 --> 00:02:09,256
系统功能的支持


51
00:02:10,795 --> 00:02:12,216
这些可以让


52
00:02:12,646 --> 00:02:14,386
你的 App 接触到


53
00:02:14,386 --> 00:02:16,146
尽可能多的用户


54
00:02:16,146 --> 00:02:18,436
并让它紧跟潮流


55
00:02:19,046 --> 00:02:23,206
我们都知道这


56
00:02:23,206 --> 00:02:24,916
不是全部的内容


57
00:02:26,056 --> 00:02:27,516
因为你当然也添加了


58
00:02:27,516 --> 00:02:29,346
你自己独特的功能


59
00:02:29,346 --> 00:02:31,416
让你的 App 脱颖而出


60
00:02:32,476 --> 00:02:34,206
所以我想花点


61
00:02:34,206 --> 00:02:35,756
时间重申一下


62
00:02:36,546 --> 00:02:38,756
我们还有很多东西需要学习


63
00:02:39,796 --> 00:02:40,706
需要编写的代码和维护的


64
00:02:40,706 --> 00:02:43,116
东西很多 那么 SwiftUI


65
00:02:43,116 --> 00:02:45,496
是如何帮你完成这些工作呢


66
00:02:48,036 --> 00:02:49,586
请各位先想一下自己的 App


67
00:02:50,606 --> 00:02:51,636
首先 你有大家希望


68
00:02:51,636 --> 00:02:53,546
从你的 App 中获得的


69
00:02:53,546 --> 00:02:55,596
基本功能 比如控制和导航


70
00:02:55,596 --> 00:02:57,576
易于使用并根据不同


71
00:02:57,696 --> 00:02:59,536
的设备调整布局


72
00:03:00,856 --> 00:03:02,956
我们需要做这些事情


73
00:03:02,956 --> 00:03:04,596
我们需要它们来构建


74
00:03:04,596 --> 00:03:06,206
一个真正出色的 App


75
00:03:08,606 --> 00:03:09,296
但还有一些对于你的


76
00:03:09,296 --> 00:03:11,636
App 来说令人激动的


77
00:03:11,636 --> 00:03:12,476
独一无二的自定义功能


78
00:03:12,476 --> 00:03:14,776
这些也是有趣的功能


79
00:03:14,776 --> 00:03:16,996
我们为这些有趣的


80
00:03:16,996 --> 00:03:19,046
功能倾注了热情


81
00:03:19,046 --> 00:03:21,606
我们也为能构建出它们而感到骄傲


82
00:03:22,856 --> 00:03:24,816
所以 SwiftUI 的目标


83
00:03:24,896 --> 00:03:27,376
非常简单 我们希望


84
00:03:27,376 --> 00:03:28,736
你把尽可能多的时间


85
00:03:28,736 --> 00:03:30,966
花在有趣的功能上


86
00:03:30,966 --> 00:03:32,666
而不是花在基本功能上


87
00:03:32,756 --> 00:03:35,746
在不用牺牲质量前提下


88
00:03:36,856 --> 00:03:38,986
这就是我们所说的


89
00:03:38,986 --> 00:03:41,956
构建优秀 App 的最短路径


90
00:03:42,176 --> 00:03:43,346
因为各位都已经在


91
00:03:43,346 --> 00:03:44,346
构建优秀的 App 了


92
00:03:45,116 --> 00:03:47,956
我们只是想让大家更快地达成目标


93
00:03:50,056 --> 00:03:51,536
本次演讲是为了让大家


94
00:03:51,576 --> 00:03:53,206
更好地了解 SwiftUI


95
00:03:53,206 --> 00:03:54,986
我们会看一些代码


96
00:03:54,986 --> 00:03:56,736
但我们也会讨论


97
00:03:56,736 --> 00:03:58,796
SwiftUI 的设计以及


98
00:03:58,796 --> 00:04:00,746
它如何能帮你构建更好的 App


99
00:04:01,846 --> 00:04:02,816
本次演讲过后


100
00:04:03,586 --> 00:04:04,916
你就能够使用 SwiftUI


101
00:04:04,916 --> 00:04:07,176
构建一个完整的用户界面


102
00:04:07,916 --> 00:04:10,886
我们首先从视图和


103
00:04:10,886 --> 00:04:13,646
修饰符的基本内容讲起


104
00:04:14,636 --> 00:04:16,796
那么我们将需要一个例子


105
00:04:17,055 --> 00:04:18,166
我总是试着选择


106
00:04:18,166 --> 00:04:21,546
一个我关心的例子来激励我


107
00:04:22,896 --> 00:04:24,726
如果大家最近上网


108
00:04:24,726 --> 00:04:26,416
可能会看到千禧一代


109
00:04:26,416 --> 00:04:27,446
比如像我自己


110
00:04:27,506 --> 00:04:30,576
把这个东西当成我们


111
00:04:30,756 --> 00:04:34,266
生活中最重要的部分


112
00:04:35,956 --> 00:04:38,876
没错 牛油果吐司


113
00:04:39,016 --> 00:04:41,016
[笑声]


114
00:04:41,516 --> 00:04:44,566
[掌声]


115
00:04:45,066 --> 00:04:46,806
看来我们的观众里有千禧一代


116
00:04:47,116 --> 00:04:49,196
所以今天我们要做一个


117
00:04:49,196 --> 00:04:51,306
App 来点牛油果吐司


118
00:04:51,896 --> 00:04:53,136
我已经做了一些内容


119
00:04:53,136 --> 00:04:54,416
所以它现在看起来


120
00:04:54,416 --> 00:04:55,496
是这样的


121
00:04:56,616 --> 00:04:58,596
这是一个简单的形式


122
00:04:58,596 --> 00:04:59,896
让我能立刻从手机上


123
00:04:59,896 --> 00:05:01,066
点我想要的食物


124
00:05:02,096 --> 00:05:03,536
显然 它目前为止还没有


125
00:05:03,536 --> 00:05:04,876
很多内容 但我们会在


126
00:05:04,876 --> 00:05:06,016
整个演讲中继续构建


127
00:05:07,026 --> 00:05:09,456
但在深入研究代码之前 我想先


128
00:05:09,456 --> 00:05:11,016
谈一下视图


129
00:05:11,586 --> 00:05:15,346
这是因为视图是用户


130
00:05:15,346 --> 00:05:17,746
界面的基本构建块


131
00:05:18,636 --> 00:05:19,856
它对我们构建 SwiftUI


132
00:05:19,856 --> 00:05:21,996
每一环节都非常重要


133
00:05:23,776 --> 00:05:25,586
如果你之前使用过其他


134
00:05:25,586 --> 00:05:27,806
UI 框架 比如 UIKit 或


135
00:05:27,806 --> 00:05:30,066
AppKit 你可能已经


136
00:05:30,136 --> 00:05:31,196
听说过视图这一术语


137
00:05:32,676 --> 00:05:34,756
SwiftUI 也有视图


138
00:05:34,756 --> 00:05:36,726
它们的主要作用与它们在


139
00:05:36,726 --> 00:05:38,146
这些框架中的作用相同


140
00:05:39,676 --> 00:05:42,146
从高层级来讲


141
00:05:42,146 --> 00:05:47,306
视图只是定义 UI 的一部分


142
00:05:47,566 --> 00:05:49,146
当你看一个 App 时


143
00:05:49,146 --> 00:05:50,826
你看到的一切都是


144
00:05:50,826 --> 00:05:52,096
由视图定义的


145
00:05:53,656 --> 00:05:55,116
单独的控件是视图


146
00:05:56,426 --> 00:05:59,306
容纳它们的容器也是视图


147
00:05:59,656 --> 00:06:02,026
事实上 你在屏幕上


148
00:06:02,026 --> 00:06:03,616
看到的每一个像素都可以


149
00:06:03,616 --> 00:06:05,606
以某种方式追溯为视图


150
00:06:06,206 --> 00:06:09,306
我们通过将这些


151
00:06:09,306 --> 00:06:11,226
视图组合成控制架构


152
00:06:11,226 --> 00:06:12,826
来构建用户界面


153
00:06:13,306 --> 00:06:16,026
从底部的容器


154
00:06:16,866 --> 00:06:21,776
到底部的文本 图像和形状


155
00:06:24,076 --> 00:06:25,446
如果你以前用过


156
00:06:25,446 --> 00:06:26,826
UIKit 或 AppKit


157
00:06:26,826 --> 00:06:28,176
应该很熟悉这幅图


158
00:06:28,316 --> 00:06:29,526
重要的是要理解


159
00:06:29,526 --> 00:06:33,706
SwiftUI 的视图也是如此


160
00:06:33,706 --> 00:06:36,636
SwiftUI 可能与你


161
00:06:36,636 --> 00:06:38,316
习惯的不同之处在于


162
00:06:38,316 --> 00:06:41,166
视图在代码中的表达方式


163
00:06:42,116 --> 00:06:44,966
我们来看一些代码


164
00:06:45,516 --> 00:06:47,356
在我们的示例 App 中


165
00:06:47,356 --> 00:06:49,676
我们只有一个垂直栈包括控件和文本


166
00:06:50,276 --> 00:06:52,656
通过代码很容易看出这一点


167
00:06:55,186 --> 00:06:56,236
但实际上 你会注意到


168
00:06:56,286 --> 00:06:57,886
左边的代码与右边的


169
00:06:58,776 --> 00:07:00,086
等价视图层次关系


170
00:07:00,086 --> 00:07:01,666
视图非常匹配


171
00:07:03,276 --> 00:07:04,586
在栈的根目录中


172
00:07:04,586 --> 00:07:09,506
栈包含了文本和控件


173
00:07:10,276 --> 00:07:12,316
指向每个控件中


174
00:07:12,646 --> 00:07:14,306
包含的单个文本标签


175
00:07:18,046 --> 00:07:19,816
现在你看不到的是对函数的调用


176
00:07:19,816 --> 00:07:21,526
比如添加子视图


177
00:07:23,146 --> 00:07:24,356
因为我们不是


178
00:07:24,356 --> 00:07:25,426
一点一点地构建视图层次


179
00:07:25,426 --> 00:07:27,636
而是将它初始化为


180
00:07:27,636 --> 00:07:29,976
一个完整的组合结构


181
00:07:31,626 --> 00:07:34,006
这是因为 SwiftUI


182
00:07:34,006 --> 00:07:36,926
以声明的方式定义


183
00:07:36,926 --> 00:07:38,266
其视图 而非强制


184
00:07:39,136 --> 00:07:41,126
我想不出比


185
00:07:41,126 --> 00:07:42,286
牛油果吐司更好的


186
00:07:42,286 --> 00:07:45,526
类比来解释这些概念了


187
00:07:45,776 --> 00:07:47,976
所以让我们试着用命令式代码做牛油果吐司


188
00:07:50,556 --> 00:07:51,956
命令式代码包括


189
00:07:51,956 --> 00:07:54,826
通过发送显式命令来构建结果


190
00:07:55,966 --> 00:07:57,116
这有点像在电话里


191
00:07:57,116 --> 00:07:59,686
教朋友做牛油果吐司


192
00:08:01,186 --> 00:08:02,186
你开始告诉他们


193
00:08:02,186 --> 00:08:03,766
需要什么原料


194
00:08:03,766 --> 00:08:06,496
什么设备 然后开始


195
00:08:06,496 --> 00:08:08,876
指导他们做吐司和切牛油果


196
00:08:08,876 --> 00:08:10,506
所有这些指导


197
00:08:10,506 --> 00:08:13,366
开始变得有啰嗦


198
00:08:13,666 --> 00:08:16,126
如果你的朋友


199
00:08:16,126 --> 00:08:17,956
搞砸了任何一个小步骤


200
00:08:17,956 --> 00:08:20,146
比如忘记烤面包 那么


201
00:08:20,206 --> 00:08:21,686
最后的结果就毁了


202
00:08:24,216 --> 00:08:25,626
现在让我们把它和


203
00:08:25,626 --> 00:08:27,606
牛油果吐司做个比较


204
00:08:29,466 --> 00:08:30,526
声明代码包括通过


205
00:08:30,526 --> 00:08:32,546
描述你想要的内容


206
00:08:32,546 --> 00:08:36,126
然后让其他人来想办法如何为你构建结果


207
00:08:36,696 --> 00:08:39,476
这有点像从牛油果师傅


208
00:08:39,476 --> 00:08:42,655
那里点牛油果吐司


209
00:08:45,596 --> 00:08:47,766
幸运的是 加州有很多这样的面包店


210
00:08:49,726 --> 00:08:50,936
现在你要做的就是


211
00:08:50,936 --> 00:08:51,886
说出你想要的


212
00:08:52,416 --> 00:08:55,336
你甚至可以插入自定义指令


213
00:08:55,936 --> 00:08:58,156
就是这样


214
00:08:58,416 --> 00:08:59,826
因为有专家为我们制作


215
00:08:59,826 --> 00:09:01,326
所以我们能保证


216
00:09:01,326 --> 00:09:02,766
得到高质量的结果


217
00:09:03,446 --> 00:09:06,006
现在让我们继续看一下代码


218
00:09:06,176 --> 00:09:08,476
SwiftUI 将充当专家的角色


219
00:09:08,476 --> 00:09:10,426
随时为您提供帮助


220
00:09:11,376 --> 00:09:13,506
在代码中 我们通过


221
00:09:13,506 --> 00:09:17,136
初始化编码这些关系的结构


222
00:09:17,136 --> 00:09:20,976
来声明视图之间的架构关系


223
00:09:23,416 --> 00:09:25,726
SwiftUI 会将你的


224
00:09:26,086 --> 00:09:29,326
视图转换为屏幕上


225
00:09:29,326 --> 00:09:30,736
呈现的结果


226
00:09:33,166 --> 00:09:34,186
关于这个还有很多要讲


227
00:09:34,186 --> 00:09:35,776
但是现在让我们先


228
00:09:35,776 --> 00:09:37,876
习惯一下代码中的语法


229
00:09:38,326 --> 00:09:40,326
我们将从容器视图开始


230
00:09:43,356 --> 00:09:44,706
容器视图声明为


231
00:09:44,706 --> 00:09:46,686
作为其内容的


232
00:09:46,746 --> 00:09:47,816
其他视图的组合


233
00:09:49,806 --> 00:09:51,096
这些内容视图是在一种


234
00:09:51,096 --> 00:09:53,066
称为视图构建器的特殊


235
00:09:53,146 --> 00:09:54,366
类型的闭包中声明


236
00:09:55,946 --> 00:09:57,156
比如 我们已经看到了


237
00:09:57,156 --> 00:09:59,916
VStack 或垂直栈


238
00:09:59,916 --> 00:10:01,686
这是其中一个容器的例子


239
00:10:02,206 --> 00:10:04,586
视图构建器允许我们


240
00:10:04,586 --> 00:10:07,206
在闭包中编写声明代码


241
00:10:08,186 --> 00:10:09,466
我们可以在闭包中


242
00:10:09,466 --> 00:10:11,446
列出我们的内容 不是调用


243
00:10:11,446 --> 00:10:13,726
像 AddSubViews 这样的函数


244
00:10:14,476 --> 00:10:16,716
为了进一步了解


245
00:10:16,716 --> 00:10:17,916
它的工作原理 让我们


246
00:10:17,916 --> 00:10:19,876
看一下 VStack 的实际 API


247
00:10:20,366 --> 00:10:23,306
你可以看到内容参数


248
00:10:23,306 --> 00:10:25,776
被定义为一个闭包


249
00:10:26,296 --> 00:10:27,706
但使用这个 ViewBuilder


250
00:10:27,706 --> 00:10:28,176
属性进行了标记


251
00:10:29,446 --> 00:10:31,426
Swift Compiler 知道如何


252
00:10:31,426 --> 00:10:33,196
将此属性标记的闭包


253
00:10:33,236 --> 00:10:35,076
转换为一个新的闭包


254
00:10:35,076 --> 00:10:37,166
该闭包返回一个


255
00:10:37,166 --> 00:10:40,576
表示栈中所有内容的视图


256
00:10:42,106 --> 00:10:43,636
这是 SwiftUI 使用


257
00:10:44,256 --> 00:10:46,046
Swift 功能帮你编写


258
00:10:46,046 --> 00:10:47,966
更少代码的一个例子


259
00:10:51,416 --> 00:10:53,066
像 VStack 这样的视图


260
00:10:53,066 --> 00:10:55,006
还可以接受除内容之外的其他参数


261
00:10:55,426 --> 00:10:57,136
例如 我们可以配置


262
00:10:57,136 --> 00:10:59,136
我们的 VStack


263
00:10:59,136 --> 00:11:00,856
使其内容沿着前缘对齐


264
00:11:00,856 --> 00:11:02,696
而不是使用默认的中心对齐


265
00:11:06,486 --> 00:11:08,356
总之 这是一种


266
00:11:08,356 --> 00:11:10,986
非常好的自然语法


267
00:11:10,986 --> 00:11:12,676
允许我们使用大括号


268
00:11:12,676 --> 00:11:15,416
和缩进来区分


269
00:11:15,416 --> 00:11:17,336
容器视图及其


270
00:11:17,336 --> 00:11:21,076
配置和其中的内容


271
00:11:24,046 --> 00:11:24,966
我们也遵循许多控件的语法


272
00:11:24,966 --> 00:11:26,506
因为 SwiftUI


273
00:11:26,506 --> 00:11:28,976
里的大多数控件也是容器


274
00:11:31,046 --> 00:11:32,476
这在我们的实例 App 中可以看到


275
00:11:32,476 --> 00:11:34,566
在每种情况下 我们的控件


276
00:11:34,566 --> 00:11:36,776
都定义了一段文本作为


277
00:11:36,776 --> 00:11:39,396
它们的标签 用于描述它们的用途


278
00:11:42,046 --> 00:11:43,516
现在我们在这不仅可以放文本


279
00:11:43,516 --> 00:11:44,516
我们可以放任何一种视图


280
00:11:45,396 --> 00:11:46,886
我们将在稍后对此


281
00:11:46,886 --> 00:11:47,716
进行更深入的讨论


282
00:11:49,636 --> 00:11:51,466
这里看到的另一种


283
00:11:51,466 --> 00:11:53,266
语法是 Toggles 和


284
00:11:53,676 --> 00:11:55,976
Stepper 命令中的美元符号


285
00:11:57,426 --> 00:11:58,466
前面的美元符号


286
00:11:58,546 --> 00:12:00,206
表示我们正在向


287
00:12:00,316 --> 00:12:02,166
控件传递一个绑定


288
00:12:02,166 --> 00:12:03,366
而非一个普通的值


289
00:12:04,796 --> 00:12:05,886
那么什么是绑定呢


290
00:12:06,356 --> 00:12:09,366
在我们的示例 App 中


291
00:12:09,366 --> 00:12:11,106
Stepper 包含在一个视图中


292
00:12:11,106 --> 00:12:12,606
该视图依赖于持续


293
00:12:12,606 --> 00:12:13,676
追踪当前订单的状态


294
00:12:13,966 --> 00:12:15,786
它使用 @State 属性


295
00:12:15,786 --> 00:12:18,386
来定义订单的特性


296
00:12:19,536 --> 00:12:21,116
当 SwiftUI 看到用


297
00:12:21,116 --> 00:12:22,926
该属性标记的特性时


298
00:12:22,926 --> 00:12:24,346
它会自动在后台创建


299
00:12:24,346 --> 00:12:26,226
并持续管理状态


300
00:12:26,226 --> 00:12:28,336
然后通过该属性


301
00:12:28,336 --> 00:12:30,976
公开该状态的值


302
00:12:34,106 --> 00:12:36,096
在本例中 它包含


303
00:12:36,096 --> 00:12:37,656
一个我自己定义的 struct


304
00:12:38,746 --> 00:12:40,696
它表示我们所有的订单信息


305
00:12:43,096 --> 00:12:45,276
如果我们只想读写


306
00:12:45,336 --> 00:12:47,616
@State 的数据是很简单的


307
00:12:47,806 --> 00:12:50,116
我们可以直接读写属性


308
00:12:51,316 --> 00:12:52,376
当我们为 Stepper 做


309
00:12:52,376 --> 00:12:53,806
标签时 我们就这样做了


310
00:12:56,136 --> 00:12:58,016
然而 Stepper 还需要


311
00:12:58,016 --> 00:12:59,896
在按钮被轻点时的状态


312
00:12:59,896 --> 00:13:01,056
能够编辑 State


313
00:13:02,306 --> 00:13:05,886
我们使用这个美元符号前缀来表示


314
00:13:05,886 --> 00:13:08,306
我们应该传递一个绑定到


315
00:13:08,306 --> 00:13:09,846
Quantity 属性中


316
00:13:10,656 --> 00:13:13,296
而非只传递一个只读值


317
00:13:14,836 --> 00:13:17,056
绑定是一种托管参考


318
00:13:17,136 --> 00:13:19,106
允许一个视图编辑


319
00:13:19,506 --> 00:13:21,456
另一个视图的状态


320
00:13:24,456 --> 00:13:26,016
现在 要了解更多关于状态


321
00:13:26,016 --> 00:13:27,976
和绑定以及如何管理


322
00:13:28,146 --> 00:13:29,196
App 中使用的所有


323
00:13:29,196 --> 00:13:31,056
其他类型的数据依赖


324
00:13:31,056 --> 00:13:32,796
我强烈建议


325
00:13:32,796 --> 00:13:34,216
大家看一下视频


326
00:13:34,216 --> 00:13:35,296
《Data Flow Through SwiftUI》


327
00:13:35,906 --> 00:13:38,066
但是现在 重点是


328
00:13:38,066 --> 00:13:40,496
要记住如果你曾经


329
00:13:40,496 --> 00:13:41,866
看到过一个属性 比如


330
00:13:41,866 --> 00:13:44,536
@State 它通常表示


331
00:13:44,986 --> 00:13:48,806
SwiftUI 在幕后代你管理的某种


332
00:13:48,806 --> 00:13:50,546
数据依赖关系


333
00:13:52,156 --> 00:13:53,726
如果你看到一个美元符号前缀


334
00:13:53,726 --> 00:13:55,876
那通常表示我们在


335
00:13:55,876 --> 00:13:57,596
传递一个被绑定的参数


336
00:13:57,676 --> 00:13:57,976
到另一个视图


337
00:14:03,046 --> 00:14:04,106
回到我们的实例 App


338
00:14:04,106 --> 00:14:06,256
还有一个更重要的


339
00:14:06,256 --> 00:14:08,236
语法我们还没有讨论


340
00:14:08,516 --> 00:14:09,556
你可以看到我们在上面


341
00:14:09,556 --> 00:14:12,476
为标题设置字体


342
00:14:14,016 --> 00:14:19,676
让我们把它放大 首先初始化文本


343
00:14:21,106 --> 00:14:22,476
这也是 SwiftUI


344
00:14:22,476 --> 00:14:23,466
另一种视图


345
00:14:26,046 --> 00:14:27,556
然后 我们在 Text


346
00:14:27,556 --> 00:14:29,906
文本上调用一个方法 并将


347
00:14:29,906 --> 00:14:32,296
系统定义的文本传递给它


348
00:14:32,936 --> 00:14:35,116
这种方法在 SwiftUI


349
00:14:35,116 --> 00:14:36,736
中称为修饰语句


350
00:14:37,526 --> 00:14:39,626
修饰语句只是一个


351
00:14:40,076 --> 00:14:42,076
从现有视图创建


352
00:14:42,076 --> 00:14:42,766
新视图的方法


353
00:14:45,086 --> 00:14:46,406
我的意思就是


354
00:14:47,516 --> 00:14:48,846
这是没有 font


355
00:14:48,846 --> 00:14:49,976
修饰语句时 UI 的样子


356
00:14:49,976 --> 00:14:52,046
在这种情况下


357
00:14:52,046 --> 00:14:55,146
只呈现默认的主体字体


358
00:14:56,356 --> 00:14:57,966
这就是视图架构


359
00:14:57,966 --> 00:14:58,746
关系图的样子


360
00:14:59,536 --> 00:15:01,226
我们看到 VStack


361
00:15:01,446 --> 00:15:02,806
中包含了我们的文本


362
00:15:06,076 --> 00:15:07,766
当文本被修改时


363
00:15:07,766 --> 00:15:10,826
将插入一个新视图 来包装现有的文本


364
00:15:11,656 --> 00:15:13,616
新视图指示 SwiftUI


365
00:15:13,616 --> 00:15:15,586
用新的 front 来呈现文本


366
00:15:17,396 --> 00:15:18,436
这些修饰符甚至


367
00:15:18,436 --> 00:15:18,996
可以链接在一起


368
00:15:20,076 --> 00:15:21,356
例如 我们可以通过


369
00:15:21,356 --> 00:15:22,886
添加前景颜色修饰语句


370
00:15:22,886 --> 00:15:24,506
来更改标题的文本颜色


371
00:15:25,986 --> 00:15:27,436
这将为视图架构中添加


372
00:15:27,436 --> 00:15:29,556
另一个视图 该视图将包装


373
00:15:29,686 --> 00:15:30,386
修饰语句视图


374
00:15:34,286 --> 00:15:35,866
显然 我们的视图架构


375
00:15:36,426 --> 00:15:38,236
很快就会变大


376
00:15:38,236 --> 00:15:40,546
对于经验丰富的 UI


377
00:15:40,546 --> 00:15:42,236
程序员来说 这可能


378
00:15:42,236 --> 00:15:43,506
会为他们做内部


379
00:15:43,596 --> 00:15:44,186
控件时提个醒


380
00:15:45,006 --> 00:15:46,586
因为多年来 我们


381
00:15:46,716 --> 00:15:48,606
训练自己通过让


382
00:15:48,606 --> 00:15:50,396
视图层级架构尽可能


383
00:15:50,396 --> 00:15:52,046
保持小和轻从而来


384
00:15:52,046 --> 00:15:54,506
优化 App 的性能


385
00:15:55,046 --> 00:15:58,366
但请记住 我们是在写


386
00:15:58,506 --> 00:15:59,556
定义代码


387
00:16:00,976 --> 00:16:03,486
SwiftUI 是我们的专业指导


388
00:16:03,876 --> 00:16:05,786
它会根据我们的意见


389
00:16:05,786 --> 00:16:07,366
根据我们点的菜


390
00:16:07,766 --> 00:16:09,426
熟练地编写出代码


391
00:16:10,326 --> 00:16:11,326
因此 即使我们必须将


392
00:16:11,326 --> 00:16:13,236
文本包装在多个封装器


393
00:16:13,236 --> 00:16:16,026
视图中 SwiftUI 也会


394
00:16:16,026 --> 00:16:17,916
在后台将其重叠成


395
00:16:17,966 --> 00:16:20,376
一个高效的数据结构


396
00:16:20,376 --> 00:16:22,236
然后供渲染系统使用


397
00:16:23,786 --> 00:16:25,066
你无需担心会


398
00:16:25,066 --> 00:16:26,506
影响性能 你会


399
00:16:27,376 --> 00:16:29,526
发现这种链接


400
00:16:29,526 --> 00:16:31,596
修饰语句实际上


401
00:16:31,596 --> 00:16:33,236
提供了很多好处


402
00:16:34,836 --> 00:16:37,406
比如 修饰符链能够


403
00:16:37,686 --> 00:16:41,476
强制执行视觉效果的确定顺序


404
00:16:43,586 --> 00:16:44,856
现在我们看到的是一段


405
00:16:44,856 --> 00:16:45,796
以绿色为背景的文字


406
00:16:46,736 --> 00:16:48,726
但是文本看起来有些过多


407
00:16:48,726 --> 00:16:50,446
所以让我们试着


408
00:16:50,446 --> 00:16:51,906
通过在文本周围添加一些


409
00:16:52,226 --> 00:16:53,496
间隔来扩展背景


410
00:16:56,046 --> 00:16:57,436
我们添加了间隔修饰符


411
00:16:57,436 --> 00:16:59,606
你可以看到它在视图层级中


412
00:16:59,606 --> 00:17:00,766
添加了一个新视图


413
00:17:01,896 --> 00:17:02,976
但屏幕上没有任何变化


414
00:17:06,046 --> 00:17:07,406
实际上间隔就在这里


415
00:17:07,406 --> 00:17:08,415
只是我们看不见而已


416
00:17:09,996 --> 00:17:11,195
我们来看一下代码


417
00:17:11,195 --> 00:17:12,876
我们的背景修饰符只是把


418
00:17:12,876 --> 00:17:15,036
文本包了起来 而没有改变间隔


419
00:17:15,586 --> 00:17:16,935
这表示间隔被


420
00:17:16,935 --> 00:17:18,786
应用到了背景之外


421
00:17:21,046 --> 00:17:22,646
幸运的是 通过移动


422
00:17:22,646 --> 00:17:23,976
背景修饰符来


423
00:17:23,976 --> 00:17:25,656
包装文本和添加间隔


424
00:17:25,656 --> 00:17:27,455
能轻易解决这个问题


425
00:17:32,046 --> 00:17:32,856
现在让我们再来看一下


426
00:17:32,856 --> 00:17:34,026
我们刚才做的事情


427
00:17:35,466 --> 00:17:36,716
想象一下 如果间隔


428
00:17:36,716 --> 00:17:38,116
和背景是文本上的属性


429
00:17:38,116 --> 00:17:40,226
而不是单独的修饰符


430
00:17:42,206 --> 00:17:43,726
这种情况下 如果没有


431
00:17:43,726 --> 00:17:45,416
反复试验或阅读过文档


432
00:17:45,416 --> 00:17:47,366
我们将无法知道


433
00:17:47,366 --> 00:17:49,246
他们的申请顺序


434
00:17:50,416 --> 00:17:52,566
相反 通过像这样将修饰符


435
00:17:52,566 --> 00:17:54,656
链接在一起 我们可以


436
00:17:54,656 --> 00:17:55,646
直接显示顺序


437
00:17:56,686 --> 00:17:57,976
我们也把它设计的很易于


438
00:17:57,976 --> 00:17:59,966
自定义 就像刚才那样


439
00:18:02,096 --> 00:18:03,036
现在 这些修饰符的


440
00:18:03,036 --> 00:18:04,476
另一个好处是它们可以


441
00:18:04,476 --> 00:18:06,056
在视图之间共享


442
00:18:06,486 --> 00:18:08,686
例如 这里我们对多种


443
00:18:08,796 --> 00:18:11,256
不同类型的控件


444
00:18:11,256 --> 00:18:12,566
应用了不透明效果


445
00:18:13,836 --> 00:18:14,846
我们甚至可以将


446
00:18:14,846 --> 00:18:16,376
不透明度应用于整个栈


447
00:18:17,356 --> 00:18:18,786
而不是每个单独的控件


448
00:18:19,906 --> 00:18:21,466
这些视图都不需要定义


449
00:18:21,466 --> 00:18:23,476
自己的不透明度属性


450
00:18:24,146 --> 00:18:25,766
这意味着它们


451
00:18:25,766 --> 00:18:28,156
可以拥有更简单


452
00:18:28,416 --> 00:18:29,526
更集中的接口


453
00:18:30,576 --> 00:18:33,316
这些就构成了 SwiftUI 的整体原理


454
00:18:36,046 --> 00:18:37,196
即倾向使用较小的


455
00:18:37,936 --> 00:18:39,216
单一用途的视图


456
00:18:40,446 --> 00:18:42,106
这些更简单的视图


457
00:18:42,106 --> 00:18:44,296
更容易理解


458
00:18:44,296 --> 00:18:45,966
也更容易在更长的时间内维护


459
00:18:47,436 --> 00:18:48,296
一旦你得到了所有


460
00:18:48,296 --> 00:18:50,076
这些小视图 你就可以把它们


461
00:18:50,076 --> 00:18:51,376
组合在一起来创建更大


462
00:18:51,476 --> 00:18:52,556
更复杂的视图


463
00:18:54,016 --> 00:18:56,986
SwiftUI 的整个框架


464
00:18:57,086 --> 00:18:59,336
都是围绕着小的代码段的


465
00:18:59,336 --> 00:19:01,466
的组合而设计 你应该用同样


466
00:19:01,466 --> 00:19:02,976
的方式来组织你的代码


467
00:19:05,246 --> 00:19:06,446
所以你可以从


468
00:19:06,446 --> 00:19:07,636
简单的文本开始


469
00:19:09,086 --> 00:19:10,786
你可以把它修改的更好


470
00:19:10,896 --> 00:19:12,666
你可以把它们组合在一起


471
00:19:12,666 --> 00:19:14,316
来创建一些优秀的程序


472
00:19:15,406 --> 00:19:17,066
比如像这个


473
00:19:17,066 --> 00:19:18,766
牛油果吐司 App


474
00:19:18,766 --> 00:19:20,216
就我个人而言


475
00:19:20,216 --> 00:19:21,966
我迫不及待地想看到大家


476
00:19:22,046 --> 00:19:23,226
都来使用 SwiftUI


477
00:19:23,226 --> 00:19:23,976
构建用户界面


478
00:19:26,466 --> 00:19:27,506
但在此之前


479
00:19:27,506 --> 00:19:28,366
我们首先需要知道如何


480
00:19:28,366 --> 00:19:31,056
构建我们的自定义视图


481
00:19:31,056 --> 00:19:32,456
现在让我们来创建一些新内容


482
00:19:35,616 --> 00:19:37,296
来看一下我们的 App


483
00:19:37,296 --> 00:19:39,666
我很想看一下我以前的订单历史


484
00:19:40,856 --> 00:19:42,266
我已经草拟了一个设计方案


485
00:19:42,896 --> 00:19:44,346
它只是一个简单的列表


486
00:19:44,346 --> 00:19:46,186
显示了每个订单的摘要


487
00:19:46,186 --> 00:19:48,446
以及我选择的配料的一些图标


488
00:19:50,136 --> 00:19:51,516
我已经写了一些代码


489
00:19:51,516 --> 00:19:53,306
让我们一步一步


490
00:19:53,306 --> 00:19:54,566
快速地来看一下


491
00:19:55,926 --> 00:19:58,286
首先 我定义了一个


492
00:19:58,896 --> 00:20:01,296
名为 OrderHistory 的


493
00:20:01,366 --> 00:20:02,926
新视图为一个符合视图协议的结构


494
00:20:04,176 --> 00:20:05,436
我们接下来还会讲到


495
00:20:06,466 --> 00:20:07,716
我的视图只有一个


496
00:20:07,716 --> 00:20:09,956
输入属性 即 previousOrders


497
00:20:09,956 --> 00:20:12,066
它只是我所有订单信息的集合


498
00:20:14,726 --> 00:20:16,136
我的视图有一个计算属性


499
00:20:16,136 --> 00:20:18,856
名为 body  它能够传回视图的内容


500
00:20:19,936 --> 00:20:21,246
这里我们使用的 sum


501
00:20:21,246 --> 00:20:22,956
关键词是 Swift 功能


502
00:20:22,956 --> 00:20:26,306
它允许 Swift 自动推断传回类型


503
00:20:30,046 --> 00:20:32,216
body 属性会传回一个列表


504
00:20:32,466 --> 00:20:34,676
该列表通过将之前的


505
00:20:34,676 --> 00:20:36,056
每个订单标记到一个


506
00:20:36,056 --> 00:20:39,036
新视图集合来生成


507
00:20:39,036 --> 00:20:41,736
其内容 每个订单使用


508
00:20:41,956 --> 00:20:43,976
另一个进行追踪的视图构建器


509
00:20:48,046 --> 00:20:49,566
现在我们已经理解了


510
00:20:49,726 --> 00:20:51,316
这段代码 让我们回过头来


511
00:20:51,316 --> 00:20:52,786
深入了解一下 SwiftUI


512
00:20:52,786 --> 00:20:55,766
为什么以这种方式定义自定义视图


513
00:20:57,286 --> 00:20:58,736
让我们从视图是如何能


514
00:20:58,796 --> 00:21:01,716
遵循视图协议的结构开始讲


515
00:21:02,466 --> 00:21:04,066
如果你用过 UIKit 或者


516
00:21:04,066 --> 00:21:06,456
AppKit 你可能已经


517
00:21:06,456 --> 00:21:07,786
习惯于将视图定义为


518
00:21:07,786 --> 00:21:09,696
用于将视图定义为继承


519
00:21:09,696 --> 00:21:12,176
公共视图超类的类


520
00:21:12,256 --> 00:21:14,076
而不是符合协议的结构


521
00:21:14,546 --> 00:21:17,686
例如 UIKit 中的自定义


522
00:21:17,686 --> 00:21:21,546
视图继承了 UIView 超类


523
00:21:22,556 --> 00:21:24,736
UIView 为 alpha 和


524
00:21:24,736 --> 00:21:26,076
backgroundColor 等常见


525
00:21:26,076 --> 00:21:27,356
视图属性定义了存储位置


526
00:21:27,906 --> 00:21:30,886
假设我们不用 SwiftUI


527
00:21:30,886 --> 00:21:33,636
而用 UIKit 来构建 OrderHistory


528
00:21:33,636 --> 00:21:36,586
我们的自定义视图将


529
00:21:36,586 --> 00:21:38,316
继承 UIView 的存储属性


530
00:21:38,556 --> 00:21:39,856
并为它自己的自定义


531
00:21:39,856 --> 00:21:41,506
行为添加更多的属性


532
00:21:43,116 --> 00:21:46,346
那么 SwiftUI 和这个有什么不同呢


533
00:21:46,676 --> 00:21:47,736
请记住 在 SwiftUI 中


534
00:21:48,486 --> 00:21:50,146
我们将这些相同类型的


535
00:21:50,146 --> 00:21:51,816
公共视图属性表示为单独的修饰符


536
00:21:51,816 --> 00:21:53,836
就像我们对不透明度


537
00:21:53,836 --> 00:21:55,416
和背景所做的那样


538
00:21:55,986 --> 00:21:59,286
每个修饰符都创建了自己的视图


539
00:22:00,536 --> 00:22:02,216
这意味着这些属性的


540
00:22:02,546 --> 00:22:03,856
存储位置 分布在我们的


541
00:22:03,906 --> 00:22:05,456
视图层级架构中


542
00:22:05,456 --> 00:22:07,206
的每个修饰符视图中


543
00:22:07,206 --> 00:22:09,416
而不是被每个


544
00:22:09,416 --> 00:22:12,046
单独的视图继承


545
00:22:13,576 --> 00:22:14,936
现在 这能让我们的视图


546
00:22:14,936 --> 00:22:16,856
变得更小 优化其存储空间


547
00:22:16,856 --> 00:22:19,636
以满足其各自的用途


548
00:22:22,046 --> 00:22:23,366
在这个世界上


549
00:22:23,366 --> 00:22:25,336
让视图成为协议是非常


550
00:22:25,336 --> 00:22:27,126
有意义的 因为它不再


551
00:22:27,126 --> 00:22:28,956
需要为所有视图


552
00:22:28,956 --> 00:22:31,066
提供公共存储模板


553
00:22:31,176 --> 00:22:34,126
但这个视图协议实际的用途是什么呢


554
00:22:34,626 --> 00:22:35,976
让我们记住


555
00:22:35,976 --> 00:22:37,796
视图的概念定义


556
00:22:38,946 --> 00:22:41,296
视图定义了 UI 的一部分


557
00:22:41,356 --> 00:22:45,076
我们通过组合小视图来


558
00:22:45,076 --> 00:22:46,716
构建更大的视图


559
00:22:47,216 --> 00:22:50,506
这就是视图协议的作用


560
00:22:51,306 --> 00:22:52,716
它定义了一个视图架构


561
00:22:52,716 --> 00:22:54,446
给了它一个名称


562
00:22:54,446 --> 00:22:55,986
这样就可以组合


563
00:22:55,986 --> 00:22:58,366
并重用你的整个 App


564
00:22:59,026 --> 00:23:00,956
每个具体类型的视图


565
00:23:01,266 --> 00:23:03,506
只是一个封装的其他视图


566
00:23:03,506 --> 00:23:04,886
代表其内容在其


567
00:23:04,886 --> 00:23:06,616
主体属性和所有


568
00:23:07,776 --> 00:23:09,516
必需的输入来创建


569
00:23:09,666 --> 00:23:12,386
这一由其属性呈现的视图


570
00:23:15,116 --> 00:23:16,916
现在实际协议


571
00:23:16,916 --> 00:23:18,906
只定义了传回另一种


572
00:23:19,176 --> 00:23:20,916
视图的主体属性


573
00:23:23,076 --> 00:23:24,736
但是仔细看一下


574
00:23:24,736 --> 00:23:26,416
这个定义 有些人


575
00:23:26,416 --> 00:23:29,726
可能会问这不是递归的吗


576
00:23:31,336 --> 00:23:33,246
如果我有一个视图


577
00:23:33,246 --> 00:23:35,186
它将 body 定义为


578
00:23:35,186 --> 00:23:38,256
另一种视图 那么这个视图


579
00:23:38,256 --> 00:23:39,306
将把它的 body


580
00:23:39,306 --> 00:23:41,976
定义为另一种视图


581
00:23:42,196 --> 00:23:44,686
它必须要结束 对吧


582
00:23:44,686 --> 00:23:47,746
它不能永远进行下去


583
00:23:50,046 --> 00:23:51,176
这样做的原因是


584
00:23:51,176 --> 00:23:54,746
SwiftUI 提供了多种原始视图


585
00:23:55,616 --> 00:23:56,756
即没有任何


586
00:23:56,756 --> 00:23:59,756
内容的视图


587
00:23:59,756 --> 00:24:01,736
这些视图表示所有其他


588
00:24:01,736 --> 00:24:03,676
视图都构建在这些


589
00:24:03,676 --> 00:24:04,976
原子构建块之上


590
00:24:07,046 --> 00:24:09,046
我们已经看到了文本


591
00:24:09,046 --> 00:24:10,626
图像是原始视图的


592
00:24:10,626 --> 00:24:11,876
另一个例子


593
00:24:13,336 --> 00:24:15,426
SwiftUI 还提供了


594
00:24:15,586 --> 00:24:16,596
用于绘制颜色和


595
00:24:16,596 --> 00:24:18,246
形状等基本元素和像


596
00:24:18,246 --> 00:24:19,276
Spacer 一样的基元


597
00:24:19,676 --> 00:24:23,096
实际上 你可以用


598
00:24:23,096 --> 00:24:25,196
SwiftUI 中的原始视图


599
00:24:25,196 --> 00:24:26,736
来绘制一些非常复杂的图形


600
00:24:27,766 --> 00:24:28,936
要了解更多这方面的内容


601
00:24:29,206 --> 00:24:30,166
请大家看一下演讲


602
00:24:30,366 --> 00:24:31,976
《Building Custom Views in SwiftUI》


603
00:24:35,066 --> 00:24:36,156
我们的示例使用了文本


604
00:24:37,256 --> 00:24:38,866
但是我们的列表实际上


605
00:24:38,866 --> 00:24:40,836
添加了它自己的原始视图


606
00:24:40,836 --> 00:24:42,326
可以把它视为我们


607
00:24:42,326 --> 00:24:42,976
每一行之间的分隔符


608
00:24:46,066 --> 00:24:46,976
现在我们还可以看到


609
00:24:46,976 --> 00:24:48,246
自定义视图被定义为


610
00:24:48,446 --> 00:24:49,416
struct 而不是类


611
00:24:49,496 --> 00:24:51,166
这又回到了 SwiftUI


612
00:24:51,166 --> 00:24:53,176
中定义视图的方式


613
00:24:54,346 --> 00:24:55,606
在本例中 这表示


614
00:24:55,606 --> 00:24:58,106
视图不是我们使用


615
00:24:58,356 --> 00:25:00,346
基于命令事件的代码


616
00:25:00,346 --> 00:25:02,976
随时间更新的永久目的


617
00:25:05,556 --> 00:25:07,756
相反 我们的视图被


618
00:25:07,886 --> 00:25:10,876
定义为其输入的函数


619
00:25:13,046 --> 00:25:14,096
因此 无论何时我们的输入


620
00:25:14,096 --> 00:25:16,506
发生了变化 SwiftUI


621
00:25:16,506 --> 00:25:18,746
都会再次调用主体属性


622
00:25:18,746 --> 00:25:19,976
来获取视图的更新版本


623
00:25:23,096 --> 00:25:24,766
我们这里用的 List


624
00:25:25,536 --> 00:25:26,896
是定义代码强大功能


625
00:25:26,896 --> 00:25:29,576
的一个很好的例子


626
00:25:29,766 --> 00:25:31,126
如果我们的 previousOrders 集合


627
00:25:31,126 --> 00:25:33,716
改变了 SwiftUI 将


628
00:25:33,876 --> 00:25:35,116
比较列表的新旧版本


629
00:25:35,116 --> 00:25:37,096
并根据更改内容


630
00:25:37,096 --> 00:25:39,506
高效地更新屏幕上


631
00:25:39,546 --> 00:25:40,646
呈现的结果


632
00:25:42,066 --> 00:25:43,996
比如 我一直在为


633
00:25:43,996 --> 00:25:45,416
我的 App 开发云同步


634
00:25:45,736 --> 00:25:47,196
对我来说 能够在我所有的


635
00:25:47,196 --> 00:25:48,776
设备上都能使用牛油果吐司


636
00:25:48,776 --> 00:25:51,536
的相关数据至关重要


637
00:25:52,586 --> 00:25:53,486
让我们看看如果另一个


638
00:25:53,486 --> 00:25:55,586
设备从我们的历史记录中


639
00:25:55,586 --> 00:25:56,916
添加和删除订单会发生什么


640
00:25:59,356 --> 00:26:00,946
大家看到在右边的是


641
00:26:00,946 --> 00:26:03,056
SwiftUI 自动区分


642
00:26:03,306 --> 00:26:04,506
集合中的更改


643
00:26:05,086 --> 00:26:07,036
并合成插入和删除操作


644
00:26:07,036 --> 00:26:08,636
然后把它们用默认


645
00:26:08,636 --> 00:26:11,216
动画呈现出来


646
00:26:12,126 --> 00:26:13,676
这些都是无需编写


647
00:26:13,676 --> 00:26:15,426
任何额外代码就可以


648
00:26:15,426 --> 00:26:16,956
免费获得的功能


649
00:26:17,516 --> 00:26:25,546
[掌声]


650
00:26:26,046 --> 00:26:26,566
这个功能真的很赞


651
00:26:26,966 --> 00:26:29,556
这个功能很实用的原因在于


652
00:26:29,556 --> 00:26:31,306
你不需要自己一直


653
00:26:31,306 --> 00:26:33,076
亲自管理呈现状态


654
00:26:34,136 --> 00:26:36,086
现在你可以根据主体属性


655
00:26:36,146 --> 00:26:38,426
中的当前数据为


656
00:26:38,426 --> 00:26:40,896
视图生成新值


657
00:26:43,046 --> 00:26:44,666
你可以让 SwiftUI


658
00:26:44,666 --> 00:26:46,646
为你在这两个版本之间


659
00:26:46,646 --> 00:26:47,966
生成必要的更改


660
00:26:50,066 --> 00:26:51,706
这就是定义代码的强大之处


661
00:26:54,236 --> 00:26:55,126
那么让我们继续来构建


662
00:26:55,126 --> 00:26:55,946
orderHistory 视图的剩余部分


663
00:26:56,156 --> 00:26:57,536
如果大家回想一下 我们最初


664
00:26:57,536 --> 00:26:59,466
的设计就包含了这些图标


665
00:26:59,466 --> 00:27:00,776
用来在订单中


666
00:27:01,206 --> 00:27:02,956
添加额外的配料


667
00:27:03,096 --> 00:27:04,166
比如盐和红辣椒片


668
00:27:05,136 --> 00:27:07,026
让我们从盐的图标开始


669
00:27:07,906 --> 00:27:09,396
首先 我们将在文本后面添加


670
00:27:09,396 --> 00:27:11,266
一个带有 Spacer 的水平栈


671
00:27:12,826 --> 00:27:14,826
然后我会在订单中


672
00:27:14,826 --> 00:27:16,746
需要盐时给大家展示我的


673
00:27:16,826 --> 00:27:17,536
SaltIcon 视图


674
00:27:20,176 --> 00:27:21,306
正如你在这段代码中所看到的


675
00:27:22,166 --> 00:27:23,406
我们前面讨论过的 ViewBuilder


676
00:27:23,406 --> 00:27:25,316
语法允许我们


677
00:27:25,316 --> 00:27:27,676
使用自然控制流


678
00:27:27,676 --> 00:27:29,426
比如 if 语句在视图


679
00:27:29,426 --> 00:27:31,356
应该包含在栈中时


680
00:27:31,356 --> 00:27:32,316
以定义的方式来定义视图


681
00:27:35,476 --> 00:27:36,656
在定义性代码中


682
00:27:36,686 --> 00:27:38,616
使用这样的 if 语法


683
00:27:38,956 --> 00:27:39,946
非常自然


684
00:27:40,666 --> 00:27:42,296
但是也还有其他方法


685
00:27:42,296 --> 00:27:43,976
可以在视图中编写条件代码


686
00:27:44,386 --> 00:27:45,686
重点是要选择正确的工具才能


687
00:27:45,686 --> 00:27:48,006
在屏幕上得到正确的结果


688
00:27:48,316 --> 00:27:49,986
让我们看一个简单的例子


689
00:27:49,986 --> 00:27:50,696
来理解一下我的意思


690
00:27:51,286 --> 00:27:53,976
我为我们的 App 新建了


691
00:27:53,976 --> 00:27:55,486
另一个屏幕 你可以选择


692
00:27:55,486 --> 00:27:57,976
正常和倒装的 AppIcon


693
00:27:59,726 --> 00:28:01,676
我的第一步是编写


694
00:28:01,676 --> 00:28:04,066
一个自定义视图


695
00:28:04,066 --> 00:28:05,846
它接受倒装状态作为输入


696
00:28:05,846 --> 00:28:07,466
并根据我的状态应用


697
00:28:07,466 --> 00:28:11,246
一个旋转修饰符


698
00:28:13,386 --> 00:28:15,186
然而 当我们试图翻转这个


699
00:28:15,186 --> 00:28:16,556
图标时 会看到一个不太


700
00:28:16,556 --> 00:28:19,886
美观的交叉淡入动画


701
00:28:20,116 --> 00:28:21,686
这是因为我们的代码


702
00:28:21,736 --> 00:28:23,546
让 SwiftUI 在两种


703
00:28:23,546 --> 00:28:25,606
不同的视图之间切换


704
00:28:26,716 --> 00:28:28,816
包含在旋转修饰符中的视图


705
00:28:28,816 --> 00:28:32,756
相对于 AppIcon 其本身


706
00:28:33,326 --> 00:28:37,426
默认情况下 SwiftUI 会在


707
00:28:37,426 --> 00:28:40,676
添加和删除视图时淡入和淡出视图


708
00:28:41,596 --> 00:28:42,506
这就是为什么我们会得到


709
00:28:42,506 --> 00:28:43,966
这种交叉淡入效果


710
00:28:46,156 --> 00:28:47,426
现在我想让图标


711
00:28:47,426 --> 00:28:49,156
在翻转时旋转


712
00:28:50,136 --> 00:28:52,556
为了达到这一效果


713
00:28:52,556 --> 00:28:54,096
我要用一个 rotationEffect


714
00:28:54,096 --> 00:28:56,786
修饰语句来定义一个视图


715
00:28:57,126 --> 00:28:59,526
并根据自身状态来对它的输入进行配置


716
00:29:00,116 --> 00:29:02,986
通过在修饰语句中


717
00:29:02,986 --> 00:29:05,026
定义我们的条件


718
00:29:05,026 --> 00:29:06,136
SwiftUI 可以提供


719
00:29:06,136 --> 00:29:08,266
更好的默认动画


720
00:29:08,266 --> 00:29:09,186
将图标旋转到新的方向


721
00:29:10,396 --> 00:29:11,856
这里需要学习的是


722
00:29:11,856 --> 00:29:12,736
你应该尽可能地


723
00:29:12,736 --> 00:29:15,066
把你的条件添加到


724
00:29:15,066 --> 00:29:16,306
修改语句中


725
00:29:16,996 --> 00:29:18,286
因为这可以帮助 SwiftUI


726
00:29:19,126 --> 00:29:20,476
检测这些变化并为你提供


727
00:29:20,476 --> 00:29:21,566
更好的动画效果


728
00:29:23,116 --> 00:29:24,926
如果你的目的是在层级


729
00:29:24,926 --> 00:29:26,806
架构中添加或删除视图


730
00:29:27,106 --> 00:29:28,666
那我们之前看到的


731
00:29:28,706 --> 00:29:31,316
if 语法就十分有用了


732
00:29:36,046 --> 00:29:37,136
回到我们的示例 App


733
00:29:37,316 --> 00:29:39,886
我们的 OrderHistory 


734
00:29:40,006 --> 00:29:41,166
视图开始变大了


735
00:29:41,526 --> 00:29:42,686
所以最好能把它


736
00:29:42,686 --> 00:29:44,446
分解成更小的部分


737
00:29:45,226 --> 00:29:46,346
那么让我们试着将每个


738
00:29:46,346 --> 00:29:48,096
列表行的代码分解到它


739
00:29:48,096 --> 00:29:48,936
自己的自定义视图中


740
00:29:51,116 --> 00:29:52,166
首先 我将创建一个名为


741
00:29:52,166 --> 00:29:53,506
OrderCell 的新自定义视图


742
00:29:53,506 --> 00:29:56,356
现在这个视图需要一个


743
00:29:56,356 --> 00:29:58,436
body 部分 幸运的是


744
00:29:58,436 --> 00:30:00,326
我们已经在 OrderHistory


745
00:30:00,326 --> 00:30:02,296
视图的列表中构建了它


746
00:30:02,366 --> 00:30:03,936
下面我们把这段代码移过来


747
00:30:06,316 --> 00:30:09,176
为了生成 OrderCell 的主体


748
00:30:09,176 --> 00:30:10,836
我们需要为其输入数据


749
00:30:11,416 --> 00:30:12,616
我们还需要添加


750
00:30:12,616 --> 00:30:14,976
一个属性来表示它


751
00:30:16,156 --> 00:30:18,096
最后 我们将为


752
00:30:18,096 --> 00:30:19,396
列表中的每一行创建


753
00:30:19,396 --> 00:30:21,736
一个新视图实例


754
00:30:24,076 --> 00:30:25,746
这里的重点是我们能


755
00:30:25,746 --> 00:30:27,896
很容易地将 UI 分解成


756
00:30:27,896 --> 00:30:29,406
更小的部分并将代码


757
00:30:29,406 --> 00:30:31,466
分解成新的视图


758
00:30:32,106 --> 00:30:34,056
请记住 使用定义性代码


759
00:30:34,056 --> 00:30:36,046
来添加新的封装器视图


760
00:30:36,306 --> 00:30:38,436
实际上是可自由操作的


761
00:30:38,436 --> 00:30:40,526
因为 SwiftUI 会在后台


762
00:30:40,926 --> 00:30:41,766
对它进行优化


763
00:30:42,366 --> 00:30:44,656
所以重要的是


764
00:30:44,856 --> 00:30:46,136
你不需要再为


765
00:30:46,136 --> 00:30:48,096
得到更多成果并


766
00:30:48,096 --> 00:30:49,416
让 App 表现得更好


767
00:30:49,416 --> 00:30:51,566
和组织你的视图


768
00:30:51,566 --> 00:30:53,796
代码之间妥协


769
00:30:54,516 --> 00:31:01,736
[掌声]


770
00:31:02,236 --> 00:31:03,386
所以 让我们以添加


771
00:31:03,386 --> 00:31:05,526
红辣椒粉图标来作为结束


772
00:31:06,126 --> 00:31:07,486
只要像之前那样加上


773
00:31:07,486 --> 00:31:09,446
另一个条件就可以了


774
00:31:10,616 --> 00:31:12,476
这是可行的 但它的


775
00:31:12,476 --> 00:31:13,396
可扩展性不是很好


776
00:31:13,896 --> 00:31:15,286
如果我们以后添加新的佐料


777
00:31:15,286 --> 00:31:17,306
我们将不得不在代码中添加


778
00:31:17,306 --> 00:31:18,726
带有新条件的佐料


779
00:31:18,726 --> 00:31:20,686
最棒的是可以


780
00:31:20,686 --> 00:31:24,406
有条件地从订单数据来


781
00:31:24,406 --> 00:31:26,716
生成一组图标


782
00:31:29,306 --> 00:31:30,226
要生成视图集合 可以


783
00:31:30,226 --> 00:31:32,576
使用 ForEach 视图


784
00:31:34,086 --> 00:31:35,976
就像我们的列表一样 ForEach


785
00:31:36,376 --> 00:31:38,316
会接受一组数据和一个 ViewBuilder


786
00:31:38,316 --> 00:31:40,266
后者将每个数据项显示到中


787
00:31:40,316 --> 00:31:42,076
它自己的视图


788
00:31:43,366 --> 00:31:46,056
但与列表不同的是 ForEach


789
00:31:46,056 --> 00:31:47,976
不添加任何自己的视觉效果


790
00:31:49,056 --> 00:31:51,116
而是将自己的


791
00:31:51,116 --> 00:31:53,076
内容添加到容器中


792
00:31:56,106 --> 00:31:57,206
所以这段代码要好得多


793
00:31:57,476 --> 00:31:58,626
因为现在我们订单的


794
00:31:58,746 --> 00:32:00,046
历史记录将在未来自动


795
00:32:00,046 --> 00:32:01,446
支持新的佐料


796
00:32:01,486 --> 00:32:03,776
而无需向视图添加任何代码


797
00:32:06,066 --> 00:32:07,116
比如 我们可以把鸡蛋


798
00:32:07,116 --> 00:32:08,686
添加为第三个图标


799
00:32:11,286 --> 00:32:13,236
退一步讲 我们


800
00:32:13,236 --> 00:32:14,806
只用十几行代码


801
00:32:14,806 --> 00:32:16,096
就能构建出


802
00:32:16,096 --> 00:32:18,066
这么多的功能


803
00:32:18,066 --> 00:32:19,306
是非常惊人的


804
00:32:20,476 --> 00:32:22,386
更了不起的是


805
00:32:22,456 --> 00:32:24,346
还有很多代码我们


806
00:32:24,346 --> 00:32:25,226
都不需要写了


807
00:32:26,776 --> 00:32:28,026
我们已经看到了 SwiftUI


808
00:32:28,256 --> 00:32:29,866
是如何自动处理数据


809
00:32:29,866 --> 00:32:31,956
的更改 它甚至能在


810
00:32:31,956 --> 00:32:33,476
添加和删除数据时


811
00:32:33,476 --> 00:32:34,396
插入默认动画


812
00:32:37,046 --> 00:32:38,736
但我还没有提到我们的


813
00:32:38,736 --> 00:32:40,496
App 也能适应动态类型


814
00:32:41,686 --> 00:32:43,066
它甚至还支持深色模式


815
00:32:43,266 --> 00:32:44,896
这些技术支持都是免费的


816
00:32:44,896 --> 00:32:46,976
而且我们不需要编写任何额外的代码


817
00:32:48,516 --> 00:32:55,226
[掌声]


818
00:32:55,726 --> 00:32:57,566
这非常棒 这就是我们所说的


819
00:32:57,566 --> 00:32:59,566
SwiftUI 能为你提供一条


820
00:32:59,566 --> 00:33:01,886
创建 App 的捷径的意思


821
00:33:04,106 --> 00:33:05,716
以上就是用 SwiftUI


822
00:33:05,716 --> 00:33:07,426
创建自定义视图的方法


823
00:33:08,786 --> 00:33:10,256
现在我想邀请


824
00:33:10,256 --> 00:33:12,116
我的同事 Taylor


825
00:33:12,306 --> 00:33:13,716
来和各位谈谈如何


826
00:33:13,996 --> 00:33:15,416
充分利用 SwiftUI 


827
00:33:15,416 --> 00:33:18,596
为大家提供更有用的功能


828
00:33:19,516 --> 00:33:24,656
[掌声]


829
00:33:25,156 --> 00:33:28,646
>> 感谢 Matt 大家好


830
00:33:29,396 --> 00:33:31,376
现在 我们对自己的 App


831
00:33:31,376 --> 00:33:33,216
都有了一个良好开端


832
00:33:33,216 --> 00:33:34,276
Matt 构建了初始订单


833
00:33:34,276 --> 00:33:35,586
表单和历史屏的显示页面


834
00:33:35,586 --> 00:33:37,516
但有一个明显的问题就是


835
00:33:37,516 --> 00:33:38,746
它看起来不太像我们


836
00:33:39,006 --> 00:33:40,536
习惯的 iOS App


837
00:33:40,886 --> 00:33:41,986
它们一般不是这些简单的


838
00:33:41,986 --> 00:33:43,866
垂直控件栈


839
00:33:44,756 --> 00:33:46,246
通常 这种类型的 UI


840
00:33:46,246 --> 00:33:47,616
会更像大家在右边看到的那样


841
00:33:47,796 --> 00:33:49,456
最大的区别之一是


842
00:33:49,456 --> 00:33:51,126
控件周围的容器


843
00:33:51,206 --> 00:33:52,796
本身具有这种标准化


844
00:33:54,006 --> 00:33:56,176
的组列表样式


845
00:33:57,056 --> 00:33:59,816
在 SwiftUI 里我们称它为 Form


846
00:33:59,816 --> 00:34:02,406
Form 是一个容器


847
00:34:02,406 --> 00:34:03,926
就像 VStack 一样


848
00:34:03,926 --> 00:34:05,536
但是它是专门为构建


849
00:34:05,596 --> 00:34:06,696
异构控件的这些部分


850
00:34:06,726 --> 00:34:08,616
而构建的 无论在什么


851
00:34:08,616 --> 00:34:10,436
平台上它都提供


852
00:34:10,786 --> 00:34:11,956
标准的外观和体验


853
00:34:14,045 --> 00:34:15,916
现在我们已经定义了


854
00:34:15,916 --> 00:34:17,476
我们想要在自己的


855
00:34:17,476 --> 00:34:18,376
App 中的功能集


856
00:34:19,025 --> 00:34:21,726
标题 Toggle Stepper 还有 Button


857
00:34:23,036 --> 00:34:24,616
我们所做的就是将


858
00:34:24,616 --> 00:34:26,186
容器本身从现有的


859
00:34:26,186 --> 00:34:29,005
VStack 更改为一个 Form


860
00:34:29,005 --> 00:34:30,936
然后我们就可以很容易地


861
00:34:30,936 --> 00:34:33,255
添加一些部分来划分内容


862
00:34:34,565 --> 00:34:35,596
正如 Matt 前面所讨论的


863
00:34:35,596 --> 00:34:37,596
我们的代码会继续


864
00:34:37,596 --> 00:34:39,206
显示反映生成的 UI


865
00:34:40,346 --> 00:34:41,646
由于我们控件的核心定义


866
00:34:41,646 --> 00:34:43,696
没有改变 我们的代码


867
00:34:43,696 --> 00:34:44,946
实际上也不需要改变


868
00:34:45,985 --> 00:34:47,106
只要将容器从


869
00:34:47,106 --> 00:34:49,356
VStack 更改为


870
00:34:49,356 --> 00:34:50,596
Form 控件就会


871
00:34:50,596 --> 00:34:52,156
自动适应该上下文


872
00:34:52,966 --> 00:34:54,045
从整体背景和


873
00:34:54,045 --> 00:34:55,666
可滚动性到分隔每


874
00:34:55,806 --> 00:34:57,256
个控件的行 甚至是


875
00:34:57,566 --> 00:34:59,196
按钮之类的样式


876
00:35:00,316 --> 00:35:02,316
这是 SwiftUI


877
00:35:02,316 --> 00:35:03,816
再次关注渲染


878
00:35:03,816 --> 00:35:05,626
这些元素的细节


879
00:35:05,626 --> 00:35:07,786
并能让我们专注


880
00:35:07,786 --> 00:35:09,846
于 App 的功能


881
00:35:11,676 --> 00:35:12,986
还有一个从屏幕快照


882
00:35:12,986 --> 00:35:15,546
上看不见的细微的变化


883
00:35:16,556 --> 00:35:17,966
让我们仔细看一下按钮


884
00:35:17,966 --> 00:35:19,216
你可以看到对齐 填充


885
00:35:19,216 --> 00:35:20,486
和按钮周围的装饰都改变了


886
00:35:20,486 --> 00:35:24,436
点按状态也展示出了


887
00:35:24,436 --> 00:35:25,996
你从这样的 UI 中


888
00:35:25,996 --> 00:35:27,346
所期待高亮效果


889
00:35:27,346 --> 00:35:32,546
同时显示了相同的按钮定义


890
00:35:34,116 --> 00:35:35,536
正如你可能期望的那样


891
00:35:35,536 --> 00:35:36,516
这个相同的定义在其他


892
00:35:36,516 --> 00:35:37,936
上下文中或其他平台上


893
00:35:38,306 --> 00:35:39,316
也适用而且具有多种


894
00:35:39,316 --> 00:35:41,896
可能的外观和体验


895
00:35:42,126 --> 00:35:43,076
按钮还具有我们


896
00:35:43,076 --> 00:35:44,556
在其他视图中看到的相同的


897
00:35:44,556 --> 00:35:46,816
可组合性的固有能力


898
00:35:47,396 --> 00:35:48,286
标签当然不限于


899
00:35:48,286 --> 00:35:51,016
文本 它也可以是图像形式


900
00:35:51,016 --> 00:35:52,696
它可以是我们定义的


901
00:35:52,696 --> 00:35:54,996
任何类型的视图


902
00:35:54,996 --> 00:35:56,656
甚至可以是图像和文本


903
00:35:56,656 --> 00:35:58,876
的显式垂直栈


904
00:35:59,516 --> 00:36:05,846
[掌声]


905
00:36:06,346 --> 00:36:07,856
这种继承的可组合性


906
00:36:07,856 --> 00:36:08,946
带来了各种可能性


907
00:36:08,946 --> 00:36:12,186
并同时使按钮能够被简化为


908
00:36:12,186 --> 00:36:14,556
两个基本属性


909
00:36:15,576 --> 00:36:16,556
即它在激活时


910
00:36:16,556 --> 00:36:18,036
执行的操作和


911
00:36:18,176 --> 00:36:19,256
描述该操作的标签


912
00:36:20,596 --> 00:36:21,756
这就是按钮的


913
00:36:21,756 --> 00:36:22,886
整个 API 表面


914
00:36:24,046 --> 00:36:25,176
当然 这并不是说


915
00:36:25,176 --> 00:36:26,496
只有这两种方法


916
00:36:26,546 --> 00:36:27,996
可以自定义按钮


917
00:36:28,736 --> 00:36:29,556
就像我们之前看到的


918
00:36:29,556 --> 00:36:31,426
并且将继续看到的


919
00:36:31,476 --> 00:36:33,346
上下文和修饰符都支持


920
00:36:33,346 --> 00:36:35,036
在 macOS 上添加更多


921
00:36:35,036 --> 00:36:36,716
丰富的行为 从禁用状态


922
00:36:36,716 --> 00:36:38,446
到按钮 样式甚至


923
00:36:38,446 --> 00:36:39,196
控制的大小


924
00:36:40,016 --> 00:36:41,826
但是这个核心定义加上


925
00:36:41,826 --> 00:36:44,336
适应行为可以支持任何类型的按钮


926
00:36:45,196 --> 00:36:46,366
随着时间的推移


927
00:36:46,366 --> 00:36:48,186
在不同的平台上 我们看到了


928
00:36:48,186 --> 00:36:49,166
很多不同的按钮


929
00:36:49,956 --> 00:36:51,006
它们的变化不仅


930
00:36:51,006 --> 00:36:52,756
取决于外观 还取决于


931
00:36:52,756 --> 00:36:54,686
我们与它们的互动方式


932
00:36:54,686 --> 00:36:56,376
从点按到轻点 到通过


933
00:36:56,376 --> 00:36:57,726
开关控制或 Siri Remote 遥控器


934
00:36:57,726 --> 00:37:00,206
来进行选择 但它们


935
00:37:00,206 --> 00:37:02,016
都可以归结为一个


936
00:37:02,016 --> 00:37:03,296
操作和一个标签


937
00:37:05,096 --> 00:37:08,736
就像按钮一样 其中的


938
00:37:08,736 --> 00:37:10,666
每个控件都具有相同的


939
00:37:10,666 --> 00:37:11,966
适应行为能力


940
00:37:13,276 --> 00:37:15,066
控件描述的是它们


941
00:37:15,066 --> 00:37:17,126
所服务的目的或角色 而不是它们的外观


942
00:37:17,126 --> 00:37:18,816
这使得它们可以


943
00:37:18,816 --> 00:37:19,896
在不同的环境


944
00:37:19,896 --> 00:37:21,886
和平台上重用并适应


945
00:37:21,886 --> 00:37:22,716
这些情况


946
00:37:23,696 --> 00:37:24,606
这也使得他们有


947
00:37:24,606 --> 00:37:26,716
更小的 API 表面来满足


948
00:37:26,716 --> 00:37:27,606
这个确切的角色


949
00:37:27,606 --> 00:37:29,726
不过我们同时还需要


950
00:37:29,726 --> 00:37:31,426
减少控件 而不是为可能


951
00:37:31,426 --> 00:37:32,746
需要在其中使用的每个


952
00:37:32,746 --> 00:37:34,206
上下文都配置一个控件


953
00:37:35,726 --> 00:37:37,386
同时仍然支持非常


954
00:37:37,386 --> 00:37:38,766
强大的自定义功能


955
00:37:39,046 --> 00:37:40,356
比如完全重新定义


956
00:37:40,356 --> 00:37:42,826
App 中按钮的外观


957
00:37:43,756 --> 00:37:46,016
现在我们看到了这种


958
00:37:46,016 --> 00:37:47,406
适应功能如何让我们


959
00:37:47,406 --> 00:37:49,206
快速地从一堆简单的控件


960
00:37:49,486 --> 00:37:51,546
转换为系统表单的标准外观和体验


961
00:37:52,416 --> 00:37:54,516
但同样的适应性也使我们能够将


962
00:37:54,516 --> 00:37:55,996
这些控制带到其他平台上


963
00:37:56,446 --> 00:37:58,126
比如 watchOS 这样我们就可以


964
00:37:58,126 --> 00:37:59,316
在忙碌中快速点到吐司


965
00:38:01,596 --> 00:38:02,456
现在我们已经在使用的


966
00:38:02,456 --> 00:38:04,236
另一个控件是 Toggle


967
00:38:04,956 --> 00:38:06,126
各位已经看到了 SwiftUI


968
00:38:06,126 --> 00:38:07,916
中的 Toggle 不仅仅


969
00:38:07,916 --> 00:38:09,006
只是一个字面上的转换


970
00:38:09,696 --> 00:38:11,586
不管它在什么


971
00:38:11,586 --> 00:38:12,686
平台上都是这样的


972
00:38:13,616 --> 00:38:15,086
就像按钮一样


973
00:38:15,086 --> 00:38:16,926
Toggle 有两个基本属性


974
00:38:16,926 --> 00:38:18,486
即开或关 以及描述


975
00:38:18,486 --> 00:38:20,596
Toggle 整体目的的标签


976
00:38:21,656 --> 00:38:22,736
同样 这也在结构


977
00:38:22,876 --> 00:38:26,916
本身有所呈现与按钮的一个明显


978
00:38:26,916 --> 00:38:28,226
区别是 它不执行操作


979
00:38:28,226 --> 00:38:31,816
而是执行与 Boolean 值的绑定


980
00:38:32,336 --> 00:38:33,876
这个绑定是到


981
00:38:33,916 --> 00:38:35,176
App 中某个状态


982
00:38:35,176 --> 00:38:36,706
或模型的直接


983
00:38:36,706 --> 00:38:38,176
读写连接 允许


984
00:38:38,176 --> 00:38:39,706
显示 Toggle 和


985
00:38:39,706 --> 00:38:41,366
更新该状态或模型


986
00:38:41,366 --> 00:38:42,966
无需手动响应某个操作


987
00:38:42,966 --> 00:38:44,636
去提取值并在模型中设置它


988
00:38:45,246 --> 00:38:46,956
它会为你把一切搞定


989
00:38:48,516 --> 00:38:54,566
[掌声]


990
00:38:55,066 --> 00:38:56,446
现在 Toggle 和其他的


991
00:38:56,446 --> 00:38:58,426
控件在另一个非常重要的


992
00:38:58,426 --> 00:38:59,616
方面也有一定适应性


993
00:39:00,606 --> 00:39:01,986
对于一些人来说 UI


994
00:39:01,986 --> 00:39:03,816
是一种视觉体验


995
00:39:03,816 --> 00:39:04,906
而其他人可能主要使用


996
00:39:04,906 --> 00:39:06,736
其他感官来体验


997
00:39:06,736 --> 00:39:07,846
相同的 UI


998
00:39:07,846 --> 00:39:10,436
例如 视力受损的人


999
00:39:10,436 --> 00:39:11,926
可以使用旁白


1000
00:39:11,926 --> 00:39:13,306
进行导航 并使用音频


1001
00:39:13,306 --> 00:39:15,106
与 App 进行互动


1002
00:39:15,106 --> 00:39:16,996
对于没使用的人


1003
00:39:16,996 --> 00:39:18,116
这就是开始使用


1004
00:39:18,116 --> 00:39:19,566
旁白的样子


1005
00:39:19,956 --> 00:39:21,016
>> 打开旁白 


1006
00:39:22,406 --> 00:39:23,876
>> 目前旁白只是


1007
00:39:23,876 --> 00:39:25,196
系统范围内的功能之一


1008
00:39:25,196 --> 00:39:26,896
它能将你的 UI 以这些


1009
00:39:26,896 --> 00:39:28,706
替代形式呈现出来


1010
00:39:29,326 --> 00:39:30,766
而且 由于 Toggle 和


1011
00:39:30,766 --> 00:39:32,056
其他控件是根据


1012
00:39:32,056 --> 00:39:34,216
它们的用途定义的 并且包含了


1013
00:39:34,216 --> 00:39:35,816
我们可解释的标签


1014
00:39:35,816 --> 00:39:38,206
所以它们可以自动适应这些功能


1015
00:39:39,216 --> 00:39:40,176
所以当我们使用旁白


1016
00:39:40,176 --> 00:39:41,236
导航到这个切换时会听到


1017
00:39:41,946 --> 00:39:44,126
>> 加盐 开关按钮


1018
00:39:44,516 --> 00:39:48,236
双击以切换设置


1019
00:39:48,806 --> 00:39:50,846
>> 能够显示相同的标签


1020
00:39:50,846 --> 00:39:52,766
即使标签不是


1021
00:39:52,766 --> 00:39:53,716
文本也是如此


1022
00:39:54,606 --> 00:39:56,166
下面关于图像 如果图像


1023
00:39:56,166 --> 00:39:57,476
名称不够具备描述性


1024
00:39:57,696 --> 00:39:58,806
你可以直接在图像旁


1025
00:39:58,806 --> 00:40:00,886
直接提供一个标签


1026
00:40:03,046 --> 00:40:04,746
当然也可以全部自定义


1027
00:40:05,151 --> 00:40:07,151
[掌声]


1028
00:40:07,286 --> 00:40:08,216
这的确非常激动人心


1029
00:40:09,041 --> 00:40:11,041
[掌声]


1030
00:40:11,066 --> 00:40:13,386
当然 即使是完全自定义的视图


1031
00:40:13,386 --> 00:40:14,426
你也总是可以使用辅助功能


1032
00:40:14,426 --> 00:40:16,706
标签修饰符直接地提供标签


1033
00:40:18,086 --> 00:40:19,176
现在 除了旁白


1034
00:40:19,376 --> 00:40:20,706
这些信息还可以


1035
00:40:20,706 --> 00:40:22,186
用于其他功能 比如


1036
00:40:22,186 --> 00:40:24,276
iOS 和 macOS 上新的语音


1037
00:40:24,736 --> 00:40:26,096
这样我们就可以说“Tap Include Salt”


1038
00:40:26,146 --> 00:40:28,416
我们的 UI 就像预期的那样执行操作


1039
00:40:29,676 --> 00:40:30,646
确保你的 App 是


1040
00:40:30,646 --> 00:40:32,016
易于使用的 意味着它能和


1041
00:40:32,016 --> 00:40:32,906
所有这些不同的技术兼容


1042
00:40:32,906 --> 00:40:36,026
意味着每个人都可以使用你的 App


1043
00:40:36,026 --> 00:40:38,086
而且 SwiftUI 是有一定作用的


1044
00:40:39,676 --> 00:40:40,666
今年有一个很棒的演讲


1045
00:40:40,666 --> 00:40:41,626
将会详细介绍如何


1046
00:40:41,626 --> 00:40:43,116
确保 SwiftUI 的 App


1047
00:40:43,116 --> 00:40:45,976
是完全可访问的


1048
00:40:48,656 --> 00:40:49,766
现在 我们已经能够快速


1049
00:40:49,766 --> 00:40:50,916
构建这个初始基本接口


1050
00:40:50,916 --> 00:40:52,566
它具备所有我们


1051
00:40:52,566 --> 00:40:53,636
所期望的操作


1052
00:40:54,466 --> 00:40:57,066
动态类型 暗色模式和辅助功能


1053
00:40:57,066 --> 00:40:58,956
但是我们实际上


1054
00:40:58,956 --> 00:41:00,576
只为吐司本身添加了


1055
00:41:00,576 --> 00:41:01,466
一些自定义选项


1056
00:41:02,476 --> 00:41:04,256
当然 大家都知道


1057
00:41:04,316 --> 00:41:05,636
专业的手工吐司


1058
00:41:05,636 --> 00:41:08,026
会有各种不同的面包类型


1059
00:41:08,026 --> 00:41:09,716
制作牛油果的方法


1060
00:41:09,716 --> 00:41:11,676
当然还有各种


1061
00:41:11,676 --> 00:41:13,056
酱料和辅料


1062
00:41:13,786 --> 00:41:15,826
要添加这些更高级


1063
00:41:15,826 --> 00:41:17,986
的配置选项 我们可以


1064
00:41:17,986 --> 00:41:19,386
从 macOS 的灵活性中


1065
00:41:19,386 --> 00:41:21,786
寻找一些灵感


1066
00:41:22,016 --> 00:41:23,026
或者我们可能想要


1067
00:41:23,026 --> 00:41:24,496
一个小的实用窗口让我们能


1068
00:41:24,496 --> 00:41:26,546
直接从我们的桌面上点吐司


1069
00:41:28,276 --> 00:41:29,576
你可以在这里看到


1070
00:41:29,576 --> 00:41:30,706
我们已经使用的


1071
00:41:30,706 --> 00:41:32,396
现有控件呈现了


1072
00:41:32,586 --> 00:41:34,376
macOS 的预期外观 即 Toggle 


1073
00:41:34,376 --> 00:41:35,446
Stepper 和按钮


1074
00:41:35,446 --> 00:41:37,036
但我们也有一些


1075
00:41:37,036 --> 00:41:38,666
额外的控件 可以让


1076
00:41:38,666 --> 00:41:39,646
我们选择面包的类型


1077
00:41:39,686 --> 00:41:42,676
添加的酱汁 以及


1078
00:41:42,706 --> 00:41:43,976
如何准备牛油果


1079
00:41:46,436 --> 00:41:49,436
这些都是 SwiftUI 中 Picker 控件的例子


1080
00:41:50,206 --> 00:41:51,906
Picker 是为了从


1081
00:41:51,906 --> 00:41:54,316
一组选项中选择一个值而设计的


1082
00:41:55,606 --> 00:41:56,796
Picker 显然比


1083
00:41:56,796 --> 00:41:58,206
其它控件复杂一些


1084
00:41:58,206 --> 00:42:00,196
它有三个核心属性


1085
00:42:00,196 --> 00:42:01,416
而不是两个


1086
00:42:02,596 --> 00:42:03,456
即你可以从中选择的选项


1087
00:42:03,456 --> 00:42:05,356
当前从这些选项中


1088
00:42:05,356 --> 00:42:06,816
选择的选项以及描述


1089
00:42:06,946 --> 00:42:11,006
Picker 总体用途的标签


1090
00:42:11,186 --> 00:42:13,216
现在的选择是绑定


1091
00:42:13,796 --> 00:42:15,276
就像属性上的 Toggle 一样


1092
00:42:15,856 --> 00:42:17,016
这允许我们再次将其


1093
00:42:17,016 --> 00:42:19,256
直接连接到 Modeler 的状态


1094
00:42:19,346 --> 00:42:21,416
这种绑定的类型


1095
00:42:21,656 --> 00:42:23,376
对应于与每个选项


1096
00:42:23,456 --> 00:42:24,886
相关联的标记值


1097
00:42:25,926 --> 00:42:26,746
当其中一个选项被选中时


1098
00:42:26,746 --> 00:42:28,636
该标记值将被重新


1099
00:42:28,636 --> 00:42:29,826
写入选择并返回到


1100
00:42:30,096 --> 00:42:31,556
我们的模型中 所有这些


1101
00:42:31,556 --> 00:42:32,946
都是自动完成的


1102
00:42:35,046 --> 00:42:36,676
当然 macOS 上的


1103
00:42:36,776 --> 00:42:38,656
Picker 并不总是显示为弹出按钮


1104
00:42:39,416 --> 00:42:40,736
在这个单独的窗口中


1105
00:42:40,736 --> 00:42:41,766
我们可以看到两种不同风格的


1106
00:42:41,766 --> 00:42:44,356
Picker 一个是弹出按钮


1107
00:42:44,356 --> 00:42:45,726
和一个 radioGroup


1108
00:42:46,396 --> 00:42:47,926
虽然 SwiftUI 自动


1109
00:42:47,926 --> 00:42:49,476
提供了一种默认样式


1110
00:42:49,476 --> 00:42:50,686
能够适应控件的使用位置


1111
00:42:50,686 --> 00:42:53,176
但是控件本身也具有


1112
00:42:53,176 --> 00:42:54,756
自定义样式的能力


1113
00:42:54,756 --> 00:42:56,486
既可以自定义系统


1114
00:42:56,486 --> 00:42:58,136
提供的样式 也可以自定义


1115
00:42:58,136 --> 00:42:59,246
构建的样式


1116
00:43:00,336 --> 00:43:01,436
在本例中 我们希望


1117
00:43:01,436 --> 00:43:02,996
重写默认样式并


1118
00:43:02,996 --> 00:43:04,636
强制直接使用 radioGroup


1119
00:43:04,976 --> 00:43:05,946
因为我们知道我们


1120
00:43:05,946 --> 00:43:07,106
只从两个选项中进行选择


1121
00:43:08,986 --> 00:43:10,336
现在我们可以考虑对


1122
00:43:10,336 --> 00:43:11,386
Spread 也进行同样的调整


1123
00:43:12,566 --> 00:43:13,636
但一开始可能只是


1124
00:43:13,636 --> 00:43:14,786
四种可能的简单组合


1125
00:43:14,786 --> 00:43:16,916
很快就能发展成


1126
00:43:16,916 --> 00:43:17,716
各式各样的组合


1127
00:43:18,466 --> 00:43:20,486
所以说到构建 Picker


1128
00:43:20,486 --> 00:43:22,826
我们显然不希望它


1129
00:43:22,826 --> 00:43:23,716
一个一个地展开这些选项


1130
00:43:23,716 --> 00:43:26,236
就像我们不希望


1131
00:43:26,236 --> 00:43:27,516
构建一个 UI 将它们


1132
00:43:27,516 --> 00:43:29,356
全部显示为单选按钮一样


1133
00:43:31,006 --> 00:43:32,406
我们已经看过使用 ForEach


1134
00:43:32,406 --> 00:43:33,826
构建数据驱动视图


1135
00:43:34,476 --> 00:43:35,666
因为每个选项都是


1136
00:43:35,776 --> 00:43:37,576
视图本身 我们也可以


1137
00:43:37,576 --> 00:43:40,546
在这里使用它 这样就好多了


1138
00:43:41,876 --> 00:43:42,846
下面我们将详细了解


1139
00:43:42,846 --> 00:43:44,406
Spread 的每一种情况


1140
00:43:44,406 --> 00:43:45,666
并创建一个新选项 其中


1141
00:43:45,666 --> 00:43:47,836
使用 Spread 的名称和其本身作为标记


1142
00:43:50,236 --> 00:43:56,676
现在 [掌声]


1143
00:43:57,176 --> 00:43:58,946
显然 Pickers 不仅仅


1144
00:43:58,946 --> 00:43:59,906
存在于 macOS 上


1145
00:44:00,306 --> 00:44:02,066
接下来是选择


1146
00:44:02,066 --> 00:44:03,096
iOS 上的 Picker 看起来


1147
00:44:03,096 --> 00:44:04,456
像传统的轮状 Picker


1148
00:44:05,446 --> 00:44:06,806
但是 由于我们正在构建


1149
00:44:06,806 --> 00:44:08,406
一个表单 SwiftUI 会


1150
00:44:08,406 --> 00:44:09,816
自动调整 Picker 以采用


1151
00:44:09,816 --> 00:44:11,226
这种类型的 UI 的


1152
00:44:11,226 --> 00:44:12,696
另一种非常常见的形式


1153
00:44:14,686 --> 00:44:16,276
这里我们可以看到


1154
00:44:16,276 --> 00:44:18,006
Spread Picker 现在


1155
00:44:18,006 --> 00:44:19,866
由一个导航行表示 该行同时


1156
00:44:19,866 --> 00:44:21,786
显示其标签和当前选定的值


1157
00:44:22,936 --> 00:44:24,266
轻点这一行 就会出现


1158
00:44:24,266 --> 00:44:25,636
一个包含所有选项的列表


1159
00:44:26,076 --> 00:44:27,326
轻点选择其中一个


1160
00:44:27,326 --> 00:44:28,146
然后就会回到上一界面


1161
00:44:29,516 --> 00:44:36,646
[掌声]


1162
00:44:37,146 --> 00:44:38,096
不要抢我的台词


1163
00:44:38,286 --> 00:44:39,856
这就是 SwiftUI 通过创建一个


1164
00:44:39,856 --> 00:44:41,266
简单的 Picker 来处理


1165
00:44:41,526 --> 00:44:43,726
和创建整个交互设计


1166
00:44:44,516 --> 00:44:49,646
[掌声]


1167
00:44:50,146 --> 00:44:51,246
这让我们剩下的三个


1168
00:44:51,246 --> 00:44:52,306
Picker 显得微不足道


1169
00:44:53,196 --> 00:44:54,666
就像在 macOS 中一样


1170
00:44:54,666 --> 00:44:56,206
我们仍然对最终样式


1171
00:44:56,206 --> 00:44:56,866
有明确的控制


1172
00:44:57,406 --> 00:44:58,426
如果我们想要一个轮状


1173
00:44:58,426 --> 00:45:00,976
Picker 我们可以把它加进去


1174
00:45:04,046 --> 00:45:07,086
现在我们有了一组很好的 App


1175
00:45:07,836 --> 00:45:08,906
但在我们工作或忙碌时


1176
00:45:08,906 --> 00:45:10,866
点吐司是一回事


1177
00:45:10,866 --> 00:45:12,946
而与朋友和家人


1178
00:45:12,946 --> 00:45:14,526
就什么是最好的


1179
00:45:14,696 --> 00:45:16,096
牛油果吐司进行激烈的


1180
00:45:16,096 --> 00:45:18,366
争论则完全是另一回事


1181
00:45:21,066 --> 00:45:21,736
右边的表单由我们在


1182
00:45:21,736 --> 00:45:23,026
其他 App 中看到的


1183
00:45:23,026 --> 00:45:24,556
相同内容组成


1184
00:45:25,136 --> 00:45:26,186
来看一下用于


1185
00:45:26,186 --> 00:45:27,846
构建它的代码


1186
00:45:27,846 --> 00:45:28,896
它使用了与我们之前


1187
00:45:28,896 --> 00:45:30,296
使用的相同的结构和控件


1188
00:45:30,296 --> 00:45:31,666
进行创建 这并不奇怪


1189
00:45:32,406 --> 00:45:33,556
不同之处在于


1190
00:45:33,556 --> 00:45:34,726
自动适应的能力


1191
00:45:35,436 --> 00:45:36,536
例如 使用开关按钮


1192
00:45:36,536 --> 00:45:37,916
而不用开关来


1193
00:45:38,266 --> 00:45:38,976
表示 Toggle 


1194
00:45:41,286 --> 00:45:42,146
这就涉及到了


1195
00:45:42,146 --> 00:45:44,266
SwiftUI 的核心问题


1196
00:45:44,266 --> 00:45:46,886
你可以一次性学习一个概念


1197
00:45:46,886 --> 00:45:49,136
并将其应用到任何地方


1198
00:45:50,456 --> 00:45:51,986
SwiftUI 不仅仅是一种


1199
00:45:51,986 --> 00:45:53,676
一次性编写并在任何地方


1200
00:45:53,676 --> 00:45:54,726
运行的方法 它还是一个框架


1201
00:45:54,726 --> 00:45:56,086
让你能够学习这些核心概念


1202
00:45:56,376 --> 00:45:57,376
并在各种不同的上下文中


1203
00:45:57,376 --> 00:45:58,866
和平台上使用它们


1204
00:45:59,966 --> 00:46:01,386
这是从修饰符和 ViewBuilder


1205
00:46:01,386 --> 00:46:02,906
语法扩展到共享的


1206
00:46:02,906 --> 00:46:04,686
核心类型 如color


1207
00:46:04,686 --> 00:46:06,776
image 和 ForEach


1208
00:46:06,836 --> 00:46:07,886
甚至扩展到这些高级控件


1209
00:46:08,476 --> 00:46:11,056
对我来说 一个真正能


1210
00:46:11,056 --> 00:46:12,366
说明这种知识重用的例子


1211
00:46:12,366 --> 00:46:14,096
是构建 contextMenu


1212
00:46:14,096 --> 00:46:16,726
的一个稍微特定于


1213
00:46:16,726 --> 00:46:17,786
平台的例子


1214
00:46:18,376 --> 00:46:20,696
contextMenu 本身可以


1215
00:46:20,696 --> 00:46:23,326
使用修饰符附加到关联视图


1216
00:46:23,416 --> 00:46:25,446
这个修饰语句使用


1217
00:46:25,446 --> 00:46:27,816
ViewBuilder 语法来定义它的菜单内容


1218
00:46:28,586 --> 00:46:29,516
现在 如果我们看一下菜单


1219
00:46:29,516 --> 00:46:31,746
我们可以看到一些熟悉的概念


1220
00:46:32,636 --> 00:46:33,806
有些元素在点按时


1221
00:46:34,136 --> 00:46:35,456
执行一个操作 并有一个描述


1222
00:46:35,456 --> 00:46:36,656
该操作的标签


1223
00:46:37,356 --> 00:46:38,946
而另一些元素则专门负责


1224
00:46:38,946 --> 00:46:39,756
打开和关闭


1225
00:46:39,756 --> 00:46:42,186
因此 内容本身去使用


1226
00:46:42,186 --> 00:46:43,896
我们已经学会如何


1227
00:46:43,996 --> 00:46:45,456
使用的相同控件来进行


1228
00:46:45,456 --> 00:46:46,406
进行构建 这并不奇怪


1229
00:46:47,026 --> 00:46:48,576
按钮 分频器和 Toggle 


1230
00:46:49,636 --> 00:46:51,516
不过 我们的 macOS


1231
00:46:51,516 --> 00:46:52,766
菜单仍然会自动呈现


1232
00:46:53,066 --> 00:46:54,906
预期的外观和体验


1233
00:46:54,906 --> 00:46:56,316
从悬停和加速手势处理


1234
00:46:56,316 --> 00:46:57,506
到特殊的高亮


1235
00:46:57,506 --> 00:46:58,976
显示和选择样式


1236
00:47:01,516 --> 00:47:03,016
从这几个例子中 你可以


1237
00:47:03,016 --> 00:47:04,266
看出 SwiftUI


1238
00:47:04,266 --> 00:47:05,936
中的控件有点特殊


1239
00:47:06,796 --> 00:47:07,556
它们的定义是基于


1240
00:47:07,556 --> 00:47:08,836
其目的 所服务的角色


1241
00:47:08,836 --> 00:47:10,506
与 App 模型的连接


1242
00:47:10,506 --> 00:47:11,936
而不是特定于


1243
00:47:11,936 --> 00:47:13,266
它们的视觉外观


1244
00:47:14,236 --> 00:47:14,866
这意味着它们本质上


1245
00:47:14,866 --> 00:47:16,506
是可以跨多种历史


1246
00:47:16,506 --> 00:47:17,746
上下文重用的


1247
00:47:18,236 --> 00:47:19,076
并且可以根据上下文


1248
00:47:19,076 --> 00:47:20,466
平台或其他信息确定


1249
00:47:20,466 --> 00:47:23,016
适当的外观和体验


1250
00:47:23,936 --> 00:47:25,306
与此同时 它们是


1251
00:47:25,426 --> 00:47:27,636
可自定义的 既可以使用


1252
00:47:27,636 --> 00:47:29,546
视图作为标签和选项


1253
00:47:29,626 --> 00:47:30,506
也可以在系统


1254
00:47:30,506 --> 00:47:32,386
样式中任意设置这些控件


1255
00:47:32,696 --> 00:47:33,856
的样式 就像你在 Picker


1256
00:47:33,856 --> 00:47:35,066
中看到的那样 我们甚至


1257
00:47:35,066 --> 00:47:36,406
可以完全自定义这些样式


1258
00:47:37,216 --> 00:47:38,176
无论哪一种 仍然有


1259
00:47:38,616 --> 00:47:40,976
内置来支持辅助功能


1260
00:47:44,046 --> 00:47:45,236
刚才 Matt 展示了一些


1261
00:47:45,236 --> 00:47:47,126
使用修饰符对视图强制


1262
00:47:47,126 --> 00:47:49,846
执行附加行为的例子


1263
00:47:50,296 --> 00:47:52,746
对控件来说也是如此


1264
00:47:54,606 --> 00:47:55,846
iOS 上的用户可能


1265
00:47:55,846 --> 00:47:56,776
已经熟悉的一个


1266
00:47:56,776 --> 00:48:00,556
例子是改变 UI 的色调或强调色


1267
00:48:00,556 --> 00:48:01,356
这会影响出现不同


1268
00:48:01,356 --> 00:48:02,236
系统控件的数量


1269
00:48:03,016 --> 00:48:04,346
如果我们想把这个应用


1270
00:48:04,346 --> 00:48:06,156
到整个 App 中 我们可以


1271
00:48:06,156 --> 00:48:07,696
把 accentColor 修饰语句


1272
00:48:07,696 --> 00:48:09,126
应用到最外层的视图


1273
00:48:09,126 --> 00:48:10,106
这样它就会像这个按钮


1274
00:48:10,106 --> 00:48:11,666
一样被整个层级结构继承


1275
00:48:11,666 --> 00:48:14,486
现在 当涉及到禁用


1276
00:48:14,486 --> 00:48:15,956
控件时 我们可以使用


1277
00:48:15,956 --> 00:48:16,846
禁用修饰符


1278
00:48:17,686 --> 00:48:18,736
比如说在可能 


1279
00:48:18,736 --> 00:48:19,846
没有点吐司时


1280
00:48:19,846 --> 00:48:21,086
禁用“Order”按钮


1281
00:48:21,086 --> 00:48:23,016
但是 当我们需要


1282
00:48:23,016 --> 00:48:24,106
禁用整个控件组时


1283
00:48:24,106 --> 00:48:25,836
也可能会出现这种情况


1284
00:48:26,536 --> 00:48:27,616
例如 当我们无法


1285
00:48:27,616 --> 00:48:28,646
连接到购买吐司网络


1286
00:48:28,876 --> 00:48:30,606
甚至无法下单时


1287
00:48:30,606 --> 00:48:32,146
我们会希望禁用


1288
00:48:32,146 --> 00:48:33,596
表单中的每个控件


1289
00:48:34,726 --> 00:48:36,046
但是如果我们添加额外


1290
00:48:36,046 --> 00:48:37,566
的控件 其实没什么意思


1291
00:48:37,566 --> 00:48:38,456
而且容易出错


1292
00:48:39,066 --> 00:48:40,146
但是正如你在一般的


1293
00:48:40,146 --> 00:48:41,986
修饰符中看到的那样


1294
00:48:41,986 --> 00:48:43,696
我们可以将这个修饰符


1295
00:48:43,696 --> 00:48:45,126
移除再应用到整个表单中


1296
00:48:45,536 --> 00:48:46,226
就像我们在使用 accentColor


1297
00:48:46,226 --> 00:48:47,226
修饰符时所做的那样


1298
00:48:48,516 --> 00:48:54,546
[掌声]


1299
00:48:55,046 --> 00:48:56,226
现在我们表单中的所有


1300
00:48:56,226 --> 00:48:58,126
控件都将基于这条语法禁用


1301
00:48:59,156 --> 00:49:01,286
所有这些适应性


1302
00:49:01,286 --> 00:49:03,176
和继承操作都非常


1303
00:49:03,176 --> 00:49:04,976
强大 令人惊叹


1304
00:49:04,976 --> 00:49:06,516
因为我们使用的是


1305
00:49:06,516 --> 00:49:08,686
这些简单的值类型视图


1306
00:49:09,316 --> 00:49:10,286
但让我们来看看


1307
00:49:10,336 --> 00:49:12,336
hood 的工作原理


1308
00:49:12,866 --> 00:49:15,116
这些例子是建立在


1309
00:49:15,116 --> 00:49:16,686
environment 之上的


1310
00:49:17,706 --> 00:49:18,976
environment 由视图


1311
00:49:18,976 --> 00:49:21,056
出现的所有上下文组成


1312
00:49:22,486 --> 00:49:23,256
这些都是大家以前


1313
00:49:23,256 --> 00:49:24,276
可能认为是共享


1314
00:49:24,276 --> 00:49:26,066
全局状态的东西


1315
00:49:26,066 --> 00:49:26,936
是你的视图上的


1316
00:49:26,936 --> 00:49:28,256
集合或属性的一部分


1317
00:49:28,256 --> 00:49:29,346
或者需要访问之前的


1318
00:49:29,346 --> 00:49:31,326
历史才能取出值


1319
00:49:32,376 --> 00:49:33,866
但是现在这些都被打包


1320
00:49:34,026 --> 00:49:34,796
到 environment 中


1321
00:49:35,326 --> 00:49:36,916
任何想要访问它的人


1322
00:49:36,916 --> 00:49:38,276
都可以对其进行访问


1323
00:49:39,246 --> 00:49:40,286
每个视图都继承


1324
00:49:40,286 --> 00:49:41,696
其原有的 environment


1325
00:49:43,076 --> 00:49:44,826
现在举个例子 当在


1326
00:49:44,826 --> 00:49:46,196
阿拉伯语环境中运行时


1327
00:49:46,196 --> 00:49:47,476
我们的 App 的根本环境


1328
00:49:47,476 --> 00:49:49,166
有一个从右到左的布局方向


1329
00:49:49,886 --> 00:49:51,746
每个视图都继承这个布局方向


1330
00:49:52,716 --> 00:49:54,136
但是在任何给定的位点


1331
00:49:54,136 --> 00:49:55,086
都可以为视图的


1332
00:49:55,086 --> 00:49:57,016
子树重写环境


1333
00:49:58,176 --> 00:49:59,046
如果我们要创建


1334
00:49:59,046 --> 00:50:00,526
媒体播放控制


1335
00:50:00,526 --> 00:50:01,616
我们想要确保它们是


1336
00:50:01,616 --> 00:50:02,686
从左到右排列的


1337
00:50:03,546 --> 00:50:04,636
通过使用环境修饰语句


1338
00:50:04,636 --> 00:50:06,976
我们可以把它添加到层级结构上


1339
00:50:10,046 --> 00:50:11,666
现在 environment


1340
00:50:11,666 --> 00:50:12,776
也是使预览功能如此强大


1341
00:50:12,956 --> 00:50:15,156
的重要技术之一


1342
00:50:15,756 --> 00:50:16,836
它能够在各种不同的


1343
00:50:16,836 --> 00:50:18,466
上下文中显示相同的 UI


1344
00:50:18,466 --> 00:50:19,936
因此我们可以根据人们


1345
00:50:19,936 --> 00:50:21,206
可能使用它们的所有方式


1346
00:50:21,206 --> 00:50:22,976
来预览我们的 App


1347
00:50:25,276 --> 00:50:26,196
现在各位已经了解了


1348
00:50:26,196 --> 00:50:26,986
环境是如何自动影响


1349
00:50:26,986 --> 00:50:28,416
各种系统视图的


1350
00:50:28,416 --> 00:50:29,696
并且自定义视图也能


1351
00:50:29,696 --> 00:50:30,986
使用 environment


1352
00:50:31,746 --> 00:50:32,516
所以我一直在为我们的


1353
00:50:32,516 --> 00:50:33,886
下一个更新做一个小控件


1354
00:50:34,696 --> 00:50:36,406
它能选择鸡蛋放在


1355
00:50:36,406 --> 00:50:38,766
吐司上的确切位置


1356
00:50:39,646 --> 00:50:41,156
大家可以看到它是使用两个


1357
00:50:41,156 --> 00:50:43,116
简单的 ZStack 图像构建的


1358
00:50:43,116 --> 00:50:44,676
底部的 Toast 和顶部


1359
00:50:44,676 --> 00:50:46,666
带有 dragGesture 的定位图像


1360
00:50:47,526 --> 00:50:48,686
这样 我们就可以轻点


1361
00:50:48,686 --> 00:50:50,426
并拖动鸡蛋到正确的位置


1362
00:50:51,756 --> 00:50:53,466
现在如果我们要使用


1363
00:50:53,466 --> 00:50:56,246
Egg 视图 可能在某些情况下 就需要禁用它


1364
00:50:56,466 --> 00:50:57,766
也许商店的鸡蛋卖完了


1365
00:50:58,986 --> 00:51:00,106
但由于我们使用的是系统


1366
00:51:00,106 --> 00:51:01,416
dragGesture 它会被


1367
00:51:01,466 --> 00:51:04,036
禁用的修饰符自动禁用


1368
00:51:04,036 --> 00:51:05,316
所以如果有人想


1369
00:51:05,316 --> 00:51:07,306
拖动这个鸡蛋是不会成功的


1370
00:51:08,496 --> 00:51:09,826
当然 我们还应该


1371
00:51:09,826 --> 00:51:10,956
提供一些视觉反馈


1372
00:51:10,986 --> 00:51:12,526
来说明它也被禁用了


1373
00:51:12,526 --> 00:51:13,206
还好这个操作很简单


1374
00:51:14,606 --> 00:51:15,706
我们可以添加一个


1375
00:51:15,706 --> 00:51:17,506
环境属性 该属性


1376
00:51:17,506 --> 00:51:18,586
会连接到环境中的


1377
00:51:18,586 --> 00:51:19,036
isEnabled值


1378
00:51:19,886 --> 00:51:21,276
我们可以像使用其他属性


1379
00:51:21,276 --> 00:51:22,146
一样使用它的值


1380
00:51:22,966 --> 00:51:24,206
例如 当它被禁用时


1381
00:51:24,206 --> 00:51:25,276
降低我们整个


1382
00:51:25,276 --> 00:51:26,976
结构的饱和度


1383
00:51:30,066 --> 00:51:32,126
如果放置鸡蛋的视图不再被禁用


1384
00:51:32,446 --> 00:51:33,816
SwiftUI 将自动


1385
00:51:33,816 --> 00:51:35,286
恢复视图的主体并将其


1386
00:51:35,286 --> 00:51:37,896
重新呈现为未禁用状态


1387
00:51:37,976 --> 00:51:41,126
同样 这是 SwiftUI


1388
00:51:41,126 --> 00:51:42,026
在自动管理我们


1389
00:51:42,026 --> 00:51:43,106
对环境的依赖关系


1390
00:51:43,106 --> 00:51:44,276
这样我们就可以表达


1391
00:51:44,276 --> 00:51:45,676
视图与环境之间的关系


1392
00:51:45,676 --> 00:51:46,846
而不必担心什么


1393
00:51:46,846 --> 00:51:48,416
时候会发生变化


1394
00:51:51,436 --> 00:51:53,236
目前我们已经介绍了


1395
00:51:53,236 --> 00:51:54,396
一些控件以及将它们组合


1396
00:51:54,396 --> 00:51:55,096
在一起的方法


1397
00:51:55,096 --> 00:51:56,766
但我们仍然遗漏了


1398
00:51:56,766 --> 00:51:58,376
每个 App 中非常


1399
00:51:58,376 --> 00:52:00,286
重要的部分 那就是


1400
00:52:00,286 --> 00:52:02,246
在这些屏幕之间导航


1401
00:52:02,246 --> 00:52:03,896
从订单表单到鸡蛋放置的


1402
00:52:03,896 --> 00:52:05,496
Picker 再到订单历史记录


1403
00:52:06,236 --> 00:52:07,456
现在让我们从订单开始讲起


1404
00:52:07,456 --> 00:52:09,166
有些人可能已经


1405
00:52:09,166 --> 00:52:10,186
注意到了表单中


1406
00:52:10,186 --> 00:52:11,606
标题的外观


1407
00:52:12,196 --> 00:52:13,086
它不使用标准的


1408
00:52:13,086 --> 00:52:14,106
导航栏样式


1409
00:52:14,106 --> 00:52:16,286
因此我们可以首先将


1410
00:52:16,286 --> 00:52:17,976
OrderForm 包装在 NavigationView


1411
00:52:17,976 --> 00:52:18,836
中作为 App 的内容


1412
00:52:19,606 --> 00:52:20,596
NavigationView 可以


1413
00:52:20,596 --> 00:52:21,776
在 App 屏幕中导航


1414
00:52:21,776 --> 00:52:23,326
显示更多嵌套


1415
00:52:23,326 --> 00:52:24,946
或详细信息


1416
00:52:25,696 --> 00:52:27,646
在 iOS 系统中 NavigationView


1417
00:52:27,646 --> 00:52:29,146
还添加了标准的导航栏 Chrome


1418
00:52:29,146 --> 00:52:31,096
然后我们可以使用


1419
00:52:31,096 --> 00:52:32,846
NavigationBarTitle 修饰语句


1420
00:52:32,846 --> 00:52:34,056
来为表单生成一个


1421
00:52:34,056 --> 00:52:35,156
漂亮的标题


1422
00:52:35,976 --> 00:52:37,706
这个修饰语句有点特殊


1423
00:52:38,306 --> 00:52:39,336
它提供了能够被


1424
00:52:39,336 --> 00:52:40,716
源始 NavigationView


1425
00:52:40,716 --> 00:52:41,976
解释的信息


1426
00:52:43,006 --> 00:52:44,056
我们之前看到过


1427
00:52:44,056 --> 00:52:46,136
一些修饰符的例子


1428
00:52:46,136 --> 00:52:47,316
它们用环境使信息沿着


1429
00:52:47,516 --> 00:52:49,066
视图层级架构向下流动


1430
00:52:49,066 --> 00:52:50,386
这是一个使用


1431
00:52:50,386 --> 00:52:52,696
首选项向上流动信息的例子


1432
00:52:52,696 --> 00:52:54,576
现在我们不打算对此


1433
00:52:54,576 --> 00:52:55,646
进行过多的详细讨论


1434
00:52:55,646 --> 00:52:56,456
但是稍后你会看到


1435
00:52:56,456 --> 00:52:57,596
其他类似的例子


1436
00:52:59,336 --> 00:53:00,816
关注一下表单


1437
00:53:00,816 --> 00:53:01,726
我们要做的下一件事


1438
00:53:01,726 --> 00:53:03,656
是添加支持点鸡蛋的功能


1439
00:53:04,276 --> 00:53:05,476
我们可以在这里


1440
00:53:05,476 --> 00:53:06,966
添加一个 Toggle 


1441
00:53:06,966 --> 00:53:08,946
当有人选择加鸡蛋时


1442
00:53:08,946 --> 00:53:10,426
我们可以添加一个导航行


1443
00:53:10,426 --> 00:53:12,466
它会转向 EggLocationPicker


1444
00:53:13,156 --> 00:53:14,456
我们把它展开看看


1445
00:53:14,456 --> 00:53:15,396
它是如何工作的


1446
00:53:16,506 --> 00:53:18,226
它是使用一个绑定到


1447
00:53:18,226 --> 00:53:19,246
我们订单是否包含一个


1448
00:53:19,246 --> 00:53:19,856
鸡蛋的切换来构建的


1449
00:53:19,856 --> 00:53:21,546
然后它使用与 Matt


1450
00:53:21,546 --> 00:53:22,456
之前展示的相同的


1451
00:53:22,456 --> 00:53:23,756
ViewBuilder 条件


1452
00:53:23,756 --> 00:53:25,506
来选择性地包含导航行


1453
00:53:26,446 --> 00:53:28,516
现在 最酷的事情是


1454
00:53:28,516 --> 00:53:29,926
我们为 Toggle 提供了


1455
00:53:29,926 --> 00:53:31,196
一个动画绑定


1456
00:53:31,796 --> 00:53:32,936
所以每当有人轻点


1457
00:53:32,936 --> 00:53:34,836
这个开关 我们的导航行


1458
00:53:34,836 --> 00:53:36,336
就会被动态地


1459
00:53:36,336 --> 00:53:37,976
插入到 FormList 中


1460
00:53:40,046 --> 00:53:42,536
表示导航行也非常简单


1461
00:53:43,246 --> 00:53:44,556
它使用一个名为


1462
00:53:44,556 --> 00:53:46,776
Navigationbutton 的专门控件


1463
00:53:47,116 --> 00:53:48,346
允许我们在交互时


1464
00:53:48,346 --> 00:53:50,816
提供一些目标内容来导航


1465
00:53:51,636 --> 00:53:52,786
Navigationbutton 自动


1466
00:53:52,786 --> 00:53:53,826
提供了所有出色的外观


1467
00:53:53,826 --> 00:53:55,366
和体验 比如尾部边缘的


1468
00:53:55,366 --> 00:53:56,866
显示指示器


1469
00:53:57,446 --> 00:53:58,966
由于视图是轻量级的


1470
00:53:58,966 --> 00:54:00,156
我们不必担心


1471
00:54:00,156 --> 00:54:01,276
在这里创建了


1472
00:54:01,276 --> 00:54:02,416
EggLocationPicker


1473
00:54:03,106 --> 00:54:04,426
SwiftUI 只在


1474
00:54:04,426 --> 00:54:06,046
实际呈现这些视图时


1475
00:54:06,046 --> 00:54:07,446
才会呈现它们


1476
00:54:08,596 --> 00:54:10,256
现在在 EggLocationPicker 中


1477
00:54:10,256 --> 00:54:11,516
我们可以使用 PlacementView


1478
00:54:12,146 --> 00:54:13,526
自定义导航栏


1479
00:54:13,526 --> 00:54:14,546
这样一旦它被显示


1480
00:54:14,546 --> 00:54:16,346
标题就会反映它的当前状态


1481
00:54:16,966 --> 00:54:17,936
我们还可以添加一个追踪的


1482
00:54:17,936 --> 00:54:19,416
BarItem 来快速地将


1483
00:54:19,416 --> 00:54:20,756
egg 重置回初始状态


1484
00:54:21,726 --> 00:54:22,686
正如大家所希望的那样


1485
00:54:22,686 --> 00:54:24,176
这里的项与我们


1486
00:54:24,176 --> 00:54:25,176
已经学会如何使用


1487
00:54:25,176 --> 00:54:26,466
的视图是相同的 因此我们


1488
00:54:26,466 --> 00:54:27,326
只需要提供一个按钮


1489
00:54:28,346 --> 00:54:29,046
这就是创建完整导航


1490
00:54:29,046 --> 00:54:30,976
体验所需要的全部


1491
00:54:33,096 --> 00:54:34,376
现在我们可以把注意力


1492
00:54:34,376 --> 00:54:35,176
转向 OrderHistory


1493
00:54:36,116 --> 00:54:37,346
现在我们想导航到这里


1494
00:54:37,456 --> 00:54:38,646
但它不是表单的更详细


1495
00:54:38,646 --> 00:54:39,966
或嵌套的信息


1496
00:54:40,436 --> 00:54:41,756
而是 App 的一个


1497
00:54:41,756 --> 00:54:43,316
完全不同的部分


1498
00:54:44,556 --> 00:54:46,576
这更适合使用 TabbedView


1499
00:54:47,796 --> 00:54:49,186
因此 我们可以像处理


1500
00:54:49,186 --> 00:54:50,596
NavigationView 一样


1501
00:54:50,596 --> 00:54:52,856
将表单封装在 TabbedView 中 然后将


1502
00:54:52,856 --> 00:54:54,436
OrderHistory 添加为另一个子元素


1503
00:54:55,616 --> 00:54:56,976
两者都有 tabItemLabel 修饰符


1504
00:54:56,976 --> 00:54:57,896
它负责向 TabbedView


1505
00:54:57,896 --> 00:55:00,096
描述如何在选项卡栏中标记它们


1506
00:55:03,046 --> 00:55:04,746
现在我们可以快速跳转到 OrderHistory


1507
00:55:04,916 --> 00:55:06,196
但是现在我们已经对


1508
00:55:06,196 --> 00:55:07,596
OrderHistory 有了一个简单的细节了解


1509
00:55:07,596 --> 00:55:09,226
我们可能想要将其


1510
00:55:09,226 --> 00:55:10,316
扩展为更详细的信息集


1511
00:55:10,316 --> 00:55:12,046
以便从历史列表


1512
00:55:12,046 --> 00:55:13,736
导航到这些信息


1513
00:55:14,646 --> 00:55:15,796
这是嵌套或显示


1514
00:55:15,796 --> 00:55:16,676
更详细信息的另一种情况


1515
00:55:16,676 --> 00:55:18,236
就像我们前面在 NavigationView


1516
00:55:18,236 --> 00:55:19,626
和按钮 中看到的那样


1517
00:55:19,626 --> 00:55:22,156
因此我们可以替换


1518
00:55:22,156 --> 00:55:23,356
OrderHistory 列表的内容


1519
00:55:23,646 --> 00:55:24,896
因此我们可以使用这个


1520
00:55:24,896 --> 00:55:25,896
新的 OrderDetail 作为


1521
00:55:25,896 --> 00:55:27,646
NavigationButtons 的目标


1522
00:55:27,646 --> 00:55:28,926
而不是将它以内联


1523
00:55:28,926 --> 00:55:30,856
方式显示在列表中


1524
00:55:31,786 --> 00:55:32,986
构建一个数据驱动


1525
00:55:32,986 --> 00:55:34,516
列表非常简单


1526
00:55:34,516 --> 00:55:36,336
它可以导航到其他内容


1527
00:55:37,606 --> 00:55:38,796
这在 iPhone 上


1528
00:55:38,796 --> 00:55:40,206
很好用 但如果是


1529
00:55:40,206 --> 00:55:41,736
iPad 我们希望这个设置


1530
00:55:41,736 --> 00:55:43,176
使用主细节和 SplitView


1531
00:55:44,486 --> 00:55:45,926
不像 iPhone 上的 navigationStack


1532
00:55:45,926 --> 00:55:47,456
会推送到单个 RootView


1533
00:55:47,456 --> 00:55:49,226
在这里我们知道


1534
00:55:49,226 --> 00:55:50,966
我们有 RootView 的


1535
00:55:50,966 --> 00:55:52,336
两个导航 即能够将内容


1536
00:55:52,336 --> 00:55:55,476
推送到细节的 Master


1537
00:55:55,646 --> 00:55:56,716
因此 虽然我们的 NavigationView


1538
00:55:56,716 --> 00:55:57,626
仅对 iPhone 上的单个


1539
00:55:57,626 --> 00:55:59,776
RootContent 执行


1540
00:55:59,776 --> 00:56:00,606
正确操作 但我们希望


1541
00:56:00,606 --> 00:56:01,826
指出它本质上


1542
00:56:01,826 --> 00:56:03,656
包含这两部分内容


1543
00:56:03,656 --> 00:56:05,936
OrderHistory Master 和 DetailView


1544
00:56:06,696 --> 00:56:07,636
这里 我们可以使用


1545
00:56:07,636 --> 00:56:09,276
OrderDetailPlaceholder 视图


1546
00:56:09,276 --> 00:56:10,456
作为占位符 以便在没有选择


1547
00:56:10,456 --> 00:56:11,276
任何内容时充当占位符


1548
00:56:12,196 --> 00:56:12,956
现在 当在 OrderHistory


1549
00:56:12,956 --> 00:56:14,516
中与 Navigationbutton


1550
00:56:14,516 --> 00:56:15,566
交互时它将自动被


1551
00:56:15,746 --> 00:56:18,286
推送到 OrderDetail


1552
00:56:18,286 --> 00:56:20,196
这将像我们在 iPad


1553
00:56:20,196 --> 00:56:21,406
和其他使用 SplitView的


1554
00:56:21,436 --> 00:56:23,306
大类上所期望的那样


1555
00:56:23,776 --> 00:56:24,966
而对于小尺寸类


1556
00:56:25,276 --> 00:56:26,566
则会自动折叠成


1557
00:56:26,566 --> 00:56:27,606
单个 NavigationStack


1558
00:56:28,176 --> 00:56:30,656
当然 这在 macOS


1559
00:56:30,656 --> 00:56:32,946
上也能操作 创建出一个 SplitView


1560
00:56:32,946 --> 00:56:35,606
这不是写一次


1561
00:56:35,606 --> 00:56:36,596
就能运行的 还需要


1562
00:56:36,596 --> 00:56:37,706
一些额外的设计考虑


1563
00:56:37,706 --> 00:56:38,906
比如 macOS 上


1564
00:56:38,906 --> 00:56:41,276
信息密度的增加


1565
00:56:42,656 --> 00:56:43,936
但是 SwiftUI 会自动


1566
00:56:43,936 --> 00:56:45,606
处理平台的底层外观


1567
00:56:45,606 --> 00:56:47,206
从 SplitView


1568
00:56:47,206 --> 00:56:48,656
的操作到表行


1569
00:56:48,656 --> 00:56:50,396
的高度等等


1570
00:56:51,426 --> 00:56:52,436
这样我们就可以学习


1571
00:56:52,436 --> 00:56:53,526
如何使用这些不同的概念


1572
00:56:53,526 --> 00:56:55,306
后把它们应用到任意地方


1573
00:56:56,406 --> 00:56:57,556
然后我们可以把时间集中在


1574
00:56:57,826 --> 00:56:59,206
一些令人兴奋的自定义功能上


1575
00:56:59,206 --> 00:57:00,706
这些功能会使你的每个


1576
00:57:00,706 --> 00:57:00,976
App 都变得很棒


1577
00:57:03,256 --> 00:57:04,436
在这最后的一个小时里


1578
00:57:04,436 --> 00:57:05,516
我们已经讲了相当多的内容


1579
00:57:05,516 --> 00:57:06,966
还有一些其他的讲座


1580
00:57:06,966 --> 00:57:08,486
会展现更多的细节


1581
00:57:09,366 --> 00:57:10,456
我们展示了状态和绑定


1582
00:57:10,456 --> 00:57:11,426
将如何改变你和控件


1583
00:57:11,426 --> 00:57:12,926
的交互方式 但是


1584
00:57:12,926 --> 00:57:14,266
SwiftUI 中的数据流将使你


1585
00:57:14,266 --> 00:57:16,226
重新考虑数据驱动


1586
00:57:16,226 --> 00:57:16,506
的 UI 更新


1587
00:57:17,916 --> 00:57:19,056
我们使用布局调整器


1588
00:57:19,056 --> 00:57:20,346
建立了一些自定义视图


1589
00:57:20,346 --> 00:57:21,636
但是 SwiftUI 中的自定义控件


1590
00:57:21,636 --> 00:57:23,266
将深入研究布局 图形


1591
00:57:23,266 --> 00:57:24,826
和动画的高级应用


1592
00:57:24,826 --> 00:57:26,886
并做一个出色的演示


1593
00:57:28,256 --> 00:57:29,116
我们知道 很多人会


1594
00:57:29,116 --> 00:57:30,116
迫不及待地使用


1595
00:57:30,116 --> 00:57:31,546
SwiftUI 并且可能想知道


1596
00:57:31,546 --> 00:57:32,486
是否可以将其集成到


1597
00:57:32,486 --> 00:57:33,426
现有的 App 中


1598
00:57:33,426 --> 00:57:34,706
好的方面是 SwiftUI


1599
00:57:35,036 --> 00:57:36,106
的设计可以与


1600
00:57:36,106 --> 00:57:37,616
现有的视图和


1601
00:57:37,616 --> 00:57:39,116
模型无缝融合


1602
00:57:39,766 --> 00:57:40,686
我们有一个完整的讲座


1603
00:57:40,776 --> 00:57:41,626
向大家展示如何做到这一点


1604
00:57:43,026 --> 00:57:44,036
我们谈到了 SwiftUI


1605
00:57:44,036 --> 00:57:44,906
是如何设计的 来让你的


1606
00:57:44,906 --> 00:57:46,926
App 能让所有人都可以访问


1607
00:57:47,446 --> 00:57:48,166
当然 总会有一些


1608
00:57:48,166 --> 00:57:49,236
额外的考量 这次演讲


1609
00:57:49,346 --> 00:57:51,186
将会涉及更多的细节


1610
00:57:52,086 --> 00:57:53,096
最后 但最重要的是


1611
00:57:53,096 --> 00:57:54,446
我们展示了 SwiftUI


1612
00:57:54,446 --> 00:57:56,066
是如何提高跨平台


1613
00:57:56,066 --> 00:57:57,746
共享的门槛的


1614
00:57:58,616 --> 00:57:59,986
所有设备上的 SwiftUI 


1615
00:57:59,986 --> 00:58:01,426
将这一点作为基准


1616
00:58:01,426 --> 00:58:02,786
并详细介绍了如何在任意


1617
00:58:02,786 --> 00:58:04,646
平台上开发出优秀的 App


1618
00:58:05,606 --> 00:58:06,756
还有一些额外的演讲


1619
00:58:06,756 --> 00:58:08,526
比如驱动 watchOS


1620
00:58:08,526 --> 00:58:09,706
和《What's New in Swift》


1621
00:58:09,706 --> 00:58:11,416
中关于 watchOS 的详细内容


1622
00:58:12,266 --> 00:58:14,216
最后 感谢大家的收看


1623
00:58:14,566 --> 00:58:15,526
我们对此十分感激


1624
00:58:16,516 --> 00:58:23,500
[掌声]

