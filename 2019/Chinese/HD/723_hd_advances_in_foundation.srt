1
00:00:07,007 --> 00:00:12,079 line:0
（Foundation进阶）


2
00:00:12,813 --> 00:00:14,014 line:-1
大家好


3
00:00:14,381 --> 00:00:15,682 line:-1
我是Tina


4
00:00:16,183 --> 00:00:18,585 line:-2
我是Foundation团队的
一名工程师


5
00:00:18,652 --> 00:00:22,689 line:-2
我将会讲解我们为Foundation
添加新API的亮点


6
00:00:22,756 --> 00:00:25,325 line:-2
现在 我们开始介绍
这些API亮点


7
00:00:25,859 --> 00:00:29,029 line:-1
我们今天会介绍很多不同的内容


8
00:00:31,665 --> 00:00:34,034 line:-1
我们从有序集合的diff比较开始


9
00:00:34,535 --> 00:00:38,071 line:-2
它是一个API
这个API允许你在不同集合之间


10
00:00:38,138 --> 00:00:40,874 line:-1
计算 编码以及比较之间的差异


11
00:00:41,642 --> 00:00:44,411 line:-1
我用一个故事来向你们说明


12
00:00:44,912 --> 00:00:48,615 line:-2
一个bear字符非常
想转换成为bird字符


13
00:00:49,183 --> 00:00:50,684 line:-1
我们来了解如何实现


14
00:00:50,751 --> 00:00:52,319 line:-1
（有序集合的diff比较）


15
00:00:52,386 --> 00:00:56,723 line:-2
我们注意到bird中
没有bear的E和A


16
00:00:57,558 --> 00:01:00,794 line:-1
它还需要bird中的I和D


17
00:01:01,962 --> 00:01:05,199 line:-1
那么 我们来移掉E和A


18
00:01:05,766 --> 00:01:07,634 line:-1
在中间插入一个I


19
00:01:08,302 --> 00:01:09,570 line:-1
在最后插入一个D


20
00:01:10,771 --> 00:01:13,807 line:-2
这样我们移除了两个
又增加了两个


21
00:01:13,874 --> 00:01:16,543 line:-1
来将bear变为bird


22
00:01:18,545 --> 00:01:22,282 line:-2
使用有序集合diff比较的API
可以非常容易实现


23
00:01:24,418 --> 00:01:27,287 line:-2
这里的diff是一个集合的
difference类型


24
00:01:27,855 --> 00:01:30,791 line:-1
它是插入和移除的一个集合


25
00:01:31,058 --> 00:01:34,661 line:-1
表示插入和移除的元素


26
00:01:35,262 --> 00:01:37,898 line:-1
以及集合中元素的偏移量


27
00:01:38,765 --> 00:01:42,769 line:-2
你刚才看到的 它包含了两个
插入和两个移除


28
00:01:45,105 --> 00:01:48,742 line:-2
我们可以在bear上使用diff
来得到一个新的bird字符串


29
00:01:49,476 --> 00:01:53,447 line:-2
这是一个非常强大的API
它不仅仅运用于字符串上


30
00:01:53,714 --> 00:01:55,048 line:-1
任何集合类型都可以


31
00:01:55,115 --> 00:01:57,084 line:-1
这就是有序集合的diff比较


32
00:01:57,451 --> 00:01:59,953 line:-1
下面 我们来讲一下数据和连续性


33
00:02:00,020 --> 00:02:01,054 line:-1
（数据连续性）


34
00:02:01,121 --> 00:02:05,292 line:-2
你的app可能会在硬盘里创建
图片或其他类型的文件


35
00:02:05,859 --> 00:02:09,963 line:-1
通常 这些样式的数据


36
00:02:10,030 --> 00:02:12,366 line:-1
能很容易地在内存中相连区中展示


37
00:02:14,001 --> 00:02:15,102 line:-1
另一方面


38
00:02:15,435 --> 00:02:18,172 line:-2
你的app可能使用比如调度数据
或URL会话


39
00:02:18,238 --> 00:02:21,608 line:-1
从互联网上下载数据


40
00:02:22,309 --> 00:02:23,610 line:-1
这会产生字节


41
00:02:23,677 --> 00:02:26,547 line:-1
在不同时间产生多个块


42
00:02:26,813 --> 00:02:29,950 line:-1
占据内存中的相连区域


43
00:02:32,219 --> 00:02:33,754 line:-1
在Swift 5以前


44
00:02:34,021 --> 00:02:38,192 line:-1
数据结构表示连续和不连续区域


45
00:02:38,825 --> 00:02:41,929 line:-1
这个统一的界面使用起来很简单


46
00:02:42,663 --> 00:02:45,532 line:-1
但是它也代表将整个缓存


47
00:02:45,599 --> 00:02:47,267 line:-1
放置底层原始字节


48
00:02:47,601 --> 00:02:51,305 line:-2
我们需要复制这个区域
到一个连续的区域


49
00:02:53,106 --> 00:02:56,677 line:-2
这意味着有时候会有无法预知的
行为表现


50
00:02:57,277 --> 00:03:01,415 line:-1
事实上 我们知道数据真实使用情况


51
00:03:02,015 --> 00:03:03,884 line:-1
每个不连续的数据


52
00:03:03,951 --> 00:03:06,620 line:-1
在它的生命周期中有时畅通无阻


53
00:03:09,022 --> 00:03:13,660 line:-2
所以 从Swift 5开始
我们将结构数据定义为


54
00:03:13,727 --> 00:03:15,562 line:-1
一个连续的缓存类型


55
00:03:16,296 --> 00:03:21,935 line:-2
为在语法中施行该协议 我们引入了
ContiguousBytes协议


56
00:03:23,203 --> 00:03:25,372 line:-1
为了遵循这个协议


57
00:03:25,439 --> 00:03:29,309 line:-1
这个类型提供以直接


58
00:03:29,610 --> 00:03:31,078 line:-1
连续的方式进入底层原始字节


59
00:03:31,545 --> 00:03:32,913 line:-1
所以 你再也不必担心


60
00:03:32,980 --> 00:03:35,749 line:-1
意外地接触到你的数据了


61
00:03:37,084 --> 00:03:40,320 line:-1
现在 我们是如何处理其他


62
00:03:40,387 --> 00:03:42,289 line:-1
不连续的缓存类型的呢？


63
00:03:44,424 --> 00:03:49,329 line:-1
我们介绍了两个新的协议


64
00:03:49,596 --> 00:03:51,865 line:-1
将结构数据的界面从独立变为连续


65
00:03:52,132 --> 00:03:55,068 line:-1
将它推广到不同的缓存类型


66
00:03:55,469 --> 00:03:58,005 line:-1
我们来看DataProtocol


67
00:03:58,705 --> 00:04:02,943 line:-2
这是一个字节的集合
MutableDataProtocol


68
00:04:03,277 --> 00:04:05,946 line:-1
提供了额外的多变性保证


69
00:04:08,882 --> 00:04:13,020 line:-2
Buffer类型是由Swift
标准库Foundation提供的


70
00:04:13,086 --> 00:04:16,790 line:-1
调度框架采用了这些协议


71
00:04:17,524 --> 00:04:19,692 line:-1
你可能已经用过其中的一些类型


72
00:04:19,760 --> 00:04:24,298 line:-2
包括Data、UInt8数组和
DispatchData


73
00:04:25,465 --> 00:04:28,936 line:-2
我们建议你也在你的类型或方法
也采用它们


74
00:04:29,002 --> 00:04:30,637 line:-1
作为一个通用的约束


75
00:04:33,974 --> 00:04:35,709 line:-1
现在我们来看一下约束


76
00:04:36,743 --> 00:04:40,380 line:-2
通常 你想要将你的数据
尽可能地变小


77
00:04:41,081 --> 00:04:42,482 line:-1
你的app可能在有限的


78
00:04:42,549 --> 00:04:45,652 line:-1
磁盘空间的设备上运行


79
00:04:46,053 --> 00:04:49,590 line:-2
或者你需要在网上
上传或下载资源


80
00:04:51,325 --> 00:04:53,093 line:-1
这是一个非常常见的任务


81
00:04:53,460 --> 00:04:56,730 line:-2
所以我们在Swift上的数据
引入了这个压缩API


82
00:04:57,397 --> 00:04:58,899 line:-1
它现在很简单


83
00:04:59,600 --> 00:05:00,434 line:-1
谢谢


84
00:05:03,136 --> 00:05:05,572 line:-1
它只是一行代码


85
00:05:07,541 --> 00:05:10,844 line:-1
这个API也支持4种压缩算法


86
00:05:11,411 --> 00:05:14,648 line:-1
基于速度 内存和压缩率


87
00:05:14,715 --> 00:05:16,850 line:-1
来为你提供不同的平衡区


88
00:05:17,451 --> 00:05:20,587 line:-2
我相信你能从中找到
一个最适合你的


89
00:05:22,489 --> 00:05:23,323 line:-1
（单元）


90
00:05:23,390 --> 00:05:25,025 line:-1
现在 我们来讲单元


91
00:05:25,759 --> 00:05:30,531 line:-2
Foundation已经支持了
21种类型来表示通常的物理单元


92
00:05:30,898 --> 00:05:33,934 line:-1
比如长度 速度和时长


93
00:05:35,102 --> 00:05:39,840 line:-1
我们扩展了单元时长类型


94
00:05:39,907 --> 00:05:41,542 line:-1
将亚秒单元提升至了皮秒


95
00:05:41,942 --> 00:05:44,278 line:-1
这是万亿分之一秒


96
00:05:45,445 --> 00:05:49,650 line:-2
现在 单元频率类型使用赫兹
来作为基本单元


97
00:05:50,150 --> 00:05:52,786 line:-2
今年 我们引入了
framesPerSecond


98
00:05:53,687 --> 00:05:55,956 line:-1
它和赫兹的功能相同


99
00:05:56,390 --> 00:06:01,628 line:-1
但它非常适合度量设备的FPS


100
00:06:04,364 --> 00:06:07,100 line:-2
UnitInformationStorage
是一个新的类型


101
00:06:07,968 --> 00:06:11,605 line:-1
它能被用来表示数码信息的数量


102
00:06:12,639 --> 00:06:15,909 line:-1
基本单元是位 字节和四位元


103
00:06:16,643 --> 00:06:22,850 line:-2
通常使用的前缀为
SI-和binary-的单元


104
00:06:22,916 --> 00:06:26,520 line:-2
从kilo和kibi
到同样支持的yotta和yobi


105
00:06:27,721 --> 00:06:31,058 line:-1
使用MeasurementFormatter一起


106
00:06:31,124 --> 00:06:33,293 line:-1
来设计格式 比如数据大小


107
00:06:33,760 --> 00:06:38,165 line:-2
或使用ByteCountFormatter
一起来做更精准的控制


108
00:06:40,400 --> 00:06:42,236 line:-1
我们为你提供了更多的格式器


109
00:06:42,302 --> 00:06:43,237 line:-1
（展示一个日期或时间）


110
00:06:43,303 --> 00:06:46,473 line:-1
你可能每天都看到过这些字符串


111
00:06:47,074 --> 00:06:50,777 line:-2
比如 一则你发送的消息状态
一小时前已读


112
00:06:51,278 --> 00:06:53,947 line:-1
或是明天的一项付款


113
00:06:54,481 --> 00:06:58,886 line:-2
它是当前展示的
一个相关的日期或时间


114
00:07:00,053 --> 00:07:00,888 line:-1
它是


115
00:07:00,954 --> 00:07:04,258 line:-2
对于所有语言环境来说
修正它并不重要


116
00:07:04,992 --> 00:07:08,529 line:-2
我们引入了RelativeDateTimeFormatter
来协助你


117
00:07:14,635 --> 00:07:15,469 line:-1
谢谢


118
00:07:15,836 --> 00:07:20,174 line:-2
和其他格式器类似
返回的字符串是对语言环境友好的


119
00:07:20,440 --> 00:07:22,910 line:-1
你可以选择的类型有很多


120
00:07:23,243 --> 00:07:24,378 line:-1
（相对的时间日期格式器）


121
00:07:24,912 --> 00:07:27,581 line:-1
你想要的另一个样式可能是一个列表


122
00:07:28,415 --> 00:07:32,519 line:-2
我们也引入了ListFormatter
来为你提供便利


123
00:07:32,586 --> 00:07:37,324 line:-1
（列表格式器）


124
00:07:37,391 --> 00:07:41,328 line:-2
它将使用正确的分隔符将
一个列表转变为一个字符串


125
00:07:41,395 --> 00:07:43,630 line:-1
连接了所有的语言环境


126
00:07:44,831 --> 00:07:46,266 line:-1
这是另一个例子


127
00:07:46,934 --> 00:07:48,836 line:-1
一个事件会在


128
00:07:48,902 --> 00:07:51,071 line:-1
三个不同的日期发生


129
00:07:51,638 --> 00:07:54,975 line:-1
所以你会想要展现一个像上面的或是


130
00:07:55,742 --> 00:07:57,077 line:-1
下面的字符串


131
00:07:57,144 --> 00:08:00,514 line:-1
在你的事件页面罗列出月份


132
00:08:02,249 --> 00:08:04,218 line:-2
以及 当然 你会想要使用
正确的格式


133
00:08:04,284 --> 00:08:08,088 line:-1
和不同语言环境的本地化名字来展示


134
00:08:08,689 --> 00:08:11,992 line:-2
这很重要 因为 比如
在欧洲


135
00:08:12,559 --> 00:08:15,395 line:-2
通常在书面形式上
日在月的前面


136
00:08:16,663 --> 00:08:19,766 line:-2
也可用ListFormatter
非常简单地实现


137
00:08:22,102 --> 00:08:25,038 line:-2
它有一个属性叫做
itemFormatter


138
00:08:25,405 --> 00:08:28,342 line:-1
规定列表上的每一项的格式


139
00:08:28,909 --> 00:08:31,945 line:-2
在这种情况下 我想要
格式化列表的日期


140
00:08:32,779 --> 00:08:35,582 line:-2
我们知道Foundation的
DateFormatter


141
00:08:35,649 --> 00:08:37,083 line:-1
支持日期格式化


142
00:08:37,751 --> 00:08:40,754 line:-2
所以 我们使用它作为我们日期的
itemFormatter


143
00:08:41,922 --> 00:08:43,390 line:-1
这就是我们想要的


144
00:08:43,823 --> 00:08:44,892 line:-1
完成了


145
00:08:45,792 --> 00:08:49,763 line:-1
这就是示例底部的本地化字符串


146
00:08:53,133 --> 00:08:57,371 line:-2
你很容易通过设置DateFormatter
的属性来改变日期形式


147
00:08:58,238 --> 00:09:02,676 line:-2
ListFormatter适用于
所有的格式器 所以请好好利用它


148
00:09:02,743 --> 00:09:06,914 line:-2
为你的app提供更好的
本地化字符串


149
00:09:10,150 --> 00:09:11,718 line:-1
这就是格式器


150
00:09:12,152 --> 00:09:14,254 line:-1
下面 我们来介绍操作队列


151
00:09:14,321 --> 00:09:15,389 line:-1
（操作队列）


152
00:09:15,455 --> 00:09:16,723 line:-1
想象一下 在你的app中


153
00:09:16,990 --> 00:09:20,127 line:-1
有一些后台任务在同时运行


154
00:09:21,762 --> 00:09:22,763 line:-1
现在


155
00:09:23,096 --> 00:09:25,899 line:-1
用户想保存这个运行中app的状态


156
00:09:26,466 --> 00:09:27,935 line:-1
那么 你要如何实现呢


157
00:09:28,936 --> 00:09:32,105 line:-1
那么 你想要确认所有运行中的


158
00:09:32,172 --> 00:09:33,540 line:-1
任务在你能保存之前会结束


159
00:09:34,341 --> 00:09:37,477 line:-1
所以它可能需要这样实现


160
00:09:39,446 --> 00:09:42,416 line:-1
你检查当前队列中


161
00:09:42,482 --> 00:09:43,750 line:-1
运行操作的数量


162
00:09:44,318 --> 00:09:45,986 line:-1
如果没有


163
00:09:46,053 --> 00:09:49,223 line:-2
它就说明我们之前规划的任务
一定结束了


164
00:09:49,590 --> 00:09:51,325 line:-1
所以我们可以保存了 是吗？


165
00:09:52,192 --> 00:09:53,727 line:-1
不是的


166
00:09:54,161 --> 00:09:55,495 line:-1
请不要这么做


167
00:09:58,465 --> 00:10:00,501 line:-1
在它们所有的线程中


168
00:10:00,567 --> 00:10:03,604 line:-1
其他的任务有可能在同时运行


169
00:10:03,904 --> 00:10:08,342 line:-2
比如 它在检查之后
保存之前发生


170
00:10:09,710 --> 00:10:14,648 line:-2
你这里需要的是一个屏障
来保证安全操作


171
00:10:14,715 --> 00:10:19,586 line:-2
在app状态被保存时
保证没有其他任务在运行


172
00:10:20,621 --> 00:10:21,688 line:-1
像这样


173
00:10:24,191 --> 00:10:28,962 line:-2
所以 我们很兴奋地告诉你
操作队列现在支持屏障


174
00:10:29,563 --> 00:10:31,398 line:-1
你应添加BarrierBlock


175
00:10:31,465 --> 00:10:34,401 line:-1
在屏障内进行保存操作


176
00:10:35,102 --> 00:10:37,638 line:-1
这会保证在那段特定的时间


177
00:10:37,704 --> 00:10:41,542 line:-1
保存操作是唯一在运行的任务


178
00:10:42,242 --> 00:10:46,313 line:-2
以及 它只会在所有任务运行结束后
执行


179
00:10:46,747 --> 00:10:50,918 line:-2
在它结束前不会有其他
新任务运行


180
00:10:57,958 --> 00:11:01,562 line:-2
操作队列另一个更新的点是
进度报告


181
00:11:02,396 --> 00:11:04,965 line:-1
有时你可能想要追踪你当前


182
00:11:05,032 --> 00:11:06,533 line:-1
所有任务的所有的进程


183
00:11:06,834 --> 00:11:09,670 line:-1
在你的UI中展示一个进度栏


184
00:11:10,370 --> 00:11:13,774 line:-1
你现在可以通过设置操作队列中的


185
00:11:13,841 --> 00:11:17,177 line:-2
进程属性
totalUnitCount实现


186
00:11:17,244 --> 00:11:18,312 line:-1
（操作队列）


187
00:11:18,378 --> 00:11:21,381 line:-2
你在操作队列上加入的
每一个操作


188
00:11:21,448 --> 00:11:25,485 line:-1
在操作结束后 计数器为所有的


189
00:11:25,552 --> 00:11:27,221 line:-1
进程创建一个完成单元


190
00:11:32,626 --> 00:11:34,127 line:-1
接下来是文件系统


191
00:11:34,194 --> 00:11:35,128 line:-2
（为iOS上的
USB和SMB做好准备）


192
00:11:35,195 --> 00:11:40,300 line:-2
iOS现在支持USB和SMB卷
它是一个网络文件系统


193
00:11:41,101 --> 00:11:43,904 line:-1
这代表着你应该为处理可能在


194
00:11:43,971 --> 00:11:46,006 line:-1
其他卷上的文件做好准备


195
00:11:46,940 --> 00:11:50,844 line:-2
在如下场景 请确保使用FileManager
的itemReplacementDirectory


196
00:11:51,111 --> 00:11:54,414 line:-1
当你为写入新的文件内容选择地方时


197
00:11:54,481 --> 00:11:57,484 line:-1
当你操作原子级的安全保存时


198
00:11:59,620 --> 00:12:03,390 line:-1
接下来 如果用户弹出USB设备


199
00:12:03,457 --> 00:12:07,995 line:-1
或失去与SMB服务器网络连接


200
00:12:08,061 --> 00:12:09,496 line:-1
你要在卷完全消失之前做好准备


201
00:12:10,631 --> 00:12:14,268 line:-2
如果你在读取数据对象时
选择内存映射文件


202
00:12:14,835 --> 00:12:18,839 line:-2
确保使用mappedIfSafe
为你的读取选项


203
00:12:19,673 --> 00:12:23,577 line:-1
这会允许系统映射文件至虚拟内存中


204
00:12:24,144 --> 00:12:28,215 line:-1
但仅当文件处于不可移动的卷时


205
00:12:28,815 --> 00:12:33,187 line:-2
从USB或SMB盘上读取文件
可能比


206
00:12:33,253 --> 00:12:35,856 line:-1
内置存储器慢很多


207
00:12:36,890 --> 00:12:38,692 line:-1
所以 如果你还没有实现它


208
00:12:39,059 --> 00:12:42,629 line:-1
请将文件系统放置到非主线程里


209
00:12:42,696 --> 00:12:45,232 line:-1
来保持你的app持续相应


210
00:12:46,800 --> 00:12:50,571 line:-2
在使用它们之前 你可能需要测试
文件系统的性能


211
00:12:51,371 --> 00:12:52,372 line:-1
比如


212
00:12:52,773 --> 00:12:56,243 line:-1
你熟悉的APFS功能 比如克隆


213
00:12:57,044 --> 00:13:00,547 line:-1
在当你通过USB或SMB


214
00:13:00,614 --> 00:13:02,549 line:-1
访问其他卷时可能不可用


215
00:13:03,784 --> 00:13:06,720 line:-1
你可以通过


216
00:13:06,787 --> 00:13:09,223 line:-1
大量的URL资源关键字事件


217
00:13:09,957 --> 00:13:14,695 line:-2
或在处理收取错误时做好准备
来测试这些性能


218
00:13:15,696 --> 00:13:18,131 line:-2
你可以在文件管理
和QuickLook的新功能


219
00:13:18,198 --> 00:13:22,102 line:-1
的演讲上了解关于它的更多信息


220
00:13:25,706 --> 00:13:27,407 line:-1
接下来 Swift更新


221
00:13:27,474 --> 00:13:28,642 line:-1
（Swift更新了扫描仪）


222
00:13:28,709 --> 00:13:33,280 line:-2
一些Swift的API最开始基于
Objective-C的理念设计


223
00:13:34,047 --> 00:13:37,651 line:-1
我们这些年在不断提升它们


224
00:13:38,452 --> 00:13:39,720 line:-1
首先是扫描仪


225
00:13:41,588 --> 00:13:43,690 line:-1
这是Swift 4上的API


226
00:13:44,458 --> 00:13:46,426 line:-1
它之前被用来使用NSString


227
00:13:47,528 --> 00:13:49,496 line:-1
和通过引用返回对象


228
00:13:51,265 --> 00:13:56,904 line:-2
在Swift 5.1
我们将这个界面简化为了一行代码


229
00:13:58,639 --> 00:14:03,443 line:-2
以及这个新的API使用了
Swift的字符串类型


230
00:14:03,977 --> 00:14:06,880 line:-1
字符串是图新的集合


231
00:14:06,947 --> 00:14:08,582 line:-1
而不是代码点


232
00:14:09,349 --> 00:14:12,519 line:-1
这意味着使用新的扫描仪的API


233
00:14:12,586 --> 00:14:16,623 line:-2
你现在能处理复杂的序列
比如颜文字


234
00:14:18,659 --> 00:14:19,893 line:-1
（SWIFT更新了文件句柄）


235
00:14:19,960 --> 00:14:22,095 line:-1
另一个提升的地方是文件句柄


236
00:14:22,996 --> 00:14:25,799 line:-1
它以前被用来处理当错误发生时


237
00:14:25,866 --> 00:14:28,268 line:-1
在底层的文件描述符抛出异常


238
00:14:29,269 --> 00:14:32,406 line:-1
今年 我们引入了基于错误的API


239
00:14:32,840 --> 00:14:36,577 line:-1
现在你能立刻调用站点处理错误


240
00:14:37,878 --> 00:14:41,748 line:-2
这个为写入数据创建的API
现在也支持数据协议了


241
00:14:42,316 --> 00:14:45,719 line:-1
它也为非连续数据做了优化


242
00:14:48,455 --> 00:14:51,091 line:-1
这些就是新API的亮点


243
00:14:51,725 --> 00:14:56,263 line:-2
我们鼓励你在新的Xcode中
尝试使用这些新的功能


244
00:14:56,330 --> 00:14:57,164 line:-1
（试一试）


245
00:14:57,231 --> 00:15:00,300 line:-1
当使用二进制数据创建新方法时


246
00:15:00,934 --> 00:15:04,004 line:-1
考虑为它们绑定数据协议类型


247
00:15:04,404 --> 00:15:09,243 line:-2
而不是请求特殊的集合
比如UInt8数组


248
00:15:10,477 --> 00:15:15,382 line:-2
如果你在UI上以字符串的形式
展示日期或列表


249
00:15:16,550 --> 00:15:20,754 line:-2
使用RelativeDateTimeFormatter
或一个ListFormatter


250
00:15:20,821 --> 00:15:23,524 line:-2
来让字符串在每个语言环境都能
正常运行


251
00:15:25,225 --> 00:15:28,328 line:-1
我们强烈向你推荐操作队列的屏障


252
00:15:28,395 --> 00:15:30,197 line:-1
来避免竞太条件


253
00:15:31,131 --> 00:15:34,601 line:-1
如果你使用了一些进程报告机制


254
00:15:35,135 --> 00:15:38,138 line:-1
转换成操作队列提供的那个吧


255
00:15:38,972 --> 00:15:39,806 line:-1
谢谢


256
00:15:42,109 --> 00:15:45,812 line:-1
（更多信息）

