1
00:00:06,406 --> 00:00:10,777 line:0
（开发优秀的分析体验
通过自定义Instruments讲述你的故事）


2
00:00:14,982 --> 00:00:16,850 line:-1
下午好 欢迎参加我们的演讲


3
00:00:16,917 --> 00:00:18,952 line:-1
开发优秀的分析体验


4
00:00:19,319 --> 00:00:21,688 line:-2
我是Daniel Delwood 稍后同事
Kacper Harasim会加入我


5
00:00:22,122 --> 00:00:25,292 line:-2
今天我们在此要讲开发优秀的自定义
Instruments程序包


6
00:00:26,527 --> 00:00:29,429 line:-2
作为开发人员
我们都致力于创建卓越的、


7
00:00:29,496 --> 00:00:31,732 line:-2
可维护的、模块化的
并且可重复利用的代码


8
00:00:32,165 --> 00:00:34,134 line:-1
我们都使用其它人设计的框架


9
00:00:34,201 --> 00:00:36,837 line:-2
我们希望其它人也能使用
我们所创建的代码


10
00:00:37,971 --> 00:00:40,841 line:-1
良好的API设计和文档


11
00:00:40,908 --> 00:00:43,210 line:-2
对于用户使用你的框架的体验来说
至关重要


12
00:00:43,577 --> 00:00:47,147 line:-2
但我希望你们也考虑一下开发
Instruments程序包


13
00:00:48,515 --> 00:00:50,784 line:-2
要了解为什么
让我们以Metal为例


14
00:00:51,318 --> 00:00:53,820 line:-1
API设计是中枢 API的调用


15
00:00:53,887 --> 00:00:55,455 line:-1
围绕一组核心概念、


16
00:00:55,756 --> 00:00:58,125 line:-1
设备、命令缓冲区、纹理等等


17
00:00:59,126 --> 00:01:00,360 line:-1
但这并不是全部


18
00:01:00,861 --> 00:01:02,963 line:-1
API界面表达了什么是可能的


19
00:01:03,363 --> 00:01:05,032 line:-1
但文档和示例代码


20
00:01:05,098 --> 00:01:08,902 line:-2
是其他人了解如何用这些概念
构造一个优秀的app的方式


21
00:01:09,937 --> 00:01:11,305 line:-1
但这也不是全部


22
00:01:11,972 --> 00:01:14,374 line:-1
这两者结合可以帮助开发人员


23
00:01:14,441 --> 00:01:15,943 line:-1
使用你的类或框架编写代码


24
00:01:16,476 --> 00:01:18,011 line:-1
但如果出现错误怎么办？


25
00:01:18,712 --> 00:01:21,849 line:-2
嗯 自定义Instruments
对于你作为作者来说是一种


26
00:01:22,115 --> 00:01:26,353 line:-2
教会其他人如何调试、优化
并真正充分利用你的APIs的方式


27
00:01:26,820 --> 00:01:29,323 line:-2
若你用过Instruments中
的Metal系统追踪模板


28
00:01:29,623 --> 00:01:31,191 line:-1
你肯定了解了其中一些可能的情况


29
00:01:31,391 --> 00:01:33,994 line:-1
创建可视化工具


30
00:01:34,061 --> 00:01:36,463 line:-2
并针对你所定义的概念和API
进行特别设计


31
00:01:37,698 --> 00:01:40,801 line:-2
Instruments程序包
是建立透明性的一种方式


32
00:01:41,134 --> 00:01:43,504 line:-2
在底层 你的框架可以对
Instruments程序包进行测试、


33
00:01:43,570 --> 00:01:45,172 line:-1
可理解并且支持良好


34
00:01:45,506 --> 00:01:47,641 line:-2
花时间来创建一个
自定义Instrument


35
00:01:47,708 --> 00:01:49,676 line:-1
可以帮助你建立自信和信任


36
00:01:50,143 --> 00:01:52,346 line:-1
坚信代码正在执行你所期待的操作


37
00:01:53,347 --> 00:01:55,916 line:-1
工具也是开发成本模型的一个好方式


38
00:01:56,250 --> 00:01:58,952 line:-2
你可以了解哪个调用消耗较大
哪个调用消耗很小


39
00:01:59,419 --> 00:02:00,988 line:-1
当出现性能问题时


40
00:02:01,054 --> 00:02:03,824 line:-1
它们是区分框架错误


41
00:02:03,991 --> 00:02:05,292 line:-1
或客户代码错误的最佳方式


42
00:02:06,627 --> 00:02:11,598 line:-2
最重要的是Instrument
可以让你讲述你的故事


43
00:02:12,366 --> 00:02:15,569 line:-2
Instruments程序包
可以让你有机会解释正在发生什么


44
00:02:15,636 --> 00:02:17,671 line:-1
从而帮助可视化重要的指标


45
00:02:17,738 --> 00:02:20,207 line:-2
并在用户遇到问题时
帮助他们快速查找问题


46
00:02:21,074 --> 00:02:22,876 line:-1
今天我们要讲


47
00:02:22,943 --> 00:02:25,245 line:-1
如何创建优秀的检测 从里到外


48
00:02:25,512 --> 00:02:28,982 line:-2
从核心开始讲
即在框架中开发跟踪点


49
00:02:29,316 --> 00:02:33,687 line:-1
然后在跟踪点上创建架构


50
00:02:34,054 --> 00:02:37,658 line:-2
最后在讲可视化和Instrument UI前
讲一下在Instruments内建模和构造


51
00:02:38,625 --> 00:02:42,329 line:-2
我们今天要按顺序讲追踪、建模
和可视化


52
00:02:42,796 --> 00:02:46,266 line:-2
让我们现在开始吧
讲一下OSSignpost


53
00:02:47,835 --> 00:02:52,072 line:-2
OSSignpost是2018年
引入的一个低消耗的追踪基元


54
00:02:52,472 --> 00:02:56,076 line:-1
路标分为两种：点事件和区间


55
00:02:56,743 --> 00:02:58,912 line:-2
现在它们支持在参数中
记录任意一种数据


56
00:02:59,079 --> 00:03:01,882 line:-2
通过像printf一样的
formatString


57
00:03:02,349 --> 00:03:06,220 line:-2
与printf不同
所有路标都以静态字符串命名


58
00:03:07,921 --> 00:03:10,657 line:-2
现在在Swift中
OSSignpost只是其中一个核心API


59
00:03:10,724 --> 00:03:13,760 line:-1
它有三种类型：开始、结束和事件


60
00:03:14,294 --> 00:03:17,965 line:-2
在C语言中 它们的界面
通过三个有用的宏命令表达


61
00:03:19,333 --> 00:03:22,870 line:-2
现在重点是要注意
OSSignpost建立在OSLog上


62
00:03:23,303 --> 00:03:26,006 line:-1
意思是许多追踪行为和可配置性


63
00:03:26,340 --> 00:03:28,542 line:-1
都由所提供的日志句柄决定


64
00:03:29,409 --> 00:03:32,145 line:-2
日志句柄实际上是用于
跟踪的命名空间


65
00:03:32,679 --> 00:03:35,682 line:-1
可以让你指定子系统和类别


66
00:03:36,350 --> 00:03:40,087 line:-1
以及每个路标的静态名称


67
00:03:40,420 --> 00:03:43,891 line:-1
这就给追踪点提供了逻辑结构和等级


68
00:03:45,692 --> 00:03:49,062 line:-2
自定义Instruments创建在
OSSignpost上主要有两个原因


69
00:03:49,596 --> 00:03:50,964 line:-1
第一 它们是暂时的


70
00:03:52,032 --> 00:03:54,701 line:-1
所有路标 无论是点事件或区间


71
00:03:55,002 --> 00:03:57,838 line:-1
都隐含地记录高精度的时间戳


72
00:03:59,773 --> 00:04:00,807 line:-1
在我们高度并行的世界中


73
00:04:00,874 --> 00:04:03,010 line:-1
拥有对重叠区间的良好支持


74
00:04:03,076 --> 00:04:04,611 line:-1
也非常重要


75
00:04:04,778 --> 00:04:07,614 line:-2
OSSignpost通过路标ID
来实现这个


76
00:04:08,215 --> 00:04:12,186 line:-1
这为匹配相关事件记录了足够的情境


77
00:04:12,419 --> 00:04:14,021 line:-1
甚至当开端或结束事件


78
00:04:14,087 --> 00:04:16,890 line:-2
发生在不同的线程上
或不同的分派队列上时也可以


79
00:04:18,392 --> 00:04:21,595 line:-2
OSSignpost的
第二个原因是它们消耗低


80
00:04:22,196 --> 00:04:25,165 line:-1
日志记录机制在设计时考虑到了效率


81
00:04:25,532 --> 00:04:29,503 line:-2
无论何时当你提交OSSignpost
它都记录最小量的数据


82
00:04:30,470 --> 00:04:33,040 line:-1
围绕静态字符串有一些优化


83
00:04:33,207 --> 00:04:35,943 line:-1
比如格式字符串和路标名称


84
00:04:36,143 --> 00:04:40,080 line:-2
实际上只是作为
二进制文本段的偏移量提交


85
00:04:40,747 --> 00:04:43,851 line:-2
事实上OSSignpost的
消耗足够低


86
00:04:44,418 --> 00:04:47,321 line:-2
在绝大多数情况下
你可以把它们留在生产代码中


87
00:04:47,821 --> 00:04:50,724 line:-1
这就是它们对创建工具有用的原因


88
00:04:50,791 --> 00:04:54,528 line:-2
这些工具除了帮助你解决问题之外
还可以帮助你调试优化的代码


89
00:04:56,096 --> 00:04:57,865 line:-2
当Instruments
记录路标数据时


90
00:04:57,931 --> 00:05:01,368 line:-1
你将获得所有明确的字段


91
00:05:01,802 --> 00:05:04,438 line:-2
包括那个格式字符串以及
你要提供的参数


92
00:05:05,172 --> 00:05:07,140 line:-2
但在Instruments中
你还会获得


93
00:05:07,207 --> 00:05:09,376 line:-1
所有隐含的字段


94
00:05:09,743 --> 00:05:12,446 line:-1
比如时间戳或调用线程


95
00:05:12,513 --> 00:05:13,547 line:-1
这些非常有用


96
00:05:14,548 --> 00:05:17,618 line:-1
如果你使用启用了回溯的日志句柄


97
00:05:17,985 --> 00:05:22,489 line:-2
那么还会记录调用栈
并在Instruments中显示


98
00:05:24,124 --> 00:05:26,293 line:-2
当向代码找那个添加追踪时
重要的是要注意


99
00:05:26,360 --> 00:05:30,430 line:-2
OSLog和OSSignpost
有三种不同的行为模式


100
00:05:31,331 --> 00:05:36,870 line:-2
默认情况下OSLog是…
每个OSLog句柄都启用路标


101
00:05:37,371 --> 00:05:40,674 line:-2
因此它们仍然是低消耗
并且只记录到一个环形缓冲区


102
00:05:41,875 --> 00:05:46,413 line:-2
当Instruments或
另一个客户请求显示这个数据时


103
00:05:47,848 --> 00:05:50,050 line:-1
OSLog系统会立即进入流模式


104
00:05:50,117 --> 00:05:51,552 line:-1
那将会增加一些消耗


105
00:05:53,086 --> 00:05:56,156 line:-1
然而今年有两个新的动态类别


106
00:05:56,456 --> 00:05:58,458 line:-2
只有当Instruments
记录时才能启用


107
00:05:59,493 --> 00:06:01,228 line:-1
这些动态类别


108
00:06:01,695 --> 00:06:05,199 line:-1
用于记录第二个栈追踪


109
00:06:05,365 --> 00:06:07,534 line:-1
这增加了少许额外的消耗


110
00:06:08,268 --> 00:06:11,438 line:-2
考虑到这点 OSSignpost
的实际消耗是多少？


111
00:06:13,006 --> 00:06:16,343 line:-1
嗯 许多因素都会影响真实的性能


112
00:06:16,610 --> 00:06:18,879 line:-1
比如设备类型、硬件型号、


113
00:06:19,146 --> 00:06:22,216 line:-1
OS版本号、系统加载、热处理等等


114
00:06:22,716 --> 00:06:24,318 line:-1
因此很难给出一个具体的数字


115
00:06:24,852 --> 00:06:27,221 line:-1
但我想给出一些对数尺度的


116
00:06:27,287 --> 00:06:28,388 line:-1
数量级近似值


117
00:06:28,689 --> 00:06:31,458 line:-1
因为我认为理解相对消耗很有用


118
00:06:32,292 --> 00:06:34,361 line:-1
如果我们在发布版本中看一下路标


119
00:06:35,028 --> 00:06:37,197 line:-1
所有路标都以不到一微妙的速度记录


120
00:06:37,397 --> 00:06:42,135 line:-2
新的默认关闭的动态类别实际上处于
很低的纳秒范围内


121
00:06:43,537 --> 00:06:47,875 line:-2
当Instruments在延迟
或最后几秒模式记录时


122
00:06:48,609 --> 00:06:50,310 line:-1
这些动态类别将会开启


123
00:06:50,377 --> 00:06:52,946 line:-1
以匹配默认为开的类别的行为


124
00:06:53,514 --> 00:06:55,315 line:-1
并且它们的消耗相同


125
00:06:55,382 --> 00:06:58,051 line:-1
除动态堆栈类别外


126
00:06:58,218 --> 00:07:00,988 line:-2
由于动态堆栈记录调用栈
所以它消耗稍微大一些


127
00:07:01,288 --> 00:07:02,856 line:-1
处于毫秒范围内


128
00:07:04,525 --> 00:07:06,260 line:-1
然而当请求流模式时


129
00:07:06,426 --> 00:07:08,996 line:-1
所有这些的消耗将明显增加


130
00:07:09,730 --> 00:07:11,532 line:-1
并进入几十微妙的范围


131
00:07:13,000 --> 00:07:14,101 line:-1
考虑到这一点


132
00:07:15,702 --> 00:07:19,806 line:-2
你可以采取什么措施来最小化
OSSignpost在记录时的消耗？


133
00:07:20,040 --> 00:07:22,209 line:-1
如果你担心那个运行时间消耗


134
00:07:22,276 --> 00:07:24,178 line:-1
或它们开始在配置文件中显示的话


135
00:07:25,479 --> 00:07:27,014 line:-1
嗯 你可以采取两个很容易的措施


136
00:07:27,447 --> 00:07:31,051 line:-2
首先你使用Instruments
的延迟或最后几秒模式


137
00:07:31,118 --> 00:07:32,152 line:-1
替换立即模式


138
00:07:32,519 --> 00:07:34,788 line:-2
这可以避免OSSignpost
进入流模式


139
00:07:35,255 --> 00:07:36,456 line:-1
并减少消耗


140
00:07:36,623 --> 00:07:38,325 line:-1
配置模板 当你打开模板时


141
00:07:38,525 --> 00:07:40,861 line:-2
以其中一种模式进行记录
是一件很容易的事


142
00:07:43,463 --> 00:07:46,633 line:-1
同时如果你使用新的动态追踪类别


143
00:07:46,867 --> 00:07:49,803 line:-2
这是一种在不记录时
最小化消耗的好方法


144
00:07:50,070 --> 00:07:53,974 line:-1
因为路标默认为关闭


145
00:07:54,708 --> 00:07:56,810 line:-2
只有自定义Instruments
才可以启用它们


146
00:07:56,877 --> 00:08:00,180 line:-2
因此这个数据也不会在内置的
OSSignpost工具中与追踪挤在一起


147
00:08:02,416 --> 00:08:05,085 line:-1
那么作为框架或子系统的作者


148
00:08:05,152 --> 00:08:08,555 line:-2
当你分析时到底提交多少路标
才是合理的？


149
00:08:09,122 --> 00:08:10,090 line:-1
嗯 你可以提交许多


150
00:08:10,157 --> 00:08:14,127 line:-1
但让我们假定一个非常保守的目标


151
00:08:14,361 --> 00:08:16,797 line:-2
当你分析时
即使单核的CPU也低于1%


152
00:08:17,531 --> 00:08:19,800 line:-1
然后让我们假定


153
00:08:20,267 --> 00:08:22,202 line:-1
路标的大概消耗是


154
00:08:22,269 --> 00:08:25,372 line:-1
每启用一个路标需要大约半微妙


155
00:08:26,440 --> 00:08:29,443 line:-1
那等同于每秒启用20000个路标


156
00:08:30,244 --> 00:08:32,446 line:-2
即使是在iPad Pro上的
显示链接情境中


157
00:08:32,513 --> 00:08:35,448 line:-1
以每秒120帧的速度运行


158
00:08:36,015 --> 00:08:39,119 line:-1
这仍然足够使帧之间有83个区间


159
00:08:40,587 --> 00:08:46,693 line:-2
再一次 真实性能会发生改变
这些只是估算


160
00:08:47,094 --> 00:08:50,564 line:-1
重点是要记住路标是一个共享资源


161
00:08:51,865 --> 00:08:54,234 line:-2
你用得越多
对日志记录系统的影响越大


162
00:08:54,635 --> 00:08:58,105 line:-2
那就是说它们可以执行这种
高速率追踪


163
00:08:58,172 --> 00:09:00,474 line:-1
并且有时候非常有用


164
00:09:00,941 --> 00:09:03,911 line:-2
有时候它们对于查找你代码中的
管道停滞


165
00:09:04,244 --> 00:09:06,213 line:-1
或排序问题非常关键


166
00:09:07,281 --> 00:09:10,150 line:-1
然而请记住 你可能想根据不同用户


167
00:09:10,450 --> 00:09:12,819 line:-1
把路标分离到不同类别中


168
00:09:13,353 --> 00:09:15,889 line:-1
很可能你框架的客户


169
00:09:15,956 --> 00:09:18,458 line:-2
不像框架的贡献者那样
需要那么多细节


170
00:09:18,792 --> 00:09:21,161 line:-1
客户可能需要追踪更多的实施细节


171
00:09:22,296 --> 00:09:25,399 line:-2
如果你把追踪点分到
不同的日志句柄中


172
00:09:25,766 --> 00:09:28,535 line:-1
这将使你的工具只能启用必要的子集


173
00:09:30,270 --> 00:09:32,239 line:-1
因为追踪是检测的基础


174
00:09:32,306 --> 00:09:34,308 line:-1
我想快速讲四个最佳实践


175
00:09:36,243 --> 00:09:40,647 line:-2
第一个也是最重要的一个
总是终止你开始的任意区间


176
00:09:41,281 --> 00:09:42,783 line:-1
这对于正确性来说至关重要


177
00:09:43,450 --> 00:09:45,319 line:-1
永久开启的区间


178
00:09:45,385 --> 00:09:47,454 line:-2
真会降低Instruments的
分析速度


179
00:09:48,388 --> 00:09:51,258 line:-2
在这个例子中
我们有OSSignpost调用


180
00:09:51,325 --> 00:09:55,662 line:-2
包装了一段消耗大
并且有潜在报错风险的代码


181
00:09:56,396 --> 00:09:58,832 line:-1
问题是如果出现报错


182
00:09:58,999 --> 00:10:03,670 line:-2
控制流将跳到捕捉范围
并完全跳过终止路标


183
00:10:05,038 --> 00:10:07,841 line:-2
现在Swift的延迟状态
确实是处理这个问题的好方法


184
00:10:07,908 --> 00:10:11,845 line:-1
确保无论提前返回或出现报错


185
00:10:13,547 --> 00:10:16,183 line:-1
当我们提交当前范围时


186
00:10:16,250 --> 00:10:17,484 line:-2
仍会调用那个
OSSignpost终止调用


187
00:10:19,186 --> 00:10:20,521 line:-1
第二 为了效率


188
00:10:20,854 --> 00:10:25,125 line:-2
请避免在开始和结束追踪点中
记录相同的数据


189
00:10:25,292 --> 00:10:27,194 line:-2
当数据可用时
只在第一个追踪点中记录它


190
00:10:27,895 --> 00:10:29,396 line:-1
这就避免了重复工作


191
00:10:29,796 --> 00:10:32,132 line:-2
并尽快给
Instruments提供值


192
00:10:32,766 --> 00:10:38,071 line:-2
在这个例子中 我们不需要重复
请求编号或原生尺寸


193
00:10:39,206 --> 00:10:43,877 line:-2
我们不使用请求编号来匹配
重叠情况下的区间


194
00:10:44,845 --> 00:10:47,181 line:-1
这些追踪点实际上可以用来


195
00:10:47,748 --> 00:10:51,952 line:-2
给每个区间对的日志句柄
生成唯一的路标ID


196
00:10:53,420 --> 00:10:58,492 line:-2
第三 当没启用路标时避免做
不必要的工作


197
00:10:59,359 --> 00:11:02,696 line:-2
如果你的日志句柄需要使用其中一个
动态追踪类别


198
00:11:02,996 --> 00:11:05,032 line:-1
那么路标启用属性将表明


199
00:11:05,098 --> 00:11:06,934 line:-2
无论Instruments
当时是否正在记录


200
00:11:07,267 --> 00:11:08,902 line:-1
意思是


201
00:11:09,102 --> 00:11:14,975 line:-2
把消耗大的数据的计算放在那个
OSSignpost检查之后是个不错的方式


202
00:11:17,211 --> 00:11:20,647 line:-2
第四 其实对于你的工具而言
你需要的只是追踪数据


203
00:11:21,448 --> 00:11:23,550 line:-2
思考一下你的Guard
语句和预处理


204
00:11:23,951 --> 00:11:25,686 line:-1
因为有时你想追踪这些


205
00:11:25,752 --> 00:11:27,120 line:-1
以包含短区间


206
00:11:27,754 --> 00:11:29,456 line:-1
比如 如果你有一个方法


207
00:11:29,756 --> 00:11:32,893 line:-2
你想了解缓存命中和缓存缺失
之间的区别


208
00:11:33,660 --> 00:11:36,496 line:-2
但其它时候
这些提早的返回可能意义不大


209
00:11:36,864 --> 00:11:38,332 line:-1
对于这些情况而言


210
00:11:38,732 --> 00:11:41,969 line:-1
请考虑把路标移到预处理之后


211
00:11:42,236 --> 00:11:45,806 line:-2
从而减少
你要发送给路标系统的数据量


212
00:11:46,840 --> 00:11:49,376 line:-2
现在了解了这些技巧
重要的是要记住


213
00:11:49,643 --> 00:11:51,445 line:-1
追踪点确实是你在追踪点上


214
00:11:51,678 --> 00:11:53,347 line:-1
创建的所有工具的基础


215
00:11:53,747 --> 00:11:56,550 line:-2
并且绝大多数时候
它们将出现在你的生产代码中


216
00:11:56,917 --> 00:11:58,685 line:-2
因此这也是为什么考虑追踪点的
性能和可维护性


217
00:11:58,886 --> 00:12:01,188 line:-1
非常重要的原因


218
00:12:01,889 --> 00:12:03,190 line:-1
因为它们处于核心中


219
00:12:03,557 --> 00:12:04,992 line:-1
路标调用的变更


220
00:12:05,058 --> 00:12:07,828 line:-2
可能会导致需要修改
你在追踪点上所创建的工具


221
00:12:09,429 --> 00:12:10,998 line:-1
因此请保持追踪点的稳定


222
00:12:11,498 --> 00:12:13,400 line:-1
避免追踪实施细节


223
00:12:13,734 --> 00:12:18,038 line:-2
如果可能 请尽可能接近API层
添加OSSignpost调用


224
00:12:19,039 --> 00:12:21,708 line:-2
现在在代码基中四处移动追踪点
已经不成问题了


225
00:12:22,042 --> 00:12:24,144 line:-2
你不必担心诸如内联之类的
编译器优化


226
00:12:24,211 --> 00:12:25,779 line:-1
那可能会替你进行此类优化


227
00:12:26,813 --> 00:12:30,284 line:-1
你需要确保不要修改


228
00:12:30,651 --> 00:12:32,085 line:-1
静态字符串


229
00:12:32,352 --> 00:12:36,456 line:-1
我的意思是特别是子系统、类别、


230
00:12:37,090 --> 00:12:39,626 line:-1
路标名称或格式字符串


231
00:12:40,027 --> 00:12:41,161 line:-1
如果你修改了其中任意一个


232
00:12:41,228 --> 00:12:43,597 line:-2
你要记得更新
Instruments程序包


233
00:12:45,132 --> 00:12:47,801 line:-1
接下来让我们讲一下建模


234
00:12:48,168 --> 00:12:51,171 line:-2
以及向Instruments内的
数据中添加结构


235
00:12:53,106 --> 00:12:56,443 line:-2
Instruments的架构基于
表中所存储的一切


236
00:12:56,877 --> 00:12:59,179 line:-1
模式决定那些表的结构


237
00:12:59,246 --> 00:13:01,381 line:-2
这些都是由Instruments
分析内核管理的


238
00:13:02,249 --> 00:13:04,952 line:-2
要更深入地了解
Instruments架构的信息


239
00:13:05,252 --> 00:13:08,555 line:-2
我推荐你参看2018年的创建
自定义Instruments演讲


240
00:13:08,889 --> 00:13:11,024 line:-1
然而现在让我们看一下


241
00:13:11,091 --> 00:13:13,026 line:-1
建模在哪里创建分析体验


242
00:13:14,328 --> 00:13:16,496 line:-1
在左侧我们有OSSignpost


243
00:13:16,563 --> 00:13:19,399 line:-2
它是Instruments记录的
主要数据源之一


244
00:13:20,033 --> 00:13:21,635 line:-1
表中所填充的数据


245
00:13:21,835 --> 00:13:24,571 line:-2
有预定义的模式可以在自定义
Instruments中使用


246
00:13:26,073 --> 00:13:27,908 line:-1
建模在中间 是下一个阶段


247
00:13:27,975 --> 00:13:31,078 line:-2
建模器从一个或多个输入表中
观察数据


248
00:13:31,378 --> 00:13:34,381 line:-1
对数据进行推理 然后把数据提交给


249
00:13:34,448 --> 00:13:37,050 line:-1
你指定的一个或多个输出表


250
00:13:38,085 --> 00:13:40,754 line:-1
建模器是特定域逻辑所在的地方


251
00:13:41,121 --> 00:13:43,056 line:-1
输出表的模式


252
00:13:43,423 --> 00:13:47,694 line:-2
用于指定在数据中应用哪种
类型和格式


253
00:13:49,363 --> 00:13:51,298 line:-1
右侧是最后一步即可视化


254
00:13:51,798 --> 00:13:55,035 line:-2
可视化用于在XML中描述
Instruments中标准UI


255
00:13:55,435 --> 00:13:58,005 line:-2
你可以在这里指定
如何在建模器的输出表中


256
00:13:58,071 --> 00:13:59,406 line:-1
显示数据和如何用图表显示数据


257
00:13:59,840 --> 00:14:02,509 line:-1
比如给哪一栏绘图并用作值


258
00:14:02,743 --> 00:14:04,611 line:-1
或哪一栏用作彩色标签


259
00:14:05,779 --> 00:14:07,814 line:-2
因为所有的自定义
Instruments的可视化


260
00:14:07,881 --> 00:14:10,884 line:-2
都基于你的模式
以及你的建模器的输出


261
00:14:11,451 --> 00:14:13,353 line:-1
因此下边这个过程非常重要


262
00:14:13,420 --> 00:14:16,423 line:-2
检查OSSignpost
追踪点是否良好


263
00:14:16,924 --> 00:14:20,394 line:-2
然后了解如何把这个数据
放到自定义的模式中


264
00:14:22,996 --> 00:14:25,766 line:-2
因此自定义Instrument中
的所有数据必须存储在表中


265
00:14:25,832 --> 00:14:28,168 line:-1
表以一种或两种方式处理数据


266
00:14:28,769 --> 00:14:30,704 line:-1
点模式有一个时间戳栏


267
00:14:31,471 --> 00:14:34,942 line:-2
而区间模式既有时间戳栏
又有持续时间栏


268
00:14:35,642 --> 00:14:39,146 line:-2
这意味着你需要定义至少一个
点或区间模式


269
00:14:39,546 --> 00:14:41,682 line:-1
然后把命名和类型提供给其余的栏


270
00:14:42,850 --> 00:14:45,619 line:-1
现在通过建模规则填充数据


271
00:14:46,186 --> 00:14:47,588 line:-1
建模规则操纵的是输入数据


272
00:14:47,654 --> 00:14:49,857 line:-2
这些规则在CLIPS
语言中进行表达


273
00:14:50,390 --> 00:14:54,194 line:-2
好消息是Instruments
提供一些模式


274
00:14:54,628 --> 00:14:56,096 line:-1
可以自动生成建模器


275
00:14:56,430 --> 00:14:59,399 line:-2
因此你不需要编写CLIPS代码
除非你希望这么做


276
00:15:00,868 --> 00:15:02,469 line:-1
事实上 如果你刚开始编写


277
00:15:02,536 --> 00:15:04,171 line:-1
并且你想确保数据的准确性


278
00:15:04,505 --> 00:15:07,608 line:-2
Instruments在库中提供一个内置
OSSignpost工具


279
00:15:08,008 --> 00:15:09,877 line:-1
对于记录和检查


280
00:15:09,943 --> 00:15:12,646 line:-2
OSSignpost区间看起来
是否合理非常有效


281
00:15:13,247 --> 00:15:16,650 line:-2
检查器可以帮助你验证原生数据
是否就是你所预期的数据


282
00:15:18,085 --> 00:15:19,219 line:-1
一旦你检查了数据


283
00:15:19,586 --> 00:15:21,021 line:-2
一个新的
Instruments目标


284
00:15:21,522 --> 00:15:23,457 line:-1
是开始创建你自己的工具的好方法


285
00:15:24,024 --> 00:15:27,594 line:-2
通过Xcode针对自定义
Instruments的内置XML片段


286
00:15:27,828 --> 00:15:29,630 line:-1
你距离在库中拥有


287
00:15:29,963 --> 00:15:32,566 line:-2
自动建模器和Instrument
只差几个元素了


288
00:15:33,133 --> 00:15:35,536 line:-1
要了解这一切的最佳方式是通过演示


289
00:15:35,602 --> 00:15:37,838 line:-2
为此 我要邀请我同事
Kacper上台来


290
00:15:44,611 --> 00:15:46,380 line:-1
谢谢Daniel 大家好


291
00:15:48,749 --> 00:15:50,784 line:-2
我们在Mac上的
Solar System app


292
00:15:50,851 --> 00:15:53,887 line:-1
用于处理大量关于星球、


293
00:15:54,288 --> 00:15:56,523 line:-1
图片、视频和二进制的数据


294
00:15:57,057 --> 00:15:58,926 line:-1
为了优化它的磁盘使用情况


295
00:15:59,092 --> 00:16:01,228 line:-2
我创建了一个框架叫做
Solar Compression


296
00:16:01,461 --> 00:16:03,163 line:-1
使用路标的压缩库


297
00:16:03,363 --> 00:16:06,233 line:-1
有效地从磁盘中编码和解码数据


298
00:16:07,100 --> 00:16:09,670 line:-1
现在我想给我的框架创建检查


299
00:16:09,870 --> 00:16:11,972 line:-1
给未来用户提供一些数据


300
00:16:12,973 --> 00:16:16,143 line:-2
我们有两个概念值得追踪
和进行可视化呈现


301
00:16:16,777 --> 00:16:20,848 line:-2
首先CompressionManager
是个用于协调压缩任务的对象


302
00:16:21,415 --> 00:16:23,183 line:-1
可以通过许多通道创建它


303
00:16:23,350 --> 00:16:26,453 line:-1
指定可以同时执行多少任务


304
00:16:27,554 --> 00:16:29,223 line:-1
第二 我想通过捕捉压缩速率


305
00:16:29,289 --> 00:16:32,793 line:-1
衡量对特定文件类型和算法的


306
00:16:33,026 --> 00:16:34,528 line:-1
压缩性能


307
00:16:35,229 --> 00:16:36,430 line:-1
通过检查这些


308
00:16:36,496 --> 00:16:39,299 line:-1
用户可以决定是否值得压缩数据


309
00:16:40,434 --> 00:16:43,303 line:-2
我编写了区间
在OSSignpost API中


310
00:16:43,370 --> 00:16:44,738 line:-1
表达框架的这个概念


311
00:16:45,005 --> 00:16:47,875 line:-2
让我们进入CompressionManager
Swift文件看一下


312
00:16:49,610 --> 00:16:51,311 line:-1
首先让我们看一下日志句柄


313
00:16:51,712 --> 00:16:55,582 line:-2
我的日志句柄把我框架的
捆绑包标识符指定为子系统


314
00:16:55,883 --> 00:16:57,551 line:-1
并把我的类名称指定为类别


315
00:16:59,520 --> 00:17:00,721 line:-1
压缩和解压


316
00:17:00,787 --> 00:17:03,557 line:-1
是压缩管理器的公共界面的一部分


317
00:17:04,558 --> 00:17:07,560 line:-1
它们一开始都创建压缩工作项实例


318
00:17:07,627 --> 00:17:10,497 line:-1
压缩有关特定压缩任务的信息


319
00:17:11,164 --> 00:17:14,201 line:-2
接下来它们调用私有的
SubmitWorkItemMethod


320
00:17:15,736 --> 00:17:18,105 line:-1
因为压缩通道可能非常繁忙


321
00:17:18,305 --> 00:17:21,775 line:-2
在通道上创建压缩项
和执行压缩项之间


322
00:17:21,942 --> 00:17:23,343 line:-1
可能有很长的时间间隔


323
00:17:23,777 --> 00:17:26,246 line:-1
这是开始测量这种延迟的完美场所


324
00:17:27,181 --> 00:17:29,783 line:-1
我们要通过调用


325
00:17:30,083 --> 00:17:31,685 line:-2
以CompressionItemWait
名称开始命名的路标类型


326
00:17:32,986 --> 00:17:35,222 line:-2
接下来我们在这里使用
Guard条件语句


327
00:17:35,389 --> 00:17:39,026 line:-2
在我们继续进一步之前
要确保源文件存在


328
00:17:39,860 --> 00:17:42,930 line:-2
根据Daniel的建议
我要把它移到函数顶部


329
00:17:43,096 --> 00:17:45,365 line:-1
从而确保我的区间总是处于关闭状态


330
00:17:47,367 --> 00:17:49,670 line:-2
接下来我们有
ExecuteWorkItemMethod


331
00:17:49,937 --> 00:17:53,507 line:-2
当压缩任务已经准备好在通道上
执行时调用它


332
00:17:54,641 --> 00:17:57,811 line:-2
起初 我们需要给那个项指出
等待结束的时间


333
00:17:58,078 --> 00:18:01,548 line:-2
通过调用以与之前名称相同的名称
为命名结尾的路标类型实现


334
00:18:03,150 --> 00:18:05,485 line:-2
接下来我们用
CompressionExecution路标


335
00:18:05,686 --> 00:18:07,454 line:-1
表明压缩的开端


336
00:18:08,188 --> 00:18:10,891 line:-2
在元数据中 我们有诸如此类的东西
比如算法、


337
00:18:10,958 --> 00:18:14,528 line:-1
某种操作、关于源目的地的信息、


338
00:18:14,595 --> 00:18:17,297 line:-1
通道和调用线程


339
00:18:18,398 --> 00:18:22,836 line:-2
正如我们之前所了解的
OSSignpost隐含记录参数


340
00:18:23,003 --> 00:18:26,240 line:-2
包括线程 因此你现在移除线程
没有任何问题


341
00:18:31,378 --> 00:18:33,213 line:-1
接下来我们创建目的地文件


342
00:18:33,714 --> 00:18:37,384 line:-1
并同步执行压缩操作


343
00:18:37,951 --> 00:18:41,889 line:-2
完成后 我们把它记录下来
并附加目的地文件尺寸


344
00:18:42,556 --> 00:18:45,592 line:-2
这是我可以改善路标调用的
另一个地方


345
00:18:45,959 --> 00:18:49,763 line:-2
这里的StartCompressionMethod
是一个会产生报错的方法


346
00:18:50,264 --> 00:18:51,698 line:-1
如果它确实产生了报错


347
00:18:52,065 --> 00:18:54,168 line:-1
将不会调用这里的路标调用


348
00:18:55,002 --> 00:18:56,336 line:-1
为了防止这种情况发生


349
00:18:56,403 --> 00:18:58,639 line:-1
我可以在这里引入延迟代码块


350
00:19:00,741 --> 00:19:04,912 line:-2
并移动我的代码
从而确保区间总是处于关闭状态


351
00:19:07,581 --> 00:19:12,286 line:-2
让我们使用Xcode的Profile动作
来看一下Instruments中的路标


352
00:19:19,359 --> 00:19:20,894 line:-1
让我们从一个空的模板开始


353
00:19:22,729 --> 00:19:24,965 line:-2
给它添加我们的
路标工具


354
00:19:26,800 --> 00:19:28,769 line:-1
并只做几秒钟的记录


355
00:19:32,306 --> 00:19:33,574 line:-1
我们现在可以检验数据


356
00:19:33,974 --> 00:19:38,545 line:-2
我展开路标instrument查看
所有记录下来的子系统


357
00:19:40,247 --> 00:19:41,882 line:-2
这是我们的那个
Solar Compression


358
00:19:42,249 --> 00:19:45,853 line:-2
我可以进一步展开它
查看压缩管理器类别


359
00:19:46,987 --> 00:19:51,558 line:-2
我可用Control-Z重新调整
追踪的尺寸以适应全部所包含的图表


360
00:19:52,860 --> 00:19:55,495 line:-2
让我们捏合以放大
更具体地检验数据


361
00:19:57,397 --> 00:20:00,567 line:-1
顶部有全部的压缩执行路标


362
00:20:01,368 --> 00:20:03,170 line:-1
底部有等待执行的任务的


363
00:20:03,237 --> 00:20:04,471 line:-1
全部区间


364
00:20:04,972 --> 00:20:07,174 line:-1
在这里我们可以注意到一些模式


365
00:20:08,475 --> 00:20:11,678 line:-1
比如一次最多执行两个任务


366
00:20:12,379 --> 00:20:15,616 line:-2
因此很可能app代码使用了两个
压缩通道


367
00:20:16,850 --> 00:20:19,553 line:-1
同时我们可以看到一些尖峰


368
00:20:19,920 --> 00:20:23,123 line:-1
那表明有许多任务等待被压缩


369
00:20:25,392 --> 00:20:29,296 line:-2
OSSignpost是用于分析
你自己的路标的好工具


370
00:20:29,496 --> 00:20:31,498 line:-1
但通常不能给框架的用户


371
00:20:31,899 --> 00:20:34,067 line:-1
提供足够的分析情境


372
00:20:35,002 --> 00:20:36,170 line:-2
为了改善这个功能
我创建了另一个…


373
00:20:36,236 --> 00:20:41,441 line:-2
我创建了使用自定义Instruments的
Solar Compression工具


374
00:20:42,376 --> 00:20:45,679 line:-2
通过把这两个路标放到
两个独立的表中


375
00:20:45,746 --> 00:20:49,850 line:-2
并调整符合工具标准的UI
我努力改善我们的可视化功能


376
00:20:50,250 --> 00:20:52,953 line:-2
现在让我们打开包含这个
工具的追踪文档


377
00:20:58,825 --> 00:21:01,562 line:-1
在底部我们看到全部等待执行的任务


378
00:21:01,628 --> 00:21:04,364 line:-2
它们的呈现方式与OSSignpost
工具中的呈现方式一样


379
00:21:07,234 --> 00:21:10,003 line:-1
在顶部我们看到全部执行区间


380
00:21:10,204 --> 00:21:11,638 line:-1
现在由通道分离开


381
00:21:11,805 --> 00:21:14,708 line:-2
因此我们确实可以看到
有两个可用的通道


382
00:21:16,176 --> 00:21:19,313 line:-1
在这底部 我看到全部的压缩任务


383
00:21:19,479 --> 00:21:21,982 line:-1
附带区间信息、源路径、


384
00:21:22,249 --> 00:21:24,785 line:-1
文件尺寸、压缩速率等等


385
00:21:25,752 --> 00:21:27,588 line:-1
有一个任务引起了我的注意


386
00:21:27,855 --> 00:21:30,190 line:-1
这个任务很长 并且以红色显示


387
00:21:30,591 --> 00:21:33,126 line:-1
那意味着这个任务的压缩速率很慢


388
00:21:34,628 --> 00:21:36,196 line:-1
为了方便地了解它是哪种任务


389
00:21:36,430 --> 00:21:38,298 line:-1
我可以切换到活跃的任务详情


390
00:21:38,966 --> 00:21:43,470 line:-2
它只用于显示与我的检查头
相交叉的区间


391
00:21:44,204 --> 00:21:47,274 line:-2
我可以移动我的检查头
并分析一个任务


392
00:21:48,709 --> 00:21:51,178 line:-1
看起来我们正在尝试压缩zip存档


393
00:21:51,778 --> 00:21:55,048 line:-1
文件尺寸缩减了百分之一点多


394
00:21:55,549 --> 00:21:58,385 line:-2
这并没有缩减很多
也许你根本不应该压缩它


395
00:22:00,487 --> 00:22:02,689 line:-1
接下来让我们看一下任务概要详情


396
00:22:02,756 --> 00:22:04,825 line:-1
这里汇总了全部压缩任务


397
00:22:05,225 --> 00:22:07,427 line:-1
它提供三种汇总等级


398
00:22:07,661 --> 00:22:11,098 line:-1
压缩、源扩展和算法


399
00:22:12,266 --> 00:22:14,835 line:-1
在右侧我们看到不同的统计信息


400
00:22:14,902 --> 00:22:19,640 line:-2
比如平均压缩速率、持续时间
或节约的空间总量


401
00:22:20,507 --> 00:22:24,111 line:-1
这些详情对于比较不同的算法


402
00:22:24,278 --> 00:22:27,848 line:-2
或查看不同文件类型的压缩速率
有什么不同非常有用


403
00:22:28,682 --> 00:22:31,652 line:-2
比如我们可以看到我们的JPEG
文件尺寸


404
00:22:31,985 --> 00:22:35,455 line:-1
平均缩减了34%


405
00:22:35,522 --> 00:22:38,058 line:-2
这对于已经严重压缩的文件来说
很不错


406
00:22:39,660 --> 00:22:43,363 line:-2
现在让我们看一下
Instrument Inspector怎么样


407
00:22:47,167 --> 00:22:51,538 line:-2
我们在这边有
OSSignpost表是点模式


408
00:22:51,905 --> 00:22:54,975 line:-1
它查看…所有的开始和结束事件


409
00:22:56,276 --> 00:22:58,912 line:-1
我们还有两个路标的表


410
00:23:00,514 --> 00:23:02,216 line:-1
这是我们的执行表


411
00:23:02,549 --> 00:23:05,118 line:-2
它包含我们所记录的与任务有关的
所有数据


412
00:23:05,552 --> 00:23:09,189 line:-2
但现在它是根据我们所分配的
编程类型进行格式化的


413
00:23:11,358 --> 00:23:15,863 line:-2
在右侧我们可以看到
这个表由UI直接使用


414
00:23:19,333 --> 00:23:21,301 line:-1
目前我对我的工具非常满意


415
00:23:21,935 --> 00:23:25,706 line:-2
我要改善一件事
即等待执行的任务的呈现方式


416
00:23:26,440 --> 00:23:28,275 line:-1
我不想查看特定区间


417
00:23:28,542 --> 00:23:30,844 line:-1
我想通过某种方式把它们汇总起来


418
00:23:31,211 --> 00:23:33,614 line:-1
清晰地指出负载较高的区域


419
00:23:34,348 --> 00:23:36,750 line:-2
我认为Daniel
可能有办法能实现


420
00:23:37,384 --> 00:23:38,218 line:-1
Daniel？


421
00:23:46,260 --> 00:23:47,094 line:-1
谢谢Kacper


422
00:23:47,427 --> 00:23:50,063 line:-2
正如Kacper所展示的那样
库中的OSSignpost工具


423
00:23:50,430 --> 00:23:53,433 line:-2
和Inspector
是用于可视化原生数据


424
00:23:53,800 --> 00:23:56,103 line:-2
检查Instrument确实
看到了你所预期的数据的不错的方式


425
00:23:57,104 --> 00:23:59,973 line:-2
甚至不需要编写自定义
CLIPS建模器


426
00:24:00,240 --> 00:24:01,909 line:-1
Kacper就能创建一个工具


427
00:24:01,975 --> 00:24:04,111 line:-1
从而以更有意义的方式呈现他的数据


428
00:24:04,344 --> 00:24:06,680 line:-1
通过使用他的框架的压缩概念实现


429
00:24:07,014 --> 00:24:11,485 line:-2
只使用了四个追踪点和两个
OSSignpost区间模式


430
00:24:12,286 --> 00:24:14,821 line:-1
意思是那并不完全是


431
00:24:14,888 --> 00:24:15,923 line:-1
他想要创建的分析体验


432
00:24:17,024 --> 00:24:20,394 line:-2
现在自定义建模器
是调整那个体验的不错的工具


433
00:24:20,761 --> 00:24:23,530 line:-2
它们可以让你融合
多个日志句柄的数据


434
00:24:23,597 --> 00:24:25,365 line:-1
甚至可以使用来自内嵌表的数据


435
00:24:25,899 --> 00:24:28,335 line:-1
它们可以让你嵌入更复杂的逻辑


436
00:24:28,702 --> 00:24:32,005 line:-1
以维持状态 并对事件顺序进行推理


437
00:24:32,840 --> 00:24:34,908 line:-1
编写你自己的自定义建模器


438
00:24:34,975 --> 00:24:38,645 line:-2
对于某些自定义程度较高的绘图
和详情使用模式也很有用


439
00:24:39,146 --> 00:24:42,115 line:-1
点模式、区间模式和建模器标签


440
00:24:42,182 --> 00:24:43,483 line:-1
是开始自定义建模器的好方式


441
00:24:43,917 --> 00:24:46,286 line:-2
但这是一个很深的话题
我们在这场演讲中没有时间细讲


442
00:24:46,787 --> 00:24:48,322 line:-1
要获取更多关于自定义建模的信息


443
00:24:48,589 --> 00:24:51,158 line:-2
请参看2019年的建模和
自定义Instruments演讲


444
00:24:51,425 --> 00:24:53,894 line:-2
更深入地讲了具体信息
并附带示例代码


445
00:24:54,995 --> 00:24:57,698 line:-1
让我们继续讲分析体验的UI部分


446
00:24:58,131 --> 00:25:01,134 line:-1
可视化


447
00:25:02,402 --> 00:25:05,606 line:-1
可视化是关于你作为作者


448
00:25:05,973 --> 00:25:08,408 line:-2
向使用你代码的开发人员
讲述自己的故事的机会


449
00:25:09,209 --> 00:25:10,944 line:-1
最重要的准则是要记住


450
00:25:11,578 --> 00:25:14,381 line:-1
数据与故事不一样


451
00:25:15,148 --> 00:25:19,152 line:-2
如Kacper所展示的 通过查看
内嵌OSSignpost图表


452
00:25:19,686 --> 00:25:22,489 line:-2
原生区间只擅长向它们的作者
传达意义


453
00:25:23,290 --> 00:25:26,093 line:-1
使用你的工具的用户不会直观地了解


454
00:25:26,159 --> 00:25:29,363 line:-1
时间线中的某个空缺是好还是坏


455
00:25:29,796 --> 00:25:32,666 line:-2
或下一个处理阶段是什么
但不应该这样


456
00:25:33,567 --> 00:25:35,269 line:-2
作为Instruments
程序包的开发人员


457
00:25:35,569 --> 00:25:36,703 line:-1
你应该不只是


458
00:25:36,904 --> 00:25:39,473 line:-1
创建显示发生了什么的可视化信息


459
00:25:39,873 --> 00:25:41,408 line:-1
你要教学和诊断


460
00:25:41,842 --> 00:25:44,478 line:-2
你要帮助用户查找问题
即使你不在那儿


461
00:25:46,013 --> 00:25:48,048 line:-1
并且可视化也不只是与图表有关


462
00:25:48,448 --> 00:25:50,584 line:-1
有时候沟通问题的最好方式是


463
00:25:51,018 --> 00:25:52,886 line:-1
使用正确的统计数据集


464
00:25:52,953 --> 00:25:57,124 line:-2
或使用精心编写的文本叙述
准确描述出问题所在


465
00:25:58,725 --> 00:26:00,894 line:-1
然而图表如此重要的原因是


466
00:26:01,161 --> 00:26:03,497 line:-1
绝大部分情况下 图表是用户的起点


467
00:26:03,830 --> 00:26:05,566 line:-1
这是你的故事书的第一页


468
00:26:06,867 --> 00:26:09,837 line:-2
可视化应该帮助其他人学习、
了解和调试


469
00:26:10,137 --> 00:26:13,707 line:-2
而自私的动机是
优秀的工具也会加速分诊


470
00:26:14,241 --> 00:26:17,344 line:-1
这是可视化的目标 让问题变得明显


471
00:26:17,945 --> 00:26:20,047 line:-1
图表是你将看到的第一个汇总


472
00:26:20,113 --> 00:26:22,182 line:-2
它们应该把你的目光吸引到
重要的区域


473
00:26:22,583 --> 00:26:24,251 line:-1
一旦你开始深入了解


474
00:26:24,418 --> 00:26:26,153 line:-1
你的代码应该围绕


475
00:26:26,587 --> 00:26:29,056 line:-1
详情视图和指标那些核心概念


476
00:26:29,923 --> 00:26:33,193 line:-2
因为Instruments
处理两种类型的时序数据


477
00:26:33,260 --> 00:26:36,396 line:-2
点和区间 我想讲一下
这两者的显示方式


478
00:26:38,398 --> 00:26:41,568 line:-1
汇总点事件有助于评估它们的重要性


479
00:26:42,035 --> 00:26:43,704 line:-1
如果它们全都相对相等


480
00:26:43,971 --> 00:26:46,039 line:-1
那么在时间线上


481
00:26:46,106 --> 00:26:48,275 line:-2
显示事件密度的一个不错的方式是
通过柱形图


482
00:26:49,009 --> 00:26:51,378 line:-1
快速扫一眼就能立即看到较高的柱子


483
00:26:51,445 --> 00:26:53,013 line:-2
你就知道从哪里开始看
以及要放大哪里


484
00:26:53,380 --> 00:26:54,515 line:-1
对于自定义Instruments


485
00:26:54,581 --> 00:26:56,416 line:-1
自定义图表行为非常容易


486
00:26:57,017 --> 00:27:00,354 line:-2
柱形图元素可以让你指定
每个时间桶的宽度


487
00:27:00,954 --> 00:27:02,589 line:-1
有一个最适合分辨率元素


488
00:27:02,923 --> 00:27:05,192 line:-1
可以让你在用户缩小时使用柱形图


489
00:27:05,592 --> 00:27:08,362 line:-1
然后当用户放大时


490
00:27:08,428 --> 00:27:09,463 line:-1
交换单一事件的细节


491
00:27:11,999 --> 00:27:14,902 line:-1
当点事件的重要性发生变化时


492
00:27:15,202 --> 00:27:18,272 line:-2
有时候对为重大事件开辟一条道路
很有帮助


493
00:27:19,907 --> 00:27:23,310 line:-2
多个图表和详情视图
可以从同一个表中引用数据


494
00:27:23,777 --> 00:27:25,279 line:-1
从而指定最顶级的


495
00:27:25,579 --> 00:27:28,615 line:-2
意思就是给
Instruments描述


496
00:27:28,682 --> 00:27:30,384 line:-1
如何从表中选择要显示哪些值


497
00:27:31,084 --> 00:27:33,654 line:-2
现在这两个功能都能完全
在XML中实现


498
00:27:33,887 --> 00:27:35,088 line:-1
而不需要自定义建模器


499
00:27:37,491 --> 00:27:39,760 line:-1
表格式汇总点数据或区间数据


500
00:27:40,027 --> 00:27:42,763 line:-1
你可以定义哪些指标是重要指标


501
00:27:43,430 --> 00:27:45,132 line:-1
通过汇总的详情视图


502
00:27:45,199 --> 00:27:48,635 line:-1
有用于结合值的函数


503
00:27:49,002 --> 00:27:50,170 line:-2
如Min、Max、Average
和Standard Deviation


504
00:27:50,737 --> 00:27:52,940 line:-1
新用户可以查看你所提供的汇总


505
00:27:53,607 --> 00:27:56,009 line:-1
从而了解哪些重要


506
00:27:56,176 --> 00:27:57,377 line:-1
以及要对哪些进行优化


507
00:27:57,911 --> 00:27:59,346 line:-1
即使是显示属性也很重要


508
00:27:59,413 --> 00:28:01,782 line:-1
比如栏的标题是什么


509
00:28:01,849 --> 00:28:04,017 line:-1
或它们的显示顺序


510
00:28:05,819 --> 00:28:07,988 line:-1
现在当用户深入查看详情时


511
00:28:08,322 --> 00:28:11,959 line:-2
叙述类型是用于解释正在发生什么的
一种很棒的方式


512
00:28:12,526 --> 00:28:15,929 line:-2
它可以让你使用自然语言
和其它类型的格式


513
00:28:16,129 --> 00:28:19,132 line:-2
以一种易理解的方式解释
运行时间行为


514
00:28:20,000 --> 00:28:22,402 line:-1
这些视图可以很好地告诉用户


515
00:28:22,569 --> 00:28:24,538 line:-1
预期应该发生什么但却没有发生


516
00:28:25,072 --> 00:28:27,074 line:-1
或当某些有意思的事情发生时


517
00:28:27,140 --> 00:28:28,775 line:-1
他们可能想进一步调查


518
00:28:30,177 --> 00:28:32,546 line:-1
因此绘制区间数据可能有点棘手


519
00:28:33,680 --> 00:28:37,551 line:-1
跟点不一样 区间因为重叠的原因


520
00:28:37,618 --> 00:28:38,452 line:-1
并不总是位于单一垂直空间内


521
00:28:39,186 --> 00:28:43,223 line:-2
如果你可以规划固定的或有限制的
重复的区间的数量


522
00:28:43,524 --> 00:28:47,427 line:-2
有两种方式可以将一条垂直的栏
分为多个可视区域


523
00:28:48,295 --> 00:28:50,664 line:-1
限制绘制用于把栏分成


524
00:28:50,731 --> 00:28:52,499 line:-1
使用一个标题的多个空间


525
00:28:53,166 --> 00:28:57,037 line:-2
而实例绘制用于给每个空间
定义自己的标题


526
00:28:57,938 --> 00:28:59,339 line:-1
现在OSSignpost工具


527
00:28:59,740 --> 00:29:01,308 line:-1
结合使用这些技术


528
00:29:01,375 --> 00:29:03,977 line:-1
但只有当要显示的重叠区间的数量


529
00:29:04,044 --> 00:29:05,546 line:-1
为有限数量时才能用


530
00:29:06,346 --> 00:29:07,281 line:-1
当有许多等级时


531
00:29:08,081 --> 00:29:11,518 line:-2
你可能要采用Instruments 11
中的一个新功能


532
00:29:12,452 --> 00:29:15,355 line:-1
把追踪数据分离到嵌套的追踪中


533
00:29:15,422 --> 00:29:19,092 line:-2
使其易于过滤、查找
甚至是易于pin你正在查找的东西


534
00:29:19,726 --> 00:29:22,296 line:-1
特别是当图表情境的数量特别多时


535
00:29:23,163 --> 00:29:25,532 line:-1
但无论你是否提供追踪等级


536
00:29:25,599 --> 00:29:28,368 line:-1
规划汇总区间数据都很重要


537
00:29:28,802 --> 00:29:31,038 line:-1
要么是在每一个等级上都进行汇总


538
00:29:31,505 --> 00:29:33,307 line:-2
要么是作为你的
Instruments的主图表


539
00:29:35,542 --> 00:29:36,777 line:-1
对于简单的区间数据


540
00:29:36,844 --> 00:29:39,580 line:-1
可以尝试应用与点相同的方案


541
00:29:40,013 --> 00:29:41,315 line:-1
即使用柱形图元素


542
00:29:42,349 --> 00:29:44,518 line:-2
然而只有当你拥有短区间时
才能很好地发挥作用


543
00:29:44,585 --> 00:29:47,421 line:-1
因为柱形图元素按开始时间进行汇总


544
00:29:48,288 --> 00:29:51,225 line:-2
对于较长的区间
这可能会导致向左倾斜


545
00:29:51,658 --> 00:29:53,427 line:-1
并且它会产生非常大的值


546
00:29:54,795 --> 00:29:58,365 line:-2
更重要的是 当绘制拥有持续时间的
元素的图表时


547
00:29:58,765 --> 00:30:02,536 line:-2
请不要在Y轴绘制时间
因为X轴已经代表时间了


548
00:30:03,403 --> 00:30:05,506 line:-1
诸如利用率百分比这样的指标


549
00:30:05,572 --> 00:30:06,874 line:-1
对于显示这种数据较好


550
00:30:08,709 --> 00:30:10,644 line:-1
在更实际的使用中


551
00:30:10,711 --> 00:30:12,012 line:-1
区间总是发生更多的重叠


552
00:30:12,346 --> 00:30:15,782 line:-2
因此我想演示三个例子
关于汇总图表


553
00:30:15,949 --> 00:30:17,618 line:-1
以及在你的框架中所呈现的概念


554
00:30:17,684 --> 00:30:19,786 line:-1
和你想要的使用模式


555
00:30:20,354 --> 00:30:23,757 line:-2
如何影响你的表模式
以及如何帮助你确定呈现样式


556
00:30:25,459 --> 00:30:29,963 line:-2
对于某些情境
持续的重叠表明资源利用率高


557
00:30:30,597 --> 00:30:31,632 line:-1
对于这种数据


558
00:30:31,698 --> 00:30:34,101 line:-2
使用限定平均载荷
是可视化这种数据的好办法


559
00:30:34,701 --> 00:30:36,270 line:-1
甚至会突显某些极端值


560
00:30:37,304 --> 00:30:38,572 line:-1
CLIPS建模器


561
00:30:38,805 --> 00:30:41,241 line:-2
和Instruments
擅长维护状态注入数据


562
00:30:41,575 --> 00:30:44,178 line:-2
因此结合那个
OSSignpost事件流


563
00:30:44,244 --> 00:30:46,513 line:-1
通过来自区间计时器标签的输入


564
00:30:47,080 --> 00:30:48,982 line:-1
当计时器信号到达时


565
00:30:49,049 --> 00:30:52,052 line:-2
建模器可以计算并提交
平均限制利率用


566
00:30:52,920 --> 00:30:55,923 line:-1
建模器的输出表看起来可能像这样


567
00:30:55,989 --> 00:30:59,393 line:-2
只表达了四栏数据
并绘制了你所看到的图表


568
00:30:59,960 --> 00:31:03,297 line:-1
包括一个决定图表的值的利用率栏


569
00:31:03,830 --> 00:31:06,099 line:-1
以及决定显示颜色的严重性栏


570
00:31:08,335 --> 00:31:09,436 line:-1
对于其它情境


571
00:31:09,503 --> 00:31:11,872 line:-1
许多快速运行的区间可能更重要


572
00:31:11,939 --> 00:31:14,341 line:-2
因为它们可以表达
你的框架使用率低下的情况


573
00:31:15,242 --> 00:31:17,644 line:-1
查看与上一个示例中同样的数据


574
00:31:17,945 --> 00:31:21,081 line:-1
好的图表可能基于建模器计数


575
00:31:21,148 --> 00:31:24,251 line:-2
在特定时段内所看到的
唯一区间的数量


576
00:31:25,519 --> 00:31:28,355 line:-2
建模器的输出表与上一个
看起来非常类似


577
00:31:29,089 --> 00:31:33,460 line:-2
但用户的注意力立即就被吸引到
时间线上一个非常与众不同的区域上


578
00:31:33,827 --> 00:31:34,795 line:-1
有助于放大


579
00:31:34,862 --> 00:31:36,730 line:-1
并调查导致这些区间短的原因


580
00:31:38,532 --> 00:31:40,167 line:-1
前两个示例


581
00:31:40,367 --> 00:31:42,769 line:-1
都以10毫秒分组汇总数据


582
00:31:43,203 --> 00:31:46,273 line:-1
但如果某个重叠时段


583
00:31:46,340 --> 00:31:50,410 line:-2
对于区分一个、两个或更多并存区间
来说非常重要该怎么办呢？


584
00:31:51,445 --> 00:31:53,780 line:-1
嗯 我们不根据时间量化


585
00:31:54,214 --> 00:31:57,784 line:-1
按重叠度进行分类的图表会更有帮助


586
00:31:57,985 --> 00:32:01,221 line:-1
并显示具体的持续时间


587
00:32:03,190 --> 00:32:06,226 line:-2
建模器只追踪
OSSignpost事件


588
00:32:06,627 --> 00:32:09,329 line:-2
可以输出一个额外的表
包含自定义区间模式


589
00:32:10,397 --> 00:32:14,034 line:-2
这一次 可以通过可变的持续时间
来填写模式


590
00:32:14,201 --> 00:32:16,136 line:-1
还有一个描述栏作为标签使用


591
00:32:17,538 --> 00:32:19,640 line:-1
这三个只是示例


592
00:32:20,007 --> 00:32:21,475 line:-1
但它们可以帮助你了解


593
00:32:21,708 --> 00:32:23,777 line:-1
当呈现数据时


594
00:32:24,144 --> 00:32:26,813 line:-1
当你设计图标模式时 概念很重要


595
00:32:27,981 --> 00:32:30,551 line:-2
对于许多情况来说
自动生成的建模器


596
00:32:30,717 --> 00:32:32,519 line:-1
就可以满足你创建合适的体验


597
00:32:32,753 --> 00:32:34,021 line:-1
所需要的功能和灵活性


598
00:32:34,655 --> 00:32:36,190 line:-1
但一定在某些时候


599
00:32:36,256 --> 00:32:38,892 line:-1
你想拥有一个输入或输出


600
00:32:39,560 --> 00:32:42,529 line:-2
对于那些情况
在我所展示的某些示例表中


601
00:32:42,963 --> 00:32:46,466 line:-2
自定义建模器可以提供
额外控制和灵活性


602
00:32:46,867 --> 00:32:48,535 line:-1
从而可视化地表达它们的概念


603
00:32:49,169 --> 00:32:52,372 line:-1
或富文本的叙述、图表和详情视图


604
00:32:53,407 --> 00:32:55,175 line:-1
现在我要把舞台交给Kacper


605
00:32:55,242 --> 00:32:56,844 line:-1
看看他有什么样的可视化操作


606
00:33:02,816 --> 00:33:03,684 line:-1
谢谢Daniel


607
00:33:04,852 --> 00:33:06,753 line:-1
我讲了自定义建模器


608
00:33:06,820 --> 00:33:09,523 line:-1
并努力改善我们现有的检查


609
00:33:09,957 --> 00:33:10,791 line:-1
让我们看一下


610
00:33:11,491 --> 00:33:14,494 line:-2
我要从我创建的那个
Solar Compression模板开始看


611
00:33:17,965 --> 00:33:20,934 line:-2
它现在包含一个
文件系统行动工具


612
00:33:21,101 --> 00:33:22,803 line:-1
当使用压缩库时


613
00:33:22,970 --> 00:33:26,139 line:-2
用于提供关于I/O操作的消耗的
额外信息


614
00:33:27,274 --> 00:33:28,108 line:-1
让我们记录一下


615
00:33:29,943 --> 00:33:34,982 line:-2
现在我在窗口模式中记录
从而减少记录所带来的消耗


616
00:33:36,550 --> 00:33:41,088 line:-2
Instrument会从主机传输
所有数据并运行建模器


617
00:33:45,993 --> 00:33:47,194 line:-1
现在让我们检验一下数据


618
00:33:48,695 --> 00:33:51,231 line:-1
我可以立即看到


619
00:33:51,298 --> 00:33:52,699 line:-1
在文件系统行动


620
00:33:53,033 --> 00:33:54,935 line:-1
和我的执行路标之间有一些相关性


621
00:33:56,203 --> 00:33:58,272 line:-1
我们主要看较长的zip压缩任务


622
00:33:58,338 --> 00:33:59,439 line:-1
我们之间曾分析过


623
00:34:00,407 --> 00:34:02,242 line:-1
把它显示为红色


624
00:34:02,543 --> 00:34:03,810 line:-1
可以很好地吸引用户的注意


625
00:34:04,011 --> 00:34:07,414 line:-1
但如果能使用叙述


626
00:34:07,681 --> 00:34:08,916 line:-1
来提供一些额外信息更好


627
00:34:09,949 --> 00:34:13,253 line:-2
我编写了建模器
用于检测压缩率低的情况


628
00:34:13,520 --> 00:34:15,289 line:-1
并呈现一些可能的方案


629
00:34:17,357 --> 00:34:19,126 line:-1
让我们具体看一下建议详情


630
00:34:19,193 --> 00:34:21,562 line:-1
看一下这个建模器的输出


631
00:34:25,866 --> 00:34:27,967 line:-1
这个建模器…我们得到了一个建议


632
00:34:28,302 --> 00:34:31,371 line:-1
建议说存档zip文件的尺寸


633
00:34:31,772 --> 00:34:33,841 line:-1
缩减了百分之一点多


634
00:34:34,308 --> 00:34:37,110 line:-1
可能没有必要压缩这个文件


635
00:34:38,011 --> 00:34:40,514 line:-1
它还暗示如果速度不是问题


636
00:34:40,781 --> 00:34:43,183 line:-1
我应该尝试使用LZMA算法


637
00:34:43,250 --> 00:34:45,585 line:-1
可能会提供较快的压缩速率


638
00:34:46,253 --> 00:34:49,322 line:-2
看起来很有用
我现在要尝试修改算法


639
00:34:49,857 --> 00:34:52,125 line:-1
再次记录 并重新验证结果


640
00:34:53,994 --> 00:34:56,530 line:-2
让我们看一下等待执行的任务
是如何进行汇总的


641
00:34:57,164 --> 00:35:00,033 line:-2
我计算了正在等待执行的任务的
平均载荷


642
00:35:00,501 --> 00:35:04,905 line:-2
这样 用户可以清晰地指出
载荷较高的区域


643
00:35:05,873 --> 00:35:08,976 line:-1
让我们看一下这个红色区域


644
00:35:10,143 --> 00:35:13,180 line:-1
看起来有许多任务正在等待执行


645
00:35:13,247 --> 00:35:15,449 line:-1
但随着任务在这个通道上的执行


646
00:35:15,716 --> 00:35:16,950 line:-1
数量正在减少


647
00:35:17,885 --> 00:35:20,020 line:-1
用户可以对那样的区域做出分析


648
00:35:20,287 --> 00:35:23,323 line:-2
如果有必要
可以增加压缩通道的数量


649
00:35:23,390 --> 00:35:25,125 line:-1
从而实现更高级别的并发性


650
00:35:26,527 --> 00:35:29,263 line:-1
实际上这个结论可以作为


651
00:35:29,329 --> 00:35:31,098 line:-1
对详情视图的另一个建议


652
00:35:32,799 --> 00:35:36,737 line:-2
现在让我们看一下它在
Instrument Inspector中表现如何


653
00:35:37,704 --> 00:35:41,175 line:-2
让我们搜索我们的
Solar Compression执行表


654
00:35:41,842 --> 00:35:43,677 line:-1
并看一下捆绑方案


655
00:35:45,812 --> 00:35:49,583 line:-2
OSSignpost
自动生成的建模器


656
00:35:49,783 --> 00:35:52,819 line:-2
把OSSignpost
点模式数据传输到


657
00:35:53,020 --> 00:35:55,455 line:-2
Solar Compression
执行表中


658
00:35:56,023 --> 00:35:58,926 line:-2
就在这里 正如我们之前所看到的
它由UI使用


659
00:35:59,560 --> 00:36:03,130 line:-2
我们这里还有这个新实体
即我们的建议建模器


660
00:36:03,597 --> 00:36:07,134 line:-1
它把压缩执行表中的区间


661
00:36:07,801 --> 00:36:10,838 line:-1
传输到点模式中的建议中


662
00:36:11,138 --> 00:36:13,440 line:-1
稍后用于驱动叙述详情


663
00:36:15,609 --> 00:36:19,746 line:-2
我对这个Instruments
传达我的库的概念的方式很满意


664
00:36:20,047 --> 00:36:22,316 line:-2
我感觉我们已经准备好
把它交给用户了


665
00:36:22,816 --> 00:36:24,151 line:-1
让我们返回到幻灯片中


666
00:36:33,227 --> 00:36:34,895 line:-1
创建优秀的分析体验


667
00:36:35,162 --> 00:36:37,531 line:-1
是要给用户提供一个探索路径


668
00:36:38,432 --> 00:36:40,400 line:-1
应该从一个有用的模板开始


669
00:36:40,667 --> 00:36:42,636 line:-1
这个模板用于提供


670
00:36:42,703 --> 00:36:43,904 line:-2
查看问题的必要的
Instruments


671
00:36:44,605 --> 00:36:47,407 line:-1
请记住 如果你的代码


672
00:36:47,474 --> 00:36:49,343 line:-1
对由其它检查所暴露的信息敏感


673
00:36:49,676 --> 00:36:53,380 line:-1
比如采样、系统追踪或优先级行动


674
00:36:53,647 --> 00:36:55,315 line:-1
你应该在你的模板中包含这些


675
00:36:56,316 --> 00:36:57,684 line:-1
当分析记录时


676
00:36:57,985 --> 00:37:00,554 line:-2
优秀的图表应该可以把用户的注意力
迅速吸引到


677
00:37:00,787 --> 00:37:03,457 line:-1
执行时间线中可能存在问题的地方


678
00:37:03,991 --> 00:37:07,094 line:-2
详情应该把他们带到
导致问题的主要原因上


679
00:37:07,461 --> 00:37:09,129 line:-1
并且通常还要提供有意义的暗示


680
00:37:10,697 --> 00:37:13,033 line:-1
为了帮助你开发更好的分析体验


681
00:37:13,333 --> 00:37:16,003 line:-2
今年在Instruments中
引入了两个新功能


682
00:37:16,336 --> 00:37:18,805 line:-1
第一个是分等级追踪的概念


683
00:37:19,606 --> 00:37:22,843 line:-2
其中一个例子是这里可见的
OSSignpost工具


684
00:37:23,076 --> 00:37:26,647 line:-1
通过等级


685
00:37:26,813 --> 00:37:27,748 line:-1
暴露了底层的子系统和类别名称空间


686
00:37:29,449 --> 00:37:31,652 line:-2
等级时自定义
Instruments的一部分


687
00:37:31,852 --> 00:37:35,556 line:-2
你今天看到的所有等级都可在自己
的Instrument中创建


688
00:37:37,558 --> 00:37:40,527 line:-2
我们还有一种自定义你的分析流程的
新方式


689
00:37:40,794 --> 00:37:42,696 line:-1
即通过创建自定义追踪范围


690
00:37:43,997 --> 00:37:46,967 line:-2
这些允许你从不同角度查看
在你的追踪文档中所收集的数据


691
00:37:47,267 --> 00:37:50,204 line:-1
通过应用追踪过滤器


692
00:37:50,571 --> 00:37:52,906 line:-2
或为每个范围选择不同的追踪分支
来实现


693
00:37:54,174 --> 00:37:56,476 line:-1
如果我只对查看系统调用


694
00:37:56,543 --> 00:37:58,412 line:-1
和压缩库的路标感兴趣


695
00:37:59,079 --> 00:38:02,883 line:-2
或只对分析虚拟内存对app的影响
感兴趣


696
00:38:03,116 --> 00:38:05,886 line:-1
我可以创建过滤掉其它追踪的范围


697
00:38:06,086 --> 00:38:07,521 line:-1
并一直给它们返回值


698
00:38:08,722 --> 00:38:10,958 line:-1
稍后我可以把它们保存在我的模板中


699
00:38:11,191 --> 00:38:13,694 line:-2
并与团队或Instruments
用户一起共享


700
00:38:15,863 --> 00:38:17,664 line:-1
检查形式的工具


701
00:38:17,731 --> 00:38:20,534 line:-1
会把用户与你的框架的交互体验


702
00:38:20,868 --> 00:38:23,804 line:-1
从良好变成优秀 从不了解变成信任


703
00:38:24,671 --> 00:38:28,709 line:-2
你可以通过它们来描述你框架中
所存在的概念


704
00:38:29,710 --> 00:38:33,013 line:-2
它们应该教育人们
并帮助他们捕捉容易犯的错误


705
00:38:34,047 --> 00:38:36,683 line:-1
无论何时当客户出现性能调试问题时


706
00:38:37,150 --> 00:38:39,152 line:-1
他们都可以返回到工具中寻找答案


707
00:38:39,386 --> 00:38:40,487 line:-1
这种交互


708
00:38:40,888 --> 00:38:43,724 line:-1
将增加他们对你的库的信心和信任


709
00:38:45,425 --> 00:38:49,196 line:-2
要获取更多关于自定义Instruments的
信息请访问Instruments开发人员帮助


710
00:38:49,930 --> 00:38:52,232 line:-1
我们还推荐你们观看这些演讲


711
00:38:52,799 --> 00:38:54,868 line:-2
谢谢 祝你们愉快地度过
余下的会议时光

