1
00:00:00,506 --> 00:00:04,500
[音乐]


2
00:00:13,131 --> 00:00:15,131
[掌声]


3
00:00:15,246 --> 00:00:15,906
>> 早上好


4
00:00:16,856 --> 00:00:18,716
欢迎来到 What's New in Swift 专场


5
00:00:19,786 --> 00:00:21,086
今天 我们将讨论两个重要


6
00:00:21,146 --> 00:00:23,856
且令人兴奋的 Swift 发布版本


7
00:00:24,276 --> 00:00:28,876
Swift 5 是我们最近在三月份发布的版本


8
00:00:29,036 --> 00:00:32,906
Swift 5.1 现在可以在 Xcode 11 中使用开发者预览版


9
00:00:34,196 --> 00:00:36,326
有了这两个新的版本


10
00:00:36,326 --> 00:00:41,156
我们进一步释放了 Swift 作为语言和技术的潜力


11
00:00:41,216 --> 00:00:42,986
Apple 和你们所有人都可以


12
00:00:43,276 --> 00:00:45,616
在此基础上进行开发


13
00:00:46,666 --> 00:00:49,326
从 Swift 和 API 的


14
00:00:49,326 --> 00:00:54,666
强大组合的形式中获益


15
00:00:55,756 --> 00:00:58,136
现在 Apple 的操作系统


16
00:00:58,206 --> 00:00:59,876
已经为第三方 App 提供了


17
00:00:59,876 --> 00:01:02,356
共享的 Swift Runtime


18
00:01:02,356 --> 00:01:03,726
并且用 Swift 写的二进制框架


19
00:01:03,726 --> 00:01:05,716
现在已经可以部署


20
00:01:06,326 --> 00:01:08,416
使用这些 Apple 做出了


21
00:01:08,616 --> 00:01:10,856
仅用于 Swift 的跑马灯效果框架


22
00:01:11,926 --> 00:01:14,136
此外 在 Xcode 中


23
00:01:14,486 --> 00:01:15,826
对 Swift 包管理器的集成支持


24
00:01:15,826 --> 00:01:17,296
使得 Swift 包可以直接


25
00:01:17,296 --> 00:01:21,516
进入 App 开发的核心工作流中


26
00:01:22,166 --> 00:01:25,066
同时 Swift 语言本身有了新的可供性


27
00:01:25,066 --> 00:01:27,886
来构建精美丰富的 API


28
00:01:28,396 --> 00:01:31,216
也有了用于表达 API 发展的新特性


29
00:01:31,716 --> 00:01:33,096
对于该语言及其整个生态环境来说


30
00:01:33,096 --> 00:01:36,306
这都是一个非常激动人心的时刻


31
00:01:36,966 --> 00:01:38,716
那么让我们开始吧


32
00:01:38,716 --> 00:01:42,296
首先我要多说几句二进制框架


33
00:01:42,296 --> 00:01:43,806
特别是深入谈谈


34
00:01:43,806 --> 00:01:46,176
促成这一发展的核心要素


35
00:01:46,846 --> 00:01:48,536
那些要素就是 ABI 稳定性


36
00:01:48,536 --> 00:01:50,256
及模块稳定性


37
00:01:51,516 --> 00:01:56,496
ABI 就是 Application Binary Interface


38
00:01:56,496 --> 00:01:57,966
它是一些规则 用来控制编译后的代码


39
00:01:57,966 --> 00:02:01,766
如何在运行时进行交互的具体细节


40
00:02:02,576 --> 00:02:04,636
就像是函数调用这样的细节


41
00:02:04,916 --> 00:02:06,796
那么它究竟是如何工作的


42
00:02:07,416 --> 00:02:12,636
参数中的值是如何从调用者传递给被调用者的呢


43
00:02:13,086 --> 00:02:14,386
可用的元数据是什么


44
00:02:14,386 --> 00:02:15,506
它在内存中又是如何排列的


45
00:02:15,626 --> 00:02:16,766
所有这些细节都是


46
00:02:16,766 --> 00:02:19,436
编译后的代码相互作用时所必须的


47
00:02:19,766 --> 00:02:21,526
因此为了说明这个观点


48
00:02:21,526 --> 00:02:24,116
假设你有一个用 Swift 写的程序


49
00:02:24,236 --> 00:02:25,626
它是一个 App


50
00:02:25,626 --> 00:02:27,246
可以是命令行工具 这并不是很重要 


51
00:02:27,246 --> 00:02:28,876
只要是可执行的


52
00:02:29,706 --> 00:02:33,756
它使用的框架也是用 Swift 写的


53
00:02:33,756 --> 00:02:35,066
而所有的这些已编译代码


54
00:02:35,066 --> 00:02:37,786
是在一个运行过程中一起运行的


55
00:02:37,876 --> 00:02:40,926
那么这个可执行文件


56
00:02:41,116 --> 00:02:42,146
正在使用框架中的 API


57
00:02:42,186 --> 00:02:44,456
它们必须能在运行时与彼此进行对话


58
00:02:45,246 --> 00:02:46,966
那么 为了完成这个


59
00:02:46,966 --> 00:02:48,186
它们必须有一个可兼容的 ABI


60
00:02:48,186 --> 00:02:50,926
就像这两段代码是被分开进行编译的


61
00:02:51,006 --> 00:02:53,856
但编译后的代码则需要一起共同工作


62
00:02:54,436 --> 00:02:56,296
在 ABI 稳定性之前


63
00:02:56,296 --> 00:02:58,876
我们唯一能保证的是


64
00:02:59,066 --> 00:03:00,546
它们会有一个可兼容的 ABI


65
00:03:00,546 --> 00:03:02,966
只要构建它们的编译器是相同的


66
00:03:03,056 --> 00:03:04,826
之所以这样 是因为


67
00:03:04,826 --> 00:03:08,176
我们真的是在发展 Swift 的核心基础要素


68
00:03:08,176 --> 00:03:09,746
以确保所有我们


69
00:03:09,746 --> 00:03:13,096
想要的构建块都被放在合适的位置上


70
00:03:13,096 --> 00:03:14,106
以便在未来进行构建


71
00:03:14,766 --> 00:03:18,286
那么 在 Swift 5 中我们已经明确了那些细节


72
00:03:18,386 --> 00:03:20,436
现在的 Swift 已有了 ABI 稳定性


73
00:03:20,436 --> 00:03:23,796
这意味着这两个组件不再需要用相同的编译器进行构建了


74
00:03:23,796 --> 00:03:25,826
只要它们是用 Swift 5 编译器


75
00:03:25,826 --> 00:03:28,106
或更新的版本进行构建的


76
00:03:28,676 --> 00:03:31,386
第二个重要的要素


77
00:03:31,386 --> 00:03:33,346
就是模块的稳定性


78
00:03:33,346 --> 00:03:35,146
这是一个编译时的概念


79
00:03:35,146 --> 00:03:36,996
如果你有一个 Swift 框架


80
00:03:37,156 --> 00:03:38,966
使用该框架内的所有 API


81
00:03:38,966 --> 00:03:43,076
那么这些就都是一个被称为模块的共享命名空间的一部分


82
00:03:43,466 --> 00:03:48,296
当 Swift 编译器构建该框架时


83
00:03:48,296 --> 00:03:53,716
它会生成该框架中的所有 API 的 Manifest


84
00:03:53,716 --> 00:03:56,326
之后该框架的客户端就可以使用这些 API


85
00:03:56,636 --> 00:03:58,776
该 Manifest 被称为 Swift 模块文件


86
00:03:59,196 --> 00:04:00,666
那么如果我们回到这个例子


87
00:04:00,666 --> 00:04:03,346
我们就假设我们正在编译程序


88
00:04:03,386 --> 00:04:04,716
有一个源文件


89
00:04:04,716 --> 00:04:06,396
它引用了该框架


90
00:04:06,466 --> 00:04:09,216
接下来该编译器就会去读取模块文件


91
00:04:09,256 --> 00:04:11,416
并获取可用的 API


92
00:04:11,416 --> 00:04:14,246
但是这个模块文件里的细节真的很丰富


93
00:04:14,246 --> 00:04:17,326
并且在很多方面


94
00:04:17,326 --> 00:04:19,826
与编译器本身紧密耦合


95
00:04:19,826 --> 00:04:22,746
所以我们就有和 ABI 稳定性相同的问题了


96
00:04:22,746 --> 00:04:24,016
那么唯一的办法就是


97
00:04:24,016 --> 00:04:27,446
这两块必须要用相同的编译器进行编译


98
00:04:28,026 --> 00:04:33,446
在 Swift 5.1 里我们引入了一个新的补充 Manifest


99
00:04:33,936 --> 00:04:36,396
它被称为 Swift 模块接口文件


100
00:04:36,996 --> 00:04:38,766
它可以被框架用来提供


101
00:04:39,186 --> 00:04:42,896
用户端可以使用的稳定接口


102
00:04:43,666 --> 00:04:45,736
而如果你将它打开


103
00:04:45,736 --> 00:04:47,816
它看起来就像 Swift 源代码


104
00:04:47,866 --> 00:04:50,836
它也是被构建在源稳定性的概念上的


105
00:04:50,836 --> 00:04:52,776
这个概念在 Swift 中很早就有了


106
00:04:53,086 --> 00:04:54,946
那么有了这两个要素


107
00:04:55,186 --> 00:04:57,626
你就可以得到可以部署


108
00:04:57,626 --> 00:05:00,296
并与他人共享的 Swift 框架


109
00:05:01,516 --> 00:05:06,546
[掌声]


110
00:05:07,046 --> 00:05:08,096
那么我们有很多十分有趣的


111
00:05:08,096 --> 00:05:09,576
关于 ABI 稳定性的细节


112
00:05:09,576 --> 00:05:10,786
我们已经准备了


113
00:05:10,786 --> 00:05:13,216
很长一段时间了


114
00:05:13,216 --> 00:05:14,386
如果你有兴趣


115
00:05:14,386 --> 00:05:15,896
了解更多的细节


116
00:05:15,896 --> 00:05:16,946
我们今天就要向大家介绍


117
00:05:16,946 --> 00:05:19,326
swift.org 是一个很好的资源


118
00:05:19,326 --> 00:05:23,056
这是 Swift 开放源代码的项目的主页


119
00:05:23,056 --> 00:05:24,136
里面有很多很棒的


120
00:05:24,136 --> 00:05:26,276
关于 ABI 稳定性的博客文章


121
00:05:27,816 --> 00:05:29,286
同时 如果你有兴趣


122
00:05:29,286 --> 00:05:33,576
使用二进制框架来为你自己所用


123
00:05:33,576 --> 00:05:34,416
比如与他人进行共享


124
00:05:34,416 --> 00:05:35,866
我们会在这周晚些时候的


125
00:05:35,866 --> 00:05:37,176
Swift 中的 Binary Frameworks in Swift 专场中


126
00:05:37,176 --> 00:05:38,976
对这些进行讨论


127
00:05:39,276 --> 00:05:40,256
届时我们还会讨论


128
00:05:40,256 --> 00:05:41,666
当与他人共享框架时


129
00:05:41,996 --> 00:05:44,036
你应该进行考虑的一些事项


130
00:05:45,316 --> 00:05:48,286
那么二进制框架只是 API 中要为大家介绍的一个部分


131
00:05:48,286 --> 00:05:51,116
另一个重要的部分就是 Swift 包


132
00:05:51,946 --> 00:05:53,336
现在 Xcode 中已经


133
00:05:53,336 --> 00:05:55,216
集成了 Swift 包管理器


134
00:05:55,626 --> 00:05:58,816
它们是创建 App 的核心工作流的一部分


135
00:05:59,666 --> 00:06:00,826
这周还会有两个关于


136
00:06:00,826 --> 00:06:04,206
在 Xcode 中创建和使用包的专场


137
00:06:04,296 --> 00:06:07,766
二进制框架和 Swift 包的结合


138
00:06:07,766 --> 00:06:09,346
为我们提供了一组非常丰富的选项


139
00:06:09,346 --> 00:06:12,766
来与他人共享 API


140
00:06:14,556 --> 00:06:15,966
那么让我们换个话题


141
00:06:15,966 --> 00:06:17,386
来谈谈性能


142
00:06:18,066 --> 00:06:20,386
Swift 语言是一种


143
00:06:20,386 --> 00:06:22,326
现代的 安全的


144
00:06:22,326 --> 00:06:24,216
且高性能的编程语言


145
00:06:24,856 --> 00:06:25,856
同时 ABI 稳定性


146
00:06:25,856 --> 00:06:28,376
还带来了一些关键的性能优势


147
00:06:29,706 --> 00:06:30,976
其中的一个性能优势


148
00:06:30,976 --> 00:06:32,696
是因为在操作系统中有了


149
00:06:32,696 --> 00:06:34,676
App 所共享的 Swift Runtime


150
00:06:34,676 --> 00:06:37,206
这是三月份发布的


151
00:06:37,206 --> 00:06:41,086
包括 macOS iOS tvOS watchOS 以及现在的 iPadOS


152
00:06:41,406 --> 00:06:42,666
在这些发布版本中都有


153
00:06:42,666 --> 00:06:45,176
一个共享的 Swift Runtime


154
00:06:45,176 --> 00:06:46,046
第三方 App 和 Apple 原生 App


155
00:06:46,046 --> 00:06:47,936
及系统中的所有东西都在使用


156
00:06:48,526 --> 00:06:51,546
那么 它究竟是如何工作


157
00:06:51,546 --> 00:06:54,196
又是在什么时候开始起作用呢


158
00:06:54,406 --> 00:06:56,376
如果你的 App 是用 Swift 5


159
00:06:56,376 --> 00:06:58,656
或更新的版本创建的


160
00:06:58,716 --> 00:07:00,496
它就会在运行的时候


161
00:07:00,916 --> 00:07:02,486
使用系统中的共享 Runtime


162
00:07:03,636 --> 00:07:05,336
然而 你也许仍然需要将你的 App


163
00:07:05,336 --> 00:07:08,496
构建并部署到较早发行的操作系统版本中


164
00:07:08,496 --> 00:07:09,546
而那时的版本还没有共享 Runtime


165
00:07:10,886 --> 00:07:13,976
在这种情况下 Xcode 会继续在你的 App 中


166
00:07:13,976 --> 00:07:15,986
捆绑一个 Runtime 的副本


167
00:07:15,986 --> 00:07:18,596
以便它可以继续在那些较老的操作系统版本上运行


168
00:07:19,796 --> 00:07:24,166
但是 我们总是倾向于使用在操作系统中的副本


169
00:07:24,166 --> 00:07:25,986
那么这样一来 


170
00:07:25,986 --> 00:07:27,956
当运行在较新的系统上时


171
00:07:28,566 --> 00:07:29,806
这个 App 中的副本将会失效


172
00:07:30,536 --> 00:07:33,976
作为优化


173
00:07:34,156 --> 00:07:37,906
iOS App Store 将不提供 App 中的 Runtime 副本


174
00:07:38,356 --> 00:07:41,926
当下载设备的操作系统包含 Runtime 时


175
00:07:41,926 --> 00:07:44,966
为用户节约下载流量


176
00:07:45,606 --> 00:07:51,286
这是一个非常重要的代码量优化


177
00:07:51,286 --> 00:07:52,796
但在操作系统中拥有这个 Runtime


178
00:07:52,796 --> 00:07:54,526
其真正的好处是


179
00:07:54,586 --> 00:07:56,476
现在它可以作为操作系统本身的一部分


180
00:07:56,476 --> 00:07:58,126
来进行优化


181
00:07:58,126 --> 00:07:01,676
然后这些优化就可以转到 App 本身了


182
00:08:03,226 --> 00:08:06,096
有一个重要的好处就是启动时间


183
00:08:06,336 --> 00:08:08,506
那么让我们回到过去


184
00:08:08,506 --> 00:08:11,496
一年前 我们讨论了 Swift 4.2


185
00:08:12,996 --> 00:08:14,926
如果你有一个 Objective-C App


186
00:08:14,926 --> 00:08:17,506
它什么都不做


187
00:08:17,506 --> 00:08:19,166
它只是启动 然后什么都不做


188
00:08:19,716 --> 00:08:21,346
而一个 Swift App 也是


189
00:08:21,346 --> 00:08:22,526
同样没有功能


190
00:08:22,526 --> 00:08:23,386
它就只是启动


191
00:08:23,796 --> 00:08:25,446
使用 Swift 大约会有 5% 的额外时间消耗


192
00:08:25,446 --> 00:08:27,326
因为我们需要处理


193
00:08:27,356 --> 00:08:30,116
嵌入的 Runtime


194
00:08:30,306 --> 00:08:32,546
但是如果你的 App 是用


195
00:08:32,546 --> 00:08:34,265
Swift 5 编译器重新编译的


196
00:08:34,265 --> 00:08:35,506
并运行在一个有共享 Runtime 的操作系统上


197
00:08:35,506 --> 00:08:38,686
这个时间消耗就没有了


198
00:08:39,515 --> 00:08:43,216
[掌声]


199
00:08:43,716 --> 00:08:45,676
这个真的十分重要


200
00:08:45,676 --> 00:08:47,006
我的意思是 该延时是


201
00:08:47,006 --> 00:08:50,156
用户要开始使用你的 App 的时间


202
00:08:50,156 --> 00:08:53,866
和他们真正开始体验它的时间之间的差别


203
00:08:54,996 --> 00:08:56,856
我们进行优化的


204
00:08:56,856 --> 00:08:58,476
另一个重要的领域


205
00:08:58,476 --> 00:09:02,686
是进一步调整编译器编译后的代码


206
00:09:02,686 --> 00:09:03,676
它进一步减少了


207
00:09:03,676 --> 00:09:06,026
Swift App 的代码规模


208
00:09:06,026 --> 00:09:07,776
这真的很像是微调


209
00:09:07,776 --> 00:09:11,126
考虑 Swift App 中特定的模式


210
00:09:11,126 --> 00:09:13,086
比如说字典在生成代码时


211
00:09:13,086 --> 00:09:16,656
应该怎样表示 等等


212
00:09:16,656 --> 00:09:19,696
我们只是要确保编译器的输出


213
00:09:19,696 --> 00:09:23,406
针对这些用例进行了优化


214
00:09:23,786 --> 00:09:24,756
通过各种各样的优化


215
00:09:24,756 --> 00:09:29,546
我们看到代码规模能够减少 10%


216
00:09:29,546 --> 00:09:31,506
如果使用 Swift 5.1 编译器的话


217
00:09:31,846 --> 00:09:32,846
如果你使用 Optimize for Size 选项


218
00:09:32,846 --> 00:09:36,566
那代码规模会减少 15%


219
00:09:36,976 --> 00:09:39,086
那么这是一些非常重要的优化


220
00:09:40,076 --> 00:09:42,786
我们也已经继续


221
00:09:42,786 --> 00:09:44,536
对桥接的性能进行完善


222
00:09:45,156 --> 00:09:46,246
通过桥接 我说的是


223
00:09:46,246 --> 00:09:49,046
Swift 和 Objective-C 之间的桥接


224
00:09:49,046 --> 00:09:52,456
这两种语言之间有着很强的互操作性


225
00:09:54,556 --> 00:09:56,666
那么 Swift 和 Objective-C


226
00:09:56,666 --> 00:10:00,206
都有我们所谓的通用的流通类型


227
00:10:00,256 --> 00:10:01,786
它们被用在整个 API 空间里


228
00:10:02,326 --> 00:10:04,206
比如 String 和 NSString


229
00:10:04,556 --> 00:10:06,356
Dictionary 以及 NSDictionary


230
00:10:06,356 --> 00:10:10,296
而这些流通类型之间的互操作性


231
00:10:10,296 --> 00:10:11,136
是 Swift 和 Objective-C 之间


232
00:10:11,136 --> 00:10:13,706
互操作性的非常基础的部分


233
00:10:14,246 --> 00:10:15,646
使用自己的流通类型的 Objective-C API


234
00:10:15,646 --> 00:10:19,326
被重新映射到使用 Swift 流通类型的 Swift 中


235
00:10:19,506 --> 00:10:21,166
现在的工作一个编译器


236
00:10:21,166 --> 00:10:23,006
是一个编译器工作的组合


237
00:10:23,566 --> 00:10:24,696
但同时还要使用到 Runtime


238
00:10:24,696 --> 00:10:26,116
它在你将一个类型的值


239
00:10:26,116 --> 00:10:28,696
传递为另一种类型


240
00:10:28,726 --> 00:10:29,956
并跨越 API 边界时出现


241
00:10:31,026 --> 00:10:32,076
这是我们进一步调整的一部分


242
00:10:32,076 --> 00:10:33,626
作为 Swift 的一部分


243
00:10:33,676 --> 00:10:35,756
现在是操作系统的一部分


244
00:10:36,676 --> 00:10:39,106
比如现在 NSDictionary


245
00:10:39,106 --> 00:10:40,256
和 Dictionary 之间的桥接速度


246
00:10:40,256 --> 00:10:42,156
比之前快 1.6 倍


247
00:10:43,186 --> 00:10:44,966
如果你正在传递一个


248
00:10:44,966 --> 00:10:47,416
Swift 字符串给 Objecitive-C


249
00:10:47,416 --> 00:10:49,346
而它作为 NSString 桥接而使用


250
00:10:49,346 --> 00:10:50,206
并且是从 Objective-C 端使用它


251
00:10:50,206 --> 00:10:55,566
那么它的操作就可以达到 15 倍之快


252
00:10:56,516 --> 00:11:01,096
[掌声]


253
00:11:01,596 --> 00:11:04,666
所有的这些小的好处加起来确实不少


254
00:11:04,666 --> 00:11:05,896
因为这些类型


255
00:11:05,896 --> 00:11:08,436
在整个 API 生态系统中都在使用


256
00:11:09,076 --> 00:11:12,326
现在说到字符串


257
00:11:12,326 --> 00:11:13,986
我们继续完善了它们的核心表达


258
00:11:13,986 --> 00:11:15,316
我们做了一个重大的改变


259
00:11:15,316 --> 00:11:18,826
在 Swift 5 中的字符串类型上


260
00:11:19,786 --> 00:11:20,856
这是一个隐藏的变化


261
00:11:20,856 --> 00:11:23,346
我们将字符串的 Unicode 表达


262
00:11:23,346 --> 00:11:29,326
从 UTF-16 更改为 UTF-8


263
00:11:30,206 --> 00:11:33,416
那么这完全是由性能驱动的


264
00:11:34,296 --> 00:11:36,226
这个变化有很多丰富的细节


265
00:11:36,226 --> 00:11:38,506
如果你有兴趣了解更多的相关内容


266
00:11:38,506 --> 00:11:40,406
你可以去 swift.org


267
00:11:40,406 --> 00:11:41,566
那里有一篇博文


268
00:11:41,566 --> 00:11:43,666
讲解了实际的技术变化及其推动力量


269
00:11:44,196 --> 00:11:45,766
那么在这里我要强调一些重要的事情


270
00:11:46,816 --> 00:11:49,556
首先 我们将 Swift 创建为


271
00:11:49,556 --> 00:11:52,996
一种你可以达到像 C 语言性能的语言


272
00:11:54,256 --> 00:11:55,536
但其中的一个关键方面是


273
00:11:55,536 --> 00:11:56,846
我们想要 Swift 对现有的


274
00:11:56,846 --> 00:12:00,266
C API 生态系统有很强的互操作性


275
00:12:00,266 --> 00:12:05,016
当 Swift 字符串使用 UTF-16 时


276
00:12:05,016 --> 00:12:08,866
当你把一个字符串传递给 C API 的时候


277
00:12:09,186 --> 00:12:10,936
你也许不知道


278
00:12:10,936 --> 00:12:12,796
你需要进行的操作是


279
00:12:12,796 --> 00:12:14,556
分配 副本和转码


280
00:12:14,556 --> 00:12:15,776
只是为了把字符串放进


281
00:12:15,776 --> 00:12:17,746
一个可以传递到 C 的兼容格式中


282
00:12:17,746 --> 00:12:19,366
那么这就是很大的开销了


283
00:12:20,176 --> 00:12:22,346
现在通过移动到 UTF-8


284
00:12:22,346 --> 00:12:23,436
我们可以直接将一个


285
00:12:23,436 --> 00:12:25,396
以 null 结尾的 UTF-8 字符串


286
00:12:25,396 --> 00:12:26,036
传递给 C API


287
00:12:26,396 --> 00:12:29,276
不需要分配和副本 且零开销


288
00:12:30,886 --> 00:12:32,666
同时我们还能够


289
00:12:32,666 --> 00:12:34,816
扩大字符串类型本身的优化


290
00:12:35,576 --> 00:12:37,396
字符串有一个小的字符串优化


291
00:12:37,396 --> 00:12:39,376
即如果该字符串中的字符数


292
00:12:39,376 --> 00:12:41,796
大约是 15 个字符或者更少的话


293
00:12:41,796 --> 00:12:44,746
我们就不需要一个单独的分配来获得


294
00:12:44,746 --> 00:12:45,816
这些字符的有效荷载


295
00:12:45,816 --> 00:12:48,546
我们可以直接将它打包到字符串值中


296
00:12:48,706 --> 00:12:49,726
这真的是一个进步


297
00:12:49,836 --> 00:12:53,026
在 Swift 5 中我们能够将这个优化扩展到


298
00:12:53,026 --> 00:12:55,716
包括基本上所有的 Unicode 字符


299
00:12:55,716 --> 00:12:57,806
不仅限于 ASCII 这就意味着


300
00:12:57,806 --> 00:13:00,946
它现在可以应用到非罗马字符的语言中


301
00:13:01,506 --> 00:13:03,596
我们在这样做的同时


302
00:13:03,596 --> 00:13:06,236
也在性能层面上保持


303
00:13:06,456 --> 00:13:08,036
NSStrings 和 String 之间


304
00:13:08,036 --> 00:13:08,876
强大的互操作性


305
00:13:10,216 --> 00:13:11,456
但是真正令人兴奋的是


306
00:13:11,456 --> 00:13:13,906
这完全是关乎性能的


307
00:13:13,906 --> 00:13:14,966
我已经说过好几次了


308
00:13:16,056 --> 00:13:17,486
有一个很好的例子


309
00:13:17,556 --> 00:13:18,916
就是 SwiftNIO


310
00:13:18,916 --> 00:13:20,266
对于不熟悉它的人来说


311
00:13:20,266 --> 00:13:21,756
SwiftNIO 是来自于


312
00:13:21,756 --> 00:13:23,086
用于服务器的 Swift


313
00:13:23,566 --> 00:13:27,976
它是一个用于构建网络协议和服务的跨平台框架


314
00:13:28,246 --> 00:13:30,486
它为了速度而进行了调整


315
00:13:31,676 --> 00:13:35,156
通过切换到 UTF-8


316
00:13:35,226 --> 00:13:37,776
我们可以看到构建在 SwiftNIO 上的


317
00:13:37,776 --> 00:13:40,266
网络服务器的吞吐量增加了 20%


318
00:13:40,266 --> 00:13:44,136
那么这就只是文本处理的一个基准


319
00:13:44,736 --> 00:13:46,726
而这恰恰与我们的想法类似


320
00:13:46,726 --> 00:13:47,926
我们想让字符串成为一种


321
00:13:47,926 --> 00:13:51,406
你可以用它来进行


322
00:13:51,566 --> 00:13:54,216
高性能密集的字符串操作


323
00:13:54,216 --> 00:13:56,326
但同时它对用户友好


324
00:13:56,386 --> 00:13:59,906
且易于使用的类型


325
00:14:00,366 --> 00:14:01,576
过一会我会把舞台交给 Anna


326
00:14:01,696 --> 00:14:03,266
她会向大家主要介绍


327
00:14:03,266 --> 00:14:04,636
Swift 5 和 Swift 5.1 


328
00:14:04,636 --> 00:14:06,536
中的语言变化


329
00:14:06,536 --> 00:14:07,636
在此之前 我想再谈一些


330
00:14:07,636 --> 00:14:09,556
核心工具和改进


331
00:14:09,556 --> 00:14:12,846
及其中的开源项目的关键方面


332
00:14:14,416 --> 00:14:16,766
现在 Swift 作为一个开源项目


333
00:14:16,766 --> 00:14:18,936
已经不仅仅是一个项目上的


334
00:14:18,936 --> 00:14:20,556
日常的工程工作了


335
00:14:20,886 --> 00:14:22,216
而是关于 Swift 成为一个


336
00:14:22,216 --> 00:14:23,926
更广泛且更多样化的


337
00:14:23,986 --> 00:14:25,886
软件生态系统的一部分


338
00:14:26,536 --> 00:14:28,816
那么举个例子


339
00:14:28,816 --> 00:14:30,566
Swift 社群聚集在一起


340
00:14:30,566 --> 00:14:32,746
为 Swift 创建了官方的 Docker 镜像


341
00:14:32,926 --> 00:14:35,786
它们都被托管在 Docker Hub 中


342
00:14:36,446 --> 00:14:37,546
而如果你在 Mac 上


343
00:14:37,546 --> 00:14:38,636
安装 Docker 其实就是


344
00:14:38,636 --> 00:14:40,606
敲几下键盘的事情


345
00:14:40,606 --> 00:14:42,016
你就可以拥有一个 Docker


346
00:14:42,016 --> 00:14:43,406
就是这个 Docker 镜像


347
00:14:43,406 --> 00:14:45,066
同时拥有在你的 Mac 上


348
00:14:45,466 --> 00:14:46,896
工作的 Docker Linux 容器


349
00:14:46,896 --> 00:14:48,866
包括一个编译器和包管理器


350
00:14:48,866 --> 00:14:50,866
这就是你需要的一切


351
00:14:51,366 --> 00:14:52,566
之所以能这样做


352
00:14:52,626 --> 00:14:53,986
是因为容器如今被视为


353
00:14:53,986 --> 00:14:56,306
构建服务的一个


354
00:14:56,406 --> 00:14:58,396
固有的部分


355
00:14:59,736 --> 00:15:01,816
另一个重要的开源技术


356
00:15:01,816 --> 00:15:03,516
就是 SourceKit


357
00:15:03,936 --> 00:15:05,536
它是语义代码引擎


358
00:15:05,656 --> 00:15:07,286
支持着很多 Xcode 的特性


359
00:15:07,426 --> 00:15:08,426
如自动补全


360
00:15:08,426 --> 00:15:11,376
跳转到定义 以及重构等等


361
00:15:12,116 --> 00:15:14,406
这是我们继续完善的地方


362
00:15:14,406 --> 00:15:15,546
我们想要使得


363
00:15:15,546 --> 00:15:17,826
代码补全之类的结果更好


364
00:15:19,186 --> 00:15:21,406
所以我们需要不断地迭代


365
00:15:22,266 --> 00:15:23,886
但同时我们想要让它


366
00:15:23,886 --> 00:15:25,466
更可靠也更鲁棒


367
00:15:27,296 --> 00:15:28,556
我们所做的努力之一


368
00:15:28,556 --> 00:15:29,546
作为今年开源项目的一部分


369
00:15:29,546 --> 00:15:31,006
是为 SourceKit 构建一个


370
00:15:31,006 --> 00:15:32,526
新的压力测试工具


371
00:15:33,676 --> 00:15:37,696
它所做的就是用 IDE 可以发出的所有查询


372
00:15:37,696 --> 00:15:40,086
连续击打 SourceKit


373
00:15:40,136 --> 00:15:42,296
以快速找出 SourceKit 的问题


374
00:15:42,856 --> 00:15:43,816
那么比如崩溃和断言


375
00:15:43,816 --> 00:15:44,756
它为我们创造了


376
00:15:44,796 --> 00:15:46,476
可重现的测试用例


377
00:15:46,896 --> 00:15:49,106
这里还有一些变化的东西


378
00:15:50,466 --> 00:15:52,086
我们相信用 Swift


379
00:15:52,086 --> 00:15:55,096
为你们所有人创建


380
00:15:55,096 --> 00:15:56,996
一流的工具


381
00:15:56,996 --> 00:15:58,396
并将其投入我们自己的


382
00:15:58,396 --> 00:15:59,386
工作流程的一部分


383
00:15:59,386 --> 00:16:01,146
这就像是我们在享用


384
00:16:01,786 --> 00:16:04,386
自己的理念 而像这样的努力


385
00:16:04,486 --> 00:16:06,686
就是现在我们日常的


386
00:16:06,686 --> 00:16:08,766
项目工程的一个核心部分


387
00:16:10,906 --> 00:16:12,986
那么我想要谈一谈


388
00:16:12,986 --> 00:16:14,626
一个面向未来的


389
00:16:14,626 --> 00:16:16,046
对 SourceKit 的投入


390
00:16:16,046 --> 00:16:17,676
那就是采用语言服务器协议


391
00:16:18,386 --> 00:16:20,896
举这个之前出现过的例子


392
00:16:21,576 --> 00:16:23,546
你可以用 Xcode


393
00:16:23,546 --> 00:16:24,896
或者把这个图片概括成为


394
00:16:24,896 --> 00:16:27,636
任何一种编辑器或工具


395
00:16:27,636 --> 00:16:29,086
我的意思是 SourceKit 是开源的


396
00:16:29,406 --> 00:16:30,776
它被设计为用于


397
00:16:30,776 --> 00:16:33,116
构建工具的可重用组件


398
00:16:34,196 --> 00:16:37,386
因此这样可以工作 对


399
00:16:37,386 --> 00:16:40,016
但这真的是一种很老的模型


400
00:16:40,236 --> 00:16:41,646
你可以假设那里有


401
00:16:41,646 --> 00:16:43,996
各种各样的工具和编辑器


402
00:16:43,996 --> 00:16:45,806
以及 IDE 它们想要


403
00:16:45,806 --> 00:16:48,816
连接到各种不同的语言服务


404
00:16:49,246 --> 00:16:50,316
因此 虽然它们能够直接


405
00:16:50,316 --> 00:16:51,526
连接逻辑来与 SourceKit 进行对话


406
00:16:51,526 --> 00:16:53,836
但这就都是相当临时的


407
00:16:53,836 --> 00:16:54,926
你必须让每一个编辑器


408
00:16:54,926 --> 00:16:57,096
连接到它自己的支持


409
00:16:57,096 --> 00:16:58,136
同时它们必须理解 SourceKit


410
00:16:58,136 --> 00:16:58,926
而且它们也必须了解


411
00:16:58,926 --> 00:17:00,526
所有它们想要连接的其他服务


412
00:17:00,526 --> 00:17:02,776
所以这不是一个可扩展的模型


413
00:17:03,296 --> 00:17:04,576
但是像大多数


414
00:17:04,576 --> 00:17:05,626
计算机科学中的问题一样


415
00:17:05,626 --> 00:17:06,486
你都可以用一个间接层来解决


416
00:17:06,486 --> 00:17:08,546
除了性能问题


417
00:17:08,546 --> 00:17:11,776
已经出现了一种


418
00:17:11,776 --> 00:17:12,886
行业标准解决方案


419
00:17:12,886 --> 00:17:15,596
称为语言服务协议或 LSP


420
00:17:15,596 --> 00:17:18,056
这个想法是


421
00:17:18,056 --> 00:17:20,205
如果编辑器使用 LSP


422
00:17:20,205 --> 00:17:22,056
这是一组标准的查询


423
00:17:22,056 --> 00:17:23,846
而服务可以将其返回


424
00:17:23,846 --> 00:17:25,286
你就可以直接将它们


425
00:17:25,286 --> 00:17:26,056
混聚在一起


426
00:17:27,576 --> 00:17:28,976
这是一个正在进行的积极的努力


427
00:17:28,976 --> 00:17:31,136
也是一个开放源代码


428
00:17:31,376 --> 00:17:32,236
你可以关注一下


429
00:17:32,846 --> 00:17:34,446
但是要让你们了解一下


430
00:17:34,446 --> 00:17:36,806
它的功能


431
00:17:36,806 --> 00:17:39,146
这个动画显示的是


432
00:17:39,146 --> 00:17:41,596
使用 SourceKit LSP 的代码补全支持


433
00:17:41,596 --> 00:17:44,296
还有对其他各种


434
00:17:44,296 --> 00:17:45,536
编辑器的支持


435
00:17:45,536 --> 00:17:48,006
你可以在 GitHub 的页面上找到说明


436
00:17:49,516 --> 00:17:54,616
[掌声]


437
00:17:55,116 --> 00:17:56,476
正是像这样的投入


438
00:17:56,476 --> 00:17:57,906
让我们感到非常的兴奋


439
00:17:57,906 --> 00:17:59,416
因为 Swift 真的是


440
00:17:59,416 --> 00:18:00,976
我们为通用计算


441
00:18:00,976 --> 00:18:03,326
而构建的语言 对吗


442
00:18:03,326 --> 00:18:05,166
它有巨大的潜力


443
00:18:05,216 --> 00:18:07,616
这实际上是为了


444
00:18:07,616 --> 00:18:10,036
让 Swift 真正蓬勃发展


445
00:18:10,036 --> 00:18:11,636
在一个多样化的软件生态系统中


446
00:18:12,126 --> 00:18:13,766
到这里 我要把舞台


447
00:18:13,766 --> 00:18:15,146
交给我的同事 Anna Zaks


448
00:18:15,146 --> 00:18:16,496
她会向大家分享


449
00:18:16,496 --> 00:18:18,516
Swift 中的语言变化


450
00:18:19,516 --> 00:18:24,056
[掌声]


451
00:18:24,556 --> 00:18:25,146
>> 谢谢你 Ted


452
00:18:25,756 --> 00:18:26,526
Ted 和大家分享了


453
00:18:26,526 --> 00:18:28,586
项目和编译器方面的改进


454
00:18:28,956 --> 00:18:30,366
现在让我来为大家介绍


455
00:18:30,526 --> 00:18:32,136
我们在 Swift 语言


456
00:18:32,136 --> 00:18:33,516
以及 Swift 5 和 Swift 5.1 中的


457
00:18:33,516 --> 00:18:36,006
标准库上所作的改进


458
00:18:37,126 --> 00:18:38,836
这些特性中有许多都在


459
00:18:38,836 --> 00:18:41,576
继续完善语言和库的核心部分


460
00:18:42,256 --> 00:18:43,956
同时为了与 Apple 今年推出的 


461
00:18:43,956 --> 00:18:45,556
几个主要的 Swift 框架


462
00:18:45,556 --> 00:18:47,086
匹配一致


463
00:18:47,086 --> 00:18:48,626
我们已经添加了能支持创建


464
00:18:48,626 --> 00:18:50,386
更好的 Swift API 的特性


465
00:18:51,356 --> 00:18:52,876
你们很多人都知道


466
00:18:52,876 --> 00:18:54,556
Swift 语言经历了


467
00:18:54,556 --> 00:18:55,516
开放的发展过程


468
00:18:56,006 --> 00:18:57,676
你们在幻灯片上看到的


469
00:18:57,676 --> 00:18:59,716
这些 SE 编号


470
00:18:59,716 --> 00:19:01,006
与可以 Swift 发展网站上


471
00:19:01,006 --> 00:19:02,916
找到的特性文档相对应


472
00:19:03,926 --> 00:19:05,146
这是一个很棒的资源


473
00:19:05,146 --> 00:19:06,786
如果你想要进一步了解这些特性


474
00:19:07,306 --> 00:19:08,486
现在 让我来带你们


475
00:19:08,486 --> 00:19:11,096
看看其中的一些特性


476
00:19:11,256 --> 00:19:12,726
首先我要讲几个例子


477
00:19:12,726 --> 00:19:14,726
是关于遗漏缺陷的弥补


478
00:19:15,296 --> 00:19:18,046
许多人都喜欢


479
00:19:18,046 --> 00:19:20,026
单表达式闭包语法的简单性


480
00:19:20,606 --> 00:19:22,036
因此他们需要用单表达式


481
00:19:22,216 --> 00:19:24,226
来编写一个返回


482
00:19:24,226 --> 00:19:27,066
而函数 方法和下标


483
00:19:27,156 --> 00:19:28,896
则像是不必要的负担


484
00:19:29,216 --> 00:19:31,456
那么现在你可以在任何地方


485
00:19:31,456 --> 00:19:32,676
使用简单的语法了


486
00:19:33,516 --> 00:19:38,476
[掌声]


487
00:19:38,976 --> 00:19:40,466
另一个缺陷是被


488
00:19:40,466 --> 00:19:41,876
一个开源贡献者修复的


489
00:19:42,156 --> 00:19:43,416
他就是 Alejandro Alonso 


490
00:19:43,766 --> 00:19:45,716
令人惊讶的是


491
00:19:45,716 --> 00:19:46,856
他刚刚高中毕业


492
00:19:47,766 --> 00:19:49,146
我们看看这个结构体


493
00:19:49,146 --> 00:19:50,806
它便利地为它的


494
00:19:50,806 --> 00:19:52,436
两个属性定义默认值


495
00:19:53,396 --> 00:19:54,896
以前 你可以调用一个初始化


496
00:19:54,896 --> 00:19:57,146
然后不传递参数


497
00:19:57,806 --> 00:19:58,776
你也可以调用一个初始化


498
00:19:58,776 --> 00:20:00,216
然后传递所有参数


499
00:20:00,216 --> 00:20:02,326
但是你不可以


500
00:20:02,356 --> 00:20:04,196
调用一个初始化


501
00:20:04,196 --> 00:20:05,406
然后只传递一些参数


502
00:20:06,266 --> 00:20:08,626
在 Swift 5 中 这个问题被修复了


503
00:20:09,506 --> 00:20:11,106
一切都如你所愿地进行


504
00:20:11,606 --> 00:20:15,736
[掌声]


505
00:20:16,236 --> 00:20:18,286
编译器会为


506
00:20:18,506 --> 00:20:20,156
所有这些情况生成初始化


507
00:20:21,116 --> 00:20:23,176
另一个重要的领域是


508
00:20:23,176 --> 00:20:24,206
高性能计算


509
00:20:25,106 --> 00:20:26,896
在 Swift 5 中 标准库


510
00:20:26,896 --> 00:20:29,006
增加了对 SIMD 


511
00:20:29,006 --> 00:20:30,396
即单指令多数据流


512
00:20:30,496 --> 00:20:31,576
指令和类型的支持


513
00:20:32,496 --> 00:20:33,986
这些通常用于


514
00:20:33,986 --> 00:20:36,056
为图形编写底层性能敏感的代码


515
00:20:36,056 --> 00:20:39,766
比如图像处理或 AR


516
00:20:40,276 --> 00:20:41,706
事实上 我们今年发布的


517
00:20:41,706 --> 00:20:43,036
新的 RealityKit 库


518
00:20:43,276 --> 00:20:44,496
就正在使用这些类型


519
00:20:45,226 --> 00:20:47,716
新的 SIMD 类型表示


520
00:20:47,916 --> 00:20:49,486
固定大小的 SIMD 矢量


521
00:20:50,136 --> 00:20:51,786
正如你所期望的


522
00:20:51,786 --> 00:20:53,566
你可以在这里使用


523
00:20:53,606 --> 00:20:55,966
标准库整型和浮点类型作为元素


524
00:20:56,916 --> 00:20:58,396
让我来带你们了解一下


525
00:20:58,396 --> 00:21:01,916
你可以用这些类型来做什么


526
00:21:02,096 --> 00:21:03,876
你可以从数组字面量


527
00:21:03,876 --> 00:21:04,786
初始化 SIMD 矢量


528
00:21:05,626 --> 00:21:07,676
这里我们有大小为 4 的数组


529
00:21:08,156 --> 00:21:09,696
实际上是两个大小为 4 的数组


530
00:21:09,696 --> 00:21:11,816
而新的点运算符


531
00:21:11,816 --> 00:21:14,046
允许你在这些矢量上


532
00:21:14,096 --> 00:21:16,096
执行逐点运算


533
00:21:16,706 --> 00:21:18,676
比如等式和比较


534
00:21:19,296 --> 00:21:20,906
这里举个例子


535
00:21:20,906 --> 00:21:23,636
我们正在检查 x 是否在每个点上


536
00:21:23,936 --> 00:21:24,616
都比 y 点大


537
00:21:25,406 --> 00:21:27,136
结果告诉我们


538
00:21:27,136 --> 00:21:30,076
x 只在最后两点比 y 大


539
00:21:30,676 --> 00:21:33,076
该结果被储存在


540
00:21:33,076 --> 00:21:36,136
另一种叫 SIMDMask 的类型中


541
00:21:36,136 --> 00:21:37,906
而 SIMDMask 类型上的点运算符


542
00:21:37,906 --> 00:21:40,096
让你可以进一步操作


543
00:21:40,496 --> 00:21:42,036
这些生成的掩码


544
00:21:42,246 --> 00:21:43,226
举个例子在这里


545
00:21:43,226 --> 00:21:45,466
我们在对之前的计算结果取反


546
00:21:48,376 --> 00:21:50,456
Swift 5 还为你提供了


547
00:21:50,456 --> 00:21:53,576
更多的文本操作表达能力


548
00:21:53,806 --> 00:21:55,246
字符串内插已经


549
00:21:55,246 --> 00:21:56,946
在 Swift 5 中被重新设计


550
00:21:57,506 --> 00:22:00,346
新设计的速度和距离


551
00:22:00,346 --> 00:22:03,376
达到之前的 1.7 倍


552
00:22:03,376 --> 00:22:05,256
你可以自定义


553
00:22:05,256 --> 00:22:07,116
所构建的内插


554
00:22:07,116 --> 00:22:08,676
通过提供自己的助手


555
00:22:08,676 --> 00:22:10,956
你可以用内插字符串


556
00:22:10,956 --> 00:22:12,946
将你的类型初始化


557
00:22:12,946 --> 00:22:14,786
来赋予字符串内插自定义的意义


558
00:22:15,886 --> 00:22:17,576
Swift 从一开始


559
00:22:17,576 --> 00:22:19,116
就可以支持字符串内插


560
00:22:19,466 --> 00:22:20,666
如果你写一个反斜杠符号


561
00:22:21,016 --> 00:22:22,266
后面跟着一些括号内引用


562
00:22:22,266 --> 00:22:23,566
在一个字符串字面量中


563
00:22:23,566 --> 00:22:25,166
编译器就会


564
00:22:25,166 --> 00:22:26,636
执行该代码


565
00:22:26,636 --> 00:22:28,916
并将值插入字符串


566
00:22:28,916 --> 00:22:31,246
这一直是行得通的


567
00:22:31,246 --> 00:22:32,546
但也会有一些限制


568
00:22:33,556 --> 00:22:35,736
举个例子 用一个封闭在


569
00:22:35,736 --> 00:22:37,816
NSLocalizedString 中的内插字符串


570
00:22:37,816 --> 00:22:40,056
这样是行不通的


571
00:22:41,236 --> 00:22:44,276
内插绘发生在转换之前


572
00:22:44,946 --> 00:22:46,986
比如说在这里


573
00:22:46,986 --> 00:22:48,996
字符串文件不包含


574
00:22:48,996 --> 00:22:51,246
对字符串中


575
00:22:51,296 --> 00:22:53,306
插入的整型的转换


576
00:22:53,726 --> 00:22:57,636
因此 You have 10 apples


577
00:22:57,636 --> 00:22:58,466
将无法被转换


578
00:22:59,576 --> 00:23:01,016
相反 你首先需要做的是


579
00:23:01,016 --> 00:23:03,416
创建 formatString


580
00:23:05,146 --> 00:23:07,166
接着 将它本地化


581
00:23:08,176 --> 00:23:10,046
然后 将值插入


582
00:23:10,046 --> 00:23:11,716
已经本地化的字符串中


583
00:23:12,836 --> 00:23:14,376
这就是用 UIKit 和 AppKit


584
00:23:14,376 --> 00:23:17,406
来完成字符串本地化的正确方法


585
00:23:18,456 --> 00:23:20,476
但是新的字符串内插设计


586
00:23:20,476 --> 00:23:22,236
让我们更进一步


587
00:23:22,236 --> 00:23:24,526
来设计出更有表现力的 API


588
00:23:24,526 --> 00:23:28,036
比如 SwiftUI 框架中的文本


589
00:23:28,706 --> 00:23:30,666
文本用于表示 SwiftUI 中的标签


590
00:23:30,666 --> 00:23:33,506
我们想要将其本地化


591
00:23:34,616 --> 00:23:35,606
我们来看看要怎么做


592
00:23:36,336 --> 00:23:39,096
这里我们传递一个


593
00:23:39,096 --> 00:23:40,256
内插字符串


594
00:23:40,256 --> 00:23:41,526
给文本的初始化


595
00:23:42,506 --> 00:23:44,126
而这里的技巧是


596
00:23:44,126 --> 00:23:46,656
文本初始化不接受


597
00:23:46,656 --> 00:23:48,046
字符串类型作为输入


598
00:23:48,616 --> 00:23:50,026
而是接受另一种类型


599
00:23:50,146 --> 00:23:52,456
它叫做 LocalizedStringKey


600
00:23:52,456 --> 00:23:54,616
该类型被定义在 SwiftUI 框架内


601
00:23:54,726 --> 00:23:56,916
因此 Swift 编译器


602
00:23:56,946 --> 00:23:58,316
就将自定义的规则


603
00:23:58,316 --> 00:24:00,186
应用到了字符串中


604
00:24:00,186 --> 00:24:02,026
通过字符串内插协议


605
00:24:02,236 --> 00:24:03,876
来处理该内插


606
00:24:04,896 --> 00:24:06,496
一旦它知道使用哪个规则


607
00:24:06,496 --> 00:24:08,656
编译器就会转换


608
00:24:08,656 --> 00:24:10,606
这个字符串内插


609
00:24:10,606 --> 00:24:12,156
用该自动生成的代码


610
00:24:13,306 --> 00:24:15,276
我们用三步来理解它的作用


611
00:24:16,166 --> 00:24:18,546
第一步 Swift 创建


612
00:24:18,596 --> 00:24:21,296
一个实例给构建器


613
00:24:21,296 --> 00:24:23,076
针对 LocalizedStringKey


614
00:24:23,566 --> 00:24:25,396
这个实例会包含两个东西


615
00:24:25,396 --> 00:24:27,876
分别是 formatKey


616
00:24:27,876 --> 00:24:29,276
和一个变量数组


617
00:24:30,756 --> 00:24:33,216
第二步 我们通过处理


618
00:24:33,716 --> 00:24:36,336
内插的段来构建字符串


619
00:24:37,076 --> 00:24:38,666
首先 我们有一个字符串字面量


620
00:24:38,786 --> 00:24:40,036
我们将它添加给 formatKey


621
00:24:41,296 --> 00:24:43,506
其次 在处理 quantity 时


622
00:24:43,646 --> 00:24:45,856
分别恢复 formatKey 中的


623
00:24:45,856 --> 00:24:48,256
格式说明符


624
00:24:48,256 --> 00:24:50,186
和变量数组中的值


625
00:24:51,666 --> 00:24:54,046
最后给 formatKey 添加另一段字面值


626
00:24:55,346 --> 00:24:58,946
第三步 调用 LocalizedStringKey 的初始化器


627
00:24:58,946 --> 00:25:00,806
这个时候你有了足够的信息


628
00:25:00,806 --> 00:25:03,306
来将字符串合理地本地化


629
00:25:05,356 --> 00:25:06,856
这样 SwiftUI 就可以使用


630
00:25:06,856 --> 00:25:08,326
该语言特性将文本本地化


631
00:25:08,386 --> 00:25:12,646
然后用户就可以读取信息 很酷吧


632
00:25:13,516 --> 00:25:19,036
[掌声]


633
00:25:19,536 --> 00:25:21,266
这个例子只是


634
00:25:21,266 --> 00:25:22,796
粗浅地介绍了一点


635
00:25:22,796 --> 00:25:23,886
字符串内插的使用


636
00:25:24,296 --> 00:25:26,196
如果你像我们一样


637
00:25:26,196 --> 00:25:27,886
对这个新特性感兴趣的话


638
00:25:27,916 --> 00:25:30,646
那么你可以去阅读


639
00:25:30,646 --> 00:25:33,056
ExpressibleByStringInterpolation 协议的文档


640
00:25:35,166 --> 00:25:36,926
现在 我们来谈谈焦点


641
00:25:37,506 --> 00:25:39,896
API 设计的一部分就是要


642
00:25:39,896 --> 00:25:42,806
决定从你的 API 中排除什么


643
00:25:42,876 --> 00:25:44,766
在 Swift 5.1 中 我们已经


644
00:25:44,866 --> 00:25:47,466
专门针对返回的类型做了改进


645
00:25:47,986 --> 00:25:50,146
虽然很重要的一点是


646
00:25:50,146 --> 00:25:51,636
返回的类型表示


647
00:25:51,636 --> 00:25:53,166
类型的性能


648
00:25:53,166 --> 00:25:54,956
你的 API 的用户可以从中推断


649
00:25:54,956 --> 00:25:57,416
但有时我们想要


650
00:25:57,416 --> 00:25:59,246
将返回的内容抽象化


651
00:26:00,246 --> 00:26:01,906
一个函数可以


652
00:26:01,906 --> 00:26:05,066
在运行时返回多次 


653
00:26:05,066 --> 00:26:06,736
或者它总是返回相同的类型


654
00:26:07,366 --> 00:26:08,716
但是该类型也许会透露


655
00:26:08,716 --> 00:26:11,426
你的 API 的实现细节


656
00:26:12,456 --> 00:26:14,446
且显示一些你的 API 的用户


657
00:26:14,446 --> 00:26:16,186
不应该推出的东西


658
00:26:17,026 --> 00:26:18,456
让我们来看看 Swift


659
00:26:18,666 --> 00:26:20,766
提供给这些例子的选项


660
00:26:22,226 --> 00:26:23,846
我们在例子中


661
00:26:24,176 --> 00:26:25,106
使用简单的形状 API


662
00:26:25,626 --> 00:26:27,116
那么正如你所期待的


663
00:26:27,116 --> 00:26:29,626
我们这里有一个 Shape 协议


664
00:26:29,626 --> 00:26:31,696
我们有定义如圆形 椭圆形


665
00:26:31,696 --> 00:26:34,616
和正方形等基本图形的类型


666
00:26:35,736 --> 00:26:37,226
同时我们还有这样的结构


667
00:26:37,226 --> 00:26:40,136
可以操作图形来创建


668
00:26:40,136 --> 00:26:42,256
图形的并集然后转换它们


669
00:26:42,916 --> 00:26:45,076
看看这个 FaceShape 的例子


670
00:26:45,796 --> 00:26:47,906
注意 这个 API 会根据你的图形的类型


671
00:26:47,946 --> 00:26:50,206
也就是 faceType


672
00:26:50,296 --> 00:26:53,016
来返回不同的类型


673
00:26:53,216 --> 00:26:55,686
但它们都是符合 Shape 协议的


674
00:26:55,996 --> 00:26:57,806
因此它是一个很好的例子


675
00:26:57,876 --> 00:26:59,466
将协议类型用作我们的返回类型


676
00:27:00,086 --> 00:27:02,726
那么 在这个例子中


677
00:27:02,916 --> 00:27:05,126
我们来构建一个八角星


678
00:27:05,216 --> 00:27:07,696
通过创建一个正方形


679
00:27:07,696 --> 00:27:10,596
和转换后的正方形的并集 对吗


680
00:27:11,866 --> 00:27:13,476
在这里声明具体的返回类型


681
00:27:13,476 --> 00:27:15,376
就会将大部分实现细节


682
00:27:15,376 --> 00:27:16,696
透露给客户


683
00:27:16,696 --> 00:27:19,726
同时显示出这个


684
00:27:19,726 --> 00:27:21,546
不必要的细节


685
00:27:21,546 --> 00:27:24,106
会让 API 很难推出


686
00:27:25,626 --> 00:27:27,406
但是 在这里使用一个


687
00:27:27,406 --> 00:27:29,216
协议类型 Shape 也不太好


688
00:27:29,606 --> 00:27:30,236
让我们看看这是为什么


689
00:27:31,706 --> 00:27:33,226
当协议类型被返回时


690
00:27:33,226 --> 00:27:34,856
这里并不能保证


691
00:27:34,856 --> 00:27:36,516
从每个调用中


692
00:27:36,516 --> 00:27:38,046
返回相同的类型给 API


693
00:27:38,046 --> 00:27:40,606
除 Swift 的泛型外


694
00:27:40,606 --> 00:27:42,486
它也给我们带来了


695
00:27:42,486 --> 00:27:44,086
这些基础的限制


696
00:27:44,806 --> 00:27:46,906
如果八角星有两个值


697
00:27:46,906 --> 00:27:49,046
从相同的 API 


698
00:27:49,046 --> 00:27:51,336
但不同的两个调用中


699
00:27:51,336 --> 00:27:53,526
返回到这个 API


700
00:27:53,526 --> 00:27:54,976
它们可能就没有相同的类型


701
00:27:54,976 --> 00:27:56,766
这样你就不能进行比较相等


702
00:27:57,636 --> 00:27:59,296
返回的类型不能


703
00:27:59,296 --> 00:28:01,766
有任何的关联类型


704
00:28:01,766 --> 00:28:03,486
也不能有涉及到自身的需求


705
00:28:04,526 --> 00:28:06,606
此外 丢失此类型标识


706
00:28:06,606 --> 00:28:07,926
也可能让


707
00:28:07,926 --> 00:28:08,976
某些编译器无法进行优化


708
00:28:11,496 --> 00:28:14,216
Swift 5.1 引入了另外一个


709
00:28:14,216 --> 00:28:17,126
叫做不透明结果类型的概念


710
00:28:17,706 --> 00:28:19,476
这是一个伟大的进步


711
00:28:19,476 --> 00:28:21,476
适用于已知返回相同具体类型的 API


712
00:28:21,476 --> 00:28:24,406
但是有可能想要将这种类型


713
00:28:24,406 --> 00:28:26,816
对用户隐藏起来


714
00:28:27,876 --> 00:28:29,126
不透明结果类型


715
00:28:29,126 --> 00:28:31,576
在这里写作 some Shape


716
00:28:31,576 --> 00:28:33,736
它代表一个特定的


717
00:28:33,736 --> 00:28:35,266
Shape 类型从这个 API 中返回


718
00:28:36,936 --> 00:28:38,996
这种类型标识的保证


719
00:28:39,316 --> 00:28:40,536
也让我们能够


720
00:28:40,536 --> 00:28:42,326
在 API 的主体里


721
00:28:42,326 --> 00:28:43,586
执行更强的类型检查


722
00:28:44,516 --> 00:28:46,296
因此 如果你有几个返回了


723
00:28:46,296 --> 00:28:48,046
不同类型的返回语句


724
00:28:48,046 --> 00:28:50,946
编译器就会将其缓存


725
00:28:51,256 --> 00:28:53,246
并提醒你修复该问题


726
00:28:54,606 --> 00:28:55,996
不透明结果类型能够


727
00:28:55,996 --> 00:28:58,476
在 Swift 5.1 中使用


728
00:28:58,476 --> 00:29:00,626
你可以从文档中了解更多


729
00:29:01,806 --> 00:29:03,296
注意 这个特性需要


730
00:29:03,296 --> 00:29:04,336
新的 Swift Runtime


731
00:29:05,086 --> 00:29:07,366
因此它只能在更新的 Swift 操作系统里工作


732
00:29:08,356 --> 00:29:09,796
如果你要进行向后部署


733
00:29:09,796 --> 00:29:11,636
你就可以使用这个特性


734
00:29:11,636 --> 00:29:13,686
但你需要进行静态可用性检查


735
00:29:13,986 --> 00:29:15,656
来保证它们的使用


736
00:29:17,816 --> 00:29:19,766
现在我们来说说代码重用


737
00:29:19,866 --> 00:29:22,306
及叫做属性包装器的新功能


738
00:29:23,636 --> 00:29:26,306
访问属性的自定模式很常见


739
00:29:26,856 --> 00:29:28,816
其中的一些模式


740
00:29:28,816 --> 00:29:30,246
具有一流的语言支持


741
00:29:30,246 --> 00:29:32,426
比如懒惰模式


742
00:29:32,866 --> 00:29:34,206
但你也可能正在编写


743
00:29:34,206 --> 00:29:35,826
你自己的自定包装器


744
00:29:36,716 --> 00:29:39,066
也许你有一些


745
00:29:39,106 --> 00:29:42,396
访问访问本地线程存储或写时拷贝


746
00:29:42,396 --> 00:29:43,686
也许你使用计算属性


747
00:29:43,686 --> 00:29:45,536
来储存用户默认值


748
00:29:46,956 --> 00:29:48,666
我们一直编写自定的


749
00:29:48,666 --> 00:29:50,476
get 和 set


750
00:29:50,476 --> 00:29:52,146
但有时这个代码是重复的


751
00:29:53,106 --> 00:29:54,636
例如在这里我有两个


752
00:29:54,636 --> 00:29:57,506
指定用户默认值的属性


753
00:29:58,436 --> 00:29:59,696
但这个代码的大多数


754
00:29:59,696 --> 00:30:02,206
只是在复制粘贴


755
00:30:02,336 --> 00:30:03,856
有了属性包装器


756
00:30:03,856 --> 00:30:06,756
我们可以声明一种


757
00:30:06,756 --> 00:30:07,896
指定访问模式的类型


758
00:30:09,446 --> 00:30:10,816
我们将它命名为 UserDefaults


759
00:30:12,186 --> 00:30:13,846
接着 我们告诉编译器


760
00:30:13,846 --> 00:30:15,416
这个类型是特殊的


761
00:30:16,256 --> 00:30:18,246
它的首要目的就是


762
00:30:18,246 --> 00:30:21,236
包裹一个属性并指定其访问模式


763
00:30:22,486 --> 00:30:24,646
这样做我们得到的就是


764
00:30:24,646 --> 00:30:26,056
这个类型会允许我们


765
00:30:26,106 --> 00:30:28,796
使用一个自定属性来声明


766
00:30:28,796 --> 00:30:31,126
用户默认访问模式的属性


767
00:30:32,486 --> 00:30:33,556
我们来仔细看看


768
00:30:33,806 --> 00:30:35,326
有了这里的属性包装器


769
00:30:35,326 --> 00:30:38,746
我们可以重写


770
00:30:38,746 --> 00:30:40,116
之前那两个用户默认属性 


771
00:30:40,116 --> 00:30:41,096
写成这样


772
00:30:41,216 --> 00:30:43,626
这样就没有重复了


773
00:30:43,626 --> 00:30:44,886
非常干净明了


774
00:30:45,386 --> 00:30:47,196
我需要做的就只是


775
00:30:47,196 --> 00:30:50,546
添加自定属性


776
00:30:50,546 --> 00:30:52,236
同时知道这些属性


777
00:30:52,236 --> 00:30:53,436
仍被声明为布尔类型


778
00:30:53,716 --> 00:30:55,296
因此你可以使用它们


779
00:30:55,296 --> 00:30:56,826
像使用简单的布尔值一样


780
00:30:58,516 --> 00:31:04,276
[掌声]


781
00:31:04,776 --> 00:31:06,236
属性包装器使得我们可以


782
00:31:06,236 --> 00:31:08,096
定义自定访问模式


783
00:31:08,486 --> 00:31:09,856
而属性可以选择使用它们


784
00:31:09,856 --> 00:31:11,776
只需要在其声明中


785
00:31:11,776 --> 00:31:13,726
添加一个自定属性


786
00:31:16,136 --> 00:31:18,046
我们寻求特定的工具


787
00:31:18,046 --> 00:31:19,396
来解决特定的问题


788
00:31:19,926 --> 00:31:22,486
它们在各自的领域都十分有用


789
00:31:23,526 --> 00:31:25,776
同样 DSL 在程序员的生活中


790
00:31:25,776 --> 00:31:27,256
也有着重要的作用


791
00:31:27,936 --> 00:31:29,536
我们用它们来


792
00:31:30,006 --> 00:31:31,646
查询数据库并构建图表


793
00:31:31,646 --> 00:31:33,256
我们喜欢这种声明风格


794
00:31:33,546 --> 00:31:35,116
我们可以简洁明了地


795
00:31:35,116 --> 00:31:39,126
声明我们网页的布局


796
00:31:40,016 --> 00:31:42,146
但是 它们也有不同


797
00:31:43,176 --> 00:31:44,626
当我们每次使用其中一种时


798
00:31:44,626 --> 00:31:46,806
都需要进行上下文切换


799
00:31:46,806 --> 00:31:48,966
每种语言都有自己的语法和语义


800
00:31:50,166 --> 00:31:51,546
它们都有各自独特的


801
00:31:51,546 --> 00:31:52,746
强大的工具来支持它们


802
00:31:53,456 --> 00:31:55,576
如果你缺失了一个 HTML 标记


803
00:31:55,576 --> 00:31:57,496
如果你在一个 HTML 编辑器里 


804
00:31:57,496 --> 00:31:58,806
这是很容易解决的


805
00:31:59,916 --> 00:32:01,426
但是 因为语法和语义


806
00:32:01,456 --> 00:32:03,436
都被调整为特定的目的


807
00:32:03,506 --> 00:32:05,986
支持它们的工具


808
00:32:05,986 --> 00:32:08,036
也常常有特定的领域


809
00:32:09,196 --> 00:32:10,946
因此当我们需要将


810
00:32:10,946 --> 00:32:12,636
这些 DSL 整合进我们的项目时


811
00:32:13,496 --> 00:32:14,776
通常没有什么好办法


812
00:32:16,066 --> 00:32:17,586
在一些情况里 我们会


813
00:32:17,586 --> 00:32:20,336
添加自定构建阶段


814
00:32:20,336 --> 00:32:21,336
但通常我们会用这个解决方案


815
00:32:22,456 --> 00:32:23,826
它看起来十分眼熟


816
00:32:23,826 --> 00:32:25,296
这是一个表示 HTML 的


817
00:32:25,296 --> 00:32:26,376
字符串字面值


818
00:32:27,666 --> 00:32:29,936
我们完成了整合 却失去了工具的支持


819
00:32:30,566 --> 00:32:32,726
编译器代码补全将这个


820
00:32:32,726 --> 00:32:33,606
看作一个字符串


821
00:32:34,476 --> 00:32:35,866
这里没有类型检查


822
00:32:36,186 --> 00:32:38,176
对 Swift 编译器来说只是一堆文本


823
00:32:39,046 --> 00:32:40,526
因此像忘记结束标记


824
00:32:40,526 --> 00:32:42,836
这样的低级错误


825
00:32:42,836 --> 00:32:44,286
直到运行时才会被注意到


826
00:32:45,306 --> 00:32:47,316
我们想要使用这些 DSL


827
00:32:47,736 --> 00:32:49,146
但我们也想要将它们


828
00:32:49,276 --> 00:32:51,526
整合到我们的语言和工具中


829
00:32:53,316 --> 00:32:55,466
在 Swift 5.1 中 我们


830
00:32:55,466 --> 00:32:57,626
引入了在 Swift 中定义


831
00:32:57,626 --> 00:32:58,766
嵌入式 DSL 的功能


832
00:32:59,516 --> 00:33:06,516
[掌声]


833
00:33:07,016 --> 00:33:08,256
我们来看看这个代码


834
00:33:08,256 --> 00:33:10,116
它定义了一个 HTML 对象


835
00:33:10,656 --> 00:33:12,476
我的一位同事只是为了娱乐


836
00:33:12,476 --> 00:33:15,636
用这个新的 Swift 特性


837
00:33:15,636 --> 00:33:17,906
在几个小时内 为 HTML DSL


838
00:33:17,906 --> 00:33:19,236
提供了原型支持


839
00:33:20,056 --> 00:33:21,706
在这里你可以看到


840
00:33:21,706 --> 00:33:23,796
这个代码看起来像 Swift


841
00:33:23,796 --> 00:33:26,276
但你又被 HTML 元素的定义所吸引


842
00:33:26,536 --> 00:33:29,886
而你在这里可以看到


843
00:33:29,886 --> 00:33:32,646
熟悉的 Swift 概念 比如闭包和方法调用


844
00:33:33,076 --> 00:33:34,596
我们这里使用的是


845
00:33:34,596 --> 00:33:35,956
Swift 程序中的变量


846
00:33:36,756 --> 00:33:38,496
该工具将会确保


847
00:33:38,496 --> 00:33:40,366
没有标签的缺失


848
00:33:40,366 --> 00:33:42,816
同时提供语法的高亮显示和重构操作


849
00:33:43,946 --> 00:33:45,666
我们的设想是


850
00:33:45,666 --> 00:33:47,126
你不仅可以声明一个


851
00:33:47,126 --> 00:33:49,366
元素列表 还可以使用


852
00:33:49,426 --> 00:33:51,506
这样的 Swift 控制语句


853
00:33:51,506 --> 00:33:54,116
就在这个 DSL 当中


854
00:33:56,306 --> 00:33:56,456
好了


855
00:33:58,516 --> 00:34:02,316
[掌声]


856
00:34:02,816 --> 00:34:04,386
让我们来看看在后台


857
00:34:04,386 --> 00:34:05,706
这是如何实现的


858
00:34:06,256 --> 00:34:07,926
DSL 实现者添加了一个函数


859
00:34:07,986 --> 00:34:10,565
来构建每一个 HTML 元素


860
00:34:11,545 --> 00:34:13,356
而这些函数都是闭包函数


861
00:34:14,216 --> 00:34:16,626
而这里有趣的部分是


862
00:34:16,626 --> 00:34:18,216
这些闭包是特殊的


863
00:34:18,815 --> 00:34:20,106
它们都有这个自定特性


864
00:34:20,106 --> 00:34:22,806
即 @HTMLBuilder


865
00:34:22,806 --> 00:34:24,656
这告诉了编译器


866
00:34:24,656 --> 00:34:27,025
要使用 HTMLBuilder 类型


867
00:34:27,096 --> 00:34:27,896
来处理这些闭包


868
00:34:29,576 --> 00:34:30,826
我们来看看包含 DSL 代码的


869
00:34:30,826 --> 00:34:32,706
闭包函数是如何转换为


870
00:34:32,706 --> 00:34:34,716
一个正常的 Swift 闭包函数的


871
00:34:36,056 --> 00:34:37,896
这个 DSL 闭包在做什么呢


872
00:34:38,386 --> 00:34:40,446
它正在生成一批值


873
00:34:41,386 --> 00:34:42,806
然而 这些值是未使用的


874
00:34:42,806 --> 00:34:43,976
同时这里也没有


875
00:34:43,976 --> 00:34:45,716
返回语句


876
00:34:46,456 --> 00:34:48,126
那么为了让它工作


877
00:34:48,126 --> 00:34:51,286
编译器将这个代码进行转换


878
00:34:51,896 --> 00:34:53,646
通过先收集这些未使用的值


879
00:34:54,266 --> 00:34:57,196
然后调用构建函数


880
00:34:57,196 --> 00:34:59,226
将它们组合起来


881
00:35:00,686 --> 00:35:02,196
这些函数都是由


882
00:35:02,196 --> 00:35:05,046
HTMLBuilder 类型提供的


883
00:35:05,046 --> 00:35:08,076
它是由你这个 DSL 作者编写的


884
00:35:08,146 --> 00:35:10,396
同时它可以构建任何


885
00:35:10,396 --> 00:35:11,576
适合你的 DSL 的对象


886
00:35:12,236 --> 00:35:14,196
这里我们正在构建 HTML


887
00:35:14,196 --> 00:35:15,676
因此它就会构建 HTML 对象


888
00:35:17,976 --> 00:35:19,756
我们很高兴使用这个功能


889
00:35:19,756 --> 00:35:21,336
我们用它来驱动


890
00:35:21,566 --> 00:35:23,796
你会在新的 SwiftUI 中


891
00:35:23,796 --> 00:35:26,286
用到的声明语法


892
00:35:27,516 --> 00:35:33,266
[掌声]


893
00:35:33,766 --> 00:35:35,366
这里有一个相关的例子


894
00:35:35,366 --> 00:35:37,616
在 Swift UI 中使用


895
00:35:37,616 --> 00:35:39,896
其自定 Swift DSL


896
00:35:41,196 --> 00:35:42,706
这个特性可在 beta 1 中使用


897
00:35:42,706 --> 00:35:44,596
我们很想看到


898
00:35:44,596 --> 00:35:46,146
它将怎样让你从中受益


899
00:35:46,146 --> 00:35:47,846
而你又会用它构建出怎样的 DSL


900
00:35:48,886 --> 00:35:50,226
我们会马上在 Swift 论坛上


901
00:35:50,226 --> 00:35:52,526
讨论该特性背后的这些细节


902
00:35:53,336 --> 00:35:54,356
如果你有兴趣来


903
00:35:54,356 --> 00:35:55,776
塑造这个特性的未来


904
00:35:55,776 --> 00:35:57,416
或者其他的 Swift 特性


905
00:35:57,886 --> 00:35:59,306
那么十分欢迎你的加入


906
00:36:01,596 --> 00:36:03,216
总的来说 


907
00:36:03,216 --> 00:36:05,106
我所说谈到的许多改进


908
00:36:05,106 --> 00:36:06,996
都会在我们今年


909
00:36:06,996 --> 00:36:08,436
新发布的 Swift 框架之中


910
00:36:09,276 --> 00:36:11,186
我们非常期待看到


911
00:36:11,186 --> 00:36:13,286
你们将如何从中获益


912
00:36:13,286 --> 00:36:15,276
让你们的 API 更有表现力


913
00:36:15,276 --> 00:36:15,946
干净且易于使用


914
00:36:16,776 --> 00:36:18,626
我们的同事将会做一个


915
00:36:18,626 --> 00:36:20,906
关于现代 Swift API 设计的演讲


916
00:36:20,906 --> 00:36:22,466
届时他们会与你们分享


917
00:36:22,466 --> 00:36:24,206
在用这些特性构建 Apple 框架时


918
00:36:24,206 --> 00:36:26,646
所学到的一些经验教训


919
00:36:27,446 --> 00:36:29,356
那么今天就到这里了


920
00:36:29,356 --> 00:36:30,816
参会愉快 谢谢大家


921
00:36:31,516 --> 00:36:36,500
[掌声]

