1
00:00:06,039 --> 00:00:10,911 line:0
（与SwiftUI相整合）


2
00:00:18,085 --> 00:00:19,052 line:-1
下午好


3
00:00:19,520 --> 00:00:21,021 line:-1
我是Tanu Singhal


4
00:00:21,455 --> 00:00:23,156 line:-1
我和我的同事Raleigh一起


5
00:00:23,557 --> 00:00:27,461 line:-2
今天跟大家分享
与SwiftUI相整合


6
00:00:28,161 --> 00:00:29,863 line:-1
（目标）


7
00:00:29,930 --> 00:00:31,331 line:-1
今天我们的第一个目标是


8
00:00:31,765 --> 00:00:35,903 line:-2
帮助你在你现有的app中
添加SwiftUI


9
00:00:37,137 --> 00:00:43,577 line:-2
接下来我们学习如何在SwiftUI中
嵌入UIKit、AppKit和WatchKit


10
00:00:44,778 --> 00:00:49,483 line:-1
稍后我们讲设置数据模型的策略


11
00:00:49,550 --> 00:00:51,685 line:-2
从而使数据模型
适用于SwiftUI


12
00:00:52,753 --> 00:00:56,023 line:-1
最后我们学习使用拖放、


13
00:00:56,089 --> 00:00:59,359 line:-2
粘贴模式和SwiftUI中的
焦点系统


14
00:00:59,426 --> 00:01:02,596 line:-2
从而使我们的app
能更好地整合到整个系统中


15
00:01:05,566 --> 00:01:10,137 line:-2
在app上托管SwiftUI内容
非常简单


16
00:01:10,204 --> 00:01:11,572 line:-2
（在你的app中
托管SwiftUI视图）


17
00:01:11,638 --> 00:01:14,808 line:-1
我们通过托管控制器来实现


18
00:01:16,476 --> 00:01:22,716 line:-2
托管控制器可以用于
把SwiftUI视图设置为


19
00:01:22,783 --> 00:01:25,552 line:-2
ViewController
或InterfaceController的内容


20
00:01:27,688 --> 00:01:31,358 line:-1
托管控制器在全部三个框架中都可用


21
00:01:33,927 --> 00:01:37,865 line:-2
首先让我们具体看一下
UIHostingController


22
00:01:39,499 --> 00:01:44,004 line:-2
UIHostingController
是UIViewController的子类


23
00:01:45,172 --> 00:01:49,476 line:-2
它有一个初始化程序 可获取一个
叫做rootView的单一参数


24
00:01:50,644 --> 00:01:53,714 line:-2
我们要把SwiftUI视图
传递到这里


25
00:01:55,182 --> 00:01:57,718 line:-1
一旦对托管控制器进行了初始化


26
00:01:57,985 --> 00:02:03,156 line:-2
它通过代码或Storyboard
呈现 就像任何其它视图控制器一样


27
00:02:05,692 --> 00:02:09,128 line:-2
对于Mac 我们有
NSHostingController


28
00:02:09,830 --> 00:02:14,735 line:-2
用于在NSViewController中
呈现SwiftUI内容


29
00:02:16,603 --> 00:02:18,372 line:-1
现在如果你是Mac开发人员


30
00:02:18,639 --> 00:02:22,442 line:-2
你可能并不总是希望呈现
整个视图控制器


31
00:02:23,076 --> 00:02:27,314 line:-2
也许你想在你现有的AppKit
视图等级中


32
00:02:27,381 --> 00:02:30,017 line:-1
嵌入一个小的SwiftUI视图


33
00:02:31,351 --> 00:02:34,555 line:-2
为此我们有
NSHostingView


34
00:02:35,756 --> 00:02:39,560 line:-2
NSHostingView
是NSView的子类


35
00:02:39,826 --> 00:02:43,697 line:-1
用于直接在AppKit视图等级中


36
00:02:43,764 --> 00:02:46,400 line:-1
呈现SwiftUI视图


37
00:02:48,468 --> 00:02:50,170 line:-1
如果你使用了自动布局


38
00:02:50,904 --> 00:02:52,472 line:-1
我们会自动遵守


39
00:02:52,539 --> 00:02:56,076 line:-2
你的SwiftUI视图的
内容尺寸偏好


40
00:02:56,376 --> 00:02:58,812 line:-1
并且你的布局将满足你的预期


41
00:03:00,714 --> 00:03:04,918 line:-2
当使用容器视图在你现有的
AppKit或UIKit视图等级中


42
00:03:04,985 --> 00:03:09,289 line:-2
嵌入UIHostingControllers
或NSHostingControllers时


43
00:03:09,723 --> 00:03:13,660 line:-1
也可以使用自动布局


44
00:03:16,930 --> 00:03:21,668 line:-2
对于watchOS开发人员
我们有WKHostingController


45
00:03:22,936 --> 00:03:26,139 line:-1
要使用它 你首先要创建一个子类


46
00:03:26,907 --> 00:03:31,378 line:-2
在子类中 我们会从主体中返回
SwiftUI视图


47
00:03:32,346 --> 00:03:34,781 line:-1
接下来进入Storyboard


48
00:03:35,716 --> 00:03:39,286 line:-1
并选择任意界面控制器或托管控制器


49
00:03:40,921 --> 00:03:46,159 line:-2
从身份检测器中
对WKHostingController


50
00:03:46,226 --> 00:03:48,128 line:-1
把类设置为你的自定义子类


51
00:03:49,396 --> 00:03:54,034 line:-2
现在托管控制器可以与任何
其它界面控制器一样使用了


52
00:03:55,369 --> 00:03:57,671 line:-2
如果你由于发生在
WatchKit上的变更


53
00:03:57,738 --> 00:04:00,674 line:-1
需要使主体无效


54
00:04:01,008 --> 00:04:04,811 line:-2
你可通过使用
setNeedsBodyUpdate


55
00:04:04,878 --> 00:04:07,414 line:-1
和updateBodyIfNeeded方法实现


56
00:04:09,183 --> 00:04:15,689 line:-2
在动态交互式通知中使用
SwiftUI内容也很简单


57
00:04:17,024 --> 00:04:21,361 line:-2
为此我们使用WKUserNotification
HostingController


58
00:04:22,296 --> 00:04:26,466 line:-2
再一次 我们首先从主体中返回
SwiftUI视图


59
00:04:27,134 --> 00:04:30,037 line:-2
然后每次调用
didReceive通知方法时


60
00:04:30,103 --> 00:04:33,207 line:-1
这个主体都会被更新


61
00:04:35,776 --> 00:04:39,246 line:-2
要了解关于用SwiftUI
创建Watch app的更多信息


62
00:04:39,746 --> 00:04:42,616 line:-2
请查看watchOS上的
SwiftUI演讲


63
00:04:45,452 --> 00:04:48,589 line:-1
现在让我们看一个示例app


64
00:04:48,655 --> 00:04:51,325 line:-2
关于我们需要在哪里使用
托管控制器


65
00:04:52,993 --> 00:04:55,195 line:-1
几天前我出门去买一些植物


66
00:04:56,296 --> 00:04:58,966 line:-2
我学习了很多
关于不同的植物和树木的知识


67
00:04:59,233 --> 00:05:03,003 line:-2
我决定创建一个
把这些植物分类的app


68
00:05:04,538 --> 00:05:07,407 line:-1
我开始使用UIKit创建app


69
00:05:08,008 --> 00:05:11,812 line:-2
你在这里看到的是一个
标准的UIKit表视图控制器


70
00:05:13,547 --> 00:05:16,049 line:-1
然后我学习了SwiftUI


71
00:05:16,583 --> 00:05:20,821 line:-2
并使用SwiftUI为我的app
创建了详情视图


72
00:05:22,122 --> 00:05:25,158 line:-1
现在我还没有添加任何


73
00:05:25,225 --> 00:05:28,228 line:-2
从UIKitTableViewController
导航到SwiftUI的代码


74
00:05:29,663 --> 00:05:32,566 line:-2
让我们进行一次演示
看看我们该如何设置它


75
00:05:32,966 --> 00:05:39,806 line:-2
（关于在你的app中
托管SwiftUI视图的演示）


76
00:05:47,181 --> 00:05:49,149 line:-1
在这里我们有SwiftUI视图


77
00:05:50,050 --> 00:05:52,519 line:-1
用于呈现详情视图


78
00:05:52,953 --> 00:05:55,422 line:-1
这是当我们轻触表时


79
00:05:55,489 --> 00:05:57,024 line:-1
想要导航到的视图


80
00:05:57,891 --> 00:05:59,626 line:-1
让我们进入Storyboard


81
00:06:03,363 --> 00:06:05,866 line:-1
Storyboard将进入库


82
00:06:06,333 --> 00:06:08,502 line:-1
并查找托管视图控制器


83
00:06:09,169 --> 00:06:11,738 line:-2
让我们在Storyboard中
拖动它


84
00:06:13,507 --> 00:06:17,511 line:-2
我要选择表中的这个网格
按住Control键


85
00:06:17,578 --> 00:06:19,813 line:-1
并把它拖动到托管控制器中


86
00:06:20,547 --> 00:06:22,316 line:-1
选择显示跳转


87
00:06:23,517 --> 00:06:27,221 line:-2
现在我们需要在这个托管控制器中
添加内容


88
00:06:27,788 --> 00:06:30,724 line:-2
因此让我们打开另一侧的
表视图控制器


89
00:06:33,260 --> 00:06:35,963 line:-2
让我隐藏其中一些面板
留出更多空间


90
00:06:39,199 --> 00:06:41,668 line:-1
现在我要选择我们刚创建的跳转


91
00:06:42,236 --> 00:06:45,639 line:-2
按住Control键
把它拖到视图控制器代码中


92
00:06:46,607 --> 00:06:49,243 line:-2
这会创建一个
IBSegueAction


93
00:06:50,944 --> 00:06:54,181 line:-2
IBSegueActions
是Xcode 11中的新功能


94
00:06:54,248 --> 00:06:58,218 line:-2
允许你把Storyboard中的
跳转连接到


95
00:06:58,485 --> 00:07:00,187 line:-1
你的视图控制器代码


96
00:07:00,854 --> 00:07:01,955 line:-1
通过使用这些


97
00:07:02,022 --> 00:07:05,759 line:-2
你可以直接在你的目标视图控制器中
设置属性


98
00:07:05,826 --> 00:07:08,762 line:-2
而不需要使用
prepareForSegue方法


99
00:07:13,300 --> 00:07:14,168 line:-1
谢谢


100
00:07:16,904 --> 00:07:19,907 line:-2
让我们关闭Storyboard
因为我们主要看代码


101
00:07:21,608 --> 00:07:25,045 line:-2
在这里我要创建一个
SwiftUI视图的实例


102
00:07:26,280 --> 00:07:29,883 line:-2
这里的rootView被设置到了
PlantDetailsView


103
00:07:29,950 --> 00:07:31,785 line:-2
PlantDetailsView
是我们的SwiftUI视图


104
00:07:32,753 --> 00:07:35,722 line:-2
我们所要做的就是
把这个rootView传递到


105
00:07:36,223 --> 00:07:38,692 line:-1
托管控制器的初始化工具中


106
00:07:41,228 --> 00:07:42,629 line:-1
现在当我们运行我们的app时


107
00:07:43,063 --> 00:07:46,767 line:-2
我们将可以从
UIKitTableViewController


108
00:07:47,568 --> 00:07:50,804 line:-2
导航到我们的PlantDetailsView
PlantDetailsView在SwiftUI中


109
00:07:54,508 --> 00:07:57,744 line:-2
（关于在你的app中
托管SwiftUI视图的演示）


110
00:08:01,615 --> 00:08:07,354 line:-2
我们在这演示中看到了在app中
添加SwiftUI是多么容易


111
00:08:08,589 --> 00:08:13,594 line:-2
接下来我们要学习
在SwiftUI视图内


112
00:08:13,660 --> 00:08:15,596 line:-1
嵌入使用现有框架创建的视图


113
00:08:17,097 --> 00:08:20,067 line:-2
为此我们要使用
Representable协议


114
00:08:20,901 --> 00:08:25,973 line:-2
Representable协议允许我们
在SwiftUI中呈现UIViews、NSViews


115
00:08:26,039 --> 00:08:29,209 line:-1
和WKInterfaceObject


116
00:08:29,276 --> 00:08:30,544 line:-2
（Representable
协议）


117
00:08:30,611 --> 00:08:34,914 line:-2
此外我们还可以在SwiftUI中
呈现视图控制器


118
00:08:34,982 --> 00:08:38,118 line:-2
通过视图控制器
Representable协议实现


119
00:08:40,287 --> 00:08:43,857 line:-2
Representable
协议有两个必需方法


120
00:08:44,258 --> 00:08:46,827 line:-1
Make方法和Update方法


121
00:08:48,428 --> 00:08:49,730 line:-1
Make方法


122
00:08:50,364 --> 00:08:54,902 line:-2
是创建你希望在SwiftUI中
呈现的视图或控制器的地方


123
00:08:55,636 --> 00:08:59,039 line:-1
而Update方法是把这个视图


124
00:08:59,106 --> 00:09:00,841 line:-1
更新为当前配置的地方


125
00:09:02,009 --> 00:09:05,812 line:-2
在初始化过程中
首先调用Make方法


126
00:09:05,879 --> 00:09:08,015 line:-1
然后再调用Update方法


127
00:09:09,416 --> 00:09:12,452 line:-1
可以多次调用Update方法


128
00:09:12,519 --> 00:09:15,889 line:-2
无论何时当SwiftUI
请求更新时都可以调用它


129
00:09:17,891 --> 00:09:21,695 line:-2
最后我们为你提供了一个
可选的Dismantle方法


130
00:09:22,129 --> 00:09:25,332 line:-1
你可以在视图或控制器被移除之前


131
00:09:25,399 --> 00:09:27,835 line:-2
在Dismantle方法中
放一些需要运行的清除代码


132
00:09:30,170 --> 00:09:33,207 line:-1
现在让我们看看这些方法的


133
00:09:33,273 --> 00:09:34,474 line:-1
Swift定义


134
00:09:36,210 --> 00:09:39,713 line:-2
请注意Make、Update
和Dismantle方法


135
00:09:39,780 --> 00:09:43,283 line:-1
在跨平台上看起来和用起来很相似


136
00:09:44,384 --> 00:09:46,320 line:-1
对于AppKit和UIKit


137
00:09:46,954 --> 00:09:50,357 line:-1
这些协议可用于


138
00:09:50,424 --> 00:09:52,926 line:-2
在SwiftUI中
呈现视图和视图控制器


139
00:09:53,760 --> 00:09:58,732 line:-2
对于WatchKit 我们可以使用
WKInterface representable协议


140
00:09:59,032 --> 00:10:03,704 line:-2
在SwiftUI中呈现
WKitInterfaceObjects的子集


141
00:10:05,072 --> 00:10:08,442 line:-2
你可以在developer.apple.com上
查询


142
00:10:08,509 --> 00:10:10,410 line:-2
所支持的WatchKitObjects的
完整列表


143
00:10:12,346 --> 00:10:13,714 line:-1
那么正如我们所提到过的


144
00:10:13,780 --> 00:10:17,584 line:-2
Make和Update方法
是在SwiftUI中


145
00:10:17,651 --> 00:10:22,422 line:-1
呈现视图的仅有的两个必需方法


146
00:10:23,257 --> 00:10:26,393 line:-1
然而视图通常很复杂


147
00:10:26,660 --> 00:10:29,363 line:-2
你想做的可能不仅仅是
简单地呈现它们


148
00:10:29,429 --> 00:10:30,564 line:-1
（视图的高级整合）


149
00:10:30,631 --> 00:10:36,436 line:-2
也许你想在SwiftUI中
暴露目标动作或委托


150
00:10:38,205 --> 00:10:42,442 line:-2
或你可能想从SwiftUI的
环境中读取内容


151
00:10:42,509 --> 00:10:43,944 line:-1
并做出相应的响应


152
00:10:45,379 --> 00:10:50,184 line:-2
了解你的视图上是否有动画
也很有用


153
00:10:52,219 --> 00:10:57,524 line:-2
为了让你能更好地整合
你的视图和SwiftUI


154
00:10:57,824 --> 00:11:00,494 line:-2
我们创建了
Representable情境


155
00:11:01,862 --> 00:11:05,299 line:-2
Representable
情境有三个属性


156
00:11:05,766 --> 00:11:07,935 line:-1
第一个是coordinator


157
00:11:08,468 --> 00:11:12,239 line:-1
帮助协调你的视图和SwiftUI


158
00:11:13,106 --> 00:11:16,877 line:-2
coordinator
可用于实施通用模式


159
00:11:16,944 --> 00:11:19,880 line:-1
比如委托、数据源和目标动作


160
00:11:19,947 --> 00:11:21,515 line:-2
（Representable
情境）


161
00:11:21,582 --> 00:11:24,284 line:-2
下一个属性是
environment


162
00:11:24,718 --> 00:11:28,055 line:-1
帮助你读取SwiftUI的环境


163
00:11:28,522 --> 00:11:32,759 line:-1
可以是系统环境 比如色性或尺寸类


164
00:11:32,826 --> 00:11:34,528 line:-1
或明确的方向


165
00:11:35,162 --> 00:11:39,399 line:-1
或是app定义的自定义环境属性


166
00:11:40,534 --> 00:11:43,237 line:-1
最后是transaction属性


167
00:11:44,137 --> 00:11:48,876 line:-2
让我们的视图了解
在SwiftUI中是否有动画


168
00:11:50,811 --> 00:11:54,348 line:-2
Representable
情境可在视图、


169
00:11:54,414 --> 00:11:57,518 line:-1
视图控制器以及界面控制器中使用


170
00:11:59,620 --> 00:12:01,755 line:-1
现在让我们再看一下


171
00:12:01,822 --> 00:12:04,691 line:-2
我们之前看到过的
Representable协议图表


172
00:12:05,859 --> 00:12:09,830 line:-1
在Make和Update方法中


173
00:12:10,230 --> 00:12:12,099 line:-2
我们为Representable
情境传递了一个参数


174
00:12:13,100 --> 00:12:18,238 line:-2
这个情境已经拥有关于environment
和transaction的信息


175
00:12:19,373 --> 00:12:21,842 line:-2
然而如果你想使用
coordinator


176
00:12:22,176 --> 00:12:24,044 line:-1
你需要自己创建


177
00:12:24,745 --> 00:12:25,812 line:-1
可以通过


178
00:12:25,879 --> 00:12:28,582 line:-2
使用可选的Make Coordinator
方法实现


179
00:12:29,983 --> 00:12:31,685 line:-1
在初始化过程中


180
00:12:31,752 --> 00:12:34,388 line:-2
首先调用
Make Coordinator方法


181
00:12:34,454 --> 00:12:37,624 line:-2
然后是Make View
和Update View方法


182
00:12:38,091 --> 00:12:40,661 line:-1
从而当你配置你的视图时


183
00:12:40,994 --> 00:12:43,864 line:-2
coordinator
在情境中可用


184
00:12:45,899 --> 00:12:48,569 line:-1
通过例子来理解这些概念


185
00:12:48,635 --> 00:12:50,170 line:-1
可能容易得多


186
00:12:51,538 --> 00:12:53,907 line:-1
我们再看一下我们的植物app


187
00:12:54,241 --> 00:12:56,844 line:-1
这是我们刚才看到过的详情视图


188
00:12:57,845 --> 00:13:00,147 line:-1
它是在SwiftUI中创建的视图


189
00:13:01,682 --> 00:13:05,485 line:-2
我还在UIKit中
创建了另一个视图


190
00:13:06,086 --> 00:13:07,855 line:-1
用于呈现评级


191
00:13:08,822 --> 00:13:09,823 line:-1
我想要做的就是


192
00:13:10,224 --> 00:13:15,629 line:-2
在我的SwiftUI视图中嵌入
基于UIKit的评级控件


193
00:13:17,364 --> 00:13:22,169 line:-2
除此之外 我还想在
SwiftUI中添加一个标签


194
00:13:22,236 --> 00:13:25,172 line:-1
可以从我的评级控件中读取评级


195
00:13:26,673 --> 00:13:31,378 line:-2
这些全部都可以通过
UIViewRepresentable协议实现


196
00:13:32,145 --> 00:13:34,281 line:-1
让我们在演示中实现这些功能


197
00:13:34,348 --> 00:13:36,950 line:-2
（关于在SwiftUI中
嵌入UIKit视图的演示）


198
00:13:39,419 --> 00:13:43,056 line:-2
在这个项目中 我包含了一个
UIKitRatingsControl


199
00:13:43,490 --> 00:13:47,327 line:-2
它是基于UIKit的视图
渲染那些五星


200
00:13:47,895 --> 00:13:51,598 line:-2
它就是我们要在SwiftUI中
呈现的视图


201
00:13:53,367 --> 00:13:58,772 line:-2
RatingsControlRepresentation
其实是UIKit视图的包装器


202
00:13:59,106 --> 00:14:02,943 line:-2
它可以让我们在SwiftUI中
呈现我们的UI视图


203
00:14:04,478 --> 00:14:07,080 line:-2
我们还为UIViewRepresentable协议
添加了两个必需方法


204
00:14:07,347 --> 00:14:12,252 line:-2
即makeUIView
和updateUIView


205
00:14:14,087 --> 00:14:15,923 line:-1
在makeUIView方法中


206
00:14:16,456 --> 00:14:20,761 line:-2
我所要做的就是
创建我的UI视图的一个实例


207
00:14:21,094 --> 00:14:24,665 line:-2
也就是这里的
UIKitRatingsControl并返回它


208
00:14:25,799 --> 00:14:26,934 line:-1
通过这个代码


209
00:14:27,000 --> 00:14:30,270 line:-1
我可以开始在SwiftUI中


210
00:14:30,337 --> 00:14:31,839 line:-1
使用RatingsControlRepresentation了


211
00:14:32,539 --> 00:14:34,408 line:-1
让我们看看预览


212
00:14:37,878 --> 00:14:40,614 line:-2
这些星星的显示
通过在SwiftUI中


213
00:14:40,681 --> 00:14:43,817 line:-2
调用RatingsControlRepresentation
实现的


214
00:14:43,884 --> 00:14:47,154 line:-2
这反过来呈现了
基于UIKit的视图


215
00:14:48,222 --> 00:14:51,525 line:-2
然而请注意
所有星星都是灰色的


216
00:14:52,426 --> 00:14:55,229 line:-1
要根据评级正确设置突显


217
00:14:55,729 --> 00:14:58,465 line:-2
我们需要从SwiftUI中
读取这个评级


218
00:14:58,732 --> 00:15:01,001 line:-2
并把它设置到
我们的UIKit视图上


219
00:15:02,669 --> 00:15:06,373 line:-2
在我们的代码中
我们已经为评级添加了一个捆绑


220
00:15:06,440 --> 00:15:08,942 line:-2
因此我们可以
从SwiftUI中读取它


221
00:15:10,477 --> 00:15:13,514 line:-2
现在让我们进入
updateUIView方法


222
00:15:14,047 --> 00:15:16,517 line:-1
并在UI视图上设置评级


223
00:15:20,821 --> 00:15:24,491 line:-2
星星将立即按照我们所预期的那样
进行突显


224
00:15:25,559 --> 00:15:28,295 line:-2
并且这是我们从SwiftUI中
读取到的


225
00:15:31,398 --> 00:15:32,232 line:-1
谢谢


226
00:15:35,169 --> 00:15:38,205 line:-2
我们要进入实时模式查看
最后一个预览


227
00:15:38,972 --> 00:15:43,410 line:-2
在这预览中 我在SwiftUI中
包含了一个清除按钮


228
00:15:43,677 --> 00:15:45,946 line:-1
用于把评级更新为零


229
00:15:47,114 --> 00:15:48,715 line:-1
请注意当我轻触它时


230
00:15:49,216 --> 00:15:52,252 line:-2
会调用
UpdateUIView方法


231
00:15:52,319 --> 00:15:54,988 line:-1
并把评级上传到我们的UI视图上


232
00:15:55,989 --> 00:15:59,426 line:-1
我们还可以轻触星星修改评级


233
00:16:00,727 --> 00:16:02,763 line:-1
当我轻触这些星星时


234
00:16:03,263 --> 00:16:06,667 line:-1
右侧的标签并没有进行适当的更新


235
00:16:07,968 --> 00:16:14,374 line:-2
原因是我们的UI视图对于评级
是固有值


236
00:16:14,641 --> 00:16:17,911 line:-2
并且不会把固有值
传回到SwiftUI


237
00:16:18,912 --> 00:16:20,180 line:-1
为了解决这个问题


238
00:16:20,247 --> 00:16:23,183 line:-1
我们要使用目标动作模式


239
00:16:23,817 --> 00:16:26,019 line:-1
让我们继续并实施它


240
00:16:27,621 --> 00:16:31,525 line:-2
要使用目标动作模式
我们需要添加一个协调器


241
00:16:32,125 --> 00:16:33,927 line:-1
让我们在这里创建一个协调器


242
00:16:34,828 --> 00:16:36,730 line:-1
这只是个NSObject


243
00:16:37,564 --> 00:16:41,602 line:-1
是我们存储我们所感兴趣的值的地方


244
00:16:42,302 --> 00:16:46,073 line:-2
并且我们有一个初始化工具
用于设置我们所关心的值


245
00:16:46,406 --> 00:16:47,875 line:-1
就是这里的评级


246
00:16:49,142 --> 00:16:54,147 line:-2
接下来我们给评级添加了一个叫做
ratingChanged选择器


247
00:16:54,715 --> 00:16:58,418 line:-1
我们通过目标动作模式调用它


248
00:16:58,852 --> 00:17:02,489 line:-1
在这里我们仅仅把协调器的评级


249
00:17:02,756 --> 00:17:05,492 line:-2
设置为我们从UI视图中
所获取的评级


250
00:17:06,993 --> 00:17:09,930 line:-2
现在我们可以实施
makeCoordinator方法了


251
00:17:10,998 --> 00:17:12,165 line:-1
在这个方法中


252
00:17:12,432 --> 00:17:15,636 line:-1
我们仅仅是返回协调器的一个实例


253
00:17:15,969 --> 00:17:20,273 line:-2
并且我们从RatingsControl
Representation中传递评级捆绑


254
00:17:23,242 --> 00:17:27,781 line:-2
最后我们可以在makeUIView方法中
使用这个协调器


255
00:17:28,682 --> 00:17:30,050 line:-1
并添加目标


256
00:17:31,652 --> 00:17:32,486 line:-1
这样


257
00:17:32,553 --> 00:17:35,322 line:-2
无论何时当在UIKit中 触发
valueChanged事件时


258
00:17:35,656 --> 00:17:39,226 line:-2
就调用协调器
ratingChanged方法


259
00:17:40,227 --> 00:17:43,096 line:-2
现在我们已经准备好
把它添加到我们的app中了


260
00:17:43,897 --> 00:17:45,866 line:-2
我要进入
PlantDetailsView


261
00:17:47,267 --> 00:17:49,870 line:-2
在这里调用
RatingsControlRepresentation


262
00:17:51,271 --> 00:17:55,709 line:-2
我们还可以设置一个
受UIKit支持的框架


263
00:17:56,443 --> 00:17:58,545 line:-1
让我们重新预览一下


264
00:18:01,415 --> 00:18:02,816 line:-1
我要进入实时模式


265
00:18:04,451 --> 00:18:07,154 line:-1
现在当我轻触这些星星时


266
00:18:07,688 --> 00:18:11,191 line:-2
值和文本标签如我们所期待的那样
进行了更新


267
00:18:15,896 --> 00:18:19,066 line:-2
（关于在SwiftUI中
嵌入UIKit视图的演示）


268
00:18:21,068 --> 00:18:24,371 line:-2
我们希望你对于在你的app中
使用SwiftUI感到兴奋


269
00:18:24,805 --> 00:18:25,939 line:-1
作为第一步


270
00:18:26,206 --> 00:18:28,942 line:-1
用SwiftUI内容


271
00:18:29,009 --> 00:18:30,777 line:-1
创建一些托管控制器


272
00:18:31,345 --> 00:18:36,049 line:-2
使用IBSegueActions把托管控制器
添加到你的app中非常简单


273
00:18:36,116 --> 00:18:37,417 line:-1
（试一下！）


274
00:18:37,484 --> 00:18:40,787 line:-1
如果你已经创建好


275
00:18:40,854 --> 00:18:43,190 line:-2
想要嵌入到
SwiftUI视图等级中的视图


276
00:18:43,257 --> 00:18:45,692 line:-2
你可以了解一下
Representable协议


277
00:18:46,460 --> 00:18:50,497 line:-2
最后一定要利用
Representable情境


278
00:18:50,564 --> 00:18:52,299 line:-1
实现更高级的功能


279
00:18:53,367 --> 00:18:58,305 line:-2
接下来Raleigh会讲
整合数据模型和SwiftUI


280
00:18:58,372 --> 00:19:00,007 line:-1
（与你的数据模型相整合）


281
00:19:05,345 --> 00:19:06,280 line:-1
谢谢Tanu


282
00:19:07,948 --> 00:19:09,116 line:-1
我是Raleigh Ledet


283
00:19:09,183 --> 00:19:12,085 line:-2
我既是SwiftUI
又是AppKit工程师


284
00:19:13,020 --> 00:19:17,324 line:-1
你们已经了解在你现有的app中


285
00:19:17,391 --> 00:19:18,825 line:-2
迅速添加
SwiftUI视图有多么容易


286
00:19:19,092 --> 00:19:20,827 line:-1
并且我们已经得到了数据


287
00:19:21,195 --> 00:19:24,064 line:-2
但我想讲的是如何真正把它
与你的数据整合到一起


288
00:19:25,866 --> 00:19:29,136 line:-2
你在Tanu的演示中所看到的是
我们把植物数据模型


289
00:19:29,469 --> 00:19:31,905 line:-1
传递给我们的根SwiftUI视图


290
00:19:32,873 --> 00:19:34,341 line:-1
这非常棒 因为SwiftUI视图


291
00:19:34,408 --> 00:19:36,710 line:-1
能取出适当的属性


292
00:19:36,777 --> 00:19:37,945 line:-1
并且我们能对这些属性进行渲染


293
00:19:38,712 --> 00:19:41,882 line:-1
然而这更应该叫做单次操作


294
00:19:41,949 --> 00:19:42,850 line:-1
（静态数据）


295
00:19:43,283 --> 00:19:46,753 line:-1
因为我们的数据模型是存在于


296
00:19:46,820 --> 00:19:48,522 line:-1
SwiftUI框架之外


297
00:19:48,589 --> 00:19:49,823 line:-1
（动态数据）


298
00:19:49,890 --> 00:19:52,359 line:-2
这意味着如果我们的数据模型
发生任何变更


299
00:19:52,426 --> 00:19:54,528 line:-2
也许是云发生变更
或甚至是用户发生变更


300
00:19:54,995 --> 00:19:56,463 line:-1
SwiftUI将不了解这些变更


301
00:19:56,864 --> 00:19:59,266 line:-2
并且它也不会对我们的数据内容
进行重新渲染


302
00:20:01,001 --> 00:20:02,102 line:-1
我们的方案是


303
00:20:02,803 --> 00:20:05,372 line:-2
BindableObject
数据模型


304
00:20:06,006 --> 00:20:07,674 line:-1
它是一个非常简单的协议


305
00:20:07,741 --> 00:20:11,278 line:-2
你所要做的就是公开发布一个
didChange发布器


306
00:20:14,548 --> 00:20:17,251 line:-2
一旦你实施了
didChange属性


307
00:20:17,317 --> 00:20:19,953 line:-2
你就在SwiftUI视图中遵守了
BindableObject协议


308
00:20:20,587 --> 00:20:25,692 line:-2
就是我们之前引用数据模型的那个
SwiftUI视图


309
00:20:25,759 --> 00:20:29,196 line:-2
现在我们可以使用
@ObjectBinding包装器


310
00:20:30,464 --> 00:20:34,334 line:-2
它告诉SwiftUI我们正引用
BindableObject


311
00:20:34,635 --> 00:20:37,237 line:-2
然后它就知道它可以为这个视图订阅
BindableObject


312
00:20:37,905 --> 00:20:39,606 line:-1
现在无论何时当你的数据发生变更时


313
00:20:40,007 --> 00:20:44,144 line:-2
didChange发布器
都会给它所有的订阅者


314
00:20:44,211 --> 00:20:46,046 line:-1
发布有数据发生了变更


315
00:20:46,113 --> 00:20:48,949 line:-2
当然 其中一个订阅者
是SwiftUI


316
00:20:49,416 --> 00:20:51,218 line:-1
现在SwiftUI自动了解


317
00:20:51,285 --> 00:20:53,520 line:-1
哪个视图正在引用你的数据模型


318
00:20:53,587 --> 00:20:54,821 line:-1
并需要更新


319
00:20:55,989 --> 00:20:56,823 line:-1
此外


320
00:20:58,258 --> 00:21:00,961 line:-1
我们可以使用$加数据


321
00:21:01,395 --> 00:21:03,497 line:-1
并可以对数据模型


322
00:21:04,231 --> 00:21:05,432 line:-1
使用捆绑


323
00:21:05,499 --> 00:21:08,235 line:-1
这将使我们拥有直接重写


324
00:21:08,569 --> 00:21:09,870 line:-1
数据模型的权限


325
00:21:11,538 --> 00:21:14,508 line:-2
因此现在 无论何时当我们做修改时
也许是修改文本字段


326
00:21:14,575 --> 00:21:17,077 line:-2
这些修改都将直接
在我们的数据模型中进行更新


327
00:21:18,879 --> 00:21:19,847 line:-1
因此正如你所看到的


328
00:21:20,347 --> 00:21:22,850 line:-2
BindableObecject
协议非常简单


329
00:21:22,916 --> 00:21:25,018 line:-1
再一次 你只需要实施一个属性


330
00:21:25,686 --> 00:21:27,254 line:-1
并且它有很高的灵活性


331
00:21:27,988 --> 00:21:30,490 line:-1
它可以使许多发布器


332
00:21:30,557 --> 00:21:34,261 line:-2
与你正在使用的
任何一种通知系统一起


333
00:21:34,528 --> 00:21:36,697 line:-1
记录在你的数据模型中所发生的变更


334
00:21:37,865 --> 00:21:39,633 line:-1
并且这里的关键点是我们想确保


335
00:21:39,700 --> 00:21:42,202 line:-1
你的数据模型在你的app中


336
00:21:42,269 --> 00:21:43,804 line:-1
保持数据的单一数据来源


337
00:21:45,205 --> 00:21:47,174 line:-1
这在SwiftUI中非常重要


338
00:21:48,075 --> 00:21:51,545 line:-2
我们总是希望你的数据模型
或你在SwiftUI中的任意状态


339
00:21:51,612 --> 00:21:53,413 line:-1
都只有单一的事实来源


340
00:21:54,481 --> 00:21:57,351 line:-1
与声明性视图等级一起


341
00:21:57,417 --> 00:21:59,920 line:-1
就不再需要给同步数据


342
00:22:00,187 --> 00:22:01,588 line:-1
写入视图控制器了


343
00:22:05,492 --> 00:22:06,860 line:-1
现在让我们在演示中看一下


344
00:22:08,629 --> 00:22:11,798 line:-2
Tanu过来找我的时候
她告诉了我关于植物的想法


345
00:22:12,266 --> 00:22:13,634 line:-1
我非常激动


346
00:22:14,401 --> 00:22:16,403 line:-1
并且我想参与并提供一些帮助


347
00:22:16,470 --> 00:22:18,939 line:-1
我想从写Mac版app开始


348
00:22:20,407 --> 00:22:22,709 line:-2
因此我们就开始写app
她做iOS版


349
00:22:23,277 --> 00:22:25,646 line:-1
我做Mac版


350
00:22:26,146 --> 00:22:27,481 line:-1
然后我们达到了相同的目标


351
00:22:27,915 --> 00:22:29,516 line:-1
当我们看到SwiftUI时


352
00:22:30,150 --> 00:22:31,385 line:-1
我们感到惊叹万分


353
00:22:31,451 --> 00:22:34,254 line:-2
因为我们可以使用
SwiftUI快速前进


354
00:22:34,788 --> 00:22:36,023 line:-1
并写我们的详情视图


355
00:22:40,093 --> 00:22:41,295 line:-1
那么在这里我们正在


356
00:22:42,062 --> 00:22:44,765 line:-2
运行同一个app
只不过现在是在Mac上


357
00:22:46,099 --> 00:22:49,136 line:-2
那么在这里
左侧有NSTableView


358
00:22:49,203 --> 00:22:51,672 line:-1
右侧有同样的详情视图


359
00:22:54,041 --> 00:22:55,175 line:-1
但现在我们想再进一步


360
00:22:55,242 --> 00:22:57,311 line:-2
把它真正与我们的数据模型
整合到一起


361
00:22:57,377 --> 00:22:59,780 line:-1
从而我们可以修改我们的详情视图


362
00:22:59,847 --> 00:23:01,915 line:-1
并变更反映到我们的数据模型中


363
00:23:03,050 --> 00:23:04,117 line:-1
这是我们的数据模型


364
00:23:04,618 --> 00:23:06,587 line:-2
你可以看到
它是个非常简单的数据模型


365
00:23:11,191 --> 00:23:13,760 line:-1
我们所拥有的就是一些植物


366
00:23:14,127 --> 00:23:16,797 line:-1
嗯 我特别想指出一点


367
00:23:18,332 --> 00:23:19,833 line:-1
无论何时当植物发生变更时


368
00:23:19,900 --> 00:23:22,836 line:-2
我们都会发布一个
PlantsDidChange通知


369
00:23:23,437 --> 00:23:25,639 line:-2
我们这样做是为了
让视图控制器中的表视图


370
00:23:25,973 --> 00:23:29,743 line:-2
可以监听变更
并在表视图中重新加载数据


371
00:23:30,344 --> 00:23:33,614 line:-1
但因为我们已经发布了一个通知


372
00:23:33,680 --> 00:23:38,619 line:-2
我们要使用那个通知来实施
didChange BindableOBject


373
00:23:41,388 --> 00:23:42,990 line:-2
那么这是我们对
didChange的实施


374
00:23:43,056 --> 00:23:46,527 line:-2
我们对PlantsDidChange使用了
NotificationCenter发布器


375
00:23:46,593 --> 00:23:49,129 line:-2
我们使用self作为
我们想要监看的对象


376
00:23:49,830 --> 00:23:52,199 line:-1
现在我想指出另外一点


377
00:23:53,600 --> 00:23:56,503 line:-1
对数据的修改需要通知


378
00:23:56,970 --> 00:24:00,007 line:-2
主线程上的SwiftUI
需要进行修改


379
00:24:00,073 --> 00:24:03,477 line:-2
因此我们用receive(on)
操作器以确保


380
00:24:03,544 --> 00:24:05,312 line:-2
我们的发布器向主线程上
所有的订阅者发布通知


381
00:24:06,847 --> 00:24:10,450 line:-2
现在我们的数据模型已经准备好了
我们可以转向详情视图了


382
00:24:11,118 --> 00:24:13,253 line:-1
在这里你可以看到我们引用了


383
00:24:13,320 --> 00:24:14,521 line:-2
我们的
PlantsDataModel


384
00:24:15,489 --> 00:24:16,957 line:-1
现在我们可以添加


385
00:24:21,962 --> 00:24:23,297 line:-2
我们的
ObjectBinding了


386
00:24:25,866 --> 00:24:28,202 line:-2
现在我们正在使用
ObjectBinding包装


387
00:24:28,268 --> 00:24:30,904 line:-1
我们要向下进入…


388
00:24:30,971 --> 00:24:34,107 line:-2
我们在isEditing状态上现有视图
但我们目前使用的是EmptyView


389
00:24:35,876 --> 00:24:38,212 line:-1
我已经在EditablePlantsView中写好了


390
00:24:38,278 --> 00:24:41,315 line:-2
我想指出的是
在这里我们使用了$前缀


391
00:24:41,381 --> 00:24:44,585 line:-2
从而我们可以对指定植物索引
进行绑定


392
00:24:46,620 --> 00:24:48,155 line:-1
现在我们要重新运行app


393
00:24:51,592 --> 00:24:55,128 line:-2
现在通过那个简单的修改
app运行起来跟以前一样


394
00:24:55,195 --> 00:24:59,233 line:-2
当我们点击编辑按钮时
我们现在可以编辑各种属性了


395
00:24:59,299 --> 00:25:01,502 line:-1
你可以看到立即更新了表视图


396
00:25:01,568 --> 00:25:05,005 line:-2
我非常喜欢夏威夷木槿
我要把它评为五星


397
00:25:05,072 --> 00:25:07,875 line:-2
那么现在我们已经直接
在我们的数据模型中更新了数据


398
00:25:07,941 --> 00:25:10,410 line:-1
我们随时可以重新回到数据模型中


399
00:25:17,584 --> 00:25:19,119 line:-1
（关于与我们的数据相整合的演示）


400
00:25:22,389 --> 00:25:26,126 line:-2
如你在那个演示中所见 我使用了
NotificationCenter


401
00:25:26,193 --> 00:25:28,695 line:-2
因此我只需要使用NotificationCenter
发布器即可


402
00:25:29,296 --> 00:25:31,265 line:-1
但我们还有其它类型的发布器


403
00:25:31,765 --> 00:25:34,334 line:-1
比如关键值观察发布器


404
00:25:36,537 --> 00:25:41,275 line:-2
遵守KVO的任何对象都有一个
关键值观察发布器


405
00:25:41,341 --> 00:25:44,111 line:-1
你可以通过对关键值函数


406
00:25:44,178 --> 00:25:45,612 line:-1
使用发布器来获取它


407
00:25:46,547 --> 00:25:49,149 line:-1
但让我们再看一个更有意思的例子


408
00:25:50,350 --> 00:25:53,654 line:-1
在这个例子中 我们有一个类用于


409
00:25:53,954 --> 00:25:56,456 line:-2
在用户默认中监看
用户默认所发生的变更


410
00:25:58,825 --> 00:26:00,294 line:-1
有意思的是


411
00:26:01,061 --> 00:26:03,497 line:-2
我们给每个用户默认都创建了一个
发布器


412
00:26:03,564 --> 00:26:06,166 line:-2
一个用于userOption1
一个用于userOption2


413
00:26:06,700 --> 00:26:09,870 line:-1
但我们把它们合并到了一个发布器中


414
00:26:11,438 --> 00:26:13,807 line:-2
并应用到我们的
didChange属性


415
00:26:15,175 --> 00:26:16,109 line:-1
因此现在


416
00:26:16,176 --> 00:26:20,013 line:-2
无论当userOption1或
userOption2发生变更时


417
00:26:21,014 --> 00:26:25,519 line:-2
didChange合并发布器
都将在SwiftUI发布修改


418
00:26:25,586 --> 00:26:27,721 line:-2
并且SwiftUI将更新
我们的视图


419
00:26:29,022 --> 00:26:30,157 line:-1
（合并）


420
00:26:30,224 --> 00:26:33,060 line:-1
所有发布器都经由合并框架


421
00:26:33,126 --> 00:26:35,529 line:-2
并且那还有更多发布器
你可以查看它们


422
00:26:35,596 --> 00:26:38,198 line:-1
并且合并框架是一个很强大的新框架


423
00:26:38,265 --> 00:26:41,869 line:-2
它是一个统一的声明性API
用于随时间处理值


424
00:26:41,935 --> 00:26:44,171 line:-1
（合并）


425
00:26:44,238 --> 00:26:47,341 line:-1
除了你在合并操作器看到的发布器


426
00:26:47,407 --> 00:26:48,809 line:-1
还有大量不同的操作器


427
00:26:48,876 --> 00:26:53,180 line:-2
执行复杂的合并或把不同的发布器
打包到一起


428
00:26:54,314 --> 00:26:57,484 line:-2
我强烈建议你观看
在实践中合并演讲


429
00:26:58,785 --> 00:27:03,557 line:-1
然而我想指出另一个指定发布器


430
00:27:03,924 --> 00:27:05,392 line:-1
即PassthroughSubject


431
00:27:06,660 --> 00:27:09,196 line:-1
如果你的数据模型遇到这样一种情况


432
00:27:09,263 --> 00:27:12,165 line:-1
合并框架中没有任何一个发布器


433
00:27:12,599 --> 00:27:15,002 line:-1
适用于你的情况


434
00:27:15,669 --> 00:27:19,106 line:-2
你可以使用PassthroughSubject
就像我在核心数据示例中所做的那样


435
00:27:20,007 --> 00:27:21,542 line:-1
如果你有一个核心数据app


436
00:27:21,975 --> 00:27:25,112 line:-2
那么你就已经在使用
NSFetchedResultsController


437
00:27:25,179 --> 00:27:27,681 line:-1
来从数据库中取出数据了


438
00:27:28,649 --> 00:27:32,186 line:-2
并且NSFetchedResultsController
允许你提供一个委托


439
00:27:32,252 --> 00:27:33,287 line:-1
以帮助协调


440
00:27:34,254 --> 00:27:37,457 line:-1
你需要实施的其中一个委托消息是


441
00:27:37,925 --> 00:27:40,727 line:-1
controllerDidChangeContent


442
00:27:41,395 --> 00:27:44,031 line:-2
当数据库中的数据发生变更时
它会告诉你


443
00:27:44,097 --> 00:27:46,800 line:-2
当数据发生变更时
我们需要让SwiftUI知道


444
00:27:47,334 --> 00:27:51,038 line:-2
因此我们抓取我们的didChange
PassthroughSubject发布器


445
00:27:51,405 --> 00:27:53,640 line:-1
我们要告诉它手动发送变更


446
00:27:53,707 --> 00:27:56,543 line:-2
现在SwiftUI把它看作是
其中一个订阅者


447
00:27:56,610 --> 00:27:58,745 line:-1
并更新你的全部视图


448
00:27:59,713 --> 00:28:01,248 line:-1
（处理数据流的工具）


449
00:28:01,315 --> 00:28:03,684 line:-2
我主要讲
BindableObject


450
00:28:04,451 --> 00:28:06,753 line:-1
但还有许多工具可以帮助你管理


451
00:28:06,820 --> 00:28:08,922 line:-1
SwiftUI之内和之外的数据


452
00:28:09,423 --> 00:28:14,061 line:-2
SwiftUI中的数据流
是一场很棒的演讲


453
00:28:14,394 --> 00:28:15,395 line:-1
非常具体地讲了所有的数据工具


454
00:28:15,729 --> 00:28:19,233 line:-2
同时讨论了何时使用
哪种类型的工具合适


455
00:28:20,801 --> 00:28:22,803 line:-1
（与系统相整合）


456
00:28:22,870 --> 00:28:23,737 line:-1
现在当然了


457
00:28:24,505 --> 00:28:26,540 line:-1
当你运行SwiftUI界面时


458
00:28:26,607 --> 00:28:28,141 line:-1
你并不是只需要思考


459
00:28:28,208 --> 00:28:30,210 line:-1
与你的数据模型相整合


460
00:28:30,544 --> 00:28:33,280 line:-2
你还需要思考
与系统中其余的东西相整合


461
00:28:33,347 --> 00:28:37,818 line:-2
与iOS和macOS的拖放相整合
与tvOS相整合


462
00:28:38,952 --> 00:28:41,989 line:-2
以及也许是与watchOS上的
数码表冠相整合


463
00:28:44,791 --> 00:28:47,461 line:-1
让我们从item提供器开始讲


464
00:28:48,428 --> 00:28:50,430 line:-1
item提供器是一个强大的技术


465
00:28:50,497 --> 00:28:52,399 line:-1
由基础框架提供


466
00:28:52,733 --> 00:28:55,903 line:-1
为你提供一种围绕你的app


467
00:28:55,969 --> 00:28:57,237 line:-1
以不同形式移动数据的方法


468
00:28:57,304 --> 00:29:01,842 line:-2
它还是用于帮助在各进程间
转移数据的工具


469
00:29:03,343 --> 00:29:07,514 line:-2
从大体上说item提供器
是通用类型识别器的一个集合


470
00:29:07,581 --> 00:29:11,485 line:-2
描述你的item可以表示为
哪种类型的数据


471
00:29:11,752 --> 00:29:15,489 line:-2
当然了 你需要按照请求
为那个类型提供数据


472
00:29:16,723 --> 00:29:19,960 line:-1
请记住 之前在演示中我指出


473
00:29:20,027 --> 00:29:22,963 line:-1
我们需要在主线程上修改数据


474
00:29:23,030 --> 00:29:24,932 line:-1
而item提供器是异步的


475
00:29:25,832 --> 00:29:27,668 line:-2
因此当你让数据
形成item提供器时


476
00:29:27,734 --> 00:29:29,770 line:-1
你需要确保你实际上修改了数据


477
00:29:29,837 --> 00:29:31,805 line:-1
或让发布器在主线程上进行发布


478
00:29:33,774 --> 00:29:35,809 line:-1
我们使用item提供器和拖放


479
00:29:36,343 --> 00:29:41,882 line:-2
因此你可以使用onDrag修改器
把视图作为拖拽源


480
00:29:42,282 --> 00:29:44,384 line:-2
那么现在当用户开始在你的视图上
进行拖拽时


481
00:29:44,451 --> 00:29:47,354 line:-2
我们将调用闭包 然后你就可以
提供一个item提供器


482
00:29:47,654 --> 00:29:48,488 line:-1
它会


483
00:29:49,056 --> 00:29:51,191 line:-1
提供与那个视图相关联的数据


484
00:29:51,258 --> 00:29:54,127 line:-1
然后我们会自动渲染你的视图


485
00:29:54,194 --> 00:29:55,863 line:-1
并把它用作DragImage


486
00:29:55,929 --> 00:29:56,997 line:-1
（拖放）


487
00:29:57,064 --> 00:30:00,501 line:-2
要接受一个释放
你可以使用onDrop修改器


488
00:30:01,268 --> 00:30:02,836 line:-1
通过onDrop修改器


489
00:30:03,403 --> 00:30:07,474 line:-2
你可以传递一些
通用类型识别器字符串


490
00:30:07,908 --> 00:30:10,577 line:-2
这个字符串描述你可以在你的视图上
接受的任意一种数据


491
00:30:11,478 --> 00:30:12,613 line:-1
如果用户在你的视图上释放


492
00:30:13,680 --> 00:30:15,182 line:-1
那种类型的数据


493
00:30:15,249 --> 00:30:18,085 line:-1
我们将自动调用你的动作闭包


494
00:30:18,151 --> 00:30:21,622 line:-2
并提供一些
可形成那个类型的item提供器


495
00:30:22,489 --> 00:30:23,924 line:-1
当然我们还将告诉你


496
00:30:23,991 --> 00:30:26,894 line:-2
在你的视图中
发生释放操作的准确位置


497
00:30:27,895 --> 00:30:31,031 line:-1
onDrop修改器还有另一个变量


498
00:30:31,098 --> 00:30:34,468 line:-2
它获取的是委托闭包
而不是释放闭包


499
00:30:34,935 --> 00:30:37,237 line:-1
并且当释放在你的视图中四处移动时


500
00:30:37,304 --> 00:30:40,007 line:-2
委托为你提供关于释放过程的
更大的可见度


501
00:30:40,073 --> 00:30:42,009 line:-1
比如你可以在用户实际释放


502
00:30:42,075 --> 00:30:46,013 line:-1
并实施释放动作之前获得游标的位置


503
00:30:48,448 --> 00:30:50,884 line:-2
我们还在pasteboard中
使用item提供器


504
00:30:51,952 --> 00:30:52,819 line:-1
因此比如说如果你想接受


505
00:30:53,387 --> 00:30:57,224 line:-2
一个粘贴命令 你可以使用
onPaste命令修改器


506
00:30:58,492 --> 00:31:00,928 line:-1
类似于onDrop修改器


507
00:31:00,994 --> 00:31:04,331 line:-1
你提供一些通用类型识别器


508
00:31:04,398 --> 00:31:05,332 line:-1
然后就可以接受粘贴了


509
00:31:05,699 --> 00:31:07,234 line:-1
当用户在你的视图上进行粘贴时


510
00:31:07,301 --> 00:31:09,870 line:-1
我们将提供一些item提供器


511
00:31:10,537 --> 00:31:11,705 line:-1
然而我想指出一些


512
00:31:12,372 --> 00:31:16,043 line:-2
使onPaste与onDrop
完全不同的东西


513
00:31:17,477 --> 00:31:20,614 line:-1
第一个是


514
00:31:20,681 --> 00:31:21,548 line:-1
闭包中没有位置参数


515
00:31:21,915 --> 00:31:23,951 line:-1
这对于这里所发生的操作至关重要


516
00:31:24,952 --> 00:31:26,720 line:-1
当你拖放时


517
00:31:26,787 --> 00:31:30,991 line:-1
用户直接通过游标或触摸位置标定


518
00:31:31,058 --> 00:31:32,659 line:-1
应该接受释放的视图


519
00:31:34,127 --> 00:31:35,929 line:-1
但粘贴命令更间接一些


520
00:31:36,296 --> 00:31:38,932 line:-1
用户要么选择从菜单中粘贴


521
00:31:38,999 --> 00:31:41,535 line:-1
或也许是使用键盘捷径


522
00:31:41,602 --> 00:31:43,904 line:-1
或使用iOS中的新手势


523
00:31:46,773 --> 00:31:49,510 line:-1
我们了解


524
00:31:49,576 --> 00:31:52,779 line:-2
粘贴命令即将在哪个视图上执行的
方式是通过焦点系统


525
00:31:53,580 --> 00:31:56,783 line:-1
焦点系统是一个很重要的工具


526
00:31:57,251 --> 00:32:01,088 line:-1
它是用户用于导航不同的UI元素


527
00:32:01,154 --> 00:32:02,456 line:-1
并通知我们没有特别指向的动作


528
00:32:03,290 --> 00:32:06,093 line:-1
应该发生在哪里


529
00:32:08,028 --> 00:32:12,533 line:-2
它在Mac上很有用
当然是对键盘输入


530
00:32:12,599 --> 00:32:15,169 line:-1
和菜单动作命令 在iOS中


531
00:32:15,802 --> 00:32:17,604 line:-1
是对键盘命令


532
00:32:17,671 --> 00:32:22,709 line:-2
此外还有复制-粘贴和撤销-重做
这两组新手势


533
00:32:22,776 --> 00:32:25,112 line:-1
（焦点）


534
00:32:25,179 --> 00:32:29,082 line:-1
在tvOS上尤其重要


535
00:32:29,149 --> 00:32:30,284 line:-1
在这里焦点是我们如何决定


536
00:32:30,350 --> 00:32:35,255 line:-2
用户想在哪里实施
SiriRemote按钮动作


537
00:32:36,657 --> 00:32:40,994 line:-2
对于watchOS 我们使用焦点
来决定向哪里发送表冠事件


538
00:32:44,364 --> 00:32:45,232 line:-1
它的运作方式是


539
00:32:45,799 --> 00:32:48,101 line:-1
在某一时刻你拥有视图等级


540
00:32:48,836 --> 00:32:51,371 line:-1
其中一个视图将被作为焦点视图


541
00:32:52,005 --> 00:32:54,374 line:-1
当用户实施间接动作时


542
00:32:54,441 --> 00:32:56,210 line:-1
比如旋转表冠


543
00:32:56,977 --> 00:32:59,413 line:-1
我们会检查焦点视图是否


544
00:33:00,180 --> 00:33:02,649 line:-1
有针对那种命令的视图修改器


545
00:33:02,716 --> 00:33:04,384 line:-1
在这个例子中是表冠命令


546
00:33:04,852 --> 00:33:07,721 line:-1
如果它有 我们会调用适当的闭包


547
00:33:08,188 --> 00:33:12,726 line:-1
如果它没有 我们会沿原型向上


548
00:33:12,793 --> 00:33:13,627 line:-2
尝试找到一个拥有表冠命令的
原型视图


549
00:33:14,261 --> 00:33:17,598 line:-1
并调用适当的闭包


550
00:33:19,333 --> 00:33:23,203 line:-1
SwiftUI将在每个平台上


551
00:33:23,637 --> 00:33:25,038 line:-1
恰当地处理


552
00:33:25,873 --> 00:33:27,608 line:-1
从一个视图到另一个视图的移动焦点


553
00:33:28,842 --> 00:33:31,478 line:-2
你所需要做的唯一一件事就是
让我们知道


554
00:33:31,545 --> 00:33:34,414 line:-2
哪个SwiftUI视图
会成为焦点视图


555
00:33:34,481 --> 00:33:36,517 line:-2
你可以通过focususable
修改器实现


556
00:33:37,551 --> 00:33:41,555 line:-1
除了leaf控件 比如文本字段


557
00:33:44,124 --> 00:33:44,958 line:-1
SwiftUI视图


558
00:33:45,692 --> 00:33:47,094 line:-1
默认不会成为焦点视图


559
00:33:47,160 --> 00:33:48,829 line:-2
因此你需要使用
focususable修改器


560
00:33:48,896 --> 00:33:51,832 line:-2
和Passthrough告诉我们
这个视图可以成为焦点视图


561
00:33:52,766 --> 00:33:56,003 line:-2
你可以视需要传递一个
可供我们调用的闭包


562
00:33:56,069 --> 00:33:58,605 line:-2
当你的视图得到或失去焦点时
我们通过调用它来通知你


563
00:33:58,672 --> 00:34:01,341 line:-1
你可以使用这个来更新你的UI


564
00:34:01,975 --> 00:34:04,611 line:-1
从而为用户提供视觉反馈通知他们


565
00:34:05,546 --> 00:34:06,613 line:-1
（命令）


566
00:34:06,680 --> 00:34:09,917 line:-2
我们有许多命令 如onExit
和onPLayPause


567
00:34:09,983 --> 00:34:13,920 line:-2
这些例子来自于tvOS
当使用Siri Remote时


568
00:34:14,621 --> 00:34:16,790 line:-1
但我现在要讲的是


569
00:34:16,857 --> 00:34:19,159 line:-1
通用的onCommand修改器


570
00:34:19,760 --> 00:34:24,164 line:-1
这是你用于指示动作的工具


571
00:34:24,231 --> 00:34:27,701 line:-2
从Objective-C-style
动作选择器


572
00:34:27,768 --> 00:34:30,737 line:-1
比如说从菜单传送到第一个响应器


573
00:34:30,804 --> 00:34:34,440 line:-2
或从工具栏按钮
同样地被传送到第一个响应器


574
00:34:34,507 --> 00:34:37,911 line:-1
再一次 这是它在iOS上的用法


575
00:34:39,279 --> 00:34:40,179 line:-1
并且它们是可链接的


576
00:34:40,246 --> 00:34:41,514 line:-1
因此假如说如果你的视图可以接受


577
00:34:42,149 --> 00:34:44,251 line:-1
三个菜单项


578
00:34:44,318 --> 00:34:46,652 line:-2
你还可以给你的视图附加三个
onCommand修改器


579
00:34:46,719 --> 00:34:49,690 line:-1
每个都有适当的选择器


580
00:34:50,958 --> 00:34:52,492 line:-1
（撤销和重做）


581
00:34:52,559 --> 00:34:54,393 line:-1
现在我知道你们的app


582
00:34:54,460 --> 00:34:57,130 line:-2
全都已经有很强大的
撤销和重做支持了


583
00:34:57,998 --> 00:34:58,899 line:-1
在SwiftUI中


584
00:34:58,966 --> 00:35:01,802 line:-2
我们所用的UndoManager
与你们已经在使用的一样


585
00:35:03,537 --> 00:35:04,371 line:-1
并且


586
00:35:04,771 --> 00:35:07,608 line:-1
在绝大部分情况下 当你向app中


587
00:35:08,041 --> 00:35:08,876 line:-1
添加新SwiftUI时


588
00:35:08,942 --> 00:35:12,279 line:-2
你不需在UndoManager中
执行任何新操作


589
00:35:12,346 --> 00:35:15,282 line:-1
特别是当你的撤销注册


590
00:35:15,349 --> 00:35:17,818 line:-1
在较低层上接近数据模型时执行时


591
00:35:18,952 --> 00:35:19,920 line:-1
然而


592
00:35:19,987 --> 00:35:22,189 line:-2
如果你需要使用
UndoManager


593
00:35:22,523 --> 00:35:25,792 line:-2
你可以通过environment
属性包装器获取


594
00:35:26,126 --> 00:35:27,828 line:-2
通过UndoManager
密钥路径


595
00:35:31,632 --> 00:35:33,033 line:-1
（Objective-C整合）


596
00:35:33,100 --> 00:35:36,203 line:-2
现在SwiftUI很明显是一个
基于Swift的API


597
00:35:38,005 --> 00:35:41,074 line:-2
但我们知道你已经拥有大量
Objective-C代码了


598
00:35:41,608 --> 00:35:43,076 line:-2
Swift中的
Objective-C


599
00:35:43,143 --> 00:35:46,046 line:-1
已经可以很好地整合到一起了


600
00:35:47,014 --> 00:35:50,417 line:-2
同样地 你也可以用SwiftUI
处理Objective-C代码


601
00:35:51,518 --> 00:35:54,454 line:-2
适用标准的
Objective-C/Swift整合规则


602
00:35:55,155 --> 00:35:58,525 line:-2
基本上 当涉及
SwiftUI时那意味着


603
00:35:58,592 --> 00:36:00,627 line:-2
你需要包装Swift中的
托管控制器


604
00:36:00,694 --> 00:36:02,930 line:-1
或托管视图


605
00:36:04,431 --> 00:36:07,334 line:-2
在这个例子中
我们要包装一个托管控制器


606
00:36:07,601 --> 00:36:10,337 line:-2
我要给UIViewController
做一个子类


607
00:36:10,604 --> 00:36:14,007 line:-2
我把它放在
Objective-C属性中


608
00:36:14,074 --> 00:36:17,544 line:-2
这会允许我稍后在
Objective-C实施文件内


609
00:36:17,611 --> 00:36:19,880 line:-1
实例化这些Swift类


610
00:36:21,515 --> 00:36:23,784 line:-1
现在 在我们的Swift实施内


611
00:36:23,851 --> 00:36:27,321 line:-2
我们可以实例化
UIHostingController


612
00:36:27,387 --> 00:36:29,723 line:-2
并把它传到适当的
SwiftUI RootView中


613
00:36:31,758 --> 00:36:34,761 line:-2
现在我们有
UIViewController


614
00:36:34,828 --> 00:36:37,164 line:-2
我们可以从Objective-C
实施文件中使用它


615
00:36:37,231 --> 00:36:39,199 line:-2
就像其它任何
UIViewController


616
00:36:39,266 --> 00:36:40,934 line:-1
在这个例子中 我们只是呈现了它


617
00:36:43,704 --> 00:36:46,240 line:-1
类似地 你也需要包装你的数据模型


618
00:36:47,508 --> 00:36:50,744 line:-2
那样我们就可以实施
BindabelObject协议


619
00:36:51,745 --> 00:36:53,680 line:-2
那么这里我们有个简单的
Swift类


620
00:36:54,348 --> 00:36:55,282 line:-1
我们要


621
00:36:56,016 --> 00:37:00,754 line:-2
通过这里的NotificationCenter
发布器实施BindableObject协议


622
00:37:00,821 --> 00:37:01,688 line:-1
这是个例子


623
00:37:01,755 --> 00:37:05,292 line:-2
让我们假设ObjCDataModel
已经发布了


624
00:37:05,559 --> 00:37:07,861 line:-1
NotificationCenter通知


625
00:37:08,629 --> 00:37:12,766 line:-2
那么我们只需要把它引用到
ObjCDataModel即可


626
00:37:13,700 --> 00:37:14,902 line:-1
它的运作方式是


627
00:37:16,370 --> 00:37:18,071 line:-1
在WrappedHostingController中


628
00:37:18,138 --> 00:37:21,241 line:-2
你要给ObjCDataModel传递一个
指示器


629
00:37:21,308 --> 00:37:24,178 line:-2
在你的托管控制器中 你可以创建
WrappedDataModel


630
00:37:24,645 --> 00:37:29,016 line:-2
并把它分配为你的ObjCDataModel
并把你的WrappedDataModel


631
00:37:29,283 --> 00:37:31,051 line:-2
传递到你的
SwiftUI rootView


632
00:37:31,919 --> 00:37:34,955 line:-1
仅通过这两个简单包装的类


633
00:37:35,789 --> 00:37:38,158 line:-1
你现在已经可以把SwiftUI


634
00:37:38,425 --> 00:37:39,693 line:-2
和Objective-C代码
无缝整合到一起了


635
00:37:42,029 --> 00:37:42,896 line:-1
因此正如你所看到的


636
00:37:43,363 --> 00:37:47,201 line:-2
开始在你的app中
使用SwiftUI 非常简单


637
00:37:47,501 --> 00:37:48,702 line:-1
当你添加新UI时


638
00:37:49,636 --> 00:37:50,971 line:-1
请开始使用SwiftUI


639
00:37:53,874 --> 00:37:57,377 line:-1
我们明天上午11点有一场讨论会


640
00:37:57,744 --> 00:38:00,214 line:-2
在你的app中
尝试使用SwiftUI


641
00:38:00,547 --> 00:38:03,016 line:-2
如果你有任何疑问
请参加我们的讨论会


642
00:38:03,083 --> 00:38:04,551 line:-1
我们非常高兴能与你们沟通


643
00:38:04,618 --> 00:38:05,853 line:-1
我们对SwiftUI感到非常激动


644
00:38:05,919 --> 00:38:07,821 line:-2
我们已经迫不及待要看到你们
能用它做出什么样的app


645
00:38:08,522 --> 00:38:10,557 line:-1
谢谢大家 请享受余下的会议时光

