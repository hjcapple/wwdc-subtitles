1
00:00:00,506 --> 00:00:04,516
[音乐]


2
00:00:05,516 --> 00:00:07,546
[掌声]


3
00:00:08,045 --> 00:00:10,456
>> 大家好 欢迎大家来到 


4
00:00:10,456 --> 00:00:11,786
《Advances in Networking》的第二部分


5
00:00:12,356 --> 00:00:13,686
如果你没有来听第一部分


6
00:00:13,686 --> 00:00:17,046
应该很快就能在 App 和网页上看到视频


7
00:00:18,486 --> 00:00:20,456
我叫 Eric Kinnear 来自网络技术部


8
00:00:20,706 --> 00:00:21,866
一会将加入讲演的是


9
00:00:21,866 --> 00:00:23,506
我的同事 Tommy 和 Stuart


10
00:00:23,986 --> 00:00:26,746
我们会介绍很多东西


11
00:00:27,226 --> 00:00:28,336
首先 我们会介绍 


12
00:00:28,336 --> 00:00:31,466
如何更加充分地利用 Bonjour 搜索


13
00:00:32,235 --> 00:00:35,236
我们会介绍 如何通过搭建框架协议


14
00:00:35,236 --> 00:00:37,726
高效简便得传递消息


15
00:00:38,406 --> 00:00:39,556
我们会看一些新的 


16
00:00:39,726 --> 00:00:41,126
升级的指标收集


17
00:00:41,356 --> 00:00:42,746
最后我们会介绍一些


18
00:00:42,746 --> 00:00:44,286
状态更新和一些操作


19
00:00:44,286 --> 00:00:47,986
让你的 App 实现最佳联网性能


20
00:00:49,476 --> 00:00:51,246
开始之前 我要提醒大家


21
00:00:52,646 --> 00:00:54,506
如果你在用 URLSession


22
00:00:54,506 --> 00:00:55,876
和 Network.framework


23
00:00:55,876 --> 00:00:56,786
你可以充分利用


24
00:00:56,876 --> 00:00:58,166
我们今天讲的一切东西


25
00:00:59,116 --> 00:01:00,826
如果你还没有用


26
00:01:00,826 --> 00:01:02,146
这就是为什么


27
00:01:02,146 --> 00:01:05,525
你应该改用更现代的网络 API


28
00:01:05,786 --> 00:01:09,876
我们直接从 Bonjour 搜索开始


29
00:01:09,986 --> 00:01:11,666
Bonjour 能在网络上


30
00:01:11,666 --> 00:01:13,256
发布和发现服务


31
00:01:13,656 --> 00:01:15,666
每当你用隔空打印  


32
00:01:15,666 --> 00:01:17,886
连接隔空播放设备


33
00:01:17,886 --> 00:01:19,906
用 HomeKit 让你的家自动化时


34
00:01:19,906 --> 00:01:21,356
你都需要 Bonjour


35
00:01:21,776 --> 00:01:23,356
每次你在连接时


36
00:01:23,356 --> 00:01:24,726
却无需输入 IP 地址或主机名时


37
00:01:24,726 --> 00:01:26,946
你都在用 Bonjour


38
00:01:27,766 --> 00:01:29,306
如你所知 Bonjour 


39
00:01:29,306 --> 00:01:30,976
在所有的 Apple 平台上都可用


40
00:01:31,546 --> 00:01:36,226
它在 Linux Android Chrome OS 上同样可用


41
00:01:36,226 --> 00:01:37,566
Chromecast 就是用它发现设备的


42
00:01:38,486 --> 00:01:39,886
你可能不知道 


43
00:01:39,886 --> 00:01:41,476
早在 2015 年


44
00:01:41,476 --> 00:01:43,346
微软也悄悄将 Bonjour 支持


45
00:01:43,346 --> 00:01:44,426
添加到 Windows 10


46
00:01:45,316 --> 00:01:47,216
从那时起 Bonjour 的实施就已经成熟


47
00:01:48,066 --> 00:01:49,416
这就意味着 Bonjour 


48
00:01:49,416 --> 00:01:51,456
现在在各大主平台均可用


49
00:01:53,876 --> 00:01:55,866
今天 我们将分享一些


50
00:01:55,866 --> 00:01:57,196
这个领域的最新进展


51
00:01:57,706 --> 00:01:59,416
有时 你在一个网络


52
00:02:00,006 --> 00:02:03,016
想要发现另一个网络上的设备


53
00:02:03,606 --> 00:02:04,996
比如说你有一台设备 


54
00:02:04,996 --> 00:02:06,226
想要连接到


55
00:02:06,726 --> 00:02:08,286
另一个网络上的打印机


56
00:02:08,286 --> 00:02:09,356
二者之间有多个跳跃


57
00:02:10,196 --> 00:02:11,616
现在 如果你在局域网上


58
00:02:11,616 --> 00:02:13,286
发送多点传送数据包


59
00:02:13,286 --> 00:02:15,436
你不会得到任何回应


60
00:02:16,606 --> 00:02:18,386
Discovery Proxy 解决这个问题


61
00:02:19,356 --> 00:02:22,486
现在你可以发送单点传送数据包到 Discovery Proxy


62
00:02:22,956 --> 00:02:24,176
它会把多点传送数据包


63
00:02:24,176 --> 00:02:27,556
发送到目标子网络接收响应


64
00:02:27,556 --> 00:02:28,806
将结果代理给你


65
00:02:29,636 --> 00:02:30,956
现在你就可以直接连接到打印机


66
00:02:30,956 --> 00:02:32,736
看 我们已经


67
00:02:32,736 --> 00:02:34,976
收到了文件


68
00:02:35,516 --> 00:02:37,946
[掌声]


69
00:02:38,446 --> 00:02:39,756
我们很高兴地宣布


70
00:02:39,756 --> 00:02:42,776
客户端上这个的代码 


71
00:02:42,776 --> 00:02:44,846
已经在你的开发者版本里了


72
00:02:44,846 --> 00:02:47,846
服务器实施和操作指南


73
00:02:48,106 --> 00:02:49,176
都可以在 GitHub 上找到


74
00:02:49,786 --> 00:02:52,596
我们来看一下


75
00:02:52,596 --> 00:02:53,346
这对你的 App 来说意味什么


76
00:02:54,686 --> 00:02:55,956
之前比较推荐的做法是 


77
00:02:55,956 --> 00:02:57,436
当你搜索时


78
00:02:57,436 --> 00:02:59,416
你需要将域设置为 nil


79
00:03:00,166 --> 00:03:01,236
一直都是如此  


80
00:03:01,236 --> 00:03:02,836
对于几乎每一种情况


81
00:03:02,836 --> 00:03:03,986
这种做法都是正确的


82
00:03:05,096 --> 00:03:06,156
以前你不觉得


83
00:03:06,156 --> 00:03:07,596
有多大的不同


84
00:03:07,596 --> 00:03:08,546
但是现在它开始有更大的影响


85
00:03:08,546 --> 00:03:13,716
指定本地会直接阻止发现


86
00:03:13,806 --> 00:03:15,896
任何远程或者代理服务


87
00:03:16,716 --> 00:03:18,316
这也许不是你想要的结果


88
00:03:18,316 --> 00:03:19,856
所以要好好检查


89
00:03:19,856 --> 00:03:21,226
你的搜索调用是不是无意间


90
00:03:21,226 --> 00:03:22,136
指定了一个域


91
00:03:23,546 --> 00:03:25,316
当你创建 App 搜索服务时


92
00:03:25,746 --> 00:03:26,616
让我们来看一下


93
00:03:26,616 --> 00:03:27,486
Network.framework 的


94
00:03:27,486 --> 00:03:29,366
一些新功能


95
00:03:29,486 --> 00:03:31,346
它们使得 Bonjour 搜索更加简便


96
00:03:31,596 --> 00:03:32,696
尤其是在 Swift 里


97
00:03:34,226 --> 00:03:35,536
去年我们介绍了


98
00:03:35,536 --> 00:03:37,276
NWListener 和 NWConnection


99
00:03:37,516 --> 00:03:38,586
以及 Network.framework


100
00:03:39,286 --> 00:03:40,876
比如 你可以让


101
00:03:40,876 --> 00:03:42,646
NWListener 发布一个 Bonjour 服务


102
00:03:42,646 --> 00:03:45,886
你可以让 NWConnection 连接到


103
00:03:45,886 --> 00:03:46,996
Bonjour 服务端点


104
00:03:47,986 --> 00:03:49,056
但是如果想要


105
00:03:49,056 --> 00:03:50,666
发现可用服务


106
00:03:50,666 --> 00:03:52,366
你就需要其他 Bonjour 搜索 API


107
00:03:53,006 --> 00:03:54,426
一旦发现了一个


108
00:03:54,426 --> 00:03:55,616
你就需要做很多工作


109
00:03:55,616 --> 00:03:56,696
将它转换为


110
00:03:56,696 --> 00:03:57,786
一个可用于连接的端点


111
00:03:59,046 --> 00:04:00,596
今天 我们宣布


112
00:04:00,596 --> 00:04:02,246
通过 NWBrowser 对象


113
00:04:02,466 --> 00:04:03,526
Network.framework 


114
00:04:03,526 --> 00:04:04,826
自带搜索支持


115
00:04:06,016 --> 00:04:07,786
NWBrowser 可以连接


116
00:04:07,786 --> 00:04:09,416
并监听其他服务   


117
00:04:09,416 --> 00:04:11,536
覆盖整个工作流


118
00:04:11,536 --> 00:04:13,866
从发布 到发现 再到连接


119
00:04:13,866 --> 00:04:14,876
用的都是大家早已熟悉的


120
00:04:14,906 --> 00:04:15,966
Network.framework 对象 


121
00:04:19,156 --> 00:04:20,916
浏览器在 Network.framework 中   


122
00:04:20,916 --> 00:04:22,616
用现代基于调度的 API


123
00:04:23,276 --> 00:04:25,386
提供发现服务的功能


124
00:04:25,386 --> 00:04:27,176
这个 API 已经优化 


125
00:04:27,176 --> 00:04:28,686
特别适合 Swift


126
00:04:29,486 --> 00:04:30,796
它还包括可选择的


127
00:04:30,796 --> 00:04:32,596
TXT 记录支持


128
00:04:33,426 --> 00:04:34,816
如果你的 App 需要


129
00:04:34,996 --> 00:04:37,936
你可以为每个发现的端点 


130
00:04:37,936 --> 00:04:38,736
请求 TXT 记录


131
00:04:39,226 --> 00:04:42,846
让我们看一下如何使用 browser


132
00:04:43,866 --> 00:04:45,596
我们可以用你想发现的 Bonjour 服务类


133
00:04:45,596 --> 00:04:46,946
和一些 NWParameters 


134
00:04:46,946 --> 00:04:48,696
将它初始化


135
00:04:48,696 --> 00:04:50,026
你可以通过 NWParameters 告诉它


136
00:04:50,026 --> 00:04:51,016
你想如何搜索


137
00:04:51,016 --> 00:04:52,426
和你处理其他所有的 


138
00:04:52,426 --> 00:04:53,896
Network.framework 对象一样


139
00:04:54,506 --> 00:04:55,596
接着 你可以创建一个


140
00:04:55,596 --> 00:04:56,916
browseResultsChangedHandler


141
00:04:57,876 --> 00:05:00,806
它可以被调用传输已发现的


142
00:05:00,806 --> 00:05:01,546
所有可用端点的列表


143
00:05:02,306 --> 00:05:03,856
最后 就像其他


144
00:05:03,856 --> 00:05:05,206
Network.framework 对象一样


145
00:05:05,206 --> 00:05:07,866
你可以在想要接收回调的队列上


146
00:05:07,866 --> 00:05:08,956
创建你的 browser


147
00:05:09,486 --> 00:05:11,906
我们仔细来看一下


148
00:05:11,906 --> 00:05:13,026
browseResultsChangedHandler


149
00:05:13,946 --> 00:05:14,846
你有两个选择


150
00:05:15,176 --> 00:05:17,026
其一 你可以


151
00:05:17,366 --> 00:05:18,846
用一个句柄


152
00:05:18,846 --> 00:05:19,966
接收更新里


153
00:05:19,966 --> 00:05:20,786
所有变化的详单


154
00:05:21,436 --> 00:05:23,206
这与低级 API   


155
00:05:23,206 --> 00:05:24,546
非常一致


156
00:05:24,546 --> 00:05:26,066
你可以清楚地看到


157
00:05:26,276 --> 00:05:27,496
所有的变化


158
00:05:28,056 --> 00:05:29,696
端点可以被添加或移除 


159
00:05:29,696 --> 00:05:31,686
而且还可以


160
00:05:31,686 --> 00:05:32,886
改变它们的内部细节


161
00:05:33,716 --> 00:05:35,546
这些变化通过 Flag 声明


162
00:05:36,436 --> 00:05:38,076
在这种情况下  


163
00:05:38,076 --> 00:05:39,696
随着端点在其他接口上被发现


164
00:05:39,696 --> 00:05:42,586
我们会查看接口是否被添加或移除


165
00:05:43,136 --> 00:05:45,996
你也可以选择


166
00:05:45,996 --> 00:05:49,916
只用句柄查看最新的


167
00:05:49,956 --> 00:05:50,596
发现结果列表


168
00:05:51,476 --> 00:05:52,786
这么做要小心


169
00:05:52,986 --> 00:05:53,916
因为随着可用端点列表改变


170
00:05:53,916 --> 00:05:57,076
这个句柄会重复被调用


171
00:05:57,676 --> 00:05:58,516
所以确保 你更新


172
00:05:58,516 --> 00:06:01,246
App 的状态和其他东西的方式是恰当的


173
00:06:05,096 --> 00:06:06,566
我们来看一个


174
00:06:06,566 --> 00:06:07,576
正在运行的 NWBrowser 的例子


175
00:06:08,476 --> 00:06:09,976
我们准备做一个 App 


176
00:06:09,976 --> 00:06:12,126
可以在两个设备之间


177
00:06:12,126 --> 00:06:14,246
发现服务和安全连接的 App


178
00:06:15,206 --> 00:06:16,236
在我们的例子中 


179
00:06:16,236 --> 00:06:17,426
我将做一个井字游戏


180
00:06:17,856 --> 00:06:19,846
你也可以做其他很多东西


181
00:06:21,136 --> 00:06:22,516
我们会用 NWListener


182
00:06:22,516 --> 00:06:23,666
把游戏发布给周围玩家


183
00:06:23,666 --> 00:06:26,866
我们会用 NWBrowser 


184
00:06:26,866 --> 00:06:28,746
搜索附近可用游戏


185
00:06:29,036 --> 00:06:30,346
一旦用户选择一个


186
00:06:30,346 --> 00:06:31,416
他们想加入的游戏


187
00:06:31,416 --> 00:06:32,856
我们就会取其中一个搜索结果 


188
00:06:32,856 --> 00:06:34,486
传送给 NWConnection


189
00:06:34,486 --> 00:06:36,946
回连到我们的监听器


190
00:06:36,946 --> 00:06:39,976
在 Xcode 中看一下


191
00:06:47,416 --> 00:06:49,376
App 已经在这儿了


192
00:06:49,376 --> 00:06:50,476
我们已经写了一些代码


193
00:06:50,516 --> 00:06:52,716
去处理不同的视图


194
00:06:52,716 --> 00:06:54,706
为用户展示


195
00:06:54,706 --> 00:06:56,006
一系列可玩的游戏


196
00:06:56,006 --> 00:06:58,366
让他们创建游戏 诸如此类


197
00:06:58,626 --> 00:07:00,286
所以这里就只关注浏览器本身


198
00:07:00,856 --> 00:07:02,816
我已经有了一个类 PeerBrowser


199
00:07:02,886 --> 00:07:04,656
我会用这个类


200
00:07:04,656 --> 00:07:06,676
管理我的 NWBrowser 


201
00:07:06,676 --> 00:07:08,006
并且提供一个 PeerBrowserDelegate


202
00:07:08,006 --> 00:07:09,716
它也会传送发现端点的列表 


203
00:07:09,716 --> 00:07:11,406
这样 UI 就可以


204
00:07:11,406 --> 00:07:12,846
将它们展现给用户


205
00:07:14,536 --> 00:07:15,936
首先 我要把我的 NWBrowser 


206
00:07:15,936 --> 00:07:17,656
作为一个实例属性


207
00:07:17,656 --> 00:07:18,806
添加到 PeerBrowser 上 


208
00:07:21,216 --> 00:07:24,706
然后 当 PeerBrowser 被初始化时


209
00:07:24,706 --> 00:07:26,166
它会立即调用 startBrowsing


210
00:07:27,126 --> 00:07:28,666
我们要把这个填上


211
00:07:29,916 --> 00:07:31,846
首先 我要创建


212
00:07:31,846 --> 00:07:33,576
一些 NWParameters


213
00:07:33,576 --> 00:07:36,206
它们和其他 Network.framework 对象一样 


214
00:07:36,206 --> 00:07:38,126
用来描述你想如何与网络互动


215
00:07:38,716 --> 00:07:39,636
在我们的例子里


216
00:07:39,636 --> 00:07:41,146
默认 parameter 就可以


217
00:07:41,376 --> 00:07:43,046
但是要设置 includePeerToPeer 为真


218
00:07:43,046 --> 00:07:45,276
这样 即使设备


219
00:07:45,276 --> 00:07:46,926
不在同一个网络上


220
00:07:46,926 --> 00:07:49,066
我们也能发现其他可玩的游戏


221
00:07:52,576 --> 00:07:55,006
接着 我们创建 NWBrowser


222
00:07:56,236 --> 00:07:58,076
搜索服务类型 


223
00:07:58,126 --> 00:07:59,216
_tictactoe._tcp


224
00:07:59,216 --> 00:08:01,356
我们要确保 


225
00:08:01,356 --> 00:08:02,286
将域设置为 nil


226
00:08:03,616 --> 00:08:04,856
用之前创建的 parameters 


227
00:08:04,856 --> 00:08:07,296
将其存入 PeerBrowser


228
00:08:07,806 --> 00:08:10,066
接下来 我们设置一个


229
00:08:10,066 --> 00:08:11,876
stateUpdateHandler 


230
00:08:11,876 --> 00:08:12,826
就像我们处理


231
00:08:12,826 --> 00:08:14,756
其他 Network.framework 对象一样   


232
00:08:14,756 --> 00:08:15,966
用来接收浏览器状态的更新


233
00:08:15,966 --> 00:08:17,366
有无错误 运行状况如何


234
00:08:17,366 --> 00:08:18,866
诸如此类


235
00:08:20,936 --> 00:08:23,166
然后我们设置 browseResultsChangedHandler


236
00:08:24,226 --> 00:08:28,216
非常简单 我们将结果列表传送给代理


237
00:08:28,216 --> 00:08:29,776
让它呈现在 UI 中


238
00:08:29,776 --> 00:08:30,806
确保代理是这样编码的


239
00:08:30,806 --> 00:08:32,826
这样 每当发生变化时


240
00:08:32,826 --> 00:08:34,275
它就会刷新 UI 


241
00:08:34,275 --> 00:08:35,275
所以我们可以一直呈现


242
00:08:35,275 --> 00:08:37,736
发现端点的最新列表


243
00:08:41,556 --> 00:08:44,996
最后 在主队列启动浏览器


244
00:08:44,996 --> 00:08:46,276
因为想在主队列接收更新


245
00:08:46,786 --> 00:08:49,696
就是这样


246
00:08:50,236 --> 00:08:51,726
通过这样一组代码


247
00:08:51,726 --> 00:08:53,546
我们可以搭建一个 NWBrowser


248
00:08:53,546 --> 00:08:54,996
让它通过 P2P 连接


249
00:08:55,256 --> 00:08:56,376
发现附近的游戏


250
00:08:56,376 --> 00:08:58,076
并为用户展示


251
00:08:58,076 --> 00:08:59,626
一系列可玩的游戏


252
00:08:59,626 --> 00:09:00,856
让用户自己选择连接哪个


253
00:09:00,856 --> 00:09:05,466
一会我们再介绍


254
00:09:05,466 --> 00:09:07,796
监听器和连接这些代码


255
00:09:07,796 --> 00:09:08,846
这个例子的代码


256
00:09:08,846 --> 00:09:10,376
可以从网站下载


257
00:09:10,376 --> 00:09:12,266
在我们继续之前


258
00:09:12,266 --> 00:09:13,846
我想先说一件事 


259
00:09:14,786 --> 00:09:16,966
我们已经有了 NWParameters 


260
00:09:16,966 --> 00:09:18,926
可以用在监听器和连接上


261
00:09:19,506 --> 00:09:20,536
刚才我提到


262
00:09:20,536 --> 00:09:21,806
我们想确保


263
00:09:21,806 --> 00:09:23,416
设备间的连接是安全的


264
00:09:23,416 --> 00:09:24,866
没有人能看到


265
00:09:24,866 --> 00:09:26,066
我们在做什么


266
00:09:26,246 --> 00:09:28,296
更没有人能干扰我们的操作


267
00:09:29,586 --> 00:09:30,676
要实现这个目标


268
00:09:30,676 --> 00:09:31,736
我们要为 NWParameters 


269
00:09:31,736 --> 00:09:34,526
定义一个扩展


270
00:09:34,526 --> 00:09:35,666
并创建一个便利构造函数


271
00:09:36,976 --> 00:09:38,386
它将密码设为字符串


272
00:09:39,396 --> 00:09:42,836
我们会给游戏的创建人 一个密码


273
00:09:42,896 --> 00:09:45,146
让其他想加入游戏的人输入密码


274
00:09:45,146 --> 00:09:46,976
这样就生成了一个


275
00:09:46,976 --> 00:09:48,436
预共享密码


276
00:09:48,436 --> 00:09:50,346
用 TLS 确保连接安全


277
00:09:50,346 --> 00:09:53,556
要实现这个  


278
00:09:53,556 --> 00:09:55,956
我们需要在构造函数中 


279
00:09:56,336 --> 00:09:57,236
创建 TCP 和 TLS 选项


280
00:09:57,966 --> 00:09:59,666
从 TLS 开始


281
00:10:01,726 --> 00:10:03,046
我们定义了一个函数


282
00:10:03,046 --> 00:10:04,266
它创建了 TLS 选项


283
00:10:04,476 --> 00:10:06,126
密码做好了


284
00:10:06,126 --> 00:10:07,076
现在我们只是


285
00:10:07,076 --> 00:10:08,226
默认 TLS 选项


286
00:10:09,656 --> 00:10:11,786
接下来 我们用新的 CryptoKit 框架


287
00:10:11,786 --> 00:10:12,976
这个框架今年刚出的


288
00:10:12,976 --> 00:10:14,586
从那个密码中 


289
00:10:14,586 --> 00:10:20,656
生成一个验证密钥和验证码


290
00:10:20,776 --> 00:10:22,326
把那个预共享密码


291
00:10:22,326 --> 00:10:24,066
添加到设置协议选项


292
00:10:24,266 --> 00:10:25,556
还要确保添加一个


293
00:10:25,556 --> 00:10:27,186
TLS 密钥算法套件 


294
00:10:27,186 --> 00:10:28,236
用来支持预共享密码


295
00:10:28,816 --> 00:10:31,716
现在可以回到 TLS 选项


296
00:10:32,266 --> 00:10:35,836
在这儿我们可以做 TCP 选项


297
00:10:38,456 --> 00:10:40,146
大部分情况下


298
00:10:40,146 --> 00:10:41,276
我们会用默认 TCP 选项


299
00:10:41,276 --> 00:10:41,966
但是也要保证 enableKeepalive 为真


300
00:10:43,186 --> 00:10:45,026
接着我们用 


301
00:10:45,026 --> 00:10:46,276
刚才在下面创建的 TLS 选项


302
00:10:46,276 --> 00:10:47,966
和基本上是默认的 TCP 选项


303
00:10:47,966 --> 00:10:51,396
初始化 NWParameters


304
00:10:51,516 --> 00:10:52,656
最后一件要做的事是


305
00:10:52,656 --> 00:10:55,786
在这里设置 includePeerToPeer


306
00:10:55,786 --> 00:10:57,486
这样即便不在同一个网络


307
00:10:57,486 --> 00:11:00,006
我们的连接和监听器


308
00:11:00,006 --> 00:11:01,976
也可以连接到附近设备


309
00:11:02,506 --> 00:11:07,546
就是这样 我们试一下


310
00:11:07,756 --> 00:11:10,276
这里 可以看到有两台设备


311
00:11:10,586 --> 00:11:11,966
正在运行 App


312
00:11:11,966 --> 00:11:13,856
我们已经准备好 UI 创建游戏了


313
00:11:14,416 --> 00:11:17,236
浏览器已经开始搜索


314
00:11:17,236 --> 00:11:18,476
正显示 搜索游戏中


315
00:11:18,476 --> 00:11:20,266
因为我们还没找到游戏


316
00:11:21,276 --> 00:11:23,106
如果我输入名字   


317
00:11:24,376 --> 00:11:26,516
点按创建游戏 你可以看到


318
00:11:26,596 --> 00:11:28,316
我拿到了一个密码


319
00:11:28,316 --> 00:11:29,726
通过发现的端点列表


320
00:11:29,726 --> 00:11:31,396
在这里是我创建的游戏


321
00:11:31,396 --> 00:11:34,296
browseResultsChangedHandler 被调用


322
00:11:34,516 --> 00:11:35,806
我们把界面展示给用户


323
00:11:36,116 --> 00:11:36,716
就是这么简单


324
00:11:37,316 --> 00:11:41,526
如果我点按加入游戏


325
00:11:41,526 --> 00:11:45,526
就会显示输入密码


326
00:11:45,526 --> 00:11:47,386
现在我确认密码


327
00:11:47,806 --> 00:11:49,276
可以看到我们创建了


328
00:11:49,276 --> 00:11:51,166
一个预共享密码


329
00:11:51,166 --> 00:11:52,276
用它回连到监听器


330
00:11:52,746 --> 00:11:54,366
一切正常的话 页面翻转


331
00:11:54,366 --> 00:11:57,036
游戏就可以玩了 就是这样


332
00:11:58,516 --> 00:12:01,500
[掌声]


333
00:12:08,236 --> 00:12:09,756
到现在为止 


334
00:12:09,756 --> 00:12:11,426
我们已经搭建了 App 的开头


335
00:12:11,426 --> 00:12:13,646
在两个设备间建立了连接


336
00:12:14,386 --> 00:12:15,846
我们用 NWListener 


337
00:12:15,846 --> 00:12:17,276
发布一个 Bonjour 


338
00:12:17,316 --> 00:12:18,246
_tictactoe._tcp 服务


339
00:12:18,246 --> 00:12:21,856
用 NWBrowser 


340
00:12:21,856 --> 00:12:24,016
搜索可玩的游戏 展示给用户


341
00:12:24,456 --> 00:12:25,866
我们可以选取一个结果


342
00:12:25,866 --> 00:12:27,236
从浏览器返回


343
00:12:27,236 --> 00:12:29,186
直接传送给 NWConnection


344
00:12:29,186 --> 00:12:30,956
回连到监听器


345
00:12:30,996 --> 00:12:32,346
在两个设备之间


346
00:12:32,346 --> 00:12:34,546
建立一个安全的连接


347
00:12:35,596 --> 00:12:36,816
当然 为了玩游戏


348
00:12:36,816 --> 00:12:38,336
两个设备要能交流


349
00:12:38,336 --> 00:12:39,446
分享游戏状态 


350
00:12:39,686 --> 00:12:42,666
告诉彼此玩家们的操作


351
00:12:42,666 --> 00:12:44,456
诸如此类


352
00:12:45,276 --> 00:12:46,726
要演示这一点


353
00:12:46,726 --> 00:12:48,216
我想请 Tommy 上台


354
00:12:48,216 --> 00:12:50,466
带大家搭建自定义框架协议


355
00:12:51,516 --> 00:12:56,316
[掌声]


356
00:12:56,816 --> 00:12:57,556
>> 好的


357
00:12:57,556 --> 00:12:58,786
谢谢你 Eric


358
00:12:59,796 --> 00:13:01,416
今天 我想给大家分享 


359
00:13:01,466 --> 00:13:04,006
一些新的方法


360
00:13:04,006 --> 00:13:05,846
可以用你写的


361
00:13:05,846 --> 00:13:08,786
自定义协议框架代码


362
00:13:08,786 --> 00:13:10,776
来扩展网络连接  


363
00:13:10,776 --> 00:13:12,916
它和网络栈的


364
00:13:12,916 --> 00:13:13,956
其他协议一样


365
00:13:13,956 --> 00:13:15,706
在同一线程上运行


366
00:13:16,116 --> 00:13:17,806
所以 要做完 Eric 


367
00:13:17,806 --> 00:13:19,666
开始做的那个游戏


368
00:13:19,666 --> 00:13:21,236
我们需要为两个游戏定义一个 


369
00:13:21,236 --> 00:13:23,236
互相发送指令的方法


370
00:13:23,856 --> 00:13:24,966
当一个玩家要操作时


371
00:13:24,966 --> 00:13:27,066
他需要给另一端发送消息


372
00:13:28,206 --> 00:13:30,386
这时我们就需要一个协议


373
00:13:30,966 --> 00:13:33,546
我们的协议


374
00:13:33,546 --> 00:13:34,276
看起来是这样的


375
00:13:34,836 --> 00:13:37,686
它是个简单的 类-长度-值


376
00:13:37,686 --> 00:13:38,996
也就是 TLV 协议


377
00:13:40,016 --> 00:13:42,196
类型占用 4 字节


378
00:13:42,196 --> 00:13:44,156
可能意味着走一步棋


379
00:13:44,936 --> 00:13:47,116
玩家想要把一个给定符号


380
00:13:47,116 --> 00:13:49,716
放在我们井字盘的给定位置


381
00:13:50,296 --> 00:13:52,796
长度也占用 4 字节


382
00:13:52,796 --> 00:13:54,626
声明其他消息


383
00:13:55,166 --> 00:13:58,726
然后是消息体


384
00:13:59,086 --> 00:14:00,326
在我们的例子中


385
00:14:00,436 --> 00:14:03,696
它可能是把猴子脸放在第 1 行第 2 列


386
00:14:04,506 --> 00:14:05,456
然后它会在 TLS 字节流上


387
00:14:05,456 --> 00:14:07,546
像这样重复


388
00:14:10,196 --> 00:14:11,706
你可能已经发现 


389
00:14:11,956 --> 00:14:13,906
尽管我们是在 


390
00:14:13,906 --> 00:14:15,736
TLS 字节流上运行的


391
00:14:15,736 --> 00:14:17,456
这个字节流本身没有被结构化


392
00:14:17,456 --> 00:14:20,946
但它在使用结构化消息


393
00:14:21,556 --> 00:14:25,026
App 并不是 以字节流的方式思考


394
00:14:25,026 --> 00:14:27,506
而是通过清晰的消息


395
00:14:28,696 --> 00:14:29,976
几乎所有的联网 App


396
00:14:29,976 --> 00:14:31,616
都会这么做


397
00:14:32,806 --> 00:14:34,666
它们有一个 Header 或 Body


398
00:14:34,666 --> 00:14:37,246
或分隔符


399
00:14:37,666 --> 00:14:40,336
用来定义消息的界限


400
00:14:41,756 --> 00:14:45,446
但是 传统通讯网络 API


401
00:14:45,446 --> 00:14:47,266
比如套接字


402
00:14:47,536 --> 00:14:49,986
读取连接上的消息


403
00:14:49,986 --> 00:14:52,336
并不简单


404
00:14:52,536 --> 00:14:53,586
你要在 App 中


405
00:14:53,586 --> 00:14:54,236
亲自做这件事


406
00:14:55,166 --> 00:14:57,436
在看这个问题之前  


407
00:14:57,466 --> 00:14:59,646
我们先来看一下


408
00:14:59,646 --> 00:15:03,526
你的 App 和其他网络栈的关系


409
00:15:03,666 --> 00:15:06,006
上面是你的 App


410
00:15:07,186 --> 00:15:08,746
它通过 API


411
00:15:08,746 --> 00:15:10,586
和网络栈交流


412
00:15:11,806 --> 00:15:13,846
所以在 Network.framework 里


413
00:15:14,366 --> 00:15:18,086
TLS 和 TCP 都在 App 的


414
00:15:18,086 --> 00:15:20,936
同一共享线程里运行


415
00:15:21,346 --> 00:15:22,486
这就是我们去年介绍的


416
00:15:22,486 --> 00:15:24,706
用户空间网络栈


417
00:15:25,786 --> 00:15:27,896
让我们近距离看一下


418
00:15:27,896 --> 00:15:30,266
当 App 在一个字节流上方时


419
00:15:30,266 --> 00:15:33,196
是如何读取信息的


420
00:15:33,376 --> 00:15:34,916
如果我们有一个协议


421
00:15:34,916 --> 00:15:36,146
和刚才井字游戏一样的协议


422
00:15:36,146 --> 00:15:39,086
那你可能有一个固定长度的 Header


423
00:15:39,796 --> 00:15:41,056
这里你可以简单地


424
00:15:41,056 --> 00:15:44,186
准确读取 Header 的长度


425
00:15:45,246 --> 00:15:46,336
收到 8 个字节


426
00:15:47,236 --> 00:15:48,286
所以是固定长度


427
00:15:48,286 --> 00:15:49,266
你知道会发生什么


428
00:15:49,796 --> 00:15:51,456
当你读取完整长度时


429
00:15:51,456 --> 00:15:52,716
栈会回调你 


430
00:15:53,396 --> 00:15:55,156
这就让你可以确定


431
00:15:55,156 --> 00:15:56,436
剩余消息的长度


432
00:15:56,786 --> 00:15:58,776
你可以准确读取


433
00:15:58,776 --> 00:16:00,216
然后读取 Header-Body-Header-Body


434
00:16:00,216 --> 00:16:03,296
如此循环往复


435
00:16:03,826 --> 00:16:07,796
这很棒


436
00:16:07,796 --> 00:16:08,966
但是你可能已经注意到


437
00:16:08,966 --> 00:16:10,816
我们要循环多次 


438
00:16:10,816 --> 00:16:13,226
每条消息至少循环两次


439
00:16:13,776 --> 00:16:15,356
如果你的协议更复杂


440
00:16:15,356 --> 00:16:16,896
如果是一个


441
00:16:16,896 --> 00:16:18,936
可变长度 Header 


442
00:16:18,936 --> 00:16:20,576
或者如果是分隔符 


443
00:16:20,576 --> 00:16:22,226
这甚至会变得更没效率


444
00:16:22,726 --> 00:16:23,876
尽管对于你的 App 来说


445
00:16:23,876 --> 00:16:25,786
写这个逻辑很简单


446
00:16:27,056 --> 00:16:28,716
如果你特别重视效率


447
00:16:28,716 --> 00:16:30,206
你有另一个选择


448
00:16:30,836 --> 00:16:33,436
你可以一次接收很多内容


449
00:16:34,176 --> 00:16:35,936
但是现在


450
00:16:35,936 --> 00:16:36,906
你有其他几个问题要处理


451
00:16:37,766 --> 00:16:39,506
首次 你要解决


452
00:16:39,506 --> 00:16:40,716
没能在一个数据块里


453
00:16:40,716 --> 00:16:42,396
接收一条完整消息


454
00:16:43,226 --> 00:16:44,476
或者你在一口气


455
00:16:44,476 --> 00:16:46,856
接收了几条消息


456
00:16:46,856 --> 00:16:48,976
或者你只接收了 Header 的一部分


457
00:16:48,976 --> 00:16:51,936
或者你只有长度域的两三个字节


458
00:16:51,936 --> 00:16:53,186
你需要保存


459
00:16:53,186 --> 00:16:55,796
重建域 然后重新解析出来


460
00:16:56,926 --> 00:16:58,876
要做到完全正确


461
00:16:58,876 --> 00:17:00,356
处理好每一种可能的特殊情况


462
00:17:00,356 --> 00:17:02,776
是非常困难的


463
00:17:03,186 --> 00:17:04,486
情况通常是这样的


464
00:17:04,486 --> 00:17:06,256
一些小的 Bug


465
00:17:06,256 --> 00:17:07,656
只有在用户使用 App 的时候


466
00:17:07,656 --> 00:17:08,685
才会显现出来


467
00:17:10,756 --> 00:17:14,106
好 情况看起来有些不妙


468
00:17:14,506 --> 00:17:16,695
如何才能两全呢


469
00:17:16,695 --> 00:17:18,786
如果能够既保证高效


470
00:17:18,786 --> 00:17:21,425
又保证代码简单


471
00:17:21,425 --> 00:17:23,256
易于验证和组合呢


472
00:17:24,056 --> 00:17:25,915
我很高兴能分享给大家一个消息


473
00:17:25,915 --> 00:17:28,215
现在 在 iOS 13 和 macOS Catalina


474
00:17:28,215 --> 00:17:29,986
你可以自己写


475
00:17:29,986 --> 00:17:32,226
在同一网络线程上运行的


476
00:17:32,756 --> 00:17:35,986
协议代码 来解决这个问题


477
00:17:36,376 --> 00:17:38,116
所以如果你要在


478
00:17:38,116 --> 00:17:39,916
通信网络 API 里定义消息


479
00:17:39,916 --> 00:17:41,446
这个方法 


480
00:17:41,446 --> 00:17:43,796
让这件事变得


481
00:17:43,796 --> 00:17:44,976
前所未有得简单


482
00:17:44,976 --> 00:17:45,706
[掌声]


483
00:17:45,706 --> 00:17:51,386
谢谢 你要在 NWConnection 里


484
00:17:51,386 --> 00:17:52,926
做这些事情


485
00:17:53,086 --> 00:17:54,546
对于上方的 App 来说


486
00:17:54,546 --> 00:17:56,126
你好像只是


487
00:17:56,126 --> 00:17:57,596
在基本连接上


488
00:17:57,596 --> 00:17:59,206
读写数据包一样


489
00:18:00,736 --> 00:18:02,356
现在我们来看一下


490
00:18:03,066 --> 00:18:04,116
这里依旧是 App 


491
00:18:04,166 --> 00:18:05,686
依旧在发送和接收


492
00:18:05,816 --> 00:18:07,456
但是现在你的框架代码


493
00:18:07,456 --> 00:18:09,556
正运行在


494
00:18:09,556 --> 00:18:11,736
和 TLS 和 TCP 相同的线程中


495
00:18:12,216 --> 00:18:13,146
所以现在你可以调用


496
00:18:13,886 --> 00:18:14,846
receiveMessage


497
00:18:15,226 --> 00:18:16,596
当你有一个


498
00:18:16,596 --> 00:18:17,626
App 可以处理的


499
00:18:17,976 --> 00:18:19,346
完整消息时


500
00:18:19,346 --> 00:18:20,966
它会准确地得到一个回调


501
00:18:21,596 --> 00:18:22,976
你可以多次重复这个过程


502
00:18:23,266 --> 00:18:25,466
每个消息一个调用


503
00:18:25,466 --> 00:18:27,246
调试就变得非常简单


504
00:18:27,246 --> 00:18:28,386
很容易就知道发生了什么


505
00:18:28,926 --> 00:18:31,696
所以 这很棒


506
00:18:31,866 --> 00:18:33,966
现在你可能会问


507
00:18:33,966 --> 00:18:35,916
这个框架协议


508
00:18:35,916 --> 00:18:38,796
可以真正实现些什么


509
00:18:38,796 --> 00:18:39,746
有什么限制


510
00:18:39,856 --> 00:18:42,076
好消息是 基本上所有


511
00:18:42,276 --> 00:18:43,786
数据包和编码 App 数据


512
00:18:43,786 --> 00:18:45,976
去传输数据的


513
00:18:45,976 --> 00:18:47,636
都可以被写为


514
00:18:48,176 --> 00:18:50,466
框架协议


515
00:18:51,146 --> 00:18:53,146
如果你进行一次握手   


516
00:18:53,146 --> 00:18:54,916
或者如果你想在连接上


517
00:18:55,026 --> 00:18:56,736
实现 KeepAlive 连接


518
00:18:56,736 --> 00:18:58,886
你甚至可以发送


519
00:18:59,076 --> 00:19:00,336
和 App 数据不对应的 


520
00:19:00,376 --> 00:19:01,606
自己的消息


521
00:19:02,156 --> 00:19:04,436
你在这里实现的协议


522
00:19:04,436 --> 00:19:09,026
可以是标准 IETF 官方协议


523
00:19:09,616 --> 00:19:12,016
也可以是为你的 App 自定义的


524
00:19:12,066 --> 00:19:13,326
我们接下来就会给井字游戏


525
00:19:13,326 --> 00:19:14,226
做一个自定义的协议


526
00:19:15,096 --> 00:19:16,456
如果你想搭建一个协议


527
00:19:16,456 --> 00:19:17,776
需要两步


528
00:19:18,446 --> 00:19:21,116
首先 实现一条可重复使用的代码


529
00:19:21,116 --> 00:19:23,286
定义你的消息框架


530
00:19:23,836 --> 00:19:24,796
这是协议


531
00:19:25,716 --> 00:19:28,486
然后把这个协议


532
00:19:28,886 --> 00:19:30,776
添加到连接协议栈


533
00:19:30,776 --> 00:19:34,366
你就可以用它建立连接


534
00:19:34,366 --> 00:19:36,626
发送和接收消息


535
00:19:37,176 --> 00:19:40,786
好了 进入第一步


536
00:19:41,016 --> 00:19:41,596
我们开始实现


537
00:19:41,696 --> 00:19:43,446
框架协议


538
00:19:44,786 --> 00:19:47,096
你要做的是 创建一个类


539
00:19:47,096 --> 00:19:48,926
让它遵循


540
00:19:48,926 --> 00:19:51,066
ProtocolFramerImplementation


541
00:19:51,896 --> 00:19:54,166
你可以在这个类里做很多事情


542
00:19:55,136 --> 00:19:56,886
但是要记住 


543
00:19:56,886 --> 00:19:58,216
最重要的两件事是


544
00:19:58,216 --> 00:20:00,456
handleOutput 发送消息


545
00:20:00,786 --> 00:20:02,956
和 handleInput 解析消息


546
00:20:03,516 --> 00:20:04,926
如果你可以做到这两件事


547
00:20:05,256 --> 00:20:06,546
太好了 它就是一个 Framer 了


548
00:20:07,736 --> 00:20:08,806
让我们看一下代码


549
00:20:09,506 --> 00:20:11,636
这是协议


550
00:20:12,266 --> 00:20:13,486
它要遵循


551
00:20:13,486 --> 00:20:15,276
ProtocolFramerImplementation


552
00:20:16,526 --> 00:20:21,346
我推荐你先创建一个定义对象


553
00:20:21,446 --> 00:20:23,476
这是你协议的句柄


554
00:20:23,476 --> 00:20:25,046
你可以在整个 App 的其他部分


555
00:20:25,366 --> 00:20:26,476
使用这个句柄


556
00:20:27,096 --> 00:20:28,826
它指的是


557
00:20:28,826 --> 00:20:30,166
你可以添加到连接的协议


558
00:20:30,626 --> 00:20:34,106
接下来你可以处理很多的


559
00:20:34,106 --> 00:20:36,156
基本回调事件


560
00:20:36,626 --> 00:20:39,226
这里最重要的是 start


561
00:20:39,576 --> 00:20:41,576
每当协议载入到连接时 


562
00:20:41,576 --> 00:20:43,436
start 都会被调用 


563
00:20:43,436 --> 00:20:46,286
用来发起连接


564
00:20:47,036 --> 00:20:48,706
如果你想做一个握手


565
00:20:48,706 --> 00:20:49,806
和另一端交换什么东西


566
00:20:49,806 --> 00:20:51,726
你可以在这里实现


567
00:20:52,626 --> 00:20:54,636
如果你的协议很简单  


568
00:20:54,636 --> 00:20:55,916
像我们的井字游戏一样


569
00:20:56,016 --> 00:20:57,386
不需要设置


570
00:20:57,726 --> 00:20:59,636
只需立刻标记连接就绪


571
00:21:00,896 --> 00:21:02,806
一旦你做了这个


572
00:21:02,806 --> 00:21:05,356
现在你需要 handleOutput 和 handleInput


573
00:21:05,686 --> 00:21:06,796
我们深入来看一下


574
00:21:09,196 --> 00:21:11,666
handleOutput 看起来这样


575
00:21:12,416 --> 00:21:13,316
每当 App 发送消息时 


576
00:21:13,316 --> 00:21:16,036
你就会被


577
00:21:16,036 --> 00:21:17,966
handleOutput 调用


578
00:21:18,546 --> 00:21:19,906
如果你需要的话


579
00:21:19,906 --> 00:21:22,116
你会收到消息元数据


580
00:21:22,116 --> 00:21:25,036
还有一些自定义值


581
00:21:25,036 --> 00:21:26,106
以及 App 正尝试发送的


582
00:21:26,106 --> 00:21:27,356
消息长度


583
00:21:27,986 --> 00:21:31,016
所以 如果你有一个


584
00:21:31,016 --> 00:21:32,626
Header-Body 协议 就像我们刚才用的


585
00:21:33,686 --> 00:21:35,886
你可以先创建 Header 结构


586
00:21:35,886 --> 00:21:38,666
试着序列化一些数据


587
00:21:39,686 --> 00:21:41,266
所以这会包括类型


588
00:21:41,846 --> 00:21:42,836
也许是从消息元数据中


589
00:21:42,836 --> 00:21:44,666
得到的类型


590
00:21:44,666 --> 00:21:47,166
还有传送给你


591
00:21:47,166 --> 00:21:48,036
到 handleOutput 的长度


592
00:21:48,476 --> 00:21:51,086
你可以组合这些数据


593
00:21:51,086 --> 00:21:52,466
然后调用 writeOutput


594
00:21:52,896 --> 00:21:54,656
writeOutput 会将字节


595
00:21:54,656 --> 00:21:56,506
排列到输出流


596
00:21:56,876 --> 00:22:00,706
但是实际上它们还没有发出去


597
00:22:00,986 --> 00:22:03,086
然后你需要写主体


598
00:22:03,226 --> 00:22:04,876
在这个例子中 


599
00:22:04,876 --> 00:22:06,916
我们完全不需要转存 App 数据


600
00:22:07,316 --> 00:22:09,876
我们可以只调用 writeOutputNoCopy


601
00:22:11,086 --> 00:22:13,236
它让我们直接


602
00:22:13,236 --> 00:22:15,686
将 App 字节排列到输出流


603
00:22:16,496 --> 00:22:17,476
当我们从 handleOutput 返回时


604
00:22:17,476 --> 00:22:20,116
所有的字节都会被


605
00:22:20,166 --> 00:22:21,536
发送出去连接


606
00:22:22,016 --> 00:22:25,636
好了 我们接着处理输入


607
00:22:26,416 --> 00:22:28,606
处理输入和处理输出类似


608
00:22:28,606 --> 00:22:29,806
但是略微复杂


609
00:22:30,856 --> 00:22:36,806
每当你的 App 接收到连接上的新字节时


610
00:22:36,806 --> 00:22:37,896
你会被 handleInput 调用


611
00:22:38,506 --> 00:22:40,346
如果你做的是 


612
00:22:40,496 --> 00:22:42,956
Header-Body 类型协议 你有两件事要做


613
00:22:42,956 --> 00:22:45,206
你需要解析 Header


614
00:22:45,206 --> 00:22:46,306
然后你需要解析 Body


615
00:22:46,966 --> 00:22:48,756
我们先解析 Header


616
00:22:49,376 --> 00:22:50,986
这儿 我们的协议有一个


617
00:22:50,986 --> 00:22:52,036
固定长度的 Header


618
00:22:52,036 --> 00:22:53,726
正好是 8 个字节


619
00:22:54,216 --> 00:22:55,526
我们做的是


620
00:22:55,606 --> 00:22:57,436
调用 parseInput 开始检查


621
00:22:57,436 --> 00:22:59,486
已经进入连接的字节流


622
00:23:00,406 --> 00:23:03,556
我们可以用最小和最大 8 字节调用它


623
00:23:03,586 --> 00:23:05,026
因为我们希望准确查看


624
00:23:05,026 --> 00:23:05,826
8 字节 Header


625
00:23:06,456 --> 00:23:09,076
如果成功了


626
00:23:09,076 --> 00:23:10,796
你会在组块里被调用


627
00:23:10,796 --> 00:23:12,066
你能看到真正的缓冲字节


628
00:23:12,066 --> 00:23:13,826
解析你的值


629
00:23:13,826 --> 00:23:15,796
如果需要的话 


630
00:23:15,796 --> 00:23:17,576
将它们存到本地变量


631
00:23:18,156 --> 00:23:20,706
解析输入的返回值


632
00:23:21,416 --> 00:23:22,786
表示你想用多少字节 


633
00:23:22,786 --> 00:23:25,086
增量输入光标 


634
00:23:25,186 --> 00:23:27,846
我处理完了这 8 个字节


635
00:23:27,916 --> 00:23:29,046
我们不需要再看到它们了


636
00:23:29,046 --> 00:23:30,896
不需要将它们传送给 App


637
00:23:31,306 --> 00:23:34,936
继续 现在你可以处理


638
00:23:34,936 --> 00:23:36,986
不是所有的 8 个字节


639
00:23:36,986 --> 00:23:37,806
都可用的情况


640
00:23:38,296 --> 00:23:41,346
在这种情况下 


641
00:23:41,416 --> 00:23:43,416
parseInput 函数会失效


642
00:23:43,506 --> 00:23:45,936
你只需等待更多字节可用


643
00:23:46,726 --> 00:23:48,616
handleInput 的返回值表明


644
00:23:48,616 --> 00:23:52,786
要有足够的字节数量


645
00:23:52,786 --> 00:23:54,546
然后你才能做更多工作


646
00:23:54,976 --> 00:23:56,476
所以在这个例子中


647
00:23:56,476 --> 00:23:57,796
我们是在告诉连接 


648
00:23:57,796 --> 00:23:59,496
在你再次唤醒我之前


649
00:23:59,496 --> 00:24:01,376
确保有 8 个字节


650
00:24:01,556 --> 00:24:06,706
如果你能成功读出 Header


651
00:24:06,706 --> 00:24:09,426
你可以创建一个消息对象


652
00:24:09,426 --> 00:24:10,276
可以和数据一起


653
00:24:10,276 --> 00:24:11,826
传送给 App


654
00:24:12,456 --> 00:24:14,796
这让你可以放入任何


655
00:24:14,796 --> 00:24:16,846
你想要发送到 App 的


656
00:24:16,896 --> 00:24:19,326
自定义值 类型 或其他指针


657
00:24:19,936 --> 00:24:23,766
最后 在这种情况下


658
00:24:23,766 --> 00:24:25,326
你可以调用 deliverInput 


659
00:24:25,326 --> 00:24:27,506
或者 deliverInputNoCopy 


660
00:24:28,096 --> 00:24:29,866
这可以让你将


661
00:24:29,866 --> 00:24:31,656
下一段确定范围的字节


662
00:24:31,656 --> 00:24:32,916
标记为应该


663
00:24:32,916 --> 00:24:35,186
直接传送给 App 的 App 数据


664
00:24:35,736 --> 00:24:39,086
它返回 Boolean 值


665
00:24:39,086 --> 00:24:41,446
去显示是不是 


666
00:24:41,446 --> 00:24:43,006
所有的字节都是可用的 


667
00:24:43,136 --> 00:24:45,296
是否成功发送


668
00:24:45,296 --> 00:24:46,656
连接需不需要再等


669
00:24:47,096 --> 00:24:48,766
所以如果你需要的话


670
00:24:48,766 --> 00:24:50,116
你真的可以


671
00:24:50,116 --> 00:24:51,506
传送输入消息


672
00:24:51,506 --> 00:24:53,476
兆甚至千兆字节长


673
00:24:53,476 --> 00:24:54,866
那些字节作为信息的一部分 


674
00:24:54,866 --> 00:24:56,336
会持续流出


675
00:24:56,336 --> 00:24:57,426
你无需等待所有的字节都可用


676
00:24:57,426 --> 00:24:59,956
或者亲自处理这些


677
00:25:02,466 --> 00:25:04,676
我知道代码很多


678
00:25:04,676 --> 00:25:06,176
但是我们马上就可以


679
00:25:06,176 --> 00:25:09,786
为井字游戏实施协议了


680
00:25:19,176 --> 00:25:22,546
好 这就是之前 


681
00:25:22,666 --> 00:25:24,076
Eric 做的游戏


682
00:25:24,906 --> 00:25:26,676
现在我要创建一个新类


683
00:25:26,816 --> 00:25:28,326
命名为游戏协议


684
00:25:28,396 --> 00:25:31,766
它会遵循 NWProtocolFramerImplementation


685
00:25:32,266 --> 00:25:34,786
我已经为这个游戏定义了


686
00:25:34,786 --> 00:25:36,616
两个不同的类型


687
00:25:36,616 --> 00:25:37,836
我想要发送两个


688
00:25:37,836 --> 00:25:38,726
不同的指令


689
00:25:39,696 --> 00:25:41,336
一个是选择角色


690
00:25:41,826 --> 00:25:43,826
游戏的第一步是


691
00:25:43,826 --> 00:25:45,176
玩家需要选择 


692
00:25:45,276 --> 00:25:46,976
他们想用哪个表情符号


693
00:25:46,976 --> 00:25:48,726
他们想当猴子还是当鸟


694
00:25:49,986 --> 00:25:53,566
然当玩家选择了他们的角色后


695
00:25:53,566 --> 00:25:55,216
就开始发送走棋操作


696
00:25:55,516 --> 00:25:57,006
这就会变成更长的 Body


697
00:25:57,006 --> 00:26:02,026
它会包括角色和行 列值


698
00:26:03,996 --> 00:26:06,826
好 我记得 


699
00:26:06,826 --> 00:26:07,936
当我实施协议时 


700
00:26:07,936 --> 00:26:10,836
我要做的第一件事就是


701
00:26:11,046 --> 00:26:12,126
创建一个定义


702
00:26:12,126 --> 00:26:15,446
这是基于我的对象的句柄


703
00:26:15,446 --> 00:26:17,846
它在系统中注册对象


704
00:26:17,896 --> 00:26:21,796
让我可以在连接中使用这个


705
00:26:26,476 --> 00:26:29,226
接下来 我要处理所有的基本回调


706
00:26:29,576 --> 00:26:30,876
这里再一次


707
00:26:30,876 --> 00:26:32,646
因为我不需要自己的握手


708
00:26:32,926 --> 00:26:34,456
当我被启动调用时


709
00:26:35,026 --> 00:26:37,806
我可以返回一个就绪的启动结果


710
00:26:40,026 --> 00:26:42,246
接着 我们来处理


711
00:26:42,246 --> 00:26:43,796
发送和打包消息


712
00:26:47,616 --> 00:26:49,696
我将在这里定义


713
00:26:49,696 --> 00:26:51,296
handleOutput 的实现


714
00:26:55,696 --> 00:26:58,416
所以头部是一个 8 字节 Header


715
00:26:58,666 --> 00:27:00,436
包括一个类型和长度


716
00:27:00,626 --> 00:27:02,366
首先我要知道我的类型是什么


717
00:27:02,366 --> 00:27:04,786
我从 App 发送的消息中


718
00:27:04,786 --> 00:27:06,636
得知类型


719
00:27:06,636 --> 00:27:08,426
我们稍后会看这个


720
00:27:08,926 --> 00:27:12,376
我已经给 framer 消息


721
00:27:12,376 --> 00:27:14,386
创建了一个自定义扩展 


722
00:27:14,426 --> 00:27:16,456
用来提取特定枚举类型


723
00:27:16,886 --> 00:27:18,646
这样我就可以知道


724
00:27:18,686 --> 00:27:20,356
是选棋还是走棋


725
00:27:21,096 --> 00:27:22,896
有了类型


726
00:27:22,896 --> 00:27:25,426
我就可以在 handleOutput  中


727
00:27:25,426 --> 00:27:27,126
通过传输的类型和长度


728
00:27:27,906 --> 00:27:29,956
实例化我的结构


729
00:27:29,956 --> 00:27:30,796
我的游戏协议 Header 


730
00:27:32,096 --> 00:27:33,736
我已经写了代码


731
00:27:34,096 --> 00:27:35,776
编码那份


732
00:27:35,776 --> 00:27:38,286
类型和长度为 


733
00:27:38,476 --> 00:27:39,466
8 字节范围的数据


734
00:27:39,786 --> 00:27:42,006
我调用 writeOutput 


735
00:27:42,006 --> 00:27:43,356
把那个数据加入到输出流队列中


736
00:27:43,856 --> 00:27:47,676
现在我要做最后一件事


737
00:27:47,706 --> 00:27:48,896
既然我已经写了 Header


738
00:27:49,116 --> 00:27:50,516
现在就要写 Body


739
00:27:50,986 --> 00:27:51,846
这里我只需调用


740
00:27:51,846 --> 00:27:53,606
writeOutputNoCopy 


741
00:27:53,606 --> 00:27:55,956
表明下一个宽度的字节 


742
00:27:55,956 --> 00:27:57,516
是这个消息的 Body


743
00:27:58,736 --> 00:28:00,256
一旦这个返回


744
00:28:00,256 --> 00:28:01,586
这些字节就会被发送  


745
00:28:01,586 --> 00:28:03,306
我就可以处理更多的信息


746
00:28:03,306 --> 00:28:04,086
不论是输入还是输出


747
00:28:04,676 --> 00:28:08,656
好 写入就完成了


748
00:28:08,656 --> 00:28:10,746
现在来看读取 


749
00:28:10,746 --> 00:28:11,646
我要处理输入


750
00:28:14,536 --> 00:28:16,886
首先我要读出 


751
00:28:16,886 --> 00:28:17,676
解析 Header


752
00:28:18,126 --> 00:28:19,836
先是一个固定大小的 Header


753
00:28:20,066 --> 00:28:21,346
8 个字节


754
00:28:22,546 --> 00:28:24,486
我将尝试解析出


755
00:28:24,486 --> 00:28:26,696
最小 8 个字节 最大 8 个字节


756
00:28:26,696 --> 00:28:32,276
每当有 8 个字节可用时


757
00:28:32,276 --> 00:28:34,296
我都会被缓冲调用 


758
00:28:34,916 --> 00:28:37,156
这里我确认


759
00:28:37,156 --> 00:28:39,196
缓冲是有效的


760
00:28:39,196 --> 00:28:42,296
然后创建结构 


761
00:28:42,296 --> 00:28:44,776
将那 8 个字节解析为类型和长度域


762
00:28:46,716 --> 00:28:47,746
一旦这一步成功了


763
00:28:47,746 --> 00:28:51,996
就表明我想用 8 个字节增量光标


764
00:28:52,056 --> 00:28:54,166
说明我已经使用了这些字节


765
00:28:54,276 --> 00:28:59,036
这些字节没用了


766
00:28:59,256 --> 00:29:01,236
现在我同样需要处理


767
00:29:01,236 --> 00:29:02,746
没有成功解析


768
00:29:02,746 --> 00:29:04,596
所有 8 个字节的情况


769
00:29:04,786 --> 00:29:06,596
可能只有 5 个字节是可用的


770
00:29:07,636 --> 00:29:08,876
所以解析失败


771
00:29:09,436 --> 00:29:10,926
我将从处理输入返回


772
00:29:10,926 --> 00:29:13,726
表明我需要


773
00:29:13,726 --> 00:29:15,246
等待 8 个字节可用


774
00:29:15,246 --> 00:29:18,166
然后才能继续


775
00:29:18,716 --> 00:29:20,026
但是如果我真的过了这一步


776
00:29:20,066 --> 00:29:21,786
我就知道 Header 是有效的


777
00:29:21,786 --> 00:29:23,886
我可以用它


778
00:29:23,886 --> 00:29:25,976
传送剩余的 App 数据


779
00:29:29,756 --> 00:29:32,516
所以现在我要创建一个信息对象


780
00:29:32,806 --> 00:29:34,326
我要将我的特定消息类型


781
00:29:34,326 --> 00:29:37,986
存储在那个消息对象中


782
00:29:40,176 --> 00:29:44,066
最后我会调用


783
00:29:44,066 --> 00:29:47,006
deliverInputNoCopy


784
00:29:47,006 --> 00:29:48,976
直接告诉连接


785
00:29:48,976 --> 00:29:50,706
接下来的那些


786
00:29:50,746 --> 00:29:53,506
每当有 是 App 数据


787
00:29:53,506 --> 00:29:55,256
当你的 App 收到消息时


788
00:29:55,256 --> 00:29:56,586
它们会准确接收到


789
00:29:56,586 --> 00:29:58,106
那个组块


790
00:29:59,026 --> 00:30:00,266
这就是我要做的


791
00:30:00,396 --> 00:30:01,606
这就是完整的协议


792
00:30:01,606 --> 00:30:04,236
接下来我会介绍


793
00:30:04,346 --> 00:30:05,846
如何初始化 把它输入到游戏连接中去


794
00:30:09,181 --> 00:30:11,181
[掌声]


795
00:30:11,346 --> 00:30:16,706
好 好消息是


796
00:30:16,706 --> 00:30:17,826
这部分比较简单


797
00:30:18,516 --> 00:30:21,116
要把协议添加到连接 并重复使用它 


798
00:30:21,116 --> 00:30:23,966
你只需要选取


799
00:30:23,966 --> 00:30:25,426
之前做的定义


800
00:30:26,316 --> 00:30:28,306
用那个定义


801
00:30:28,396 --> 00:30:29,516
创建一些协议选项


802
00:30:30,016 --> 00:30:32,426
协议选项


803
00:30:32,476 --> 00:30:34,426
是协议栈的组成部分


804
00:30:35,036 --> 00:30:38,546
有 TCP 选项 TLS 选项 


805
00:30:38,546 --> 00:30:40,396
现在有自己的自定义协议选项


806
00:30:41,036 --> 00:30:42,576
当你为连接


807
00:30:42,576 --> 00:30:43,816
创建 parameters 时


808
00:30:43,996 --> 00:30:45,766
比如说你在用 TLS 


809
00:30:45,766 --> 00:30:46,946
因为它可以确保通信安全


810
00:30:48,226 --> 00:30:50,806
以及协议栈里的 TLS 


811
00:30:50,806 --> 00:30:53,096
你可以直接


812
00:30:53,096 --> 00:30:54,446
将自己的协议


813
00:30:54,446 --> 00:30:56,926
添加到 applicationProtocols 数组的顶部


814
00:30:57,696 --> 00:30:58,736
你可以添加多个


815
00:30:58,736 --> 00:31:01,406
运行多层框架


816
00:31:02,046 --> 00:31:03,206
如果你想用 WebSocket


817
00:31:03,206 --> 00:31:04,806
也是在这个地方


818
00:31:05,346 --> 00:31:06,676
WebSocket 是一个今年


819
00:31:06,676 --> 00:31:07,996
新的系统实施


820
00:31:07,996 --> 00:31:10,496
你可以将它添加到你的连接


821
00:31:11,886 --> 00:31:14,586
WebSocket 本身


822
00:31:14,766 --> 00:31:16,976
作为协议框架被实施


823
00:31:17,266 --> 00:31:19,226
和你现在可用的


824
00:31:19,556 --> 00:31:21,036
使用的相同的 API


825
00:31:21,356 --> 00:31:22,506
它向你展示了


826
00:31:22,506 --> 00:31:25,006
一个框架协议有多强大


827
00:31:25,736 --> 00:31:27,556
如果你不想自己写


828
00:31:27,556 --> 00:31:29,386
那你可以用 WebSocket


829
00:31:33,546 --> 00:31:34,726
在这里我想说的是


830
00:31:34,726 --> 00:31:36,666
一些 App  


831
00:31:36,666 --> 00:31:38,926
在不同的情况下


832
00:31:39,256 --> 00:31:40,456
需要使用不同的协议栈


833
00:31:41,366 --> 00:31:43,156
框架协议真的是一个


834
00:31:43,156 --> 00:31:46,136
在 App 和网络连接之间


835
00:31:46,136 --> 00:31:47,436
建立合约的好方法


836
00:31:47,436 --> 00:31:48,806
即便你在使用 


837
00:31:48,806 --> 00:31:51,006
不同的协议栈


838
00:31:51,006 --> 00:31:52,596
依旧如此


839
00:31:53,466 --> 00:31:54,916
为给大家举个例子


840
00:31:54,916 --> 00:31:58,026
我们在 DNS 系统上使用这个


841
00:31:58,936 --> 00:32:01,506
DNS 通常通过 UDP


842
00:32:01,506 --> 00:32:04,206
发送数据包消息


843
00:32:05,876 --> 00:32:08,306
但是偶尔 DNS 会和 TCP 一样 


844
00:32:08,306 --> 00:32:10,736
需要在流的上端运行


845
00:32:11,236 --> 00:32:12,846
当它这么做时 


846
00:32:12,846 --> 00:32:14,596
会有一个 Body 格式


847
00:32:14,596 --> 00:32:17,356
它只有一个非常基本的长度


848
00:32:17,356 --> 00:32:19,726
用 TCP 编码 DNS 


849
00:32:20,726 --> 00:32:23,206
所以我们写了一个 framer


850
00:32:23,206 --> 00:32:26,216
用来定义这个简单的数据包


851
00:32:26,216 --> 00:32:28,106
这样在上方就有相同的代码


852
00:32:28,106 --> 00:32:32,716
发送 DNS 数据包不需要考虑


853
00:32:32,716 --> 00:32:34,626
它用的是 UDP 还是 TCP 


854
00:32:34,626 --> 00:32:36,876
它是同样的逻辑


855
00:32:37,396 --> 00:32:40,676
这样你就无需担心太多


856
00:32:40,676 --> 00:32:41,946
可以分开调试


857
00:32:41,946 --> 00:32:43,196
App 的不同部分


858
00:32:43,766 --> 00:32:47,506
我们已经将框架协议


859
00:32:47,506 --> 00:32:48,776
添加到连接


860
00:32:48,776 --> 00:32:50,706
现在准备发送和接收消息


861
00:32:50,706 --> 00:32:52,306
我们可以使用自定义值 


862
00:32:52,306 --> 00:32:55,086
接下来我们就会在游戏里


863
00:32:55,086 --> 00:32:56,166
用自定义值


864
00:32:57,476 --> 00:33:00,256
Framer.Message 


865
00:33:00,256 --> 00:33:02,896
让你可以存储


866
00:33:02,896 --> 00:33:05,436
任何对象类型的键值对


867
00:33:05,436 --> 00:33:07,366
所以你可以添加到自定义值


868
00:33:07,886 --> 00:33:10,586
去修饰你的发送操作


869
00:33:10,586 --> 00:33:12,646
接收协议的消息


870
00:33:13,586 --> 00:33:15,416
你可以创建一条消息


871
00:33:15,486 --> 00:33:16,906
按你喜欢的方式设置好它


872
00:33:16,906 --> 00:33:18,516
将它发送到


873
00:33:18,546 --> 00:33:22,126
你正在传送数据的上下文上


874
00:33:22,676 --> 00:33:25,006
所以每个发送操作 


875
00:33:25,006 --> 00:33:28,186
都已经有了内容和上下文


876
00:33:28,526 --> 00:33:31,396
上下文会描述你想要如何发送数据


877
00:33:31,856 --> 00:33:33,546
Framer.Message 只是


878
00:33:33,546 --> 00:33:37,096
发送数据的新方式


879
00:33:37,276 --> 00:33:38,936
接收也很相似


880
00:33:39,046 --> 00:33:40,936
当调用 receiveMessage 时


881
00:33:41,776 --> 00:33:43,196
在接收内容的同时


882
00:33:43,196 --> 00:33:44,936
还能接收到上下文


883
00:33:44,936 --> 00:33:47,276
它用来描述数据是如何被接收的


884
00:33:48,056 --> 00:33:49,746
你可以用协议的定义


885
00:33:49,746 --> 00:33:52,026
查看协议 framer 


886
00:33:52,126 --> 00:33:57,116
上下文会描述特定消息值


887
00:33:58,006 --> 00:34:00,786
接下来我们就要


888
00:34:00,936 --> 00:34:04,556
完成这个井字游戏了


889
00:34:05,316 --> 00:34:09,565
好 我们已经做好了游戏协议


890
00:34:10,206 --> 00:34:12,985
要把它加入到连接中


891
00:34:13,045 --> 00:34:17,025
我将返回 Eric 刚才设置的参数


892
00:34:17,025 --> 00:34:18,166
他已经用 TCP 和 TLS


893
00:34:18,166 --> 00:34:22,216
设置好了有密码的连接


894
00:34:24,106 --> 00:34:28,085
现在我要做的只是


895
00:34:28,085 --> 00:34:29,036
把这两行加进去


896
00:34:29,036 --> 00:34:32,286
我要基于游戏协议定义


897
00:34:32,286 --> 00:34:34,696
创建一些选项 


898
00:34:34,696 --> 00:34:36,485
将它们插入到


899
00:34:36,485 --> 00:34:38,716
我想要用在连接里的 App 协议数组


900
00:34:39,386 --> 00:34:41,036
现在当两设备间启动连接时


901
00:34:41,036 --> 00:34:42,396
它会准备就绪 


902
00:34:42,646 --> 00:34:46,616
在流上编码消息


903
00:34:47,096 --> 00:34:51,576
现在我要在连接中


904
00:34:51,576 --> 00:34:53,346
做几个便捷函数


905
00:34:53,346 --> 00:34:54,676
让 App 更简单地


906
00:34:54,746 --> 00:34:56,116
发送和接收


907
00:34:56,116 --> 00:34:58,786
自定义消息类型


908
00:34:59,836 --> 00:35:01,326
这里有一个连接对象


909
00:35:01,326 --> 00:35:03,856
它用刚才


910
00:35:03,856 --> 00:35:05,646
定义的参数


911
00:35:05,646 --> 00:35:07,216
设置了一个 NWConnection


912
00:35:08,346 --> 00:35:09,726
每当连接就绪时


913
00:35:09,726 --> 00:35:11,326
它就开始从 peer


914
00:35:11,326 --> 00:35:13,786
接收消息


915
00:35:15,286 --> 00:35:16,746
我们需要接收下一个消息


916
00:35:16,746 --> 00:35:17,876
来实施这个


917
00:35:21,376 --> 00:35:23,316
我现在做的是


918
00:35:23,316 --> 00:35:24,776
获取连接 在连接上


919
00:35:24,776 --> 00:35:25,766
调用 receiveMessage 


920
00:35:26,716 --> 00:35:29,656
我将得到内容和上下文


921
00:35:30,516 --> 00:35:31,596
我将用上下文


922
00:35:31,596 --> 00:35:34,506
查看我的协议


923
00:35:34,506 --> 00:35:37,086
特定的元数据


924
00:35:37,086 --> 00:35:38,476
和游戏协议定义


925
00:35:39,516 --> 00:35:40,856
这会给我消息对象


926
00:35:40,856 --> 00:35:43,266
让我把消息类型


927
00:35:43,266 --> 00:35:44,986
和数据一起


928
00:35:44,986 --> 00:35:46,146
向上传送到 App 


929
00:35:47,116 --> 00:35:48,436
当然 接下来 如果我


930
00:35:48,436 --> 00:35:49,616
成功接收到一条消息


931
00:35:49,616 --> 00:35:51,136
我会调用 receiveNextMessage 


932
00:35:51,136 --> 00:35:53,236
再次重复这个过程


933
00:35:56,016 --> 00:35:57,676
我还要给发送


934
00:35:57,946 --> 00:35:59,236
定义一些 Helper


935
00:35:59,646 --> 00:36:01,096
所以每当 App 判定


936
00:36:01,096 --> 00:36:02,206
玩家是在选择角色时


937
00:36:02,206 --> 00:36:04,466
我们可以创建一个消息


938
00:36:04,466 --> 00:36:07,716
将所选的角色作为类型


939
00:36:07,716 --> 00:36:09,306
添加到这个消息


940
00:36:10,096 --> 00:36:12,406
并将其发送到上下文中


941
00:36:12,916 --> 00:36:15,826
发送走棋操作


942
00:36:15,826 --> 00:36:16,816
也是这样的 


943
00:36:16,816 --> 00:36:18,486
在这里创建一个便捷函数 


944
00:36:18,486 --> 00:36:20,106
声明我想发送走棋操作


945
00:36:20,106 --> 00:36:21,846
然后只需获取 App 数据


946
00:36:22,316 --> 00:36:23,556
将它向下传送给连接


947
00:36:24,626 --> 00:36:25,626
这就是我们要做的


948
00:36:25,886 --> 00:36:27,606
现在就可以玩游戏了


949
00:36:27,606 --> 00:36:29,416
玩游戏需要两个人


950
00:36:29,416 --> 00:36:30,626
Eric 请回到台上


951
00:36:32,456 --> 00:36:35,896
好的 Eric 已经在这里


952
00:36:35,896 --> 00:36:38,476
创建了一个游戏


953
00:36:38,476 --> 00:36:39,546
但是我想自己创建一个


954
00:36:40,726 --> 00:36:41,136
我们来做这一步


955
00:36:41,136 --> 00:36:42,946
Eric 我们输入密码


956
00:36:42,946 --> 00:36:47,406
5176


957
00:36:47,906 --> 00:36:48,686
不要告诉别人 [笑声]


958
00:36:49,906 --> 00:36:51,116
好了


959
00:36:51,116 --> 00:36:52,826
现在我们已经设置了一个


960
00:36:52,826 --> 00:36:53,896
安全的连接


961
00:36:54,286 --> 00:36:55,336
它在用 TLS


962
00:36:55,826 --> 00:36:57,666
当 Eric 选择一个角色时


963
00:36:57,666 --> 00:36:59,746
他选择鸟


964
00:37:00,536 --> 00:37:02,136
他就是在发送


965
00:37:02,636 --> 00:37:04,556
选择符号信息


966
00:37:04,556 --> 00:37:06,806
我调用 receiveMessage 


967
00:37:06,806 --> 00:37:07,926
收到 他选择了鸟


968
00:37:07,926 --> 00:37:08,936
然后我要选择猴子


969
00:37:08,936 --> 00:37:10,246
为什么不呢


970
00:37:11,066 --> 00:37:13,566
现在 Eric 选择一个位置


971
00:37:14,326 --> 00:37:16,806
然后选择一个符号


972
00:37:17,846 --> 00:37:21,276
好的 他将走棋动作发送给了我


973
00:37:21,626 --> 00:37:22,616
我收到一个消息


974
00:37:22,616 --> 00:37:23,846
我知道他走了一步棋


975
00:37:23,846 --> 00:37:25,946
我知道他把棋放在了哪儿


976
00:37:25,946 --> 00:37:29,606
我要把猴子


977
00:37:29,606 --> 00:37:30,936
放在上面


978
00:37:31,386 --> 00:37:32,476
他下一步会怎么走呢


979
00:37:33,786 --> 00:37:35,066
哦 看起来


980
00:37:35,106 --> 00:37:36,866
他要赢了 我不知道


981
00:37:36,906 --> 00:37:38,336
我玩不了这个


982
00:37:38,756 --> 00:37:39,896
井字游戏太难了


983
00:37:40,376 --> 00:37:42,736
好像鸟赢了


984
00:37:43,446 --> 00:37:45,636
但是可以看出来


985
00:37:45,636 --> 00:37:47,496
这种类型的游戏搭建起来非常简单


986
00:37:47,496 --> 00:37:50,076
你还可以用这个


987
00:37:50,076 --> 00:37:51,666
搭建更多的小游戏


988
00:37:51,666 --> 00:37:53,846
还有很多其他的 App


989
00:37:53,846 --> 00:37:54,896
我们很期待


990
00:37:54,896 --> 00:37:55,236
你们的作品


991
00:37:56,516 --> 00:38:02,616
[掌声]


992
00:38:03,116 --> 00:38:08,856
好的 在我继续之前 


993
00:38:08,856 --> 00:38:10,276
关于框架协议 我想再说


994
00:38:10,276 --> 00:38:11,316
最后一件事


995
00:38:11,936 --> 00:38:14,156
很多人都在问


996
00:38:14,156 --> 00:38:16,976
如何用技术 比如


997
00:38:17,136 --> 00:38:20,326
在 NWConnection 中采用 STARTTLS


998
00:38:20,776 --> 00:38:23,406
STARTTLS 是来自 


999
00:38:23,406 --> 00:38:25,556
SMTP 邮箱协议的技术


1000
00:38:25,556 --> 00:38:29,586
它让你可以与较早的服务器交流


1001
00:38:29,586 --> 00:38:31,406
你并不知道


1002
00:38:31,406 --> 00:38:32,916
这个服务器


1003
00:38:32,996 --> 00:38:35,186
是否支持 TLS 和安全连接


1004
00:38:35,186 --> 00:38:36,576
你可以和它做一个初次握手


1005
00:38:37,106 --> 00:38:39,096
如果它支持 TLS 


1006
00:38:39,096 --> 00:38:41,586
你可以部分通过你的连接添加它 


1007
00:38:41,856 --> 00:38:43,476
之前没有什么好方法


1008
00:38:43,476 --> 00:38:45,196
来做这一步 


1009
00:38:45,196 --> 00:38:46,876
但是现在我们有了框架协议


1010
00:38:47,856 --> 00:38:50,726
所以 如果你创建一个


1011
00:38:50,726 --> 00:38:52,206
STARTTLS 框架协议


1012
00:38:52,206 --> 00:38:53,526
将它添加到连接


1013
00:38:53,526 --> 00:38:55,806
当 App 启动时


1014
00:38:55,916 --> 00:38:57,186
你可以和服务器握手


1015
00:38:57,186 --> 00:38:59,606
确定它是否支持 TLS


1016
00:39:00,416 --> 00:39:01,386
然后你可以 


1017
00:39:01,386 --> 00:39:02,956
在表明就绪之前 


1018
00:39:02,956 --> 00:39:04,836
在框架协议上 


1019
00:39:04,836 --> 00:39:07,286
动态添加协议到栈


1020
00:39:07,956 --> 00:39:09,156
这样 App 就会保持不变


1021
00:39:09,156 --> 00:39:11,736
不需要担心


1022
00:39:11,736 --> 00:39:13,866
部分添加 TLS 


1023
00:39:14,216 --> 00:39:15,926
这个过程会自动


1024
00:39:16,226 --> 00:39:17,446
通过框架协议进行


1025
00:39:18,246 --> 00:39:19,216
所以我们觉得这是一个


1026
00:39:19,216 --> 00:39:19,936
干净利落的方法


1027
00:39:21,516 --> 00:39:24,366
好 我们继续


1028
00:39:25,006 --> 00:39:27,146
我们已经介绍了 Bonjour


1029
00:39:27,146 --> 00:39:28,836
如果做更好的 P2P 连接


1030
00:39:28,836 --> 00:39:31,456
以及使用广域发现


1031
00:39:31,686 --> 00:39:34,136
我们介绍了框架协议


1032
00:39:35,086 --> 00:39:36,136
但是现在我想退一步


1033
00:39:36,136 --> 00:39:38,166
看看如何收集


1034
00:39:38,166 --> 00:39:40,096
你的 App 里


1035
00:39:40,096 --> 00:39:42,306
连接的指标


1036
00:39:43,356 --> 00:39:45,726
收集指标非常重要


1037
00:39:46,876 --> 00:39:50,006
当你给 App 或服务器


1038
00:39:50,006 --> 00:39:52,836
添加新功能


1039
00:39:52,836 --> 00:39:54,736
以实现更好的效果时


1040
00:39:55,446 --> 00:39:57,546
它让你确认这些功能


1041
00:39:57,546 --> 00:39:58,656
确实在发挥作用


1042
00:39:58,656 --> 00:40:00,566
你确实实现了自己想要的效果


1043
00:40:01,526 --> 00:40:03,756
它可以帮助你发现 


1044
00:40:04,346 --> 00:40:06,196
用户在真实使用中


1045
00:40:06,196 --> 00:40:08,016
可能遭遇的问题


1046
00:40:08,016 --> 00:40:12,056
这些问题在设计时并没有发现


1047
00:40:12,516 --> 00:40:14,606
今年我们有很多


1048
00:40:14,606 --> 00:40:16,206
新的指标


1049
00:40:16,206 --> 00:40:17,696
帮你更好地分析连接


1050
00:40:18,446 --> 00:40:20,426
URLSession 已经有了很多


1051
00:40:20,426 --> 00:40:22,236
很好的指标


1052
00:40:22,236 --> 00:40:23,476
但是其实还有更多


1053
00:40:23,546 --> 00:40:24,996
第一次 在 Network.framework 里


1054
00:40:24,996 --> 00:40:26,496
你可以检查连接


1055
00:40:26,496 --> 00:40:28,286
更全面地了解


1056
00:40:28,286 --> 00:40:31,166
它们的表现


1057
00:40:32,926 --> 00:40:35,326
在 URLSession 中


1058
00:40:35,326 --> 00:40:37,016
你已经得到一个 


1059
00:40:37,286 --> 00:40:40,896
DNS TCP TLS 和 HTTP 消息的


1060
00:40:40,896 --> 00:40:43,016
时间细分


1061
00:40:44,456 --> 00:40:46,086
现在你可以


1062
00:40:46,386 --> 00:40:48,726
在你的 App 里自检


1063
00:40:49,706 --> 00:40:53,006
更多的连接属性


1064
00:40:53,006 --> 00:40:54,146
和个人请求和响应 


1065
00:40:54,146 --> 00:40:56,546
正在发送的数据


1066
00:40:58,816 --> 00:41:00,376
在 Network.framework 里


1067
00:41:00,376 --> 00:41:01,856
你可以访问


1068
00:41:01,856 --> 00:41:03,506
连接建立报告


1069
00:41:03,506 --> 00:41:06,396
它总结了连接中发生的一切


1070
00:41:06,396 --> 00:41:08,966
以及数据传输报告


1071
00:41:08,966 --> 00:41:10,946
让你可以查看


1072
00:41:10,946 --> 00:41:12,236
连接过程中


1073
00:41:12,346 --> 00:41:15,036
各个时间段的性能


1074
00:41:15,106 --> 00:41:16,666
很多这些过程


1075
00:41:16,666 --> 00:41:17,836
同时进行


1076
00:41:18,426 --> 00:41:21,546
我们先从 URLSession 开始


1077
00:41:21,996 --> 00:41:25,116
我要提醒大家


1078
00:41:25,116 --> 00:41:26,596
URLSession 里所有的指标


1079
00:41:26,596 --> 00:41:27,356
在 didFinishCollecting 指标


1080
00:41:27,356 --> 00:41:30,116
代理调用里 都是可用的


1081
00:41:32,096 --> 00:41:34,086
这里有一些


1082
00:41:34,086 --> 00:41:36,016
你可以访问的新东西


1083
00:41:36,016 --> 00:41:37,326
连接的端点


1084
00:41:38,276 --> 00:41:41,236
本地和远程地址以及端口


1085
00:41:41,646 --> 00:41:43,756
你还可以查看


1086
00:41:43,756 --> 00:41:45,036
安全属性


1087
00:41:45,396 --> 00:41:48,836
有没有用 TLS 1.3


1088
00:41:48,836 --> 00:41:50,986
它是 TLS 最新的 最安全的 


1089
00:41:50,986 --> 00:41:52,436
性能最好的版本


1090
00:41:52,436 --> 00:41:56,666
你还可以用它查看路径属性


1091
00:41:57,636 --> 00:41:59,546
它会告诉你 比如说


1092
00:41:59,796 --> 00:42:01,606
你的连接用的是


1093
00:42:01,606 --> 00:42:03,446
约束低数据模式网络


1094
00:42:03,446 --> 00:42:05,656
还是一个


1095
00:42:05,656 --> 00:42:07,586
比较贵的蜂窝数据网络


1096
00:42:10,216 --> 00:42:14,586
Network.framework 里的等价指标


1097
00:42:14,586 --> 00:42:15,506
是在建立报告里面的


1098
00:42:16,346 --> 00:42:17,776
每当连接进入稳定状态


1099
00:42:17,776 --> 00:42:20,816
你就可以使用这些指标


1100
00:42:20,926 --> 00:42:23,416
这会给你一个细分


1101
00:42:23,486 --> 00:42:26,426
你的 DNS 次数 


1102
00:42:26,426 --> 00:42:29,216
协议和 TCP 和 TLS 的握手


1103
00:42:29,216 --> 00:42:31,006
以及你是否使用了代理


1104
00:42:31,536 --> 00:42:33,576
在代码里它看起来是这样的


1105
00:42:33,856 --> 00:42:35,476
获取连接 并调用


1106
00:42:35,676 --> 00:42:37,146
requestEstablishmentReport


1107
00:42:37,806 --> 00:42:39,886
这里有一个队列


1108
00:42:39,886 --> 00:42:41,516
它会把报告加入到队列里


1109
00:42:42,696 --> 00:42:43,986
有了这个 你就可以查看


1110
00:42:43,986 --> 00:42:45,776
连接花费的所有时间 


1111
00:42:46,296 --> 00:42:49,626
你可以查看各个解决步骤


1112
00:42:49,836 --> 00:42:51,306
如果一个 Bonjour 名称连接到你


1113
00:42:51,306 --> 00:42:53,416
它可能会解析 Bonjour 名称


1114
00:42:53,416 --> 00:42:55,056
为主机名


1115
00:42:55,056 --> 00:42:56,886
再把主机名解析为地址


1116
00:42:56,886 --> 00:42:58,756
你可以查看


1117
00:42:58,786 --> 00:43:00,626
每个步骤的时间细分


1118
00:43:01,136 --> 00:43:03,806
你还可以查看


1119
00:43:03,806 --> 00:43:06,286
TCP 的 TLS 的 


1120
00:43:06,346 --> 00:43:08,256
和往返次数的


1121
00:43:08,256 --> 00:43:09,126
单独计时


1122
00:43:09,346 --> 00:43:13,476
我想强调一点


1123
00:43:13,476 --> 00:43:15,386
这一点对于连接建立的


1124
00:43:15,386 --> 00:43:16,566
整体表现来说


1125
00:43:16,566 --> 00:43:18,936
非常重要


1126
00:43:18,936 --> 00:43:20,756
这一点就是它 


1127
00:43:20,886 --> 00:43:23,376
解析 DNS 的时间


1128
00:43:23,376 --> 00:43:25,166
以及 DNS 解析的来源


1129
00:43:27,386 --> 00:43:30,286
很多服务器 


1130
00:43:30,286 --> 00:43:32,876
只有很短的时间 


1131
00:43:32,876 --> 00:43:34,046
在 DNS 记录上配置


1132
00:43:34,446 --> 00:43:36,846
它们这样做的目的是


1133
00:43:36,846 --> 00:43:39,866
当服务器发生故障


1134
00:43:39,866 --> 00:43:40,886
或者想在另一个 IP 地址上


1135
00:43:40,946 --> 00:43:43,246
平衡负载时


1136
00:43:43,246 --> 00:43:44,956
它可以快速改变 IP 地址记录


1137
00:43:44,956 --> 00:43:47,546
调整客户端


1138
00:43:47,546 --> 00:43:49,056
使用新地址


1139
00:43:50,166 --> 00:43:52,116
但是 缺点是


1140
00:43:52,116 --> 00:43:54,546
这会影响客户端性能


1141
00:43:55,736 --> 00:43:57,666
在很短的时间内


1142
00:43:57,666 --> 00:43:59,546
客户端需要往返


1143
00:43:59,616 --> 00:44:01,646
做 DNS 域名解析


1144
00:44:01,646 --> 00:44:04,236
请求你要连接的


1145
00:44:04,236 --> 00:44:06,766
主机名地址


1146
00:44:07,286 --> 00:44:11,066
对于要连接到


1147
00:44:11,366 --> 00:44:12,866
高延迟链接的客户端来说 


1148
00:44:12,866 --> 00:44:13,636
这就特别糟糕


1149
00:44:14,286 --> 00:44:16,396
这将会延长连接时间


1150
00:44:16,396 --> 00:44:17,946
增加数百毫秒


1151
00:44:17,946 --> 00:44:19,156
甚至好几秒


1152
00:44:19,786 --> 00:44:22,126
最糟糕的是 大部分时间  


1153
00:44:22,126 --> 00:44:23,816
服务器地址并没有改变


1154
00:44:23,816 --> 00:44:26,256
所以这就是一个


1155
00:44:26,256 --> 00:44:27,296
没用的往返


1156
00:44:28,426 --> 00:44:33,016
我们 去年发布了 Optimistic DNS


1157
00:44:33,016 --> 00:44:34,256
可以解决这个问题


1158
00:44:35,786 --> 00:44:37,636
Optimistic DNS 


1159
00:44:37,636 --> 00:44:39,636
让你连接到 


1160
00:44:39,916 --> 00:44:42,376
主机名的最后一个


1161
00:44:42,376 --> 00:44:43,846
已知良好的 IP 地址


1162
00:44:44,816 --> 00:44:49,766
同时请求主机名的当前地址


1163
00:44:51,146 --> 00:44:52,776
大部分情况下


1164
00:44:52,776 --> 00:44:55,246
都没有什么改变


1165
00:44:55,246 --> 00:44:56,456
连接还是建立在


1166
00:44:56,456 --> 00:44:58,356
之前的 IP 地址


1167
00:44:58,676 --> 00:45:00,016
如果有变化


1168
00:45:00,016 --> 00:45:01,266
你会得到一个新的 IP 地址


1169
00:45:01,266 --> 00:45:02,776
转而连接到新地址


1170
00:45:03,376 --> 00:45:06,676
我们一直在测试它


1171
00:45:07,206 --> 00:45:09,456
它真的是一个好方法


1172
00:45:09,456 --> 00:45:11,126
所以今年 对于使用 


1173
00:45:11,126 --> 00:45:12,976
Network.framework 


1174
00:45:12,976 --> 00:45:14,156
和 URLSession 的连接


1175
00:45:14,156 --> 00:45:14,936
它是默认开启的


1176
00:45:16,736 --> 00:45:17,866
当你查看


1177
00:45:17,866 --> 00:45:19,146
连接报告时 


1178
00:45:19,146 --> 00:45:21,046
你可以通过查看来源


1179
00:45:21,046 --> 00:45:23,636
辨认你用的是不是 Optimistic DNS


1180
00:45:24,116 --> 00:45:25,216
如果是来自过期缓存


1181
00:45:25,216 --> 00:45:27,746
这就意味着


1182
00:45:27,746 --> 00:45:30,966
我们用的是 Optimistic DNS


1183
00:45:31,726 --> 00:45:34,566
我想向大家展示一下


1184
00:45:34,566 --> 00:45:36,416
如何使用指标


1185
00:45:36,416 --> 00:45:38,196
查看连接性能


1186
00:45:38,196 --> 00:45:39,926
以及 Optimistic DNS


1187
00:45:39,926 --> 00:45:47,196
和 TLS 1.3 的优点


1188
00:45:47,426 --> 00:45:49,766
好 我这里有一个 App


1189
00:45:49,766 --> 00:45:51,556
一款非常基本的 App


1190
00:45:51,556 --> 00:45:54,216
用来收集指标


1191
00:45:54,346 --> 00:45:57,286
只需要对一个给定网站运行 probe


1192
00:45:57,756 --> 00:46:00,186
好 有了


1193
00:46:00,186 --> 00:46:01,836
我点按“Run Probe”


1194
00:46:01,836 --> 00:46:03,306
连接上了 非常快


1195
00:46:03,306 --> 00:46:07,916
Wi-Fi 信号非常好


1196
00:46:08,506 --> 00:46:10,336
如果你想在一个


1197
00:46:10,336 --> 00:46:12,176
更现实的场景中测试它


1198
00:46:12,176 --> 00:46:13,496
或者看它在


1199
00:46:13,496 --> 00:46:15,606
不同网络条件下的表现


1200
00:46:16,146 --> 00:46:18,026
你现在可以到设备内部


1201
00:46:18,026 --> 00:46:20,806
在 Xcode 的模拟器面板中


1202
00:46:20,806 --> 00:46:23,226
访问设备条件


1203
00:46:23,646 --> 00:46:25,626
模拟不同的网络连接环境


1204
00:46:25,806 --> 00:46:26,886
这样你就可以看到


1205
00:46:26,886 --> 00:46:29,226
不同的情景下


1206
00:46:29,446 --> 00:46:30,416
用户的体验 [掌声]


1207
00:46:31,196 --> 00:46:33,286
这很棒


1208
00:46:35,736 --> 00:46:37,126
我们看一下如果是高延迟 DNS 链接


1209
00:46:37,296 --> 00:46:39,096
会发生什么


1210
00:46:40,256 --> 00:46:41,826
我点按 Start  


1211
00:46:41,826 --> 00:46:42,936
可以看出它在运行


1212
00:46:42,936 --> 00:46:45,496
因为左上角有一个


1213
00:46:45,496 --> 00:46:46,426
灰色框


1214
00:46:47,546 --> 00:46:50,716
现在 再次运行 probe


1215
00:46:50,716 --> 00:46:53,086
很快


1216
00:46:53,796 --> 00:46:55,926
很好 你会发现 


1217
00:46:55,926 --> 00:46:57,486
它来自过期缓存


1218
00:46:57,966 --> 00:46:59,226
也就是说 我们用的是


1219
00:46:59,276 --> 00:47:00,616
Optimistic DNS


1220
00:47:01,486 --> 00:47:04,476
Optimistic DNS 是默认运行的


1221
00:47:04,476 --> 00:47:06,196
如果你觉得


1222
00:47:06,196 --> 00:47:07,626
它不适合你的服务器的话


1223
00:47:07,626 --> 00:47:09,236
但是你可以关掉它


1224
00:47:09,956 --> 00:47:11,186
再次运行 probe 


1225
00:47:11,836 --> 00:47:14,796
你可以感受到几秒钟过去了


1226
00:47:15,796 --> 00:47:18,606
也许我有点夸张


1227
00:47:18,696 --> 00:47:19,936
希望你的用户不会遭遇


1228
00:47:19,936 --> 00:47:21,986
3 秒 DNS 延迟的情况


1229
00:47:21,986 --> 00:47:23,526
但是两种情况是很不一样的


1230
00:47:24,146 --> 00:47:26,956
现在我们尝试一个


1231
00:47:26,956 --> 00:47:30,086
更加现实的场景


1232
00:47:30,086 --> 00:47:31,836
比如常用的 3G 网络


1233
00:47:32,496 --> 00:47:35,956
启动


1234
00:47:35,956 --> 00:47:37,166
再一次运行 probe 


1235
00:47:37,766 --> 00:47:40,436
不像第一次运行的时候


1236
00:47:40,436 --> 00:47:41,356
那么快了


1237
00:47:42,096 --> 00:47:43,726
总的来说 你可以看到


1238
00:47:43,726 --> 00:47:45,866
建立连接


1239
00:47:45,866 --> 00:47:46,846
要 600 毫秒


1240
00:47:47,306 --> 00:47:51,786
TLS 花了不到


1241
00:47:51,786 --> 00:47:53,416
300 毫秒


1242
00:47:53,416 --> 00:47:56,826
也就是说差不多一半


1243
00:47:57,016 --> 00:47:59,006
所以我们的服务器被配置成


1244
00:47:59,006 --> 00:48:00,506
支持 TLS 1.3


1245
00:48:00,906 --> 00:48:04,166
现在 TLS 1.3 通常只需要一个往返


1246
00:48:04,206 --> 00:48:06,486
就可以完成一次握手


1247
00:48:06,776 --> 00:48:08,146
这是很大的进步


1248
00:48:09,086 --> 00:48:10,286
但是如果你的服务器


1249
00:48:10,286 --> 00:48:11,946
不支持 TLS 1.3


1250
00:48:11,946 --> 00:48:14,806
如果它只支持 TLS 1.2 


1251
00:48:14,806 --> 00:48:18,416
如果你 App 上使用的 API 


1252
00:48:18,416 --> 00:48:22,476
不支持 TLS 1.3


1253
00:48:22,476 --> 00:48:24,836
你可能会看到这种情况


1254
00:48:24,836 --> 00:48:27,326
TLS 自己花去 500 毫秒


1255
00:48:27,616 --> 00:48:30,246
多进行一轮往返


1256
00:48:31,166 --> 00:48:31,906
你可以看到


1257
00:48:31,906 --> 00:48:34,286
连接时间已经超过了


1258
00:48:34,286 --> 00:48:35,576
四分之三秒


1259
00:48:35,656 --> 00:48:36,496
差不多要一秒了


1260
00:48:36,926 --> 00:48:37,946
如果你有很多连接


1261
00:48:37,946 --> 00:48:39,796
用户会感受到


1262
00:48:39,796 --> 00:48:42,466
更久的延迟


1263
00:48:43,216 --> 00:48:44,376
所以我们建议


1264
00:48:44,376 --> 00:48:45,326
每当你测试 App 时


1265
00:48:45,326 --> 00:48:47,576
通过网络连接模拟器


1266
00:48:47,576 --> 00:48:49,276
运行它


1267
00:48:49,276 --> 00:48:50,856
测试一些场景


1268
00:48:50,856 --> 00:48:53,026
验证 App 是否运行良好


1269
00:49:01,196 --> 00:49:02,476
另一类指标


1270
00:49:02,476 --> 00:49:04,546
和建立连接后的


1271
00:49:04,546 --> 00:49:07,186
数据传输有关


1272
00:49:08,356 --> 00:49:10,576
所以在 URLSession 中 


1273
00:49:10,576 --> 00:49:12,456
现在你可以访问更多指标


1274
00:49:12,456 --> 00:49:13,566
数量相当于


1275
00:49:13,566 --> 00:49:15,496
你发送到请求的


1276
00:49:15,496 --> 00:49:17,186
Header 和 Body 的字节数


1277
00:49:17,186 --> 00:49:19,606
以及你从


1278
00:49:19,606 --> 00:49:21,356
请求的 Header 和 Body


1279
00:49:21,356 --> 00:49:24,686
收到的字节数


1280
00:49:25,606 --> 00:49:27,286
如果你选的是不同的 URL 


1281
00:49:27,286 --> 00:49:29,866
在一个低数据模式网络环境 


1282
00:49:30,126 --> 00:49:32,916
来下载较少的数据


1283
00:49:32,916 --> 00:49:35,946
这个就非常重要 


1284
00:49:36,026 --> 00:49:37,196
你要用它确认 


1285
00:49:37,256 --> 00:49:40,106
确实存储了用户的字节


1286
00:49:42,796 --> 00:49:44,616
在 Network.framework 中


1287
00:49:44,616 --> 00:49:46,506
你现在可以访问数据传输报告


1288
00:49:46,506 --> 00:49:48,426
这个报告总结了运行情况


1289
00:49:48,426 --> 00:49:52,886
包括字节 数据包 


1290
00:49:53,416 --> 00:49:56,606
和给定时间段内的往返次数


1291
00:49:56,986 --> 00:49:58,136
多个这些过程 


1292
00:49:58,136 --> 00:49:59,156
会同时运行 


1293
00:49:59,246 --> 00:50:00,976
并且它们要与 App 活动相对应


1294
00:50:01,236 --> 00:50:03,116
所以如果你要突然发送一段流


1295
00:50:03,116 --> 00:50:06,236
把它放入数据传输报告里


1296
00:50:06,896 --> 00:50:11,446
它不如闲置时间报告有趣


1297
00:50:11,976 --> 00:50:14,176
你要做的是  


1298
00:50:14,176 --> 00:50:15,956
在任何时间 你都可以在连接上


1299
00:50:15,956 --> 00:50:18,776
调用 startDataTransferReport 


1300
00:50:19,286 --> 00:50:21,896
首先 收集连接的


1301
00:50:21,896 --> 00:50:23,366
运行情况数据


1302
00:50:24,336 --> 00:50:25,946
发完一堆数据后


1303
00:50:25,946 --> 00:50:27,606
调用 collect


1304
00:50:28,316 --> 00:50:29,746
这会总结所有数据


1305
00:50:29,746 --> 00:50:31,606
给你一个报告


1306
00:50:32,836 --> 00:50:34,936
如果你用的是多路径协议


1307
00:50:34,996 --> 00:50:36,996
它会给你一个细分 


1308
00:50:36,996 --> 00:50:39,446
多路径线程


1309
00:50:39,446 --> 00:50:41,456
每条链接上正在使用的


1310
00:50:41,456 --> 00:50:42,976
数量细分


1311
00:50:43,896 --> 00:50:45,006
但是你们很多人 


1312
00:50:45,006 --> 00:50:47,316
只对聚合路径报告有兴趣


1313
00:50:48,716 --> 00:50:50,506
这里你可以查看


1314
00:50:50,506 --> 00:50:51,566
发送和接收的数据包数


1315
00:50:51,566 --> 00:50:53,386
传输的字节数


1316
00:50:53,386 --> 00:50:55,036
以及你观察到的


1317
00:50:55,036 --> 00:50:57,336
往返时间详细信息


1318
00:50:58,806 --> 00:51:00,756
这就是指标


1319
00:51:00,756 --> 00:51:02,306
我们特别想看到大家


1320
00:51:02,306 --> 00:51:04,316
用更多的指标


1321
00:51:04,416 --> 00:51:06,076
并且提升 App 的性能


1322
00:51:06,966 --> 00:51:08,726
现在我想把 Stuart 请上台


1323
00:51:08,726 --> 00:51:10,386
他将为大家带来


1324
00:51:10,386 --> 00:51:11,856
好的建议和新的更新


1325
00:51:12,516 --> 00:51:14,866
[掌声]


1326
00:51:15,366 --> 00:51:16,116
>> 谢谢你 Tommy


1327
00:51:17,516 --> 00:51:19,286
很荣幸


1328
00:51:19,606 --> 00:51:21,306
我能总结


1329
00:51:21,306 --> 00:51:23,326
我的同伴们 


1330
00:51:23,326 --> 00:51:24,766
用两个小时介绍的


1331
00:51:24,766 --> 00:51:26,046
联网信息


1332
00:51:26,916 --> 00:51:29,986
首先 我要介绍


1333
00:51:29,986 --> 00:51:30,906
Mac 版的 iPad App


1334
00:51:31,956 --> 00:51:33,666
我知道你们很多人对此很感兴趣


1335
00:51:34,206 --> 00:51:36,936
说到联网在 Apple 平台上


1336
00:51:36,936 --> 00:51:38,726
没有多大的区别


1337
00:51:39,536 --> 00:51:41,056
你需要注意的一件事是


1338
00:51:41,056 --> 00:51:44,626
在你的 Xcode 设置里


1339
00:51:44,626 --> 00:51:47,166
当你选择 Mac 的复选框时


1340
00:51:47,166 --> 00:51:51,826
现在你可以看到更多新选项


1341
00:51:52,216 --> 00:51:56,306
默认允许传出连接


1342
00:51:56,366 --> 00:51:57,636
如果你也想要传入连接


1343
00:51:57,636 --> 00:51:59,916
你要勾选那个复选框


1344
00:52:05,696 --> 00:52:07,976
在 watchOS 上 


1345
00:52:07,976 --> 00:52:09,396
我们有新的联网功能


1346
00:52:11,036 --> 00:52:12,946
用 AVFoundation 


1347
00:52:12,946 --> 00:52:16,016
做音频流的 App


1348
00:52:16,016 --> 00:52:18,756
现在可以使用直接联网


1349
00:52:18,756 --> 00:52:20,696
只要用的是 URLSession


1350
00:52:21,046 --> 00:52:22,136
或 Network.framework


1351
00:52:23,036 --> 00:52:24,576
Sockets 不可用


1352
00:52:30,156 --> 00:52:33,226
我们也介绍了 TLS 1.3


1353
00:52:33,636 --> 00:52:35,196
它会给你带来很多好处


1354
00:52:36,136 --> 00:52:38,866
TLS 1.3 联网性能更出色


1355
00:52:39,036 --> 00:52:42,106
TLS 1.2 一般需要两个往返 


1356
00:52:42,106 --> 00:52:43,466
才能建立一个连接


1357
00:52:43,546 --> 00:52:46,806
TLS 1.3 基本只需一个往返


1358
00:52:48,146 --> 00:52:51,646
TLS 1.2 用的是加密算法


1359
00:52:51,646 --> 00:52:53,236
我们曾经认为


1360
00:52:53,236 --> 00:52:54,896
加密算法很好


1361
00:52:54,896 --> 00:52:56,586
但是出现了问题


1362
00:52:56,586 --> 00:52:58,756
这不只是一个学术问题


1363
00:52:58,806 --> 00:53:00,486
这些都是实践出来的


1364
00:53:01,676 --> 00:53:03,566
这些问题都不会出现在


1365
00:53:03,566 --> 00:53:07,026
TLS 1.3 中


1366
00:53:07,026 --> 00:53:08,866
TLS 1.3 中所有的加密算法


1367
00:53:08,866 --> 00:53:13,696
都支持相关数据的认证加密


1368
00:53:13,986 --> 00:53:14,996
增强安全性


1369
00:53:16,176 --> 00:53:18,626
最后 大家都知道


1370
00:53:18,626 --> 00:53:20,466
对于 Apple 来说 隐私非常重要


1371
00:53:20,986 --> 00:53:23,416
TLS 1.3 在隐私方面做得更好


1372
00:53:24,176 --> 00:53:26,796
在 TLS 1.2 中 


1373
00:53:27,006 --> 00:53:30,166
很多 Header 域和证书


1374
00:53:30,166 --> 00:53:30,706
都是明文发送的


1375
00:53:31,186 --> 00:53:34,076
在 TLS 1.3 中都加密了


1376
00:53:34,686 --> 00:53:38,276
所以我们希望


1377
00:53:38,276 --> 00:53:39,736
大家都开始 


1378
00:53:39,736 --> 00:53:41,856
在 App 上用 TLS 1.3


1379
00:53:41,856 --> 00:53:43,456
当然也要确保服务器已更新 


1380
00:53:43,456 --> 00:53:46,996
支持 TLS 1.3


1381
00:53:47,616 --> 00:53:49,476
现在 大家都知道了


1382
00:53:49,476 --> 00:53:50,476
对于 Apple 来说隐私的重要性


1383
00:53:51,146 --> 00:53:52,936
我们意识到


1384
00:53:52,936 --> 00:53:56,416
接入 Wi-Fi


1385
00:53:56,416 --> 00:53:59,286
可能会暴露位置


1386
00:53:59,916 --> 00:54:02,936
从现在开始   


1387
00:54:02,936 --> 00:54:05,066
要访问那个 Wi-Fi 信息


1388
00:54:05,456 --> 00:54:07,586
和获取其他位置信息一样


1389
00:54:07,586 --> 00:54:09,736
你需要同样的权限


1390
00:54:10,786 --> 00:54:12,626
第一步是 


1391
00:54:12,626 --> 00:54:14,716
在 Xcode 里


1392
00:54:14,716 --> 00:54:16,846
添加访问 Wi-Fi 信息的能力


1393
00:54:16,846 --> 00:54:18,666
添加权限到你的项目


1394
00:54:18,666 --> 00:54:22,266
然后你的 App 必须满足


1395
00:54:22,266 --> 00:54:23,706
其他三个标准之一


1396
00:54:23,706 --> 00:54:26,086
其一 如果用户已经给了你的 App


1397
00:54:26,386 --> 00:54:28,496
位置访问权限 


1398
00:54:28,496 --> 00:54:30,416
那么你可以访问 Wi-Fi 网络信息


1399
00:54:31,556 --> 00:54:33,356
其二 如果你的 App 是设备上


1400
00:54:33,356 --> 00:54:35,766
当前启用的 VPN App


1401
00:54:36,376 --> 00:54:37,816
你可以访问信息


1402
00:54:37,986 --> 00:54:40,146
最后 如果你的 App 


1403
00:54:40,146 --> 00:54:42,276
是任何热点配置 App 


1404
00:54:42,676 --> 00:54:44,036
它可以访问信息 


1405
00:54:44,036 --> 00:54:45,396
但是只能访问


1406
00:54:45,396 --> 00:54:47,276
配置的网络信息


1407
00:54:48,496 --> 00:54:49,896
如果想要了解更多


1408
00:54:49,896 --> 00:54:51,436
可以看一下 Wi-Fi 框架


1409
00:54:52,066 --> 00:54:55,996
今天你已经听到过很多次了


1410
00:54:55,996 --> 00:54:57,096
最后我要再提一下


1411
00:54:57,096 --> 00:55:00,356
使用网络模拟工具的重要性


1412
00:55:02,166 --> 00:55:03,716
当你在 Mac 上开发 App 时


1413
00:55:03,716 --> 00:55:05,446
如果模拟器是千兆以太网


1414
00:55:05,446 --> 00:55:08,666
或在环回接口上


1415
00:55:08,666 --> 00:55:10,296
与本地服务器对话时


1416
00:55:10,296 --> 00:55:12,816
就会很简单


1417
00:55:13,396 --> 00:55:15,686
如果你的服务器没有延迟


1418
00:55:15,786 --> 00:55:18,216
带宽是无限的


1419
00:55:18,776 --> 00:55:20,496
那毫无疑问 性能会很好


1420
00:55:20,496 --> 00:55:23,276
但是如果你按这种条件搭建 App


1421
00:55:23,276 --> 00:55:25,996
那就大错特错了


1422
00:55:25,996 --> 00:55:27,836
当用户真正开始


1423
00:55:27,836 --> 00:55:29,186
使用你的 App 时 


1424
00:55:29,186 --> 00:55:30,336
你就会发现性能并不好


1425
00:55:31,006 --> 00:55:33,566
如果你从 


1426
00:55:33,826 --> 00:55:36,736
一开始开发 App


1427
00:55:37,406 --> 00:55:40,706
就养成习惯 


1428
00:55:40,706 --> 00:55:44,056
到设备情况里选择现实的


1429
00:55:44,056 --> 00:55:46,396
网络连接环境 


1430
00:55:46,396 --> 00:55:47,626
一直模拟真实的网络环境


1431
00:55:47,936 --> 00:55:49,516
检测运行你的 App


1432
00:55:49,516 --> 00:55:52,866
那么那些 Bug


1433
00:55:52,866 --> 00:55:57,106
就根本不会出现


1434
00:55:57,186 --> 00:55:59,056
多年来 我们一直向大家传递的 


1435
00:55:59,056 --> 00:56:01,706
另一个信息是


1436
00:56:01,706 --> 00:56:04,966
避免启动时检查


1437
00:56:05,186 --> 00:56:08,936
使用蜂窝数据


1438
00:56:08,936 --> 00:56:10,696
或较贵的网络之类的约束


1439
00:56:10,696 --> 00:56:13,216
实现更好的控制


1440
00:56:13,366 --> 00:56:14,756
这样就简单多了


1441
00:56:14,926 --> 00:56:16,606
一旦你开始这样开发 App


1442
00:56:16,606 --> 00:56:18,606
你就会问自己


1443
00:56:18,606 --> 00:56:19,986
为什么之前要启动时检查


1444
00:56:20,236 --> 00:56:22,326
而且启动时检查


1445
00:56:22,326 --> 00:56:24,156
并不可靠 


1446
00:56:24,156 --> 00:56:25,636
因为它们总是带来问题


1447
00:56:26,526 --> 00:56:28,666
我举个例子


1448
00:56:28,666 --> 00:56:30,556
来说明这一点


1449
00:56:30,556 --> 00:56:32,776
这个是我很喜欢的一个 App


1450
00:56:33,316 --> 00:56:36,136
因为要说明这个情况 


1451
00:56:36,636 --> 00:56:38,356
我故意做了一个


1452
00:56:38,626 --> 00:56:41,366
夸张的例子 看看


1453
00:56:41,366 --> 00:56:42,506
如果这个 App 写的不好 


1454
00:56:42,506 --> 00:56:43,166
会发生什么


1455
00:56:43,736 --> 00:56:45,036
这是在告诉用户


1456
00:56:45,176 --> 00:56:46,646
确保连接了 Wi-Fi 


1457
00:56:46,646 --> 00:56:47,376
然后点按按钮


1458
00:56:48,056 --> 00:56:49,536
但是用户并不能


1459
00:56:49,536 --> 00:56:51,836
控制选择


1460
00:56:51,836 --> 00:56:52,926
哪条联网路径


1461
00:56:53,366 --> 00:56:55,556
他们一般会


1462
00:56:55,556 --> 00:56:57,406
找 Wi-Fi 栏 希望连接到最佳网络


1463
00:56:58,226 --> 00:57:00,016
但是今天你知道了


1464
00:57:01,536 --> 00:57:03,336
在测试之前 


1465
00:57:03,336 --> 00:57:06,776
你不可能知道 Wi-Fi 情况是什么样


1466
00:57:07,516 --> 00:57:09,696
设备可能以为自己连接了 Wi-Fi


1467
00:57:09,696 --> 00:57:11,286
但是当它想用的时候


1468
00:57:11,286 --> 00:57:13,396
发现  Wi-Fi 不能用


1469
00:57:13,496 --> 00:57:15,906
现在 当 Wi-Fi Assist


1470
00:57:15,906 --> 00:57:18,036
把你从 Wi-Fi 转换到蜂窝数据时


1471
00:57:18,036 --> 00:57:19,776
那些 Wi-Fi 栏都消失了


1472
00:57:20,236 --> 00:57:21,496
但是已经晚了


1473
00:57:21,496 --> 00:57:22,746
你已经开始连接了


1474
00:57:23,546 --> 00:57:28,816
所以不要让用户猜测


1475
00:57:29,256 --> 00:57:30,436
不要只是


1476
00:57:30,436 --> 00:57:31,136
期待最优的网络


1477
00:57:31,706 --> 00:57:32,576
我来演示一下


1478
00:57:32,576 --> 00:57:35,096
这个 App 实际上是什么样


1479
00:57:35,386 --> 00:57:36,886
它将连接限制到


1480
00:57:37,796 --> 00:57:40,576
不允许访问蜂窝数据


1481
00:57:41,176 --> 00:57:44,816
在 iOS 13 里启动它


1482
00:57:44,816 --> 00:57:47,186
实际上 它使用


1483
00:57:47,186 --> 00:57:49,036
allowsExpensiveNetworkAccess 控件


1484
00:57:49,186 --> 00:57:50,956
让系统选择


1485
00:57:51,096 --> 00:57:52,486
哪个是较贵的网络


1486
00:57:53,666 --> 00:57:55,226
它还设置


1487
00:57:55,226 --> 00:57:57,076
waitsForConnectivity 为真


1488
00:57:57,466 --> 00:57:58,866
这意味着 


1489
00:57:59,196 --> 00:58:01,276
App 不需要反复重试


1490
00:58:01,586 --> 00:58:02,766
系统会一直


1491
00:58:02,766 --> 00:58:04,046
耐心等待


1492
00:58:04,046 --> 00:58:05,726
直到成功连接


1493
00:58:07,306 --> 00:58:09,876
当 App 尝试连接时


1494
00:58:09,876 --> 00:58:11,896
如果没有 Wi-Fi


1495
00:58:12,526 --> 00:58:14,506
它的 taskIsWaitingForConnectivity 代理


1496
00:58:14,506 --> 00:58:16,776
会被调用 


1497
00:58:16,776 --> 00:58:18,616
这时它会显示 UI


1498
00:58:18,616 --> 00:58:20,906
让用户选择


1499
00:58:20,906 --> 00:58:22,516
要么移步到有 Wi-Fi 的地方


1500
00:58:22,516 --> 00:58:23,986
要么按下按钮


1501
00:58:23,986 --> 00:58:25,576
使用蜂窝数据


1502
00:58:26,896 --> 00:58:29,126
一些关于弃用的消息


1503
00:58:30,236 --> 00:58:31,786
如果还有人在用 PAC 文件 


1504
00:58:31,786 --> 00:58:35,046
用这种文件 或者 FTP URL 方案


1505
00:58:35,226 --> 00:58:37,476
要注意 我们已经不支持这些了


1506
00:58:38,656 --> 00:58:40,366
SPDY 曾是非常好的


1507
00:58:40,366 --> 00:58:41,906
实验协议


1508
00:58:41,906 --> 00:58:44,176
如果还有人用 SPDY 要注意


1509
00:58:44,176 --> 00:58:46,496
SPDY 现在已经被 HTTP 2 取代了


1510
00:58:47,006 --> 00:58:48,786
Apple 现在支持的是 HTTP 2


1511
00:58:48,786 --> 00:58:50,726
一切都应朝着这个方向发展


1512
00:58:51,516 --> 00:58:54,066
而且 Secure Transport 


1513
00:58:54,066 --> 00:58:56,906
不支持 TLS 1.3 


1514
00:58:56,906 --> 00:58:59,636
永远也不会支持 TLS 1.3 


1515
00:58:59,636 --> 00:59:01,646
这也是选择 URLSession 或


1516
00:59:01,646 --> 00:59:02,536
Network.framework 的另一原因


1517
00:59:03,066 --> 00:59:08,156
所以 总的来说 今天早晨


1518
00:59:08,156 --> 00:59:10,606
我们介绍了广域 Bonjour 发现  


1519
00:59:10,606 --> 00:59:17,756
以及如何发布一个


1520
00:59:17,756 --> 00:59:18,796
井字游戏 


1521
00:59:19,076 --> 00:59:22,386
有些人可能会想


1522
00:59:22,386 --> 00:59:23,816
serviceType_tictactoe


1523
00:59:23,816 --> 00:59:26,796
是否注册到了 Ayana


1524
00:59:27,056 --> 00:59:28,786
答案是肯定的


1525
00:59:28,786 --> 00:59:29,716
你可以去网站上看看 [笑声]


1526
00:59:33,376 --> 00:59:34,736
Tommy 介绍了


1527
00:59:34,736 --> 00:59:37,086
搭建协议框架


1528
00:59:37,086 --> 00:59:39,436
收集指标


1529
00:59:39,436 --> 00:59:40,936
让你写 App 变得更容易


1530
00:59:41,396 --> 00:59:43,616
也更容易考量性能


1531
00:59:44,226 --> 00:59:48,226
今天早晨 我们还讨论了


1532
00:59:48,226 --> 00:59:50,506
低数据模式


1533
00:59:50,506 --> 00:59:52,206
要尊重用户


1534
00:59:52,206 --> 00:59:53,836
何时保存数据的需求


1535
00:59:54,526 --> 00:59:56,006
我们还讨论了


1536
00:59:56,006 --> 00:59:57,636
结合 URLSession 


1537
00:59:57,636 --> 00:59:59,866
可以很好地链接异步操作


1538
00:59:59,866 --> 01:00:01,976
我们还讨论了 WebSocket


1539
01:00:02,046 --> 01:00:04,776
如果你的 App 是基于网页的


1540
01:00:04,776 --> 01:00:06,466
它用 WebSocket


1541
01:00:06,466 --> 01:00:08,126
和服务器交流


1542
01:00:08,126 --> 01:00:09,726
现在你可以在本地 iOS App 中


1543
01:00:09,726 --> 01:00:11,876
使用同一台服务器


1544
01:00:12,886 --> 01:00:14,816
Christoph Paasch 


1545
01:00:14,816 --> 01:00:16,376
介绍了所有的移动改进


1546
01:00:16,376 --> 01:00:20,626
通过多路径 TCP 和 Wi-Fi Assist 实现


1547
01:00:21,486 --> 01:00:23,946
关于这一点


1548
01:00:24,456 --> 01:00:27,446
你们很多人会知道 ACM SIGCOMM 


1549
01:00:27,806 --> 01:00:30,906
是世界上最重要的


1550
01:00:31,116 --> 01:00:32,546
网络研究学术会议


1551
01:00:34,036 --> 01:00:35,686
每年都有


1552
01:00:35,686 --> 01:00:37,446
网络系统奖


1553
01:00:37,446 --> 01:00:39,366
选出网络领域


1554
01:00:39,366 --> 01:00:42,586
最有影响力的成就


1555
01:00:43,336 --> 01:00:45,286
今年 今天


1556
01:00:45,516 --> 01:00:47,536
他们宣布 今年的奖颁给了 


1557
01:00:47,996 --> 01:00:49,566
Christoph Paasch


1558
01:00:49,566 --> 01:00:51,676
以及多路径 TCP 团队的其他人


1559
01:00:52,516 --> 01:01:00,886
[掌声]


1560
01:01:01,386 --> 01:01:02,606
我们希望在明天的


1561
01:01:02,606 --> 01:01:04,376
网络实验室看到大家


1562
01:01:04,986 --> 01:01:07,036
如果你们有人现在在写


1563
01:01:07,036 --> 01:01:08,076
网络内核扩展的话


1564
01:01:08,076 --> 01:01:09,786
明天一定要去参加


1565
01:01:09,786 --> 01:01:11,746
《Network Extensions for Modern macOS》


1566
01:01:11,746 --> 01:01:13,976
这一场会议 谢谢大家


1567
01:01:14,516 --> 01:01:17,500
[掌声]

