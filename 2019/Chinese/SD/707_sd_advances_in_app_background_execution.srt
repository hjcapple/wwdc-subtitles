1
00:00:06,640 --> 00:00:11,512 line:0
（关于APP后台执行的改进）


2
00:00:13,280 --> 00:00:16,082 line:-1
我是Roberto


3
00:00:16,149 --> 00:00:17,017 line:-1
来自Apple的软件电量团队


4
00:00:17,084 --> 00:00:18,886 line:-1
今天能来到这里 我感到万分激动


5
00:00:19,186 --> 00:00:21,355 line:-2
我要与大家分享
关于App后台执行的改进


6
00:00:21,421 --> 00:00:22,890 line:-1
（关于APP后台执行的改进）


7
00:00:23,590 --> 00:00:25,259 line:-1
用户们喜欢用app


8
00:00:25,659 --> 00:00:28,896 line:-2
他们喜欢用app的原因是因为
app为他们提供许多很优秀的体验


9
00:00:29,596 --> 00:00:32,766 line:-2
有些是在前台
当用户积极地使用app时


10
00:00:33,467 --> 00:00:35,269 line:-1
而有些是在后台


11
00:00:35,335 --> 00:00:38,038 line:-1
要求后台执行才能实现


12
00:00:38,705 --> 00:00:41,408 line:0
如果我们提出可能需要后台执行的
一个列表


13
00:00:41,742 --> 00:00:43,343 line:0
我们可能会提出类似这样的东西


14
00:00:43,844 --> 00:00:47,214 line:0
比如导航或配件通讯


15
00:00:47,548 --> 00:00:49,550 line:0
或也许是定期更新和下载


16
00:00:50,117 --> 00:00:53,620 line:0
在Apple我们设计了
提供后台执行的API


17
00:00:53,687 --> 00:00:55,923 line:0
用于处理这些用例和提供此类体验


18
00:00:57,591 --> 00:01:00,060 line:-1
今天我们要讲的是后台执行


19
00:01:00,394 --> 00:01:01,461 line:-1
先概述一下


20
00:01:01,762 --> 00:01:04,096 line:-1
然后接着讲一些最佳实践


21
00:01:04,631 --> 00:01:06,767 line:-1
最后我同事Thomas会上台来


22
00:01:06,834 --> 00:01:08,869 line:-1
介绍一个新的后台任务框架


23
00:01:08,936 --> 00:01:11,338 line:-1
提供新的后台执行的机会


24
00:01:13,340 --> 00:01:15,509 line:-1
让我们先简单了解一下后台执行


25
00:01:15,576 --> 00:01:16,910 line:-1
（后台执行概述）


26
00:01:16,977 --> 00:01:20,581 line:0
我们可以先回答这个问题
什么是后台执行？


27
00:01:20,647 --> 00:01:21,715 line:0
我们是指什么？


28
00:01:21,782 --> 00:01:24,585 line:0
当我们提到后台时
我们可以指很多东西


29
00:01:24,651 --> 00:01:26,920 line:0
后台线程或后台队列


30
00:01:27,421 --> 00:01:29,156 line:0
但当我们讲后台执行时


31
00:01:29,223 --> 00:01:32,292 line:0
我们指的是当app不处于前台时


32
00:01:32,593 --> 00:01:34,161 line:0
运行我们的执行代码


33
00:01:35,062 --> 00:01:36,663 line:0
请看这个图表


34
00:01:37,030 --> 00:01:39,032 line:-1
我们指的是第三个方框


35
00:01:39,366 --> 00:01:41,468 line:-1
app在后台运行


36
00:01:41,535 --> 00:01:43,437 line:-1
但用户不一定能看到它运行


37
00:01:45,372 --> 00:01:47,474 line:-1
我们为什么要进入这种状态呢？


38
00:01:47,908 --> 00:01:49,843 line:-1
这可以归结为两种途径


39
00:01:50,677 --> 00:01:52,446 line:-1
第一种是app发出请求


40
00:01:53,080 --> 00:01:55,816 line:-1
这应用于更通用的后台执行


41
00:01:56,083 --> 00:01:59,953 line:-2
当app想实施一些工作时
它可以向系统发出请求


42
00:02:00,721 --> 00:02:03,790 line:-2
你可以思考一下
比如说下载或定期更新


43
00:02:04,124 --> 00:02:05,893 line:-1
或也许是完成一些后台工作


44
00:02:06,960 --> 00:02:09,830 line:-1
第二种是通过特定的事件触发器


45
00:02:10,497 --> 00:02:13,834 line:-1
app获得后台时间


46
00:02:13,901 --> 00:02:16,170 line:-1
以响应某件事


47
00:02:16,970 --> 00:02:19,873 line:-1
比如也许用户去了国外


48
00:02:20,340 --> 00:02:22,075 line:-1
或也许有一些新的健康数据


49
00:02:22,142 --> 00:02:23,677 line:-1
App需要引起注意


50
00:02:25,946 --> 00:02:29,583 line:-2
当在后台运行时
我们特别在意用户体验


51
00:02:29,917 --> 00:02:32,019 line:-2
因此当我们设计API来支持
这些用例时


52
00:02:32,085 --> 00:02:34,254 line:-1
我们有许多重要因素要考虑


53
00:02:34,988 --> 00:02:35,989 line:-1
我想强调其中三个因素


54
00:02:36,056 --> 00:02:37,758 line:-1
（关于后台执行的重要因素）


55
00:02:37,824 --> 00:02:41,562 line:-1
电源、性能和隐私


56
00:02:44,031 --> 00:02:45,065 line:-1
先讲电源


57
00:02:45,732 --> 00:02:48,802 line:-2
无论何时当你的app在前台或后台
运行时


58
00:02:49,236 --> 00:02:50,470 line:-1
都需要使用电源


59
00:02:50,838 --> 00:02:54,074 line:-2
随时间流逝 这会消耗能量
并会消耗电池


60
00:02:55,475 --> 00:02:57,244 line:-2
为了可视化这种消耗
让我们看一个时间线


61
00:02:57,678 --> 00:03:00,280 line:-2
左侧可能是一天的开始
当太阳升起时


62
00:03:00,347 --> 00:03:02,149 line:-1
而右侧可能是一天的结束


63
00:03:02,516 --> 00:03:05,419 line:-2
也许在一天结束时用户决定
给设备充电


64
00:03:06,486 --> 00:03:08,789 line:-1
我们用那个绿色充电区来代表它


65
00:03:09,556 --> 00:03:12,326 line:-1
我们用这些浅阴影矩形


66
00:03:12,392 --> 00:03:13,861 line:-1
来标绘app在前台运行的时间


67
00:03:14,695 --> 00:03:16,797 line:-1
我们用这些深阴影矩形


68
00:03:16,864 --> 00:03:18,265 line:-1
来标绘app在后台运行的时间


69
00:03:19,233 --> 00:03:20,434 line:-1
如果运行时间越长


70
00:03:20,767 --> 00:03:22,402 line:-1
我们就会越消耗电量


71
00:03:22,970 --> 00:03:25,272 line:-2
如果我们运行时间越短
电量消耗就会越少


72
00:03:26,473 --> 00:03:28,475 line:-1
因此 当我们设计API时


73
00:03:28,542 --> 00:03:31,845 line:-2
我们主要关注为了支持特定用例
所需要的运行时间


74
00:03:31,912 --> 00:03:33,413 line:-1
同时保持良好的电量


75
00:03:33,747 --> 00:03:36,583 line:-2
当使用这些API时
考虑如何有效地使用它们


76
00:03:36,850 --> 00:03:40,554 line:-2
当你完成后
请通过调用完成处理器来警告系统


77
00:03:41,088 --> 00:03:43,290 line:-2
那样 如果系统为你的app提供了
运行时间


78
00:03:43,624 --> 00:03:45,726 line:-2
你可以告诉系统说
“嘿 我提前完成了”


79
00:03:46,026 --> 00:03:49,096 line:-2
系统可以挂起你的app
然后你就会停止消耗用户的电量


80
00:03:50,531 --> 00:03:52,099 line:-1
接下来是性能


81
00:03:52,733 --> 00:03:55,435 line:-1
我们希望系统能尽可能流畅地运行


82
00:03:56,136 --> 00:03:59,640 line:-2
这意味着我们希望能快速启动app
并希望UI能快速响应


83
00:04:00,107 --> 00:04:02,809 line:-1
当我们在后台运行时 这尤其重要


84
00:04:03,043 --> 00:04:06,413 line:-1
原因是虽然我们可能会认为


85
00:04:06,480 --> 00:04:10,517 line:-1
一天之中只有一个app在运行


86
00:04:11,552 --> 00:04:14,688 line:0
但实际上一天中不同的时间点
有多个app在运行


87
00:04:14,755 --> 00:04:16,322 line:0
在前台和后台


88
00:04:17,658 --> 00:04:18,692 line:-1
当我们遮掩这件事时


89
00:04:18,759 --> 00:04:20,827 line:-2
我们可以看到我们的app可能正在
后台运行


90
00:04:20,894 --> 00:04:22,796 line:-1
而同时另一个app正在前台运行


91
00:04:23,330 --> 00:04:25,199 line:-1
或者当一个app正在前台运行时


92
00:04:25,265 --> 00:04:26,800 line:-1
有多个app正在后台运行


93
00:04:27,234 --> 00:04:28,669 line:-1
因此当我们设计API时


94
00:04:29,269 --> 00:04:32,339 line:-2
我们要考虑设置智能
CPU和内存限制


95
00:04:32,406 --> 00:04:34,541 line:-1
从而最小化对其它用途的影响


96
00:04:35,042 --> 00:04:36,410 line:-1
当使用这些API时


97
00:04:36,777 --> 00:04:38,645 line:-1
你应该注意这些限制是多少


98
00:04:38,712 --> 00:04:40,814 line:-1
从而不会影响用户正在积极去做的事


99
00:04:41,048 --> 00:04:43,617 line:-2
但更重要的是那样系统
不会终止你的app


100
00:04:44,084 --> 00:04:45,619 line:-1
然后当你的app以后再启动时


101
00:04:45,686 --> 00:04:46,820 line:-1
它的启动速度可能会变慢


102
00:04:48,755 --> 00:04:51,024 line:-1
最后一个重要因素是隐私


103
00:04:51,592 --> 00:04:55,195 line:-2
用户非常敏感
非常关心他们的私人数据


104
00:04:55,796 --> 00:04:58,465 line:-1
他们也许了解


105
00:04:58,532 --> 00:05:00,033 line:-1
app每一次在前台的运行


106
00:05:00,100 --> 00:05:02,970 line:-1
并期待能访问某些信息


107
00:05:03,537 --> 00:05:07,207 line:-2
他们可能没有意识到app每一次
在后台的运行


108
00:05:08,275 --> 00:05:09,776 line:-1
因此当我们设计API时


109
00:05:09,843 --> 00:05:12,846 line:-2
这意味着我们要使用不同的API
来适应不同的用例


110
00:05:13,180 --> 00:05:15,983 line:-2
每个API都要访问
自己特定的数据集


111
00:05:16,049 --> 00:05:17,251 line:-1
它需要支持那些数据


112
00:05:17,718 --> 00:05:18,919 line:-1
当使用这些API时


113
00:05:18,986 --> 00:05:20,888 line:-1
考虑一下对用户的透明度该有多大


114
00:05:21,722 --> 00:05:24,424 line:-1
并让他们了解你正在使用哪些数据


115
00:05:25,692 --> 00:05:27,594 line:-1
这些是关于后台执行


116
00:05:27,661 --> 00:05:29,396 line:-1
要考虑的三个重要因素


117
00:05:29,796 --> 00:05:32,099 line:-1
电源、性能和隐私


118
00:05:33,033 --> 00:05:34,868 line:0
当我们返回到用例列表时


119
00:05:35,335 --> 00:05:38,405 line:0
这些不同的用例
要转化为不同的API


120
00:05:39,173 --> 00:05:42,609 line:0
每个API都要有不同的要求
才能实现所预期的行为


121
00:05:42,910 --> 00:05:45,112 line:0
同时保持优秀的用户体验


122
00:05:47,281 --> 00:05:48,916 line:-1
现在我们已经有了个大概的了解


123
00:05:48,982 --> 00:05:52,386 line:-2
让我们深入一些最佳实践
遵循某些特定模式


124
00:05:52,853 --> 00:05:54,555 line:-1
了解一下API发生了哪些变更


125
00:05:56,390 --> 00:05:59,426 line:0
为此 让我们以一款消息app为例


126
00:05:59,760 --> 00:06:01,528 line:0
它可能有核心功能 比如


127
00:06:01,929 --> 00:06:04,531 line:0
发消息或接打电话


128
00:06:05,098 --> 00:06:06,967 line:0
然后它可能还有一些额外功能 比如


129
00:06:07,034 --> 00:06:11,572 line:0
可以让用户设置消息免打扰
或下载以前的附件


130
00:06:12,306 --> 00:06:14,241 line:0
现在我们要看一下这四个步骤


131
00:06:14,508 --> 00:06:16,977 line:0
讲一下我们要使用哪个API来实现
每个功能


132
00:06:18,412 --> 00:06:19,847 line:-1
第一个功能是发消息


133
00:06:20,681 --> 00:06:23,250 line:-1
发消息是app的核心功能


134
00:06:23,817 --> 00:06:25,352 line:-1
如果我给我朋友发消息


135
00:06:25,419 --> 00:06:28,655 line:-2
我希望它能马上送达
而不是需要一天或一周


136
00:06:29,823 --> 00:06:32,326 line:-1
因此用户期待这个功能可以立即完成


137
00:06:33,293 --> 00:06:35,963 line:-1
虽然这通常很快


138
00:06:36,396 --> 00:06:38,031 line:-1
但有时候情况并非如此


139
00:06:38,532 --> 00:06:41,535 line:-1
也许网络拥挤或也许后台服务器慢


140
00:06:42,035 --> 00:06:44,137 line:-2
可能需要一些额外的时间
才能发送消息


141
00:06:44,972 --> 00:06:46,039 line:-1
在这段额外的时间内


142
00:06:46,106 --> 00:06:49,209 line:-2
用户可能甚至会离开app
或放下手机并锁定它


143
00:06:49,910 --> 00:06:53,113 line:-2
因此我们需要一种方式来保护
这个任务的完成


144
00:06:53,814 --> 00:06:55,415 line:-1
我们要确定我们的消息已成功发送


145
00:06:55,482 --> 00:06:58,585 line:-2
从而当用户返回app时不会发生
这种情况


146
00:06:58,952 --> 00:07:01,088 line:-2
“嘿 为什么我的消息没有发送给
我朋友”


147
00:07:02,389 --> 00:07:04,892 line:-2
这个功能要使用的API是
BackgroundTaskCompletion


148
00:07:06,093 --> 00:07:07,694 line:-2
它会为app
提供一些额外的运行时间


149
00:07:08,128 --> 00:07:10,163 line:-1
在app被挂起之前在后台运行


150
00:07:11,031 --> 00:07:14,067 line:-2
要使用这个API你要调用
UIApplicationBeginBackgroundTask


151
00:07:14,134 --> 00:07:17,004 line:-2
或调用
ProcessInfoPerformExpiringActivity


152
00:07:17,271 --> 00:07:18,672 line:-1
如果app是在扩展中运行的话


153
00:07:19,006 --> 00:07:22,543 line:-2
再说一次 这是为了要完成
从前台发起的任务


154
00:07:22,809 --> 00:07:25,913 line:-1
其它例子可能包括把文件保存到磁盘


155
00:07:26,246 --> 00:07:28,782 line:-1
或完成任意用户发起的请求


156
00:07:29,616 --> 00:07:31,618 line:-1
让我们在代码中看一下


157
00:07:31,685 --> 00:07:33,153 line:-1
我们那个发消息的例子


158
00:07:34,354 --> 00:07:36,156 line:-1
这是发送消息函数


159
00:07:37,858 --> 00:07:40,394 line:-1
在函数中 当我们创建发送操作之后


160
00:07:40,794 --> 00:07:42,329 line:-2
我们调用
BeginBackgroundTask


161
00:07:42,729 --> 00:07:44,164 line:-1
这就让系统了解


162
00:07:44,231 --> 00:07:47,301 line:-2
“嘿 我们正在执行任务
即使用户把app放到后台


163
00:07:47,668 --> 00:07:49,203 line:-1
也让我们继续完成它”


164
00:07:51,205 --> 00:07:53,073 line:-1
然后当我们发送完成后


165
00:07:53,574 --> 00:07:55,042 line:-1
我们…在完成代码块中


166
00:07:55,108 --> 00:07:58,245 line:-1
我们会告诉系统结束后台任务


167
00:07:58,312 --> 00:07:59,346 line:-1
我们不再需要时间了


168
00:07:59,847 --> 00:08:01,682 line:-2
这是为了以下情况
当系统为我们提供了一些时间


169
00:08:01,748 --> 00:08:03,283 line:-2
用户把app放到后台
而我们的任务执行完成后


170
00:08:03,350 --> 00:08:04,985 line:-1
我们要告诉系统把app挂起来


171
00:08:05,285 --> 00:08:06,887 line:-1
因此我们就不再消耗用户的电量了


172
00:08:06,954 --> 00:08:08,622 line:-1
或不再潜在地影响他们的性能了


173
00:08:09,456 --> 00:08:10,624 line:-1
我还要强调最后一件事


174
00:08:11,158 --> 00:08:14,595 line:-2
有些情况是也许系统给了你一些
额外的时间


175
00:08:14,661 --> 00:08:17,364 line:-1
但情况太糟糕了 也许网络特别拥挤


176
00:08:17,798 --> 00:08:20,200 line:-2
我们甚至在额外的时间内也不能
完成任务


177
00:08:20,601 --> 00:08:22,836 line:-1
为此 我们有一个过期处理器


178
00:08:23,237 --> 00:08:25,839 line:-1
系统可以在这个时候调用过期处理器


179
00:08:26,373 --> 00:08:29,343 line:-2
在这个例子中
我们会给用户发布一条用户通知


180
00:08:29,409 --> 00:08:30,677 line:-1
一则本地通知


181
00:08:30,744 --> 00:08:33,746 line:-2
内容是“嘿 请回到app中
因为消息未发送”


182
00:08:35,482 --> 00:08:37,417 line:-1
那么回顾一下 当我们发送消息时


183
00:08:37,717 --> 00:08:41,154 line:-2
我们用BackgroundTaskCompletions
保护它的发送


184
00:08:42,155 --> 00:08:45,125 line:-2
我们想确保我们根据用户的动作
开始了这个任务


185
00:08:45,492 --> 00:08:47,461 line:-1
我们不想等到我们进入后台


186
00:08:47,528 --> 00:08:48,896 line:-2
才能调用
BeginBackgroundTask


187
00:08:49,263 --> 00:08:50,397 line:-1
因为如果我们这样做了


188
00:08:50,464 --> 00:08:53,333 line:-1
会限制在系统挂起app之前


189
00:08:53,400 --> 00:08:55,002 line:-1
我们积极尝试发送消息的时间


190
00:08:56,970 --> 00:08:59,039 line:-1
现在我们讲了发消息


191
00:08:59,239 --> 00:09:00,307 line:-1
接下来让我们讲接打电话


192
00:09:00,374 --> 00:09:01,708 line:-1
（接打电话）


193
00:09:01,775 --> 00:09:06,013 line:-1
我可能一直想给我的朋友们发消息


194
00:09:06,079 --> 00:09:07,881 line:-1
但有时你只想接通电话


195
00:09:07,948 --> 00:09:10,150 line:-1
快速接听电话


196
00:09:10,484 --> 00:09:12,819 line:-2
告诉他们一些事
这样你就不需要打字了


197
00:09:13,520 --> 00:09:17,124 line:-2
有个API能实现这个功能
即VoIPPushNotifications


198
00:09:17,791 --> 00:09:20,460 line:-2
这是一种特殊的推送类型
可以启动你的app


199
00:09:20,794 --> 00:09:21,762 line:-1
并为它提供一些运行时间


200
00:09:21,828 --> 00:09:24,831 line:-2
那样你可以向用户呈现
有人给他们打电话的事实


201
00:09:24,898 --> 00:09:26,333 line:-1
然后用户可以接电话


202
00:09:27,935 --> 00:09:28,936 line:-1
为了实现这个功能


203
00:09:29,303 --> 00:09:30,938 line:-1
你只需要在注册VoIP推送时


204
00:09:32,206 --> 00:09:36,310 line:-2
在PK推送注册中
设置VoIP推送类型


205
00:09:39,646 --> 00:09:41,114 line:-1
今年有个新改进


206
00:09:41,448 --> 00:09:45,152 line:-2
你必须在didReceiveIncomingPush
回调中


207
00:09:45,752 --> 00:09:48,589 line:-2
使用CallKit报告来电
这一点非常重要


208
00:09:49,223 --> 00:09:50,624 line:-1
否则你的app将被终止


209
00:09:51,191 --> 00:09:53,060 line:-1
并且如果你反复这样做


210
00:09:53,393 --> 00:09:56,129 line:-1
或如果导入来电反复失败


211
00:09:56,430 --> 00:09:59,533 line:-2
系统可能会完全停止启动app
进行VoIP推送


212
00:10:00,968 --> 00:10:04,004 line:-2
让我们看一下如何在代码中
适应这个变更


213
00:10:05,239 --> 00:10:08,175 line:-2
这是我们的didReceiveIncomingPush
回调


214
00:10:08,909 --> 00:10:12,613 line:-2
在回调内我们看到如果推送类型
是VoIP


215
00:10:12,679 --> 00:10:14,748 line:-1
我们将使用来自推送有效载荷的信息


216
00:10:14,815 --> 00:10:17,017 line:-1
来填充CX呼叫更新对象


217
00:10:17,451 --> 00:10:21,555 line:-1
然后使用CX提供器报告新来电


218
00:10:25,125 --> 00:10:27,661 line:-1
你需要确保在那个方法返回之前


219
00:10:27,728 --> 00:10:29,129 line:-1
报告来电


220
00:10:29,796 --> 00:10:32,199 line:-1
否则系统…系统将终止app的运行


221
00:10:33,166 --> 00:10:35,402 line:-1
还有一些其它小技巧


222
00:10:35,836 --> 00:10:38,872 line:-2
如果你在推送有效载荷中包含
来电信息


223
00:10:38,939 --> 00:10:41,375 line:-1
然后你将拥有快速呈现


224
00:10:41,441 --> 00:10:42,643 line:-1
那个来电UI所需要的全部信息


225
00:10:42,943 --> 00:10:45,078 line:-1
因此请尝试包含尽可能多的信息


226
00:10:45,379 --> 00:10:47,948 line:-1
从而你可以呈现尽可能丰富的UI


227
00:10:49,583 --> 00:10:53,153 line:-2
第二 确保你把推送的
APN过期时间


228
00:10:53,420 --> 00:10:55,055 line:-1
设置为零或一些很小的值


229
00:10:56,056 --> 00:10:58,492 line:-2
这样用户将不会在来电几分钟后
收到一个推送


230
00:10:58,559 --> 00:11:00,928 line:-1
而此时已经停止拨打电话了


231
00:11:01,862 --> 00:11:02,930 line:-1
比如说


232
00:11:02,996 --> 00:11:06,767 line:-2
如果某人给我打电话了
而推送花了两分钟时间来发送


233
00:11:07,100 --> 00:11:09,203 line:-1
然后一旦推送在两分钟之后才送达


234
00:11:09,269 --> 00:11:11,071 line:-1
我不想报告来电


235
00:11:11,371 --> 00:11:13,707 line:-2
因为那个人很可能已经不再
拨打电话了


236
00:11:14,174 --> 00:11:16,343 line:-1
因此如果我们把过期时间设置为零


237
00:11:16,410 --> 00:11:18,378 line:-1
那意味着要立即提交或提交失败


238
00:11:18,445 --> 00:11:20,147 line:-1
或几秒之内完成


239
00:11:20,447 --> 00:11:22,850 line:-2
然后我们就知道
如果设备正在接收推送


240
00:11:22,916 --> 00:11:24,585 line:-1
这仍然是一个相关的来电


241
00:11:25,986 --> 00:11:29,022 line:-1
重点是要注意如果你想发送通知


242
00:11:29,089 --> 00:11:32,359 line:-2
你总是可以使用标准推送
而不是全屏…


243
00:11:32,426 --> 00:11:34,928 line:-2
那样你就不需要在呼叫UI中
全屏呈现通知


244
00:11:35,295 --> 00:11:37,564 line:-1
并且你可以使用通知服务扩展


245
00:11:37,631 --> 00:11:39,533 line:-1
如果你需要修改推送内容的话


246
00:11:39,600 --> 00:11:41,268 line:-1
比如 如果你需要解密推送内容的话


247
00:11:42,836 --> 00:11:44,938 line:-1
那么这就是VoIP推送和接打电话


248
00:11:45,405 --> 00:11:47,007 line:-1
现在让我们讲一下静音线程


249
00:11:47,074 --> 00:11:48,275 line:-1
（静音线程）


250
00:11:48,675 --> 00:11:50,677 line:-1
当用户有个消息app时


251
00:11:50,744 --> 00:11:52,479 line:-1
他们可能会给许多不同的朋友


252
00:11:52,546 --> 00:11:54,047 line:-1
或许多不同的朋友群发送消息


253
00:11:54,248 --> 00:11:57,150 line:-1
其中有些线程可能会很繁忙


254
00:11:57,217 --> 00:11:59,920 line:-2
用户可能不想收到
那个特定线程的警告


255
00:12:00,621 --> 00:12:03,257 line:-1
但内容仍然可能是相关内容


256
00:12:03,323 --> 00:12:04,591 line:-1
内容可能仍然不错


257
00:12:05,158 --> 00:12:06,560 line:-1
当用户返回到app中时


258
00:12:06,627 --> 00:12:07,961 line:-1
他们想查看消息


259
00:12:08,028 --> 00:12:10,831 line:-1
他们只是不想当每次接收消息时


260
00:12:11,098 --> 00:12:12,332 line:-1
都要震动设备并收到通知


261
00:12:13,233 --> 00:12:16,570 line:-2
因此我们需要一种方式可以警告设备
而不是用户


262
00:12:16,937 --> 00:12:18,739 line:-1
关于有可用的新内容了


263
00:12:20,107 --> 00:12:22,342 line:-1
为此你应该使用后台推送


264
00:12:23,710 --> 00:12:26,213 line:-1
后台推送是一种机制 告诉设备


265
00:12:26,280 --> 00:12:29,049 line:-1
有新数据可用 而不警告用户


266
00:12:30,717 --> 00:12:31,652 line:-1
要使用这些


267
00:12:31,718 --> 00:12:34,588 line:-2
你只需要把内容可用标志设置为一
并进行推送


268
00:12:34,955 --> 00:12:37,157 line:-2
不需要警告 不需要声音
或不需要任何标记


269
00:12:37,958 --> 00:12:39,893 line:-1
然后系统将决定


270
00:12:39,960 --> 00:12:41,929 line:-1
何时启动app下载内容


271
00:12:42,596 --> 00:12:46,099 line:-2
根据电量和性能影响
并尝试将影响最小化


272
00:12:46,633 --> 00:12:48,168 line:-1
我们可以在时间线上看一下这个过程


273
00:12:48,635 --> 00:12:49,770 line:-1
看起来类似这样


274
00:12:50,771 --> 00:12:52,239 line:-1
用户可能正在使用app


275
00:12:52,506 --> 00:12:54,174 line:-1
并决定静音某个线程


276
00:12:54,708 --> 00:12:56,610 line:0
然后在将来的某个时间点


277
00:12:56,677 --> 00:12:58,278 line:0
某人可能在那个线程上发了消息


278
00:12:58,345 --> 00:13:00,314 line:0
设备将收到后台推送


279
00:13:01,548 --> 00:13:03,750 line:0
在此之后的某个时间app将被启动


280
00:13:04,017 --> 00:13:05,919 line:0
并获得一些运行时间来取回那个内容


281
00:13:07,020 --> 00:13:09,923 line:0
然后当用户稍后返回到app中时


282
00:13:10,290 --> 00:13:12,559 line:0
打开app 用户可以打开线程


283
00:13:12,626 --> 00:13:14,428 line:0
并看到已经收到内容了


284
00:13:14,962 --> 00:13:17,865 line:-2
对于后台推送也有一些非常重要的
新改进


285
00:13:17,931 --> 00:13:19,132 line:-1
（后台推送）


286
00:13:19,199 --> 00:13:23,837 line:-2
你必须把APN优先级设置为五
否则app将不能启动


287
00:13:25,405 --> 00:13:28,509 line:-2
并且你还应该把APNS推送类型
设置为后台


288
00:13:28,842 --> 00:13:30,544 line:-1
这是watchOS所必需的


289
00:13:30,911 --> 00:13:33,480 line:-2
但我们强烈建议在所有平台上
都这样做


290
00:13:34,214 --> 00:13:36,817 line:-2
如果你想获得关于在
watchOS上的推送的更多信息


291
00:13:37,251 --> 00:13:40,287 line:-2
昨天有场单独的Watch app
演讲 你可以参考一下


292
00:13:42,656 --> 00:13:44,591 line:-1
回顾一下 对于静音线程


293
00:13:45,325 --> 00:13:48,328 line:-2
使用后台推送
作为下载内容的最佳方式


294
00:13:48,729 --> 00:13:52,366 line:-1
如果app没有获得运行时间


295
00:13:52,432 --> 00:13:54,401 line:-1
在收到后台推送后


296
00:13:54,668 --> 00:13:58,138 line:-2
你总是可以在app重新进入前台时
下载那些内容


297
00:14:00,574 --> 00:14:02,709 line:-1
现在让我们谈谈下载以前的附件


298
00:14:04,845 --> 00:14:06,413 line:-1
假如用户登录了他们的账户


299
00:14:07,347 --> 00:14:09,149 line:-1
他们在一台新设备上登录了


300
00:14:09,783 --> 00:14:12,753 line:-2
他们可能想立即从账户中
获取某些内容


301
00:14:12,819 --> 00:14:15,389 line:-1
比如对话列表或某些最近的消息


302
00:14:16,723 --> 00:14:18,859 line:-1
但可能有一批比较老的内容


303
00:14:18,926 --> 00:14:21,061 line:-2
如果你不在用户进入app时
就立即下载它


304
00:14:21,328 --> 00:14:22,596 line:-1
那非常好


305
00:14:23,697 --> 00:14:24,765 line:-1
想象一下


306
00:14:25,132 --> 00:14:28,869 line:-2
如果我们可以在设备充电时和闲置时
下载的话


307
00:14:28,936 --> 00:14:30,637 line:-2
我们为什么要在用户处于前台时
下载呢


308
00:14:31,205 --> 00:14:34,508 line:-2
那可能会潜在地
影响他们的性能或电量


309
00:14:35,943 --> 00:14:39,179 line:-2
实现方式是使用
任意后台URL会话


310
00:14:40,147 --> 00:14:43,483 line:-2
这可以让系统推迟下载
直到出现一个更好的下载时间


311
00:14:44,184 --> 00:14:47,588 line:-1
这个API可以让你传递更多信息


312
00:14:47,955 --> 00:14:49,690 line:-1
从而它可以更智能地安排时间


313
00:14:50,490 --> 00:14:51,491 line:-1
要使用它


314
00:14:51,792 --> 00:14:54,561 line:-2
你需要像往常那样
设置后台URL会话


315
00:14:55,295 --> 00:14:57,798 line:-1
然后把任意标志设为真


316
00:14:59,666 --> 00:15:01,735 line:-2
让我们看一下你可以传入的一些
额外信息


317
00:15:01,802 --> 00:15:04,271 line:-1
从而使系统变得更智能


318
00:15:05,606 --> 00:15:07,274 line:-1
你可以传入超时间隔


319
00:15:07,608 --> 00:15:10,277 line:-1
也许你不希望系统一直尝试下载


320
00:15:10,344 --> 00:15:11,745 line:-2
因此你希望可以界定系统可以下载
多长时间


321
00:15:13,280 --> 00:15:15,082 line:-1
你可以传入一个最早开始时间


322
00:15:15,415 --> 00:15:17,251 line:-1
也许你不想执行上传或下载


323
00:15:17,317 --> 00:15:18,719 line:-1
直到将来的某个时间点


324
00:15:19,353 --> 00:15:22,256 line:-1
并且你可以传入所预期的工作量大小


325
00:15:22,523 --> 00:15:26,393 line:-1
从而系统了解当运行下载时


326
00:15:26,460 --> 00:15:27,561 line:-1
有多少工作要做


327
00:15:30,430 --> 00:15:32,566 line:-1
当你正在下载以前的附件时


328
00:15:32,833 --> 00:15:36,370 line:-2
如果可能的话 你希望推迟这个操作
从而最小化对用户可见的影响


329
00:15:36,837 --> 00:15:40,707 line:-2
我们可以对任意可推迟的下载或上传
实施同样的原则


330
00:15:41,141 --> 00:15:43,644 line:-1
也许你有一些分析


331
00:15:43,710 --> 00:15:44,912 line:-1
你想在一个更合适的时间批量上传


332
00:15:45,179 --> 00:15:46,813 line:-1
或也许有一些用户拍摄的照片


333
00:15:47,080 --> 00:15:48,282 line:-1
你想稍后再进行备份


334
00:15:49,850 --> 00:15:51,952 line:0
回顾一下 我们有一款消息app


335
00:15:52,019 --> 00:15:53,687 line:0
它有一些核心功能


336
00:15:54,054 --> 00:15:56,089 line:0
你可以发消息、接打电话


337
00:15:56,757 --> 00:15:59,393 line:0
允许用户设置消息免打扰
并且你还可以下载以前的附件


338
00:16:00,093 --> 00:16:02,663 line:0
我们使用了不同的API
实现每个功能


339
00:16:03,030 --> 00:16:04,598 line:-2
我们使用
BackgroundTaskCompletion


340
00:16:04,865 --> 00:16:07,401 line:0
保障即使用户离开app
消息也能发送出去


341
00:16:07,868 --> 00:16:10,204 line:0
我们使用VoIP推送
作为启用接打电话的方式


342
00:16:10,704 --> 00:16:13,507 line:-1
我们使用后台推送


343
00:16:13,574 --> 00:16:16,443 line:0
作为给app提供运行时间
以响应新内容的最佳方式


344
00:16:16,777 --> 00:16:20,380 line:0
并且我们使用任意URL会话
在合适的时间下载附件


345
00:16:21,682 --> 00:16:23,317 line:0
但还有许多其它用例


346
00:16:23,383 --> 00:16:25,519 line:0
我们现有的模式目前还没有覆盖到


347
00:16:25,819 --> 00:16:27,421 line:-2
因此我想邀请我同事
Thomas上台来


348
00:16:27,487 --> 00:16:30,023 line:-1
介绍一种新的后台模式和框架


349
00:16:30,090 --> 00:16:31,758 line:-1
是特别针对这些用例设计的


350
00:16:32,092 --> 00:16:32,926 line:-1
谢谢大家


351
00:16:35,229 --> 00:16:36,063 line:-1
谢谢Roberto


352
00:16:36,830 --> 00:16:38,465 line:-1
让我们讲一下这些用例


353
00:16:38,532 --> 00:16:39,733 line:-1
（新的后台任务框架）


354
00:16:39,800 --> 00:16:43,170 line:-1
这些是比如主动与服务器同步状态


355
00:16:43,637 --> 00:16:44,972 line:-1
清理数据库


356
00:16:45,305 --> 00:16:46,773 line:-1
或把数据备份到Cloud


357
00:16:47,274 --> 00:16:49,776 line:-1
这些是可推迟的维护型任务


358
00:16:50,177 --> 00:16:52,513 line:-1
你最好在后台执行


359
00:16:52,779 --> 00:16:55,549 line:-1
从而不影响前台用户活动


360
00:16:56,416 --> 00:16:57,618 line:-1
如今我们看到的是


361
00:16:57,684 --> 00:17:01,288 line:-2
app在进入后台后就立即执行
这种任务


362
00:17:01,655 --> 00:17:03,423 line:-1
在一整天之中


363
00:17:03,757 --> 00:17:05,092 line:-1
这些任务其实可以累计起来一起执行


364
00:17:06,326 --> 00:17:08,462 line:-2
如果你可以把全部那种任务都推迟到
稍后执行怎么样


365
00:17:08,795 --> 00:17:11,999 line:-1
也许是当设备充电时或闲置时？


366
00:17:13,032 --> 00:17:15,135 line:-1
这就是我们今年引入的新功能


367
00:17:15,202 --> 00:17:18,505 line:-2
一个全新的后台模式和与之匹配的
一个框架


368
00:17:18,571 --> 00:17:20,040 line:-1
我们叫做后台任务


369
00:17:20,773 --> 00:17:21,775 line:-1
后台任务


370
00:17:21,842 --> 00:17:25,045 line:-1
可以让你稍后在后台执行任务


371
00:17:26,413 --> 00:17:29,550 line:-1
它在iOS、iPadOS、


372
00:17:30,017 --> 00:17:32,819 line:-2
tvOS上可用 对Mac上的
iPad app也可用


373
00:17:34,054 --> 00:17:37,124 line:0
我们不仅引入了这个新后台模式


374
00:17:37,191 --> 00:17:38,892 line:0
我们调用后台处理任务


375
00:17:39,560 --> 00:17:43,063 line:0
我们还利用这个机会
改善了现有API


376
00:17:43,330 --> 00:17:44,831 line:0
在后台刷新app的功能


377
00:17:46,733 --> 00:17:48,669 line:-1
先讲一下新后台模式


378
00:17:49,369 --> 00:17:50,737 line:-1
后台处理任务


379
00:17:51,104 --> 00:17:54,575 line:-2
可以在系统友好时间为你的app
提供几分钟的运行时间


380
00:17:55,242 --> 00:17:58,278 line:-1
从而你可以执行我之前提到的


381
00:17:58,345 --> 00:18:01,215 line:-1
可推迟的维护级任务以及新任务


382
00:18:01,481 --> 00:18:02,850 line:-1
比如设备上、


383
00:18:02,916 --> 00:18:05,519 line:-1
Core ML、在后台训练和推断


384
00:18:05,586 --> 00:18:07,254 line:-2
你可以从它们各自的演讲中
了解更多内容


385
00:18:07,321 --> 00:18:08,589 line:-1
（后台处理任务）


386
00:18:09,356 --> 00:18:11,391 line:-1
CPU监控是系统的一个功能


387
00:18:11,725 --> 00:18:15,062 line:-2
自动终止在后台使用了太多
CPU循环的app


388
00:18:15,128 --> 00:18:18,398 line:-1
以保护用户的电量


389
00:18:19,132 --> 00:18:20,434 line:-1
有史以来我们首次


390
00:18:20,501 --> 00:18:22,903 line:-1
可以让你在任务处理过程中


391
00:18:22,970 --> 00:18:24,838 line:-1
关闭CPU监控


392
00:18:25,138 --> 00:18:27,274 line:-1
从而你可以在设备充电时


393
00:18:27,341 --> 00:18:28,876 line:-1
充分利用硬件


394
00:18:30,677 --> 00:18:33,247 line:-1
最后我们会确保你有资格


395
00:18:33,313 --> 00:18:36,149 line:-1
运行这些任务


396
00:18:36,216 --> 00:18:37,651 line:-2
只要你在app处于前台时
请求执行这些任务


397
00:18:37,718 --> 00:18:40,521 line:-2
或如果你的app最近在前台使用过
也可以


398
00:18:42,189 --> 00:18:43,390 line:-1
（后台APP刷新任务）


399
00:18:43,457 --> 00:18:47,628 line:-2
接下来我要讲用于后台app刷新的
新API


400
00:18:48,762 --> 00:18:50,063 line:-1
这是个新API


401
00:18:50,130 --> 00:18:52,566 line:-1
但它的政策与当前API一模一样


402
00:18:53,000 --> 00:18:56,770 line:-2
这意味着app每次启动时将获得
30秒的运行时间


403
00:18:57,104 --> 00:19:00,307 line:-2
用于获取新内容并在一天内保持
一直有最新内容


404
00:19:02,409 --> 00:19:05,279 line:-1
app的启动频率以及何时启动


405
00:19:05,345 --> 00:19:07,881 line:-1
取决于用户在过于使用app的方式


406
00:19:09,016 --> 00:19:12,452 line:-1
因此如果用户一般在早上、


407
00:19:12,753 --> 00:19:14,555 line:-1
下午和晚上使用你的app


408
00:19:15,022 --> 00:19:17,724 line:-2
系统将会了解这种模式
并在这些时间之前不久


409
00:19:17,791 --> 00:19:19,259 line:-1
启动你的app


410
00:19:19,326 --> 00:19:21,929 line:-1
因此你就有机会获得你所需要的内容


411
00:19:23,030 --> 00:19:26,233 line:-2
这也意味着
如果app的使用频率不高


412
00:19:26,300 --> 00:19:27,935 line:-1
启动频率可能也不高


413
00:19:30,137 --> 00:19:33,674 line:-2
正如我所提到过的
这是用于后台app刷新的新API


414
00:19:33,740 --> 00:19:37,211 line:0
因此我们不推荐使用你在这里看到的
UI Application中的现有API


415
00:19:38,212 --> 00:19:40,013 line:0
但这些API可以继续使用


416
00:19:40,080 --> 00:19:44,952 line:0
它们在iOS、iPadOS
和tvOS设备上的使用方式不变


417
00:19:45,385 --> 00:19:46,987 line:0
但Mac上不支持它们


418
00:19:47,054 --> 00:19:49,223 line:0
因此一定要采用后台任务


419
00:19:49,289 --> 00:19:50,958 line:0
在Mac上执行后台app刷新


420
00:19:53,760 --> 00:19:55,729 line:-1
让我们看看这个API是如何运作的


421
00:19:56,930 --> 00:20:00,267 line:-2
假如我们有一款app
它包含一些扩展


422
00:20:01,635 --> 00:20:03,937 line:-1
你将与之交互的原始对象是


423
00:20:04,304 --> 00:20:06,139 line:-1
后台任务调度程序


424
00:20:07,508 --> 00:20:09,076 line:-1
后台任务调度程序


425
00:20:09,142 --> 00:20:13,680 line:-2
是系统智能的、
动态的活动调度程序的界面


426
00:20:13,981 --> 00:20:16,617 line:-1
它持续监控各种系统情况


427
00:20:17,050 --> 00:20:21,455 line:-2
包括电量等级、app的使用、
网络的连通性等等


428
00:20:23,323 --> 00:20:24,758 line:-1
当app正在运行时


429
00:20:24,825 --> 00:20:28,061 line:-2
你可以请求它稍后在后台唤醒它
并执行任务


430
00:20:28,829 --> 00:20:33,267 line:-2
为此 你要创建一个后台任务
请求对象的实例


431
00:20:34,334 --> 00:20:36,970 line:-1
响应你要实施的任务的类型


432
00:20:37,437 --> 00:20:40,440 line:-2
在这个例子中
我们想执行后台app刷新


433
00:20:40,707 --> 00:20:43,377 line:-2
因此我发起了一个
后台app刷新任务请求


434
00:20:44,378 --> 00:20:45,746 line:-1
我们把它提交给调度程序


435
00:20:47,447 --> 00:20:49,750 line:-1
如果你想执行多种类型的任务


436
00:20:49,816 --> 00:20:51,351 line:-1
你可以提交多个请求


437
00:20:51,718 --> 00:20:54,188 line:-2
在这个例子中
我们还想执行一些数据库清理


438
00:20:54,488 --> 00:20:58,358 line:-2
因此我也要发起一个
后台处理任务请求并提交它


439
00:21:00,661 --> 00:21:03,964 line:-2
你还可以当扩展正在运行时
从扩展中提交请求


440
00:21:05,165 --> 00:21:08,302 line:-1
因此如果你的键盘扩展


441
00:21:08,368 --> 00:21:09,736 line:-1
想根据用户的键入习惯进行学习


442
00:21:10,070 --> 00:21:13,240 line:-2
它也可以创建一个后台处理任务请求
并提交它


443
00:21:14,174 --> 00:21:15,175 line:-1
你可以看到


444
00:21:15,242 --> 00:21:18,345 line:-2
你有多个等待处理的
后台处理任务请求


445
00:21:18,879 --> 00:21:22,783 line:-2
每个都代表你希望app执行的
特定任务


446
00:21:24,418 --> 00:21:27,387 line:-2
现在调度程序知道我们的app
要做的全部任务


447
00:21:28,722 --> 00:21:30,991 line:-1
当满足所有必要的系统条件


448
00:21:31,058 --> 00:21:32,492 line:-1
和政策时


449
00:21:33,060 --> 00:21:34,528 line:-1
它将执行那个任务


450
00:21:34,962 --> 00:21:37,598 line:-1
唤醒你的app并在后台启动它


451
00:21:38,498 --> 00:21:40,968 line:-1
给它提交一个


452
00:21:41,034 --> 00:21:43,036 line:-2
响应你应该实施的那个任务的
后台任务对象


453
00:21:43,770 --> 00:21:46,273 line:-2
在这个例子中
我们有后台app刷新任务


454
00:21:46,640 --> 00:21:50,577 line:-2
因此我们现在可以实施
后台app刷新获取内容


455
00:21:50,644 --> 00:21:51,645 line:-1
并更新我们的UI


456
00:21:52,880 --> 00:21:55,582 line:-2
当我们完成后 我们要调用
SetTaskCompleted


457
00:21:55,949 --> 00:21:59,319 line:-1
它会把任务标记为完成并挂起app


458
00:22:01,054 --> 00:22:03,957 line:-1
根据你对后台任务请求的配置方式


459
00:22:04,024 --> 00:22:05,926 line:-1
以及各种系统情况和政策


460
00:22:06,627 --> 00:22:10,130 line:-2
我们可能选择同时启动app执行
多个任务


461
00:22:11,031 --> 00:22:14,401 line:-2
在这个例子中
系统启动了我们的app


462
00:22:14,701 --> 00:22:17,171 line:-2
系统向app同时提交了之前请求的
两个后台处理任务


463
00:22:18,572 --> 00:22:19,540 line:-1
当app启动时


464
00:22:19,606 --> 00:22:22,609 line:-2
系统就为它提供一段有限的时间
来完成分配给它的任务


465
00:22:23,010 --> 00:22:26,113 line:-2
那个时间是按启动来分配的
而不是按任务分配


466
00:22:26,513 --> 00:22:30,317 line:-2
因此你应该准备好
在分配给你的时间内


467
00:22:30,584 --> 00:22:31,518 line:-1
同时地处理分配给你的全部任务


468
00:22:32,252 --> 00:22:36,590 line:-2
同时请注意键盘扩展发起的
处理任务请求


469
00:22:36,890 --> 00:22:38,392 line:-1
会提交到主app中


470
00:22:38,926 --> 00:22:42,329 line:-1
那是因为始终是启动主app


471
00:22:42,396 --> 00:22:45,532 line:-1
来处理后台任务 而不是启动扩展


472
00:22:47,935 --> 00:22:49,970 line:-1
当app完成执行必要的任务之后


473
00:22:50,037 --> 00:22:53,273 line:-2
在系统分配给它的全部后台任务
对象上调用SetTaskCompleted


474
00:22:53,774 --> 00:22:54,675 line:-1
然后就会挂起app


475
00:22:55,409 --> 00:22:58,779 line:-2
这就是关于如何使用
后台任务API的高级概述


476
00:22:59,379 --> 00:23:01,849 line:-1
你创建后台任务请求


477
00:23:02,182 --> 00:23:03,517 line:-1
并提交给后台任务调度程序


478
00:23:04,051 --> 00:23:06,453 line:-1
等待系统在后台启动你的app


479
00:23:06,920 --> 00:23:08,255 line:-1
执行必要的任务


480
00:23:08,522 --> 00:23:11,859 line:-2
然后在BG任务对象上调用
SetTaskCompleted


481
00:23:12,926 --> 00:23:15,462 line:-2
为了让你了解如何在你的app中
实施这个API


482
00:23:15,729 --> 00:23:17,030 line:-1
我要给你做一个演示


483
00:23:24,771 --> 00:23:25,873 line:-1
这是我们的app


484
00:23:25,939 --> 00:23:29,009 line:-2
它叫做Color Feed
是款典型的社交媒体类型的app


485
00:23:29,343 --> 00:23:31,845 line:-1
除了照片信息


486
00:23:31,912 --> 00:23:33,814 line:-1
你还可以获得最近流行颜色的信息


487
00:23:34,448 --> 00:23:36,116 line:-1
你可以看到


488
00:23:36,183 --> 00:23:38,819 line:-1
我可以滚动并查看


489
00:23:39,086 --> 00:23:40,320 line:-1
不同的时间点的最新颜色


490
00:23:41,421 --> 00:23:42,689 line:-1
我其实想做的是


491
00:23:42,956 --> 00:23:45,259 line:-2
确保我的app在一天的时间里
可以保持拥有最新消息


492
00:23:45,325 --> 00:23:47,060 line:-1
并进行自我刷新


493
00:23:47,127 --> 00:23:49,196 line:-1
而不需要用户进入app并手动操作


494
00:23:49,830 --> 00:23:52,466 line:-2
处理这个问题最完美的工具是
后台app刷新


495
00:23:52,533 --> 00:23:54,401 line:-1
我要通过后台任务实施这个操作


496
00:23:55,903 --> 00:23:57,437 line:-1
你要做的第一件事就是


497
00:23:57,804 --> 00:24:00,741 line:-2
向info.plist中
添加所需要的键


498
00:24:00,807 --> 00:24:02,843 line:-1
声明你对后台任务


499
00:24:03,243 --> 00:24:04,311 line:-1
和后台app刷新的支持


500
00:24:04,978 --> 00:24:07,748 line:-1
因此我要进入我的项目设置


501
00:24:09,783 --> 00:24:11,351 line:-1
点击我app的目标


502
00:24:13,020 --> 00:24:15,122 line:-1
并进入“签名和功能”选项卡


503
00:24:16,990 --> 00:24:19,393 line:-1
我要点击加号并为后台模式


504
00:24:20,327 --> 00:24:21,361 line:-1
添加新功能


505
00:24:23,964 --> 00:24:26,099 line:-1
你可以看到 它增加了这个新的部分


506
00:24:26,166 --> 00:24:29,069 line:-2
我们需要给这种类型的任务
选择合适的后台模式


507
00:24:29,603 --> 00:24:31,338 line:-1
在这个例子中 对于后台app刷新


508
00:24:31,672 --> 00:24:34,675 line:-2
该框标记为后台提取
就与在老API中一样


509
00:24:34,942 --> 00:24:36,210 line:-1
因此我要继续并查看一下


510
00:24:38,045 --> 00:24:40,914 line:-2
接下来我要进入我的
请求info.plist文件


511
00:24:41,348 --> 00:24:42,316 line:-1
就在这里…


512
00:24:43,884 --> 00:24:46,854 line:-1
我要点击加号并添加一个新键


513
00:24:48,789 --> 00:24:52,392 line:-2
这个键叫做PermittedBackground
TaskSchedulerIdentifiers


514
00:24:52,993 --> 00:24:54,795 line:-1
它是一个字符串的数组


515
00:24:55,462 --> 00:24:57,397 line:-1
这个数组中的每个字符串


516
00:24:57,464 --> 00:25:00,634 line:-2
都唯一标识你的app要执行的
某个特定的任务


517
00:25:01,034 --> 00:25:02,803 line:-1
并且它在你的app内应该是唯一的


518
00:25:03,270 --> 00:25:05,472 line:-1
我们推荐使用反向DNS表示法


519
00:25:05,539 --> 00:25:08,308 line:-2
避免与你可能使用的任何第三方框架
发生冲突


520
00:25:09,977 --> 00:25:12,279 line:-1
在这里我要扩展那个数组


521
00:25:12,346 --> 00:25:14,114 line:-1
并点击加号来添加新字符串


522
00:25:15,282 --> 00:25:18,752 line:-2
我要把它命名为
com.colorfeed.refresh


523
00:25:20,554 --> 00:25:21,555 line:-1
并点击保存


524
00:25:22,389 --> 00:25:24,825 line:-1
接下来当我的app启动时


525
00:25:25,092 --> 00:25:26,493 line:-1
我需要实际实施要处理的代码


526
00:25:26,960 --> 00:25:28,662 line:-1
我要在app委托中实现


527
00:25:31,732 --> 00:25:33,333 line:-1
我要进入app委托文件


528
00:25:33,400 --> 00:25:35,702 line:-1
我要做的第一件事是导入后台任务


529
00:25:39,673 --> 00:25:40,507 line:-1
好吧


530
00:25:41,175 --> 00:25:42,409 line:-1
下一步


531
00:25:42,876 --> 00:25:45,479 line:-1
就是告诉系统当你启动时你想做什么


532
00:25:45,546 --> 00:25:48,415 line:-1
你可以通过在app完成启动之前


533
00:25:48,482 --> 00:25:50,417 line:-1
就注册启动处理器来实现


534
00:25:51,285 --> 00:25:54,788 line:-2
didFinishLaunching
和Options方法


535
00:25:55,556 --> 00:25:56,657 line:-1
我要调用…


536
00:25:58,892 --> 00:26:01,061 line:-1
共享后台任务调度程序


537
00:26:01,128 --> 00:26:03,130 line:-1
用标识符注册任务


538
00:26:03,530 --> 00:26:07,434 line:-2
传入我刚放在info.plist
中的同一个标识符


539
00:26:08,702 --> 00:26:10,771 line:-1
下一个参数是一个分派队列


540
00:26:10,838 --> 00:26:12,873 line:-1
我的处理器将调用分派队列


541
00:26:12,940 --> 00:26:14,775 line:-2
并且如果我想在app中
同步执行其它任务


542
00:26:14,842 --> 00:26:16,810 line:-1
我可以指定我要使用的队列


543
00:26:17,411 --> 00:26:19,012 line:-1
或我可以传入无


544
00:26:19,079 --> 00:26:21,949 line:-1
系统将替我创建一个后台串行队列


545
00:26:23,483 --> 00:26:24,585 line:-1
下一个参数是


546
00:26:24,651 --> 00:26:25,986 line:-1
启动处理器


547
00:26:26,053 --> 00:26:28,755 line:-2
当在后台启动app执行后台任务时
调用它


548
00:26:29,523 --> 00:26:30,390 line:-1
你可以看到


549
00:26:30,457 --> 00:26:32,693 line:-1
它接受后台任务的一个参数


550
00:26:34,094 --> 00:26:35,195 line:-1
我要做的是


551
00:26:35,629 --> 00:26:40,767 line:-2
调用一个方法…我要编写一个名为
HandleAppRefresh的方法


552
00:26:41,068 --> 00:26:45,506 line:-2
把那个后台任务对象向下转换为
后台app刷新任务


553
00:26:45,839 --> 00:26:47,708 line:-1
因为这是用于后台app刷新的参数


554
00:26:48,842 --> 00:26:51,345 line:-2
现在我要继续并编写那个
HandleAppRefresh方法


555
00:26:55,015 --> 00:26:56,850 line:-2
我在这里编写了
用于实施后台app刷新


556
00:26:56,917 --> 00:26:58,986 line:-1
所需要的全部代码


557
00:26:59,286 --> 00:27:01,722 line:-1
它将从服务器获取最新内容


558
00:27:01,788 --> 00:27:03,991 line:-1
更新数据库并更新UI


559
00:27:04,658 --> 00:27:06,660 line:-1
为了把这个与后台任务集成到一起


560
00:27:07,127 --> 00:27:08,896 line:-1
我需要做两件事


561
00:27:09,663 --> 00:27:11,832 line:-1
第一件是处理过期


562
00:27:12,566 --> 00:27:15,969 line:-2
系统为你的任务分配了有限的
完成时间


563
00:27:16,570 --> 00:27:18,805 line:-1
当你的时间差不多要用完时


564
00:27:18,872 --> 00:27:21,475 line:-1
我们会警告你并给你提供一个机会


565
00:27:21,542 --> 00:27:22,676 line:-1
让你快速完成全部工作


566
00:27:23,010 --> 00:27:26,480 line:-1
系统可能还选择提早终止你的任务


567
00:27:26,747 --> 00:27:29,950 line:-1
如果系统决定当前情况


568
00:27:30,017 --> 00:27:31,084 line:-1
不足以运行你的任务的话


569
00:27:32,186 --> 00:27:35,289 line:-2
我要做的就是在任务上设置一个
过期处理器…


570
00:27:36,690 --> 00:27:39,126 line:-1
在过期处理器中


571
00:27:39,693 --> 00:27:42,596 line:-2
我要在我的操作队列上调用
CancelAllOperations


572
00:27:42,663 --> 00:27:44,965 line:-1
这会停止我正在做的全部工作


573
00:27:45,032 --> 00:27:47,000 line:-1
并取消我甚至还没开始的任何工作


574
00:27:48,569 --> 00:27:49,903 line:-1
我要做的下一件事是


575
00:27:50,404 --> 00:27:55,008 line:-2
完成之后在任务上调用
SetTaskCompleted


576
00:27:56,410 --> 00:27:59,580 line:-2
即使在系统调用过期处理器之后
我也需要调用SetTaskCompleted


577
00:28:01,081 --> 00:28:02,816 line:-1
如果我不这样做


578
00:28:02,883 --> 00:28:04,651 line:-1
系统实际上可能会终止我的app


579
00:28:05,052 --> 00:28:07,020 line:-1
那会影响稍后的启动性能


580
00:28:07,087 --> 00:28:08,188 line:-1
你绝对不想那样做


581
00:28:08,722 --> 00:28:10,858 line:-1
我要做的是


582
00:28:10,924 --> 00:28:12,059 line:-1
我要…


583
00:28:13,227 --> 00:28:16,964 line:-2
在那个队列中的最后一个操作
完成之后


584
00:28:17,397 --> 00:28:18,966 line:-2
调用
SetTaskCompleted


585
00:28:19,333 --> 00:28:20,868 line:-1
我要充分利用这一点


586
00:28:21,101 --> 00:28:23,203 line:-1
即操作总是会调用它们的完成代码块


587
00:28:23,537 --> 00:28:26,373 line:-1
无论操作是被提早取消或是正常完成


588
00:28:26,640 --> 00:28:29,910 line:-2
并且我通过这一点来决定
我的任务是否成功完成


589
00:28:31,144 --> 00:28:32,913 line:-1
好吧 最后一步…


590
00:28:33,347 --> 00:28:36,016 line:-1
是安排后台任务请求


591
00:28:36,617 --> 00:28:39,286 line:-1
并且我要当app进入后台时再安排


592
00:28:39,353 --> 00:28:41,421 line:-1
因为那时用户会停止使用app


593
00:28:41,655 --> 00:28:42,990 line:-1
因此我要继续并编写这个功能


594
00:28:47,494 --> 00:28:48,495 line:-1
你可以看到


595
00:28:48,562 --> 00:28:51,498 line:-2
我正在调用我刚才编写的那个
ScheduleAppRefresh方法


596
00:28:51,565 --> 00:28:53,467 line:-1
而我的app确实进入了后台方法


597
00:28:53,834 --> 00:28:57,437 line:-2
在这里我要创建一个后台app
刷新任务请求对象


598
00:28:58,005 --> 00:29:00,307 line:-1
并给它传入那个相同的标识符


599
00:29:01,341 --> 00:29:04,945 line:-2
然后我把那个请求提交到
任务调度程序


600
00:29:06,480 --> 00:29:08,916 line:-1
有一个额外属性


601
00:29:08,982 --> 00:29:10,484 line:-1
我想在任务请求对象上调用


602
00:29:11,151 --> 00:29:12,920 line:-1
即最早开始时间


603
00:29:13,453 --> 00:29:16,056 line:-1
你可以通过这个给任务指定开始推迟


604
00:29:16,590 --> 00:29:19,826 line:-2
在这个例子中
我指的是不要开始app刷新


605
00:29:19,893 --> 00:29:24,264 line:-2
不要开始刷新app 除非在我安排
它刷新后的至少15分钟之后再执行


606
00:29:24,565 --> 00:29:26,300 line:-1
这让我获得了与老的


607
00:29:26,366 --> 00:29:29,369 line:-2
SetMinimumBackgroundFetchInterval
API一样的行为


608
00:29:31,071 --> 00:29:32,739 line:-1
我安排我的任务


609
00:29:32,806 --> 00:29:35,642 line:-1
但实际上我很可能还想做另一件事


610
00:29:36,677 --> 00:29:39,780 line:-1
因为每个单个后台任务请求对象


611
00:29:39,847 --> 00:29:41,682 line:-1
恰好响应一次启动


612
00:29:42,182 --> 00:29:45,219 line:-2
现在如果系统启动了我的app
执行后台app刷新


613
00:29:45,285 --> 00:29:48,488 line:-2
系统将不会再次启动它
直到用户打开并离开我的app


614
00:29:48,889 --> 00:29:51,592 line:-2
但我并不希望这样
我希望能一直刷新


615
00:29:51,992 --> 00:29:55,462 line:-2
因此我要做的就是
在我的handle方法中


616
00:29:55,529 --> 00:29:56,396 line:-2
调用
ScheduleAppRefresh


617
00:29:57,297 --> 00:30:00,434 line:-2
我会在系统启动app执行
现有任务时 立即发起另一个请求


618
00:30:01,835 --> 00:30:03,971 line:-2
就是这个
这就是我要处理app中的


619
00:30:04,037 --> 00:30:05,839 line:-2
后台app刷新
所需要编写的全部代码


620
00:30:07,241 --> 00:30:09,543 line:-2
但因为我正在使用app
并且正在滚动浏览


621
00:30:10,644 --> 00:30:14,314 line:-1
我看到那有许多很久之前的内容


622
00:30:14,381 --> 00:30:16,750 line:-1
那可能是不再与用户相关的内容


623
00:30:16,817 --> 00:30:18,085 line:-1
只是占用磁盘空间


624
00:30:18,552 --> 00:30:21,788 line:-2
如果我们可以为用户清理数据库
那真是太棒了


625
00:30:22,289 --> 00:30:25,459 line:-1
最好的工具就是后台处理任务


626
00:30:25,526 --> 00:30:27,294 line:-1
我要继续并实施它


627
00:30:28,595 --> 00:30:31,031 line:-1
跟以前一样 我要进入我的项目设置


628
00:30:32,132 --> 00:30:33,567 line:-1
进入“签名和功能”选项卡


629
00:30:34,468 --> 00:30:36,503 line:-1
这一次 在后台模式中


630
00:30:36,803 --> 00:30:39,706 line:-1
我要确保勾选后台处理复选框


631
00:30:43,644 --> 00:30:44,945 line:-2
我要进入
我的info.plist…


632
00:30:47,080 --> 00:30:49,183 line:-1
并点击加号添加新标识符


633
00:30:49,783 --> 00:30:53,420 line:-2
我把它命名为
com.colorfeed.dbcleaning…


634
00:30:56,089 --> 00:30:56,957 line:-1
并点击保存


635
00:30:58,091 --> 00:30:59,226 line:-1
然后跟以前一样


636
00:30:59,526 --> 00:31:00,928 line:-1
我要进入app委托…


637
00:31:01,762 --> 00:31:03,197 line:-1
并再次调用注册


638
00:31:07,000 --> 00:31:09,269 line:-1
这跟我之前的调用相同


639
00:31:09,336 --> 00:31:11,238 line:-1
除非我传入了新标识符


640
00:31:12,039 --> 00:31:15,175 line:-2
并且我要调用
HandleDatabaseCleaning


641
00:31:15,242 --> 00:31:17,611 line:-1
并向下转换为后台处理任务


642
00:31:18,979 --> 00:31:20,981 line:-2
现在我要继续并实施
HandleDatabaseCleaning


643
00:31:27,254 --> 00:31:29,823 line:-1
我已经把这段代码与后台任务集成了


644
00:31:30,257 --> 00:31:33,427 line:-1
它的功能是删除昨天之前的一切数据


645
00:31:34,294 --> 00:31:37,097 line:-1
你可以看到 我设置了过期处理器


646
00:31:37,164 --> 00:31:38,565 line:-1
和取消我的全部操作


647
00:31:39,099 --> 00:31:43,270 line:-2
并且当我完成后成功调用了
SetTaskCompleted


648
00:31:44,071 --> 00:31:45,672 line:-1
有一点不同


649
00:31:45,739 --> 00:31:49,142 line:-2
就是我一直追踪我上次成功清理
数据库的时间


650
00:31:50,844 --> 00:31:53,780 line:-1
这是因为当我安排任务时


651
00:31:53,847 --> 00:31:56,884 line:-1
我想谨慎地使用系统的资源


652
00:31:57,351 --> 00:31:59,586 line:-1
我不想当用户每次离开app时


653
00:31:59,653 --> 00:32:01,154 line:-1
都安排数据库清理任务


654
00:32:01,221 --> 00:32:03,156 line:-2
如果我的数据库
实际上不需要清理的话


655
00:32:03,991 --> 00:32:06,760 line:-1
我要做的就是编写一个


656
00:32:07,027 --> 00:32:08,996 line:-2
ScheduleDatabaseCleaning方法
如果需要的话


657
00:32:11,265 --> 00:32:12,900 line:-1
我会检查


658
00:32:12,966 --> 00:32:16,103 line:-2
是否距离上次清理已经过去了
至少一周的时间


659
00:32:16,436 --> 00:32:18,372 line:-2
如果不是 我就不采取任何措施
我会立即跳出


660
00:32:19,339 --> 00:32:21,475 line:-1
反之我将继续并安排那个请求


661
00:32:22,242 --> 00:32:24,144 line:-1
我要创建一个后台处理任务请求


662
00:32:24,511 --> 00:32:26,747 line:-2
并给它传递我之前传递过的同一个
标识符


663
00:32:28,715 --> 00:32:31,552 line:-2
在后台处理任务请求上有一些
额外的属性


664
00:32:31,618 --> 00:32:32,653 line:-1
你可能要引起注意


665
00:32:33,387 --> 00:32:36,089 line:-1
第一个是要求网络连接


666
00:32:36,356 --> 00:32:37,891 line:-1
实际上它默认设为假


667
00:32:38,525 --> 00:32:40,327 line:-1
你应该确保把它设为真


668
00:32:40,394 --> 00:32:43,297 line:-2
如果执行你的任务真的需要
网络连接的话


669
00:32:43,564 --> 00:32:45,566 line:-2
否则我们可能会在没有网络连接时
启动你的任务


670
00:32:45,632 --> 00:32:48,335 line:-1
那样你就不能完成很多工作


671
00:32:49,203 --> 00:32:51,305 line:-2
在我们的例子中
我们要做一些本地数据库维护


672
00:32:51,605 --> 00:32:52,906 line:-1
因此我们可以把它保留为假


673
00:32:54,007 --> 00:32:56,610 line:-1
下一个是要求外部电源


674
00:32:57,911 --> 00:33:00,514 line:-1
根据设备的特定类型


675
00:33:00,848 --> 00:33:02,716 line:-1
和各种系统情况和政策


676
00:33:03,083 --> 00:33:06,887 line:-2
我们可能倾向于当设备充电时
启动app


677
00:33:07,654 --> 00:33:09,523 line:-1
然而如果你请求


678
00:33:09,590 --> 00:33:13,060 line:-1
如果你请求你自己执行密集的任务


679
00:33:13,126 --> 00:33:14,494 line:-1
并使用大量资源


680
00:33:14,561 --> 00:33:16,864 line:-1
我们强烈建议你把这个设为真


681
00:33:17,297 --> 00:33:19,032 line:-1
那样有助于保存用户的电量


682
00:33:19,766 --> 00:33:23,170 line:-2
把这个设为真
也是你对CPU密集型任务


683
00:33:23,237 --> 00:33:24,471 line:-1
禁用CPU监控的方式


684
00:33:26,373 --> 00:33:28,709 line:-2
就是这么多了 我要继续
并把那个请求提交到调度程序


685
00:33:28,775 --> 00:33:32,079 line:-1
如果需要的话


686
00:33:32,379 --> 00:33:34,081 line:-1
我会在app进入后台时再执行


687
00:33:35,616 --> 00:33:38,552 line:-1
这是我要处理后台app刷新


688
00:33:38,819 --> 00:33:40,254 line:-2
和后台处理任务所需要编写的
全部代码


689
00:33:41,088 --> 00:33:42,456 line:-1
但我如何知道这些代码没问题呢？


690
00:33:43,524 --> 00:33:45,192 line:-1
我想我是个完美的程序员 但是


691
00:33:45,959 --> 00:33:47,728 line:-1
显然情况并非总是如此


692
00:33:48,262 --> 00:33:51,532 line:-1
端对端测试的最好方式是


693
00:33:51,598 --> 00:33:54,034 line:-2
把它放在设备上
并像用户一样使用它


694
00:33:54,301 --> 00:33:56,937 line:-1
那会确保你可以获得


695
00:33:57,004 --> 00:33:58,505 line:-2
用于执行特定任务所需要的
时间和政策


696
00:33:59,573 --> 00:34:02,309 line:-1
但我们还知道当你编码时


697
00:34:02,376 --> 00:34:03,410 line:-1
你没有时间坐在那儿等着


698
00:34:03,477 --> 00:34:06,613 line:-2
因此我们添加了一些方法
你可以在调试器中调用


699
00:34:06,680 --> 00:34:08,849 line:-1
用于调试后台任务的使用


700
00:34:09,149 --> 00:34:10,350 line:-1
现在让我来演示一下


701
00:34:11,618 --> 00:34:13,453 line:-1
我要创建并在我的iPhone上


702
00:34:13,754 --> 00:34:15,522 line:-1
运行这个新版后台任务


703
00:34:21,261 --> 00:34:22,696 line:-1
你可以看到 它启动了


704
00:34:22,763 --> 00:34:24,697 line:-1
现在我要把它放到后台去


705
00:34:25,966 --> 00:34:27,601 line:-1
从而确保安排我的任务请求


706
00:34:28,635 --> 00:34:30,437 line:-1
我再把它放到前台来 在这里


707
00:34:30,704 --> 00:34:33,739 line:-1
我要点击底部的暂停按钮


708
00:34:35,576 --> 00:34:36,710 line:-1
这将会进入调试器


709
00:34:38,110 --> 00:34:39,446 line:-1
我可以看到控制台


710
00:34:40,447 --> 00:34:41,481 line:-1
我要做的就是


711
00:34:41,547 --> 00:34:42,949 line:-1
粘贴命令


712
00:34:43,016 --> 00:34:46,018 line:-2
你可以从文档中找到命令
因此不需要把它记下来


713
00:34:47,353 --> 00:34:48,688 line:-1
在这里我要做的就是


714
00:34:49,121 --> 00:34:51,225 line:-1
用我想要模拟的任务的标识符


715
00:34:51,291 --> 00:34:53,226 line:-2
替换这个
“task identifier”


716
00:34:53,726 --> 00:34:55,362 line:-1
我想测试后台app刷新


717
00:34:55,661 --> 00:34:58,165 line:-2
因此我要键入
com.colorfeed.refresh


718
00:34:59,266 --> 00:35:01,401 line:-1
但步骤与我的处理任务一样


719
00:35:02,269 --> 00:35:03,303 line:-1
我要按回车…


720
00:35:04,271 --> 00:35:05,138 line:0
你可以看到


721
00:35:05,205 --> 00:35:07,274 line:0
系统已经识别我想模拟一次启动


722
00:35:07,574 --> 00:35:08,942 line:0
执行后台app刷新任务


723
00:35:10,511 --> 00:35:11,979 line:0
我要点击这里的播放按钮


724
00:35:15,382 --> 00:35:16,617 line:-1
你可以看到


725
00:35:17,084 --> 00:35:18,819 line:-1
系统开始执行我的app刷新任务


726
00:35:18,886 --> 00:35:20,621 line:-1
我的app主动地进行了刷新


727
00:35:20,687 --> 00:35:22,089 line:-1
我可以看到代码起作用了


728
00:35:23,457 --> 00:35:24,558 line:-1
我要再次点击暂停


729
00:35:25,025 --> 00:35:28,195 line:0
这一次我要确保过期也没问题


730
00:35:28,262 --> 00:35:29,630 line:0
因为它也同等重要


731
00:35:30,631 --> 00:35:33,467 line:0
我要做的就是输入同一个命令


732
00:35:34,101 --> 00:35:36,570 line:0
但这一次我要用过期替换“启动”


733
00:35:36,837 --> 00:35:39,273 line:0
并按回车


734
00:35:40,641 --> 00:35:43,076 line:0
你可以看到
系统识别到我发起了这个请求


735
00:35:43,710 --> 00:35:44,678 line:0
当我点击播放时


736
00:35:44,945 --> 00:35:47,614 line:0
你应该可以看到我的app会成功地
停止刷新


737
00:35:47,915 --> 00:35:50,584 line:0
识别到那个任务已过期
并把任务标记为完成


738
00:35:51,251 --> 00:35:54,922 line:0
现在我知道对于后台任务


739
00:35:54,988 --> 00:35:58,659 line:0
我的app已经成功地实施并测试了


740
00:35:59,059 --> 00:36:00,260 line:0
后台app刷新和后台处理任务


741
00:36:05,899 --> 00:36:06,900 line:-1
谢谢


742
00:36:07,601 --> 00:36:09,036 line:-2
当你使用我们的框架时
还有一些额外的注意事项


743
00:36:09,102 --> 00:36:11,471 line:-1
你可能要引起注意


744
00:36:12,573 --> 00:36:15,642 line:-1
第一 请注意对最早开始时间的设置


745
00:36:15,709 --> 00:36:17,244 line:-1
不要把时间设置得太远


746
00:36:17,978 --> 00:36:19,446 line:-1
如果你把它设置得太远


747
00:36:19,513 --> 00:36:22,082 line:-2
并且在此期间用户也没有返回到
你的app中


748
00:36:22,416 --> 00:36:24,351 line:-1
我们可能会选择完全不启动你的任务


749
00:36:24,818 --> 00:36:28,355 line:-1
那只是为了保护用户的预期和隐私


750
00:36:28,789 --> 00:36:31,091 line:-1
几个月都不使用你app的用户


751
00:36:31,158 --> 00:36:33,727 line:-1
不会期待它突然开始在后台运行


752
00:36:34,228 --> 00:36:36,997 line:-1
因此我们建议你把最早开始时间


753
00:36:37,464 --> 00:36:40,701 line:-2
把你推迟的最早开始时间设置为
一周或更短


754
00:36:42,970 --> 00:36:46,874 line:-2
接下来请确保在处理任务过程中
你需要访问的任何文件


755
00:36:47,441 --> 00:36:49,243 line:-1
当设备被锁定时可访问


756
00:36:49,576 --> 00:36:51,979 line:-1
因为我们一般会在那时启动你的任务


757
00:36:53,046 --> 00:36:55,215 line:-1
我们保证我们不会开始你的任务


758
00:36:55,282 --> 00:36:57,217 line:-1
直到用户第一次锁定他们的设备


759
00:36:57,518 --> 00:36:59,386 line:-1
因此请确保你要访问的任何文件


760
00:36:59,453 --> 00:37:04,291 line:-2
大部分文件保护类型都是完整的
直到第一次用户验证


761
00:37:07,060 --> 00:37:08,929 line:-2
我们在传统的单个窗口的
UIKit app中


762
00:37:08,996 --> 00:37:11,431 line:-1
演示了如何实施后台app刷新


763
00:37:11,765 --> 00:37:14,801 line:-2
但你知道的 今年我们通过
UIScene API


764
00:37:15,068 --> 00:37:16,503 line:-1
引入了多窗口app


765
00:37:16,970 --> 00:37:18,472 line:-1
如果你采用那个API


766
00:37:18,839 --> 00:37:23,644 line:-2
可以在合适的时间调用UIApplication
RequestSceneSessionRefresh


767
00:37:23,710 --> 00:37:26,280 line:-1
从而告诉系统


768
00:37:26,346 --> 00:37:28,849 line:-1
App切换器中的快照需要更新


769
00:37:29,383 --> 00:37:32,085 line:-2
你可以在它们各自的文档中找到
相关详情


770
00:37:34,188 --> 00:37:35,088 line:-1
最后


771
00:37:35,389 --> 00:37:39,059 line:-2
BGTaskScheduler.submit
是一个阻塞的同步调用


772
00:37:39,426 --> 00:37:42,029 line:-2
我们之所以那样设计它是因为
那样会简化对它的采用方式


773
00:37:42,095 --> 00:37:44,198 line:-1
当你进行调度时 当你进入后台时


774
00:37:44,398 --> 00:37:45,499 line:-1
这是常见的情况


775
00:37:46,200 --> 00:37:48,101 line:-1
然而如果你计划


776
00:37:48,468 --> 00:37:51,104 line:-1
在更具性能敏感性的情境中进行调度


777
00:37:51,605 --> 00:37:53,307 line:-1
比如当app启动时


778
00:37:53,807 --> 00:37:55,976 line:-1
你要确保在后台队列上调用它


779
00:37:56,243 --> 00:37:59,613 line:-1
从而不会阻塞主线程并妨碍启动性能


780
00:38:02,182 --> 00:38:04,918 line:-1
好吧 总结一下我们今天讲过的内容


781
00:38:06,486 --> 00:38:09,756 line:-2
但请认真考虑
如何在后台使用运行时间


782
00:38:10,090 --> 00:38:13,227 line:-2
请谨记我们在设计我们的API时
所考虑的要素


783
00:38:13,627 --> 00:38:16,730 line:-1
比如电源、性能和隐私


784
00:38:18,932 --> 00:38:21,235 line:-1
请一定使用合适的后台模式


785
00:38:21,301 --> 00:38:23,303 line:-1
来完成你要执行的任务


786
00:38:23,370 --> 00:38:25,806 line:-1
并获得你想要的用户体验


787
00:38:28,475 --> 00:38:31,378 line:-1
最后请使用新后台任务API


788
00:38:31,445 --> 00:38:33,247 line:-1
来安排稍后在后台中要执行的任务


789
00:38:33,714 --> 00:38:35,349 line:-1
请使用后台app刷新任务


790
00:38:35,616 --> 00:38:37,784 line:-1
保持app拥有最新内容


791
00:38:38,118 --> 00:38:41,588 line:-2
并使用后台处理任务来执行
可推迟的维护级任务


792
00:38:42,122 --> 00:38:44,691 line:-1
当设备闲置时和充电时


793
00:38:46,760 --> 00:38:51,465 line:0
要获取更多信息 请参加我们的演讲
或访问演讲网站


794
00:38:51,532 --> 00:38:53,767 line:0
查看文档连接和示例代码


795
00:38:54,234 --> 00:38:55,269 line:0
谢谢

