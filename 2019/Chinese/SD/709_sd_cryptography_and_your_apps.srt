1
00:00:00,506 --> 00:00:04,500
[音乐]


2
00:00:12,516 --> 00:00:14,636
[掌声]


3
00:00:15,136 --> 00:00:15,666
>>  下午好


4
00:00:16,366 --> 00:00:17,206
各位下午好


5
00:00:18,456 --> 00:00:22,546
欢迎来到比特币专场


6
00:00:22,546 --> 00:00:23,156
[笑声]


7
00:00:23,156 --> 00:00:25,276
开个玩笑 欢迎大家来到


8
00:00:25,276 --> 00:00:26,306
Cryptography and Your Apps 专场


9
00:00:27,206 --> 00:00:29,126
今天 我的同事 Frederic


10
00:00:29,126 --> 00:00:31,326
会和我一起向你们展示


11
00:00:31,326 --> 00:00:33,026
在 Apple 产品上使用密码


12
00:00:33,026 --> 00:00:34,936
变得前所未有的简单


13
00:00:35,776 --> 00:00:36,636
我是 Yannick Sierra


14
00:00:36,636 --> 00:00:37,846
我在 Apple 负责管理


15
00:00:37,846 --> 00:00:39,496
加密工程团队


16
00:00:39,496 --> 00:00:43,466
那么今天一方面


17
00:00:43,466 --> 00:00:45,756
我们会带来一套系统功能


18
00:00:45,926 --> 00:00:48,456
来解决一组常见安全问题


19
00:00:49,326 --> 00:00:51,306
另一方面 我们还将


20
00:00:51,446 --> 00:00:54,406
为大家带来一个全新的


21
00:00:54,406 --> 00:00:55,576
为加密操作服务的 Swift API


22
00:00:56,336 --> 00:00:58,476
我们很高兴能为大家讲这些


23
00:00:58,476 --> 00:01:00,056
你们来到这里


24
00:01:00,056 --> 00:01:01,506
一定是因为想要


25
00:01:01,506 --> 00:01:02,766
保护一些信息 对吧


26
00:01:05,476 --> 00:01:08,246
我们知道各位


27
00:01:08,396 --> 00:01:11,016
作为开发者和用户


28
00:01:11,016 --> 00:01:12,526
都认为保护用户的信息


29
00:01:12,526 --> 00:01:13,976
是十分重要的


30
00:01:16,656 --> 00:01:17,806
我们有各种各样的信息


31
00:01:17,806 --> 00:01:19,826
它们都十分敏感


32
00:01:19,866 --> 00:01:21,966
包括个人资料信息


33
00:01:21,966 --> 00:01:23,796
比如电话号码


34
00:01:23,796 --> 00:01:25,746
和电子邮件地址


35
00:01:26,636 --> 00:01:28,156
你的 App 可能也会


36
00:01:28,156 --> 00:01:31,866
处理一些用户信息


37
00:01:31,866 --> 00:01:34,386
如照片或音乐


38
00:01:34,386 --> 00:01:36,686
通过 App 来处理和加工


39
00:01:38,196 --> 00:01:39,976
你的 App 也会


40
00:01:39,976 --> 00:01:41,596
处理商业素材


41
00:01:42,826 --> 00:01:44,846
这可能是你的 App


42
00:01:45,026 --> 00:01:46,886
提供给用户的付费内容


43
00:01:47,716 --> 00:01:49,586
或者是如手机银行


44
00:01:49,586 --> 00:01:51,626
这样的场景中的账户信息


45
00:01:53,136 --> 00:01:54,836
所有这些信息


46
00:01:54,836 --> 00:01:56,636
我们都务必保护其安全


47
00:01:57,106 --> 00:01:59,346
那么你就需要使用很好的工具


48
00:01:59,986 --> 00:02:04,436
在 Apple 里 安全和隐私


49
00:02:04,716 --> 00:02:06,146
是核心价值


50
00:02:06,826 --> 00:02:08,406
它根植在我们所开发的


51
00:02:08,406 --> 00:02:11,056
所有功能之中


52
00:02:12,356 --> 00:02:15,486
加密技术是其中一个重要的部分


53
00:02:16,036 --> 00:02:18,086
举个例子 对于设备完整性


54
00:02:18,086 --> 00:02:20,476
我们使用加密技术


55
00:02:20,476 --> 00:02:21,886
来验证在平台上运行的


56
00:02:21,886 --> 00:02:23,506
软件的完整性


57
00:02:23,876 --> 00:02:25,206
以确保它不被破坏


58
00:02:25,206 --> 00:02:27,216
同时保证其安全属性


59
00:02:27,216 --> 00:02:29,376
没有被篡改


60
00:02:30,746 --> 00:02:32,996
我们用加密技术来保护静态数据


61
00:02:34,086 --> 00:02:36,236
我们在众多用户


62
00:02:36,476 --> 00:02:38,166
喜爱的 App 中使用加密技术


63
00:02:38,666 --> 00:02:42,416
用户广泛地使用它们


64
00:02:42,616 --> 00:02:45,816
来捕捉和分享非常私人的时刻


65
00:02:46,426 --> 00:02:47,946
这是一个在信息


66
00:02:48,766 --> 00:02:50,876
Safari 浏览器和 iCloud 的例子


67
00:02:51,876 --> 00:02:53,806
我们有超过十亿的设备


68
00:02:53,806 --> 00:02:55,726
因此我们大范围地使用加密技术


69
00:02:57,056 --> 00:02:58,806
那么你可以想象


70
00:02:59,186 --> 00:03:00,206
风险也是非常高的


71
00:03:00,626 --> 00:03:02,936
性能对提高用户体验来说


72
00:03:02,936 --> 00:03:04,066
是至关重要的


73
00:03:05,016 --> 00:03:07,006
电量是保证我们


74
00:03:07,136 --> 00:03:09,296
全天使用的基础


75
00:03:09,296 --> 00:03:11,166
而安全则是基石


76
00:03:12,526 --> 00:03:13,856
现在 我们来进一步了解一下


77
00:03:13,856 --> 00:03:14,516
加密技术


78
00:03:16,196 --> 00:03:17,896
加密技术其实是一个工具


79
00:03:18,286 --> 00:03:20,116
它为一系列基本属性


80
00:03:20,306 --> 00:03:21,956
提供解决方案


81
00:03:23,186 --> 00:03:25,096
比如身份认证 它能够


82
00:03:25,096 --> 00:03:27,776
让你知道是谁向你发送了信息


83
00:03:29,456 --> 00:03:31,406
加密 就意味着


84
00:03:31,406 --> 00:03:34,546
只有你才能解密该消息


85
00:03:35,456 --> 00:03:37,836
而完整性 则代表着


86
00:03:37,836 --> 00:03:39,536
没有人可以在你之前


87
00:03:39,536 --> 00:03:42,506
修改该消息的内容


88
00:03:43,456 --> 00:03:45,636
为解决更广泛的


89
00:03:45,636 --> 00:03:47,166
安全问题


90
00:03:47,166 --> 00:03:48,916
我们将加密功能


91
00:03:48,916 --> 00:03:51,376
结合到加密协议中


92
00:03:51,376 --> 00:03:52,466
这并不容易


93
00:03:54,036 --> 00:03:56,266
事实上 你们中的很多人


94
00:03:56,266 --> 00:03:57,316
大多数人可能都听过这个说法


95
00:03:57,356 --> 00:03:59,426
不要使用加密 对吧


96
00:04:00,206 --> 00:04:01,616
这个说法有很好的理由


97
00:04:01,616 --> 00:04:04,256
有很多地方都可能出错


98
00:04:05,456 --> 00:04:07,476
比如它有可能选中


99
00:04:07,476 --> 00:04:09,116
错误的原语


100
00:04:09,116 --> 00:04:09,946
从而使你得不到


101
00:04:09,946 --> 00:04:11,766
你想要获得的安全


102
00:04:12,636 --> 00:04:14,566
或者它也可能添加了正确的


103
00:04:14,566 --> 00:04:16,745
原语 但没有正确使用它们


104
00:04:16,745 --> 00:04:19,656
而最低级的错误 


105
00:04:19,656 --> 00:04:22,366
即安装启动的时候


106
00:04:22,366 --> 00:04:23,916
就可能泄露了隐私或密钥


107
00:04:24,296 --> 00:04:25,476
这可能会造成定时攻击


108
00:04:25,476 --> 00:04:27,556
或 Padding Oracle 攻击


109
00:04:28,886 --> 00:04:30,696
这就是为什么


110
00:04:30,696 --> 00:04:32,056
加密十分困难


111
00:04:32,386 --> 00:04:35,046
新闻上我们可以看到


112
00:04:35,186 --> 00:04:36,356
无数关于加密协议


113
00:04:36,356 --> 00:04:39,636
失败的例子


114
00:04:39,636 --> 00:04:41,236
而最糟糕的是


115
00:04:41,236 --> 00:04:42,656
安全漏洞也许不是当时


116
00:04:42,656 --> 00:04:43,426
就能发现的


117
00:04:43,426 --> 00:04:45,186
也许要等到几年后


118
00:04:45,186 --> 00:04:46,306
有人报告说发现了一个漏洞


119
00:04:47,656 --> 00:04:50,386
这就是风险高的原因


120
00:04:50,386 --> 00:04:53,146
所以要保证其正确性需要


121
00:04:53,146 --> 00:04:53,736
花费很多努力


122
00:04:55,026 --> 00:04:56,286
设计一个强大的协议


123
00:04:56,636 --> 00:04:59,336
需要花费大量时间和技巧


124
00:04:59,336 --> 00:05:02,166
还需要你作为一个加密专家的专业知识


125
00:05:03,306 --> 00:05:04,686
甚至当你设计出协议的时候


126
00:05:05,056 --> 00:05:06,226
工作仍没有结束


127
00:05:06,946 --> 00:05:07,996
你还要做大量连续的工作


128
00:05:07,996 --> 00:05:10,576
来监控新的攻击


129
00:05:10,576 --> 00:05:12,156
看看什么适用于你的代码


130
00:05:12,156 --> 00:05:14,806
然后响应它


131
00:05:15,476 --> 00:05:17,096
但有时并不是那么简单


132
00:05:17,486 --> 00:05:18,676
它们可能是彼此依赖的


133
00:05:19,226 --> 00:05:20,606
那些你选择整合进


134
00:05:20,606 --> 00:05:23,846
你的 App 中的库文件


135
00:05:24,106 --> 00:05:25,856
在一些情况下


136
00:05:25,856 --> 00:05:27,006
你也需要修改并传输协议


137
00:05:27,006 --> 00:05:29,196
同时管理所有的


138
00:05:29,196 --> 00:05:30,916
可解释的场景


139
00:05:31,516 --> 00:05:35,436
所有这些是个大工程


140
00:05:36,076 --> 00:05:38,326
它会花费大量的时间和精力


141
00:05:38,326 --> 00:05:40,106
让你无暇实践可能有的精彩想法


142
00:05:40,106 --> 00:05:42,546
或者下一个很酷的功能


143
00:05:44,416 --> 00:05:46,936
这就是为什么你可以


144
00:05:46,936 --> 00:05:49,136
真正从原生功能中获益


145
00:05:50,256 --> 00:05:51,766
我们的理念一直是


146
00:05:51,766 --> 00:05:55,306
为一系列常见的问题


147
00:05:55,646 --> 00:05:57,836
提供完整的解决方案


148
00:05:57,836 --> 00:05:59,626
而你无需为此费心


149
00:06:00,936 --> 00:06:03,726
对你来说 它增加了风险


150
00:06:03,726 --> 00:06:05,586
和工作量 我们完全可以


151
00:06:05,586 --> 00:06:07,716
通过我们平台上的


152
00:06:07,716 --> 00:06:09,856
代理的硬件功能


153
00:06:09,856 --> 00:06:11,936
来实现更好的安全性


154
00:06:14,686 --> 00:06:17,046
现在 我们来看一组


155
00:06:17,046 --> 00:06:18,626
你们可能非常熟悉的


156
00:06:19,156 --> 00:06:20,646
很常见的场景


157
00:06:20,646 --> 00:06:24,146
我会先开始讲如何


158
00:06:24,146 --> 00:06:25,736
保护一个设备上的数据


159
00:06:26,366 --> 00:06:28,676
接着我们可以看看


160
00:06:28,676 --> 00:06:30,206
保护凭证和密钥


161
00:06:30,766 --> 00:06:36,456
之后是跨设备和用户的数据共享


162
00:06:38,256 --> 00:06:40,106
接着是保护网络链接安全


163
00:06:40,106 --> 00:06:42,196
那么最后是


164
00:06:42,346 --> 00:06:44,846
用证书验证间接联系人


165
00:06:46,426 --> 00:06:49,276
现在 我们来看第一个例子


166
00:06:49,406 --> 00:06:50,456
相信你们中的很多人


167
00:06:50,546 --> 00:06:54,106
已经发现了该场景


168
00:06:54,106 --> 00:06:56,556
并且在努力保护设备上的数据


169
00:06:57,406 --> 00:07:00,496
那么 我建议你们不要


170
00:07:00,496 --> 00:07:01,586
仅仅是复制粘贴你在


171
00:07:01,586 --> 00:07:03,246
一些网站上发现的东西


172
00:07:03,896 --> 00:07:06,976
最好使用数据保护


173
00:07:08,016 --> 00:07:09,276
数据保护综合了


174
00:07:09,276 --> 00:07:11,046
密码的长处


175
00:07:11,046 --> 00:07:12,766
和 Secure Enclave 中的


176
00:07:12,766 --> 00:07:14,696
硬件技术


177
00:07:14,816 --> 00:07:16,966
来确保密钥的安全性


178
00:07:16,966 --> 00:07:19,886
同时使加密数据不能被


179
00:07:19,886 --> 00:07:20,796
暴力破解密码


180
00:07:21,396 --> 00:07:23,816
但还有更多优点


181
00:07:24,526 --> 00:07:26,586
数据保护提供了


182
00:07:26,586 --> 00:07:27,556
破解后的复原


183
00:07:28,726 --> 00:07:30,656
破解后复原


184
00:07:30,656 --> 00:07:31,806
也称前向保密性


185
00:07:32,156 --> 00:07:34,166
它能确保如果攻击者


186
00:07:34,456 --> 00:07:35,666
攻击了设备的密钥


187
00:07:35,666 --> 00:07:37,736
之后用户更改了密码


188
00:07:37,736 --> 00:07:40,276
那么旧的密码


189
00:07:40,276 --> 00:07:42,086
都不能被用来恢复


190
00:07:42,086 --> 00:07:43,346
所有之后加密的数据


191
00:07:44,496 --> 00:07:47,296
这一点可以说至关重要


192
00:07:47,296 --> 00:07:48,476
如果你想要了解更多


193
00:07:49,086 --> 00:07:49,996
数据保护能做的事情


194
00:07:49,996 --> 00:07:51,946
你可以看看 iOS


195
00:07:51,946 --> 00:07:53,276
安全白皮书


196
00:07:53,276 --> 00:07:56,086
来获得更多信息


197
00:07:56,926 --> 00:07:58,386
有一件事你需要知道


198
00:07:59,166 --> 00:07:59,996
就是当你的 App 出现问题时


199
00:07:59,996 --> 00:08:02,336
你可以设置


200
00:08:02,396 --> 00:08:03,626
不同的保护属性


201
00:08:04,276 --> 00:08:08,736
首次身份验证后就可以设置


202
00:08:09,496 --> 00:08:12,776
而数据甚至一直会被保护


203
00:08:14,096 --> 00:08:15,526
直到用户在开机后第一次


204
00:08:15,526 --> 00:08:17,096
将手机解锁


205
00:08:18,346 --> 00:08:19,126
这很不错


206
00:08:20,136 --> 00:08:21,766
今天 你可以做得更好


207
00:08:22,316 --> 00:08:24,236
我们有完整的文件保护


208
00:08:24,766 --> 00:08:26,076
完整的文件保护 意味着


209
00:08:26,546 --> 00:08:28,746
只有在用户解锁他的手机后


210
00:08:28,796 --> 00:08:30,876
数据才能获取


211
00:08:31,326 --> 00:08:32,836
只要用户锁起他的手机


212
00:08:32,836 --> 00:08:33,846
将其放入一个口袋或包里


213
00:08:33,846 --> 00:08:36,336
数据就再一次被保护起来了


214
00:08:36,885 --> 00:08:39,846
这样使用起来真的很方便


215
00:08:40,145 --> 00:08:40,775
这里有一个例子


216
00:08:41,566 --> 00:08:42,686
你唯一需要使用的


217
00:08:42,846 --> 00:08:43,606
就是这个选项


218
00:08:43,916 --> 00:08:44,966
completeFileProtection


219
00:08:44,966 --> 00:08:46,706
不能比这更简单了 对


220
00:08:47,216 --> 00:08:48,376
如果你现在还没使用这个选项


221
00:08:48,376 --> 00:08:49,686
请回去查看你的 App


222
00:08:49,686 --> 00:08:50,906
看看你可以在哪里使用它


223
00:08:50,906 --> 00:08:53,446
以获得最佳级别的安全性


224
00:08:55,576 --> 00:08:58,506
现在 除了文件


225
00:08:58,506 --> 00:08:59,616
你想要保护的


226
00:08:59,616 --> 00:09:01,066
也许还有更为敏感的信息


227
00:09:02,076 --> 00:09:03,596
也有身份验证令牌 这样的证书


228
00:09:03,836 --> 00:09:05,906
它们用于对服务


229
00:09:05,906 --> 00:09:09,006
或加密密钥进行身份验证


230
00:09:09,546 --> 00:09:13,986
但不要将它们


231
00:09:13,986 --> 00:09:15,436
编写成默认值 像我们可以


232
00:09:15,436 --> 00:09:16,936
在所有平台上看到的那样


233
00:09:17,736 --> 00:09:19,666
相反 我们有钥匙串


234
00:09:21,106 --> 00:09:22,826
SecItem API 中的钥匙串


235
00:09:23,356 --> 00:09:24,826
让你能像在本地钥匙串中一样


236
00:09:25,446 --> 00:09:27,036
写那些项目 这意味着


237
00:09:27,036 --> 00:09:28,146
它们会继续保留在该设备上


238
00:09:28,146 --> 00:09:30,976
或者在 iCloud 钥匙串上


239
00:09:31,836 --> 00:09:33,076
在那里 他们将所有的设备同步


240
00:09:33,076 --> 00:09:34,426
从而实现一种


241
00:09:34,546 --> 00:09:37,306
用户账户的无缝体验


242
00:09:37,946 --> 00:09:40,086
这需要用户账户能够


243
00:09:40,306 --> 00:09:41,706
进行双重验证


244
00:09:42,306 --> 00:09:45,006
而对于钥匙串 你会发现


245
00:09:45,006 --> 00:09:47,466
它对我前面提到的文件


246
00:09:47,466 --> 00:09:48,906
和一些额外文件


247
00:09:49,576 --> 00:09:50,696
有非常相似的保护


248
00:09:51,246 --> 00:09:52,556
这里 我要再推荐你


249
00:09:52,556 --> 00:09:53,786
可以去看看那个文档


250
00:09:53,786 --> 00:09:54,286
来进一步学习


251
00:09:55,686 --> 00:09:56,946
除了了解何时可用密钥外


252
00:09:56,986 --> 00:09:58,136
有时知道用户


253
00:09:58,636 --> 00:10:00,306
如何及何时


254
00:10:00,306 --> 00:10:01,976
对其进行身份验证 也很重要


255
00:10:03,656 --> 00:10:05,576
所以在这里 我们用


256
00:10:05,576 --> 00:10:06,976
LocalAuthentication


257
00:10:08,256 --> 00:10:10,196
LocalAuthentication 使你可以


258
00:10:10,196 --> 00:10:12,446
根据何时可以执行一个操作


259
00:10:12,446 --> 00:10:14,726
来进行限制


260
00:10:15,306 --> 00:10:16,746
例如 你可以定义


261
00:10:16,886 --> 00:10:18,336
用户需要使用 Face ID


262
00:10:18,336 --> 00:10:19,646
这样的生物鉴定识别


263
00:10:19,646 --> 00:10:20,296
进行身份验证


264
00:10:21,256 --> 00:10:22,906
这样做非常方便


265
00:10:22,906 --> 00:10:25,336
同时在这方面 在 macOS 上


266
00:10:25,336 --> 00:10:26,446
我们有一些更有意思的操作


267
00:10:27,036 --> 00:10:31,066
在 macOS 上 你习惯了


268
00:10:31,146 --> 00:10:33,776
设备身份验证属性


269
00:10:33,776 --> 00:10:35,986
它为用户提供了两种方法


270
00:10:35,986 --> 00:10:38,256
来进行身份验证 分别是


271
00:10:38,256 --> 00:10:39,886
密码和支持 Touch ID 进行验证的


272
00:10:39,886 --> 00:10:41,496
Mac 上的生物鉴定识别


273
00:10:42,466 --> 00:10:43,606
今年 我们非常高兴地宣布


274
00:10:43,606 --> 00:10:46,006
现在 你不需要在


275
00:10:46,006 --> 00:10:48,746
App 上做任何的改变


276
00:10:48,746 --> 00:10:50,446
用户就可以用 Apple Watch


277
00:10:50,446 --> 00:10:52,496
来进行身份验证 只要双击 Apple Watch


278
00:10:53,376 --> 00:10:54,606
这是个很棒的全新体验


279
00:10:54,796 --> 00:10:56,506
它将会减少密码的使用


280
00:10:56,506 --> 00:10:57,986
减少摩擦


281
00:10:58,026 --> 00:10:59,926
从而提高用户体验


282
00:11:00,916 --> 00:11:02,366
现在 因为有了这些新功能


283
00:11:02,536 --> 00:11:04,306
我们增加了两个新的规则


284
00:11:05,236 --> 00:11:08,386
第一个是将身份验证


285
00:11:08,386 --> 00:11:10,416
简化为只用生物鉴定识别


286
00:11:10,416 --> 00:11:11,926
和 Watch


287
00:11:12,506 --> 00:11:16,426
第二个则是只用 Watch 验证


288
00:11:17,696 --> 00:11:18,686
我们期待看到


289
00:11:18,776 --> 00:11:19,946
你将如何在你的 macOS 上的


290
00:11:20,076 --> 00:11:21,566
App 中使用这些


291
00:11:25,196 --> 00:11:26,386
那么 我之前提到过钥匙串


292
00:11:27,316 --> 00:11:28,186
这里有一种简单的方法


293
00:11:28,236 --> 00:11:30,376
可以将一个账户


294
00:11:30,376 --> 00:11:32,286
在所有设备上的项目同步


295
00:11:33,196 --> 00:11:34,066
那么如果你有数据怎么办呢


296
00:11:35,086 --> 00:11:36,636
好 对于数据我们也有很好的


297
00:11:36,636 --> 00:11:37,236
解决方法


298
00:11:38,626 --> 00:11:41,436
CloudKit 它使你可以


299
00:11:41,436 --> 00:11:43,336
在私人 CloudKit 数据库里


300
00:11:43,336 --> 00:11:46,856
对素材进行加密


301
00:11:46,856 --> 00:11:48,556
相应的数据就会


302
00:11:48,556 --> 00:11:50,156
在所有的设备间共享


303
00:11:50,156 --> 00:11:52,376
而用户不需要登录 App


304
00:11:52,936 --> 00:11:56,296
这很不错 甚至你可以用它


305
00:11:56,296 --> 00:11:58,636
来共享给所有的用户


306
00:12:00,796 --> 00:12:02,896
它的工作方式是 Apple


307
00:12:02,936 --> 00:12:05,746
将作为一个信任方


308
00:12:05,846 --> 00:12:08,046
来帮助管理 iCloud 身份


309
00:12:08,046 --> 00:12:09,886
和对数据的控制


310
00:12:10,596 --> 00:12:13,776
这里我再举一个例子


311
00:12:13,776 --> 00:12:15,786
这个设置起来很容易


312
00:12:16,946 --> 00:12:17,976
从文件中 我们创建一个素材


313
00:12:20,556 --> 00:12:22,626
用这个素材 我们创建了一个记录


314
00:12:23,496 --> 00:12:24,846
然后我们将这个记录


315
00:12:24,906 --> 00:12:26,476
上传到私人 CloudKit 数据库


316
00:12:27,166 --> 00:12:31,386
这样就可以了 如果你想


317
00:12:31,436 --> 00:12:32,816
向其他用户添加共享


318
00:12:32,816 --> 00:12:34,486
API 也是可以做到的


319
00:12:34,486 --> 00:12:36,326
如果你之前没有关注过 CloudKit


320
00:12:36,356 --> 00:12:38,076
那么这是一个很好的时机


321
00:12:38,376 --> 00:12:39,366
你可以去查看说明文档


322
00:12:39,366 --> 00:12:40,656
看看它对你来说


323
00:12:40,656 --> 00:12:42,046
有多么强大


324
00:12:42,046 --> 00:12:45,326
那么 我们之前说了


325
00:12:45,326 --> 00:12:47,846
保护设备里的数据


326
00:12:47,846 --> 00:12:49,876
然后将其在设备间共享


327
00:12:49,876 --> 00:12:52,626
甚至是共享到另一用户的设备


328
00:12:52,626 --> 00:12:55,756
比如 在你想对来自你自己的


329
00:12:55,756 --> 00:12:58,206
服务器的数据执行此操作的时候


330
00:12:59,436 --> 00:13:00,986
你想在哪里建立


331
00:13:00,986 --> 00:13:02,276
一个安全连接


332
00:13:03,556 --> 00:13:04,646
安全连接


333
00:13:04,646 --> 00:13:06,956
真的十分重要


334
00:13:07,126 --> 00:13:08,916
因为它能帮助我们


335
00:13:08,916 --> 00:13:10,376
保证用户在使用你的


336
00:13:10,376 --> 00:13:12,826
App 时的所有信息的


337
00:13:12,826 --> 00:13:14,896
保密性 同时保证


338
00:13:14,896 --> 00:13:16,676
该信息的可信度


339
00:13:16,676 --> 00:13:18,976
确保它不被篡改


340
00:13:21,226 --> 00:13:22,346
那么在这里


341
00:13:22,346 --> 00:13:23,936
你首先不应该做的就是


342
00:13:23,936 --> 00:13:25,696
只是尝试使用你的自定协议


343
00:13:26,296 --> 00:13:27,776
有一个很好的解决方案


344
00:13:28,626 --> 00:13:29,696
这是一个标准的解决方案


345
00:13:30,946 --> 00:13:32,446
传输层安全协议


346
00:13:33,236 --> 00:13:35,826
它在我们的平台上真的很好用


347
00:13:36,246 --> 00:13:39,096
因为我们有两个很棒的 API


348
00:13:39,906 --> 00:13:41,076
第一个是网络框架


349
00:13:41,076 --> 00:13:42,796
你可能已经在


350
00:13:42,796 --> 00:13:46,316
去年的 WWDC 中发现了这个


351
00:13:47,036 --> 00:13:48,946
第二个就是 URL 会话


352
00:13:49,286 --> 00:13:51,356
你可能知道它是


353
00:13:51,356 --> 00:13:53,236
App 传输层安全的一部分


354
00:13:55,116 --> 00:13:56,726
而在 URL 会话中


355
00:13:56,726 --> 00:13:59,816
我们只需要使用一个


356
00:14:00,656 --> 00:14:00,986
https TPS 端点


357
00:14:00,986 --> 00:14:02,926
在这两种情况中


358
00:14:03,786 --> 00:14:07,106
我们依赖的都是


359
00:14:07,866 --> 00:14:09,496
包含很多默认值的 TLS


360
00:14:10,336 --> 00:14:12,876
默认值保证密码套件提供


361
00:14:13,436 --> 00:14:14,676
强大的安全性


362
00:14:14,966 --> 00:14:16,486
包括完美前向保密


363
00:14:16,556 --> 00:14:18,796
以及 Apple 产品上


364
00:14:18,796 --> 00:14:21,276
最有效的算法


365
00:14:21,816 --> 00:14:24,576
或者在默认情况下


366
00:14:26,156 --> 00:14:28,086
实现 TLS 也要使用 TLS 1.3


367
00:14:28,086 --> 00:14:30,766
你可能不是很熟悉 TLS 1.3


368
00:14:30,766 --> 00:14:32,936
它相对于之前的版本


369
00:14:32,936 --> 00:14:34,596
有很大的改进


370
00:14:34,596 --> 00:14:37,446
它可以大大提高


371
00:14:37,726 --> 00:14:39,156
安全性和效率


372
00:14:39,156 --> 00:14:41,246
通过减少一些运行行程


373
00:14:42,996 --> 00:14:45,166
如果你还没有使用 TLS 1.3


374
00:14:46,026 --> 00:14:46,876
那么请你试着将其


375
00:14:46,876 --> 00:14:48,816
应用在你的服务器上


376
00:14:48,816 --> 00:14:50,526
而你不需要在你的 App 上


377
00:14:50,526 --> 00:14:51,556
做任何改变


378
00:14:51,556 --> 00:14:53,826
就可以受益


379
00:14:55,456 --> 00:14:56,836
好 为了向你展示它真的很简单


380
00:14:56,836 --> 00:14:58,936
我这里有两个使用网络框架


381
00:14:58,936 --> 00:15:01,206
和 URL 会话的例子


382
00:15:02,026 --> 00:15:04,016
但在讲这两个例子前


383
00:15:04,016 --> 00:15:05,586
我想要强调的是


384
00:15:05,586 --> 00:15:06,826
安全传输这种方法


385
00:15:07,096 --> 00:15:08,376
我们不再推荐


386
00:15:08,376 --> 00:15:10,886
我们希望你


387
00:15:10,886 --> 00:15:12,576
转用网络框架


388
00:15:12,576 --> 00:15:13,776
和 URL 会话


389
00:15:13,776 --> 00:15:14,776
如果你正在使用安全传输的话


390
00:15:15,686 --> 00:15:17,806
我们为此准备了很多的例子


391
00:15:18,776 --> 00:15:20,896
首先是网络框架


392
00:15:20,896 --> 00:15:22,676
当你建立了一个连接


393
00:15:22,676 --> 00:15:24,926
你需要做的唯一的事就是


394
00:15:25,006 --> 00:15:27,926
加上 using:tls 好了


395
00:15:27,926 --> 00:15:30,516
你添加了该 TLS 连接


396
00:15:30,516 --> 00:15:32,226
会带给你更好的安全性和性能


397
00:15:33,296 --> 00:15:35,356
然后是 URL 会话


398
00:15:35,356 --> 00:15:38,186
在这里 你只需要用 http 端点


399
00:15:38,236 --> 00:15:40,866
好了


400
00:15:41,136 --> 00:15:43,636
在一些情况下


401
00:15:44,286 --> 00:15:45,736
你也许无法用 TLS


402
00:15:45,986 --> 00:15:47,566
例如 如果你已经在尝试


403
00:15:47,566 --> 00:15:49,876
通过一个内容发布网络


404
00:15:49,876 --> 00:15:51,356
来保护数据


405
00:15:52,146 --> 00:15:54,116
这时 你管理那些证书


406
00:15:54,116 --> 00:15:56,296
而对于证书来说


407
00:15:56,456 --> 00:15:59,606
首先要避免的就是


408
00:15:59,606 --> 00:16:01,816
将它用在解析器上


409
00:16:01,816 --> 00:16:02,896
或尝试用一个你在网站上


410
00:16:02,896 --> 00:16:04,416
随意发现的解析器


411
00:16:05,066 --> 00:16:06,626
解析器非常脆弱


412
00:16:06,626 --> 00:16:09,526
因为它包含大量的攻击暴露


413
00:16:10,956 --> 00:16:12,026
这是很严重的问题


414
00:16:13,216 --> 00:16:16,286
在平台上我们有 SecTrust


415
00:16:17,126 --> 00:16:18,466
SecTrust 提供了一个简单的方法


416
00:16:18,466 --> 00:16:20,436
即根据一个信任规则


417
00:16:21,056 --> 00:16:22,286
来验证证书


418
00:16:23,086 --> 00:16:24,286
而信任规则可能包含


419
00:16:24,286 --> 00:16:26,096
过期信息


420
00:16:27,006 --> 00:16:29,786
作废信息


421
00:16:29,786 --> 00:16:31,666
而直到证书已经被验证了


422
00:16:31,836 --> 00:16:36,386
你才知道你可以使用密码


423
00:16:36,636 --> 00:16:38,196
注意 如果你使用 TLS 的话


424
00:16:38,196 --> 00:16:40,566
你就不需要担心证书的问题了


425
00:16:40,736 --> 00:16:43,326
一切都在为你安排好了


426
00:16:43,886 --> 00:16:47,546
好 在这个版本中


427
00:16:47,546 --> 00:16:49,606
我们很高兴介绍一个


428
00:16:49,606 --> 00:16:51,846
SecTrust 中的新函数


429
00:16:52,716 --> 00:16:54,256
该函数综合了


430
00:16:54,256 --> 00:16:56,686
你之前能做的两件事


431
00:16:57,286 --> 00:16:58,476
一方面 这是一个函数


432
00:16:58,476 --> 00:17:00,206
它允许异步执行


433
00:17:00,656 --> 00:17:02,796
通过显式操作


434
00:17:02,796 --> 00:17:04,806
来完成一个验证证书


435
00:17:04,806 --> 00:17:06,026
这样你的 App 就可以


436
00:17:06,026 --> 00:17:07,336
在证书被验证的同时


437
00:17:07,336 --> 00:17:09,026
进行其他的事


438
00:17:09,626 --> 00:17:11,925
但同时 这个函数


439
00:17:11,925 --> 00:17:13,026
可以进行更丰富的处理


440
00:17:13,685 --> 00:17:15,996
那么 作为一个开发人员


441
00:17:16,705 --> 00:17:18,726
你知道万一失败了要怎么办


442
00:17:18,776 --> 00:17:20,665
你可以进行调试


443
00:17:21,306 --> 00:17:22,675
但同时 你可以在你的 App 里


444
00:17:22,675 --> 00:17:25,215
建立逻辑来对不同的


445
00:17:25,215 --> 00:17:26,556
错误场景作出回应


446
00:17:27,146 --> 00:17:29,086
那么这个新函数将会


447
00:17:29,086 --> 00:17:30,736
让调试变得更为


448
00:17:30,736 --> 00:17:31,856
方便和简单


449
00:17:31,856 --> 00:17:34,106
我们期待着你能运用它


450
00:17:34,656 --> 00:17:37,626
那么 我刚刚向大家介绍了


451
00:17:37,626 --> 00:17:40,336
五种不同的场景


452
00:17:40,336 --> 00:17:42,466
对于这些场景


453
00:17:42,836 --> 00:17:44,976
我们有非常易于使用的解决方案


454
00:17:45,456 --> 00:17:47,536
它们提供了很好的安全性


455
00:17:47,536 --> 00:17:50,186
你只需要使用默认设置


456
00:17:50,186 --> 00:17:53,306
或者修改几个属性就可以


457
00:17:53,876 --> 00:17:57,546
在这里 我们又一次地


458
00:17:58,156 --> 00:17:59,326
受益于与硬件的深度融合


459
00:17:59,326 --> 00:18:00,756
以此提供安全特性


460
00:18:00,816 --> 00:18:02,326
否则我们是很难


461
00:18:02,326 --> 00:18:03,396
提供这些特性的


462
00:18:04,026 --> 00:18:06,646
那么 无论在哪个场景中


463
00:18:06,906 --> 00:18:09,496
当你遇到它们


464
00:18:09,496 --> 00:18:10,406
就去使用系统框架


465
00:18:10,406 --> 00:18:11,986
如果你已经这么做了


466
00:18:11,986 --> 00:18:13,296
就要保证你正在使用的


467
00:18:13,296 --> 00:18:14,016
都是最好的属性


468
00:18:14,016 --> 00:18:14,936
这样你才能


469
00:18:14,936 --> 00:18:17,656
以尽可能好的方式


470
00:18:17,656 --> 00:18:19,466
来保护用户和商业素材


471
00:18:20,086 --> 00:18:24,056
我们明白在一些情况下


472
00:18:24,056 --> 00:18:26,186
使用系统功能


473
00:18:26,186 --> 00:18:29,216
也许对你来说并不是那么实用


474
00:18:29,746 --> 00:18:32,556
例如 你可能需要


475
00:18:32,926 --> 00:18:35,726
在适用系统之外具备互操作性


476
00:18:35,856 --> 00:18:38,626
你可以用你的服务


477
00:18:38,626 --> 00:18:41,936
来进行身份验证


478
00:18:41,936 --> 00:18:44,096
或者只是给一个


479
00:18:44,096 --> 00:18:46,386
需要实现的规范


480
00:18:46,386 --> 00:18:49,536
对所有这些例子 我们现在


481
00:18:49,536 --> 00:18:50,766
要介绍一个很棒的解决方案


482
00:18:51,976 --> 00:18:53,006
Apple CryptoKit


483
00:18:53,936 --> 00:18:57,026
Apple CryptoKit 是


484
00:18:57,096 --> 00:18:59,576
新的 Swift 加密 API


485
00:18:59,576 --> 00:19:00,956
其设计理念与我们


486
00:19:00,956 --> 00:19:02,866
所讨论的功能的设计理念相同


487
00:19:02,866 --> 00:19:05,396
它让你能够很容易地


488
00:19:05,396 --> 00:19:06,886
访问加密函数


489
00:19:06,886 --> 00:19:10,096
也很难误用函数


490
00:19:11,006 --> 00:19:14,966
我们很高兴在本次发布中介绍它


491
00:19:16,106 --> 00:19:17,766
现在 我要交给 Frederic


492
00:19:17,886 --> 00:19:18,916
他将向你们介绍


493
00:19:18,916 --> 00:19:20,386
这个全新的 API


494
00:19:21,076 --> 00:19:22,976
下面有请 Frederic 上台


495
00:19:23,516 --> 00:19:29,546
[掌声]


496
00:19:30,046 --> 00:19:30,846
>> 谢谢 Yannick


497
00:19:31,776 --> 00:19:32,386
大家好


498
00:19:32,796 --> 00:19:34,946
我的名字是 Frederic Jacobs


499
00:19:34,946 --> 00:19:36,526
我来自 Apple 的


500
00:19:36,526 --> 00:19:37,936
加密工程团队


501
00:19:38,646 --> 00:19:40,536
很高兴能向你们进一步介绍


502
00:19:40,536 --> 00:19:42,546
Apple CryptoKit


503
00:19:43,386 --> 00:19:44,866
我们认为你一定会喜欢


504
00:19:44,866 --> 00:19:49,346
在 Swift 中实现加密协议


505
00:19:49,396 --> 00:19:51,786
关于 Apple CryptoKit 有四个方面


506
00:19:51,786 --> 00:19:53,376
我想要在今天下午


507
00:19:53,376 --> 00:19:54,346
与你分享


508
00:19:55,216 --> 00:19:57,596
首先 我们要谈一谈


509
00:19:57,786 --> 00:19:59,656
CryptoKit 和 Swift


510
00:20:00,876 --> 00:20:03,876
第二 我们会向大家介绍


511
00:20:03,876 --> 00:20:06,016
能够在 CryptoKit 里


512
00:20:06,016 --> 00:20:07,566
获得的算法


513
00:20:08,556 --> 00:20:11,016
第三 我们将讨论一下


514
00:20:11,126 --> 00:20:14,146
Secure Enclave


515
00:20:14,146 --> 00:20:16,016
和生物鉴定识别


516
00:20:16,586 --> 00:20:18,746
最后 我们会谈谈性能


517
00:20:19,706 --> 00:20:21,006
我们开始吧


518
00:20:22,096 --> 00:20:23,806
在过去 当你从 Swift 中


519
00:20:23,856 --> 00:20:25,556
调用 C 加密 API 时


520
00:20:25,556 --> 00:20:28,726
你可能不得不编写


521
00:20:28,726 --> 00:20:30,366
这样的代码


522
00:20:31,126 --> 00:20:33,326
你需要分配缓冲区


523
00:20:33,596 --> 00:20:34,806
分析出每一个


524
00:20:34,806 --> 00:20:36,706
缓冲区的尺寸大小


525
00:20:37,406 --> 00:20:39,576
也有像随机数这样的值


526
00:20:39,576 --> 00:20:42,246
你可能需要查找


527
00:20:42,246 --> 00:20:45,366
该值的安全值是多少


528
00:20:46,326 --> 00:20:47,836
然后 你将所有这些


529
00:20:47,836 --> 00:20:50,406
嵌套调用至


530
00:20:50,406 --> 00:20:52,746
你传递指针的加密函数中


531
00:20:52,746 --> 00:20:54,346
同时这里没有参数标签


532
00:20:54,346 --> 00:20:56,556
来帮你弄清


533
00:20:56,846 --> 00:21:01,426
哪个指针需要进入哪个参数


534
00:21:02,306 --> 00:21:04,716
相比之下 用 Apple CryptoKit


535
00:21:04,716 --> 00:21:07,556
你可以只写一行代码


536
00:21:07,556 --> 00:21:09,836
来进行完全一样的操作


537
00:21:11,086 --> 00:21:12,696
是不是很棒呢


538
00:21:13,516 --> 00:21:18,506
[掌声]


539
00:21:19,006 --> 00:21:21,746
那么 为了完成这个


540
00:21:21,746 --> 00:21:23,036
你将你想要加密的数据


541
00:21:23,036 --> 00:21:24,666
进行传输


542
00:21:24,786 --> 00:21:26,836
在这个例子里 我们使用 AES.GCM


543
00:21:26,836 --> 00:21:29,536
同时 我们用你想要加密的


544
00:21:29,536 --> 00:21:31,616
数据的密钥


545
00:21:31,616 --> 00:21:34,716
这就好了


546
00:21:35,926 --> 00:21:38,276
你也许还需要


547
00:21:38,276 --> 00:21:40,016
生成自己的加密密钥


548
00:21:40,016 --> 00:21:42,036
当你从 Swift 中


549
00:21:42,036 --> 00:21:44,146
调用 C 加密 API 的时候


550
00:21:44,766 --> 00:21:46,796
我们首先需要


551
00:21:47,116 --> 00:21:48,646
转换一些位和字节


552
00:21:48,646 --> 00:21:50,456
因为加密密钥


553
00:21:50,456 --> 00:21:52,996
通常是用位来表示的


554
00:21:54,066 --> 00:21:56,446
接着你需要为


555
00:21:56,446 --> 00:22:01,416
这一数量的字节


556
00:22:01,576 --> 00:22:03,576
分配一个缓冲区


557
00:22:03,576 --> 00:22:05,606
并使用系统随机数生成器 


558
00:22:05,666 --> 00:22:08,096
来用加密安全的随机数


559
00:22:08,096 --> 00:22:09,556
填充该缓冲区


560
00:22:11,216 --> 00:22:14,606
接着 如果出现错误


561
00:22:14,606 --> 00:22:15,666
你必须处理它


562
00:22:16,726 --> 00:22:19,646
然后你终于可以使用该密钥了


563
00:22:19,646 --> 00:22:22,816
当使用完该密钥时


564
00:22:22,816 --> 00:22:24,706
即使你忘记把它归零


565
00:22:24,706 --> 00:22:28,216
也可以将其从内存中移除


566
00:22:28,836 --> 00:22:32,956
而使用 CryptoKit


567
00:22:32,956 --> 00:22:37,906
只要一行代码就可生成一个密钥


568
00:22:38,636 --> 00:22:40,376
你调用 SymmetricKey


569
00:22:40,906 --> 00:22:42,796
初始化程序 然后传输


570
00:22:42,796 --> 00:22:45,836
你希望密钥持有的一定量的位


571
00:22:50,096 --> 00:22:52,666
我们能在释放时将该密钥归零


572
00:22:52,666 --> 00:22:55,966
因为只要了解该值的


573
00:22:56,566 --> 00:22:58,916
自动引用计数


574
00:22:58,916 --> 00:23:02,626
无论它什么时候被释放


575
00:23:03,096 --> 00:23:04,806
我们都在将


576
00:23:04,806 --> 00:23:09,246
该缓冲区归零


577
00:23:09,456 --> 00:23:11,376
好 CryptoKit 和 Swift


578
00:23:12,266 --> 00:23:15,426
我们有一个强类型的 API


579
00:23:16,366 --> 00:23:18,726
无论你何时初始化一个值


580
00:23:19,426 --> 00:23:22,436
我们都在验证


581
00:23:22,436 --> 00:23:24,826
你所传递的数据


582
00:23:25,076 --> 00:23:26,596
是否为该参数的一个强值


583
00:23:28,116 --> 00:23:32,706
多亏 Swift 的内存管理模型


584
00:23:32,706 --> 00:23:34,506
我们才能够在释放时


585
00:23:34,946 --> 00:23:38,376
将所有分配在


586
00:23:38,376 --> 00:23:40,656
CryptoKit 里的秘值归零


587
00:23:41,986 --> 00:23:43,646
我们将对一些


588
00:23:43,646 --> 00:23:46,846
如消息身份验证代码之类的值


589
00:23:47,066 --> 00:23:49,416
执行公平的一致性


590
00:23:49,736 --> 00:23:50,746
如果你熟悉该内容的话


591
00:23:50,746 --> 00:23:52,756
你就能够通过


592
00:23:52,756 --> 00:23:53,966
只使用 == 操作符


593
00:23:53,966 --> 00:23:56,006
在恒定的时间内


594
00:23:56,006 --> 00:23:58,786
来对双消息身份验证代码


595
00:23:58,786 --> 00:23:59,866
进行验证


596
00:24:03,556 --> 00:24:06,516
CryptoKit 也定义协议


597
00:24:06,806 --> 00:24:09,296
这样你可以在


598
00:24:09,296 --> 00:24:12,336
哈希函数 H 上编写通用代码


599
00:24:12,426 --> 00:24:14,176
如果在你代码库的多个位置中


600
00:24:14,176 --> 00:24:16,136
需要传递不同的哈希函数


601
00:24:16,136 --> 00:24:17,656
那么你可以只编写一次代码


602
00:24:17,656 --> 00:24:19,346
然后确定函数的参数


603
00:24:19,496 --> 00:24:21,976
来调用一个不同的哈希函数


604
00:24:24,776 --> 00:24:27,456
那么 我们讲过了 CryptoKit 和 Swift


605
00:24:27,456 --> 00:24:29,836
接下来我想深入讲讲


606
00:24:29,836 --> 00:24:32,996
CryptoKit 中所支持的


607
00:24:33,066 --> 00:24:36,716
算法集


608
00:24:37,756 --> 00:24:40,716
所有算法都是标准的


609
00:24:40,716 --> 00:24:41,896
同行评议的算法


610
00:24:42,526 --> 00:24:46,216
我们来看看 CryptoKit 中支持什么


611
00:24:47,716 --> 00:24:49,066
这里支持哈希函数


612
00:24:49,066 --> 00:24:51,276
消息身份验证代码


613
00:24:51,276 --> 00:24:53,056
认证加密


614
00:24:53,696 --> 00:24:56,796
密钥协商


615
00:24:57,026 --> 00:25:01,126
以及签名


616
00:25:02,876 --> 00:25:05,096
这其中的一些算法


617
00:25:05,096 --> 00:25:06,686
是我们之前在


618
00:25:06,686 --> 00:25:09,316
如 Common Crypto 或 SecKey 等框架中


619
00:25:09,316 --> 00:25:11,576
就支持的算法


620
00:25:11,576 --> 00:25:13,136
但有一些算法


621
00:25:13,136 --> 00:25:15,206
则是我们首次支持的算法


622
00:25:15,726 --> 00:25:17,816
我将它们用绿色标出


623
00:25:18,466 --> 00:25:22,596
注意我们还有一个非安全的模块


624
00:25:23,936 --> 00:25:27,216
该模块提供如 MD5 和 SHA1


625
00:25:27,216 --> 00:25:30,776
这样的算法


626
00:25:30,776 --> 00:25:32,806
这样即使你需要使用一些


627
00:25:32,806 --> 00:25:35,356
不再满足最佳安全标准的算法


628
00:25:35,356 --> 00:25:38,526
你也可以使用 CryptoKit 


629
00:25:42,836 --> 00:25:46,306
我们通过一些例子


630
00:25:46,636 --> 00:25:47,986
来看 CryptoKit 是如何工作的


631
00:25:48,806 --> 00:25:50,356
让我们从哈希函数开始


632
00:25:50,926 --> 00:25:53,406
哈希函数会生成


633
00:25:53,406 --> 00:25:56,456
确定的固定大小的输出


634
00:25:56,616 --> 00:25:58,816
我们称其为摘要


635
00:25:58,996 --> 00:26:01,526
与 Swift 中 Hashable 希的不同


636
00:26:01,526 --> 00:26:04,326
CryptoKit中的哈希函数


637
00:26:04,726 --> 00:26:07,686
提供了如防碰撞等加密特性


638
00:26:08,626 --> 00:26:10,876
这意味着你很难找到


639
00:26:10,876 --> 00:26:16,986
两个会哈希出相同摘要的输入


640
00:26:16,986 --> 00:26:19,606
计算该哈希十分简单


641
00:26:19,606 --> 00:26:22,926
就像在你想要使用的哈希函数上


642
00:26:22,926 --> 00:26:24,976
调用哈希方法


643
00:26:24,976 --> 00:26:28,166
然后传递所要哈希的数据那样


644
00:26:29,196 --> 00:26:32,016
这里我想要哈希一些音频数据


645
00:26:32,016 --> 00:26:35,496
那么我会用 SHA256 哈希函数


646
00:26:35,496 --> 00:26:38,976
来计算一个摘要


647
00:26:45,146 --> 00:26:47,676
那你也许会从输入流中读取它


648
00:26:49,096 --> 00:26:50,416
在这种情况下


649
00:26:50,416 --> 00:26:53,906
你需要以增量来计算摘要


650
00:26:55,096 --> 00:26:57,566
首先你初始化一个哈希


651
00:26:57,566 --> 00:26:59,836
通过在哈希函数上


652
00:26:59,836 --> 00:27:01,746
调用 MT 初始化程序


653
00:27:02,236 --> 00:27:07,016
接着传送你想要哈希的数据


654
00:27:07,016 --> 00:27:09,146
然后为此一次或多次地


655
00:27:09,146 --> 00:27:14,516
调用 update() 方法


656
00:27:14,756 --> 00:27:17,966
当你想要计算该摘要时


657
00:27:17,966 --> 00:27:20,446
你只要立即在哈希上


658
00:27:20,446 --> 00:27:22,226
调用 finalize() 方法


659
00:27:22,226 --> 00:27:24,466
然后它就会返回摘要


660
00:27:24,886 --> 00:27:29,396
接下来 我们来说说


661
00:27:29,636 --> 00:27:30,886
认证加密


662
00:27:31,716 --> 00:27:34,446
这也是你们一直想知道的


663
00:27:35,106 --> 00:27:37,496
正如它的名字所示


664
00:27:37,496 --> 00:27:39,896
它可以同时提供认证和加密


665
00:27:41,436 --> 00:27:44,146
在加密协议中


666
00:27:44,146 --> 00:27:46,686
缺少认证


667
00:27:46,686 --> 00:27:49,276
会导致很多攻击


668
00:27:49,836 --> 00:27:51,316
将身份验证


669
00:27:51,436 --> 00:27:53,636
和加密手动结合


670
00:27:54,356 --> 00:27:56,266
会导致如 Padding Oracle 


671
00:27:56,266 --> 00:27:58,076
这样的攻击


672
00:27:58,436 --> 00:28:00,586
所以 我们非常乐意将它


673
00:28:00,656 --> 00:28:03,036
作为一个 API 调用提供给你


674
00:28:07,076 --> 00:28:08,846
我正在做的一个项目


675
00:28:09,096 --> 00:28:10,586
这是一个徒步旅行 App


676
00:28:11,216 --> 00:28:12,786
该 App 上的大多数内容是免费的


677
00:28:12,786 --> 00:28:15,316
但也有额外的内容


678
00:28:15,316 --> 00:28:21,276
你可以在 App 里花钱购买


679
00:28:21,386 --> 00:28:22,876
一旦购买了该内容


680
00:28:23,216 --> 00:28:25,156
你就可以获取额外的内容


681
00:28:26,576 --> 00:28:27,936
我正在使用一个内容发布网络


682
00:28:27,936 --> 00:28:29,706
以此来保证随着用户群的增长


683
00:28:29,706 --> 00:28:32,776
下载的速度仍然很快


684
00:28:35,436 --> 00:28:37,776
为了获得该内容


685
00:28:38,026 --> 00:28:41,366
我首先检查了我的服务器


686
00:28:41,366 --> 00:28:44,976
看 App 内购买是否有效


687
00:28:45,596 --> 00:28:49,706
接着从服务器中获取到密钥


688
00:28:49,706 --> 00:28:51,296
然后通过手机传递过来


689
00:28:52,656 --> 00:28:54,836
我从内容发布网络上


690
00:28:55,136 --> 00:28:56,286
下载该加密数据


691
00:28:56,286 --> 00:29:00,686
然后使用密钥


692
00:29:00,686 --> 00:29:02,736
来将加密内容解密


693
00:29:03,136 --> 00:29:06,346
如果密钥正确


694
00:29:06,346 --> 00:29:08,276
且在内容发布网络上的内容


695
00:29:08,276 --> 00:29:10,816
没有被篡改


696
00:29:10,866 --> 00:29:12,696
那么我就可以获取地图数据


697
00:29:13,306 --> 00:29:19,166
下面我们来看如何转化为代码


698
00:29:19,336 --> 00:29:22,166
我们首先用服务器


699
00:29:22,166 --> 00:29:24,366
获取的密钥数据


700
00:29:24,366 --> 00:29:29,036
初始化一个 SymmetricKey


701
00:29:29,186 --> 00:29:31,976
然后我们初始化一个密封箱


702
00:29:32,996 --> 00:29:35,576
在这个例子中


703
00:29:35,576 --> 00:29:37,246
密封箱里有什么真的不重要


704
00:29:37,306 --> 00:29:39,216
但是要知道如果你


705
00:29:39,556 --> 00:29:42,106
正在实现一个规范 


706
00:29:42,106 --> 00:29:44,066
该规范要求你以一种特定的方式


707
00:29:44,066 --> 00:29:46,146
将随机数 密码文本


708
00:29:46,146 --> 00:29:48,286
和标签结合起来


709
00:29:48,286 --> 00:29:49,986
那么你就可以使用密封箱来完成


710
00:29:50,816 --> 00:29:52,216
如果你要实现


711
00:29:52,216 --> 00:29:54,446
一个需要你传输


712
00:29:54,446 --> 00:29:57,146
特定随机数值的协议


713
00:29:57,366 --> 00:29:59,176
我们也能支持这个操作


714
00:29:59,336 --> 00:30:01,376
但是在这个例子里


715
00:30:01,416 --> 00:30:02,676
我们要看看简单的情况


716
00:30:04,096 --> 00:30:06,216
好 我们将下载的数据


717
00:30:06,216 --> 00:30:08,086
作为一个 combined


718
00:30:08,086 --> 00:30:09,636
传输到密封箱里


719
00:30:09,636 --> 00:30:12,156
既然我们有一个密封箱


720
00:30:12,896 --> 00:30:15,496
我们就可以打开它


721
00:30:15,496 --> 00:30:18,936
通过在密码上调用 open() 方法


722
00:30:19,566 --> 00:30:22,816
然后我们传输密钥


723
00:30:23,426 --> 00:30:23,976
就是这么简单


724
00:30:26,916 --> 00:30:28,896
接下来 我们说一说签名


725
00:30:30,196 --> 00:30:31,946
签名被用来


726
00:30:31,946 --> 00:30:34,036
使用一个私钥


727
00:30:34,036 --> 00:30:36,616
对数据进行身份验证


728
00:30:36,616 --> 00:30:38,926
使用签名我们可以


729
00:30:38,926 --> 00:30:41,346
用关联的公共密钥来验证数据


730
00:30:41,866 --> 00:30:45,856
我们来看一个例子


731
00:30:45,856 --> 00:30:47,846
这里我们想要用签名


732
00:30:47,846 --> 00:30:49,976
来授权操作


733
00:30:50,796 --> 00:30:54,496
而这里的操作可以是一个


734
00:30:54,496 --> 00:30:56,866
双重验证登录


735
00:30:56,916 --> 00:30:58,916
或一些敏感交易事项


736
00:30:58,916 --> 00:31:01,536
比如给 App 中的其他用户汇款


737
00:31:03,666 --> 00:31:07,096
为此 我们首先要


738
00:31:07,406 --> 00:31:09,466
在设备上生成一个私钥


739
00:31:10,956 --> 00:31:13,246
接着获取相关联的公共密钥


740
00:31:13,816 --> 00:31:16,666
关联的公共密钥


741
00:31:16,666 --> 00:31:20,826
是用你的服务进行注册的


742
00:31:20,956 --> 00:31:24,016
一旦我们想要执行该操作


743
00:31:24,016 --> 00:31:25,926
我们就用私钥


744
00:31:25,926 --> 00:31:29,516
生成交易数据上的签名


745
00:31:29,516 --> 00:31:33,056
然后将该交易数据


746
00:31:33,056 --> 00:31:35,456
和签名发送给服务器


747
00:31:36,866 --> 00:31:40,566
服务器会验证


748
00:31:40,566 --> 00:31:44,686
该签名是否正确


749
00:31:44,686 --> 00:31:47,636
如果签名正确


750
00:31:47,636 --> 00:31:51,276
它将开始执行操作


751
00:31:51,756 --> 00:31:54,976
下面我们看看这组代码


752
00:31:54,976 --> 00:31:57,676
为了生成一个


753
00:31:57,676 --> 00:32:00,066
强加密的私钥


754
00:32:00,066 --> 00:32:03,566
我们调用 PrivateKey 初始化程序


755
00:32:06,876 --> 00:32:09,546
然后我们想在服务器上


756
00:32:09,546 --> 00:32:11,316
注册一些公共密钥数据


757
00:32:12,176 --> 00:32:14,556
首先我们要获取公共密钥


758
00:32:14,806 --> 00:32:17,506
通过私钥上


759
00:32:17,596 --> 00:32:19,326
调用公共密钥


760
00:32:19,956 --> 00:32:24,536
然后我们要说


761
00:32:24,596 --> 00:32:26,766
我们想从公共密钥上


762
00:32:27,156 --> 00:32:28,346
得到的表示形式


763
00:32:29,026 --> 00:32:30,546
公共密钥有多种表示形式


764
00:32:30,546 --> 00:32:32,406
而在 CryptoKit 中


765
00:32:32,456 --> 00:32:36,216
我们支持许多公共密钥


766
00:32:37,536 --> 00:32:39,886
这种情况下


767
00:32:39,886 --> 00:32:41,106
我们使用紧凑表示


768
00:32:41,776 --> 00:32:44,106
与往常一样 我们将私钥


769
00:32:44,106 --> 00:32:45,586
存储在密钥链中


770
00:32:46,676 --> 00:32:48,996
为了实现这一点


771
00:32:48,996 --> 00:32:50,236
开发者门户上提供了


772
00:32:50,236 --> 00:32:51,266
示例代码


773
00:32:51,266 --> 00:32:54,946
要生成签名


774
00:32:54,946 --> 00:32:57,456
我们要在私钥上


775
00:32:57,516 --> 00:32:59,346
调用 signature() 方法


776
00:32:59,346 --> 00:33:02,446
然后传输我们


777
00:33:02,446 --> 00:33:03,796
想要签名的交易数据


778
00:33:03,796 --> 00:33:05,926
我们就可以返回签名


779
00:33:09,136 --> 00:33:13,126
现在 保护这些操作的密钥


780
00:33:13,266 --> 00:33:16,416
是十分有价值的


781
00:33:16,416 --> 00:33:19,366
所以我们想要给它


782
00:33:19,366 --> 00:33:21,416
最好的安全保障


783
00:33:21,906 --> 00:33:23,846
这时候就轮到 Secure Enclave 了


784
00:33:25,716 --> 00:33:27,726
Secure Enclave 是


785
00:33:27,726 --> 00:33:29,156
基于硬件的密钥管理器


786
00:33:29,466 --> 00:33:30,886
它与主处理器隔离


787
00:33:30,886 --> 00:33:33,766
来提供额外的安全层


788
00:33:34,466 --> 00:33:36,316
它被用作关键系统特性的一部分 


789
00:33:36,316 --> 00:33:39,606
如 Touch ID 或 Face ID


790
00:33:41,336 --> 00:33:45,186
让我们看看如何改进


791
00:33:45,186 --> 00:33:48,156
使用签名来利用


792
00:33:48,156 --> 00:33:49,986
Secure Enclave 的代码


793
00:33:50,596 --> 00:33:54,726
我们首先检查 Secure Enclave


794
00:33:54,726 --> 00:33:56,496
是否可以在设备上获得


795
00:33:57,206 --> 00:34:00,476
我们通过在 SecureEnclave 上调用 


796
00:34:00,476 --> 00:34:01,446
isAvailable 来完成这一步


797
00:34:01,936 --> 00:34:07,286
从这里开始 我们可以使用


798
00:34:07,286 --> 00:34:09,565
和之前生成时完全一样的代码


799
00:34:10,886 --> 00:34:14,356
来生成密钥


800
00:34:14,356 --> 00:34:15,516
同时在 Secure Enclave 里


801
00:34:15,516 --> 00:34:18,076
生成签名


802
00:34:18,606 --> 00:34:20,966
注意 为了完成这一步


803
00:34:21,016 --> 00:34:24,656
我们只需给


804
00:34:24,656 --> 00:34:27,985
调用的 PrivateKey 初始化程序


805
00:34:27,985 --> 00:34:30,016
添加前缀


806
00:34:30,016 --> 00:34:31,356
SecureEnclave.


807
00:34:32,596 --> 00:34:35,746
用 Secure Enclave 就是如此简单


808
00:34:37,755 --> 00:34:41,646
使用 Secure Enclave 的一个优势是


809
00:34:41,646 --> 00:34:44,536
你可以限制密钥的使用


810
00:34:45,096 --> 00:34:48,045
在本例中 我们想说


811
00:34:48,045 --> 00:34:50,126
我们在 Secure Enclave 上


812
00:34:50,126 --> 00:34:51,755
生成的密钥


813
00:34:52,656 --> 00:34:54,866
只有在设备解锁时


814
00:34:54,866 --> 00:34:58,596
才能访问


815
00:34:58,596 --> 00:35:01,786
且该密钥只在该设备上可用


816
00:35:02,886 --> 00:35:04,706
我们可以进一步限制密钥的使用


817
00:35:04,706 --> 00:35:06,816
方法是当我们使用


818
00:35:06,816 --> 00:35:09,556
私钥执行操作时 


819
00:35:09,556 --> 00:35:12,326
我们要求用户在场


820
00:35:13,496 --> 00:35:16,076
要求用户在场意味着


821
00:35:16,076 --> 00:35:18,006
用户要么按提示进行


822
00:35:18,006 --> 00:35:19,186
生物鉴定识别


823
00:35:19,186 --> 00:35:22,336
要么按要求


824
00:35:22,336 --> 00:35:24,846
输入设备密码


825
00:35:25,466 --> 00:35:29,956
既然我们已经组成了一个


826
00:35:29,956 --> 00:35:32,156
访问控制规则


827
00:35:32,216 --> 00:35:33,726
我们只需将其传递给


828
00:35:33,726 --> 00:35:35,426
正在生成的密钥的初始化程序


829
00:35:35,426 --> 00:35:39,616
就可以执行该策略


830
00:35:40,626 --> 00:35:41,846
你可能希望为用户


831
00:35:41,846 --> 00:35:43,576
提供一些额外的上下文


832
00:35:43,656 --> 00:35:45,646
来说明为什么需要他们


833
00:35:45,646 --> 00:35:46,236
进行身份验证


834
00:35:46,886 --> 00:35:49,216
那么 我们可以传输一个


835
00:35:49,216 --> 00:35:51,126
LocalAuthentication 上下文


836
00:35:51,696 --> 00:35:56,206
在本例中 我们想要


837
00:35:56,236 --> 00:35:58,166
LocalAuthentication 上下文的
 
00:35:58,166 --> 00:36:00,376
有效期为十秒


838
00:36:00,376 --> 00:36:02,476
因此用户在这段时间内


839
00:36:02,476 --> 00:36:03,896
将不需要


840
00:36:04,426 --> 00:36:06,746
进行身份认证


841
00:36:07,116 --> 00:36:09,056
我们想告诉用户


842
00:36:09,056 --> 00:36:10,546
他们需要进行身份认证


843
00:36:10,656 --> 00:36:12,476
因为他们正在允许


844
00:36:12,476 --> 00:36:14,066
给 Bob 转账十美元


845
00:36:14,576 --> 00:36:17,506
要使用这个认证上下文


846
00:36:17,786 --> 00:36:19,516
你只需要将它


847
00:36:19,556 --> 00:36:23,136
传给密钥的初始化器


848
00:36:26,976 --> 00:36:29,456
最后让我们来谈谈性能


849
00:36:32,226 --> 00:36:34,546
CryptoKit 建立在 corecrypto 顶端


850
00:36:35,386 --> 00:36:37,556
corecrypto 是 Apple 的


851
00:36:38,056 --> 00:36:40,286
本地加密库


852
00:36:40,286 --> 00:36:41,816
它支持之前 Yannick 描述过的


853
00:36:41,816 --> 00:36:43,726
所有系统框架


854
00:36:44,306 --> 00:36:47,676
在为你带来


855
00:36:47,676 --> 00:36:48,726
Accelerate 框架的团队


856
00:36:48,726 --> 00:36:50,826
及 CPU 设计团队的帮助下


857
00:36:50,866 --> 00:36:53,216
corecrypto 手工调整了汇编代码


858
00:36:53,216 --> 00:36:55,196
将每个周期


859
00:36:55,196 --> 00:36:58,646
从每个支持微架构中压出


860
00:37:00,636 --> 00:37:03,466
除此之外


861
00:37:03,466 --> 00:37:05,776
因为它使用了 corecrypto


862
00:37:05,776 --> 00:37:07,916
所以它利用了 corecrypto 中的


863
00:37:07,916 --> 00:37:10,886
安全缓解措施


864
00:37:10,886 --> 00:37:13,986
比如侧通道阻抗


865
00:37:14,356 --> 00:37:16,446
而且 corecrypto 经过了 FIPS 验证


866
00:37:16,446 --> 00:37:19,156
这意味着你可以用


867
00:37:19,156 --> 00:37:22,196
符合 FIPS 的方式使用 CryptoKit


868
00:37:22,996 --> 00:37:24,576
Yannick 用这张幻灯片开始


869
00:37:24,716 --> 00:37:27,586
为大家展示了很多漏洞的类别


870
00:37:27,586 --> 00:37:31,006
它们会出现在


871
00:37:31,006 --> 00:37:33,076
加密协议和加密实现中


872
00:37:34,116 --> 00:37:36,086
有了 CryptoKit 我们开始


873
00:37:36,086 --> 00:37:37,896
消除这些漏洞类别中的一些


874
00:37:37,896 --> 00:37:40,036
但 CryptoKit 仍然是一个


875
00:37:40,036 --> 00:37:42,036
底层加密 API 虽然它非常强大


876
00:37:42,036 --> 00:37:44,226
可以实现各种各样的协议


877
00:37:44,226 --> 00:37:48,906
甚至是损坏的协议


878
00:37:49,076 --> 00:37:50,726
但并不是所有的加密缺点


879
00:37:50,726 --> 00:37:52,046
都可以在密码库级别上


880
00:37:52,046 --> 00:37:53,136
得到解决


881
00:37:53,496 --> 00:37:55,266
因此 我们强烈建议你


882
00:37:55,266 --> 00:37:56,706
如果可以的话


883
00:37:56,706 --> 00:37:59,626
要依靠一个更高级别的系统框架


884
00:38:00,176 --> 00:38:01,786
这仅仅是个开始


885
00:38:01,786 --> 00:38:03,586
我们想要继续帮助你


886
00:38:03,686 --> 00:38:05,646
发布尽可能安全的 App


887
00:38:05,846 --> 00:38:07,646
通过提供 API 来帮助你


888
00:38:07,646 --> 00:38:08,856
防止你 App 中


889
00:38:08,856 --> 00:38:10,526
安全的法律漏洞


890
00:38:11,056 --> 00:38:13,486
我们非常期待看到


891
00:38:13,486 --> 00:38:15,566
你在你的 App 中使用 CryptoKit


892
00:38:15,896 --> 00:38:17,146
在本次会议的网页上


893
00:38:17,446 --> 00:38:18,546
你会找到一个


894
00:38:18,546 --> 00:38:20,986
CryptoKit 说明文档的链接


895
00:38:20,986 --> 00:38:22,536
可以在 Xcode Playground 中使用


896
00:38:23,746 --> 00:38:25,866
下载它 然后摸索一下


897
00:38:25,866 --> 00:38:28,096
看看有什么可用的


898
00:38:28,756 --> 00:38:30,596
看看你如何在你的 App 中


899
00:38:30,596 --> 00:38:32,366
使用 CryptoKit


900
00:38:34,156 --> 00:38:36,016
我们会在明天的实验室中


901
00:38:36,376 --> 00:38:38,466
解答你们的问题


902
00:38:38,466 --> 00:38:41,636
我们期待你的反馈 谢谢


903
00:38:42,016 --> 00:38:44,000
[掌声]

