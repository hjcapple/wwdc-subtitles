1
00:00:06,640 --> 00:00:08,609 line:0
（使用Core Data
制作app）


2
00:00:08,675 --> 00:00:10,010 line:0
大家好


3
00:00:14,414 --> 00:00:16,583 line:-2
欢迎来到“通过Core Data
做app”演讲


4
00:00:16,650 --> 00:00:18,919 line:-2
我是Scott Perry
来自Core Data团队


5
00:00:18,986 --> 00:00:22,689 line:-1
今天 我们要做一次快速回顾


6
00:00:22,756 --> 00:00:24,458 line:-1
重点是最佳实践


7
00:00:25,025 --> 00:00:27,094 line:-2
主题有建立和运行
Core Data


8
00:00:27,160 --> 00:00:29,930 line:-1
设置app控制器


9
00:00:29,997 --> 00:00:33,033 line:-1
以及使用多个协调器


10
00:00:33,100 --> 00:00:34,835 line:-1
和相关缩放


11
00:00:35,135 --> 00:00:38,038 line:-1
最后总结一些有用的测试技巧


12
00:00:39,473 --> 00:00:40,641 line:-1
现在开始吧


13
00:00:40,707 --> 00:00:42,543 line:-1
今年发布了一个新的样本app


14
00:00:42,609 --> 00:00:45,045 line:-1
演讲202中已经演示过了


15
00:00:45,345 --> 00:00:48,048 line:-1
从发布列表开始


16
00:00:49,383 --> 00:00:52,553 line:-1
点击上方+ 可以添加新发布


17
00:00:53,420 --> 00:00:56,056 line:-1
仔细看下细节视图


18
00:00:56,356 --> 00:00:58,458 line:-1
这是类似于博客的app


19
00:00:58,525 --> 00:01:02,863 line:-1
支持题目 内容 多个标签


20
00:01:02,930 --> 00:01:04,831 line:-1
以及多媒体附件


21
00:01:04,897 --> 00:01:07,067 line:-1
就像这个缩略图


22
00:01:08,235 --> 00:01:12,072 line:-1
我们改一下标题 再添加一个标签


23
00:01:14,274 --> 00:01:15,142 line:-1
你好


24
00:01:16,577 --> 00:01:17,444 line:-1
好了


25
00:01:17,511 --> 00:01:20,681 line:-1
保存 然后回到列表视图


26
00:01:22,349 --> 00:01:23,684 line:-1
现在看看标签管理器


27
00:01:23,750 --> 00:01:26,253 line:-1
如你所见 这里只有一个标签示例


28
00:01:26,320 --> 00:01:27,788 line:-1
和三个发布


29
00:01:27,855 --> 00:01:31,024 line:-1
我们再加两个 一个猫咪


30
00:01:31,091 --> 00:01:34,094 line:-1
一个狗狗


31
00:01:35,229 --> 00:01:36,730 line:-1
现在退出


32
00:01:36,797 --> 00:01:38,899 line:-1
打开小工具栏


33
00:01:38,966 --> 00:01:41,902 line:-1
选择添加1000个随机发布


34
00:01:42,503 --> 00:01:43,403 line:-1
好了


35
00:01:44,471 --> 00:01:45,739 line:-1
再回到标签列表


36
00:01:45,806 --> 00:01:49,910 line:-1
可以看到狗狗比猫咪更受欢迎


37
00:01:50,110 --> 00:01:51,211 line:-1
这是科学


38
00:01:54,581 --> 00:01:58,118 line:-2
以上就是app的样子
下面来想想数据的结构


39
00:01:58,919 --> 00:02:02,122 line:-2
最明显的是post类型
所以它是起点


40
00:02:02,623 --> 00:02:04,658 line:-1
我们还支持多媒体附件


41
00:02:04,725 --> 00:02:05,926 line:-1
就是下一个类型


42
00:02:05,993 --> 00:02:08,729 line:-1
同理还需要标签类型


43
00:02:09,263 --> 00:02:11,732 line:-1
但是附件可能很大


44
00:02:11,798 --> 00:02:13,834 line:-1
所以要将数据分别保存


45
00:02:13,901 --> 00:02:16,803 line:-1
毕竟列表视图只显示缩略图


46
00:02:16,870 --> 00:02:19,139 line:-1
大件数据可以存到别的地方


47
00:02:20,541 --> 00:02:22,543 line:-1
数据结构就组织好了


48
00:02:22,609 --> 00:02:26,613 line:-2
它可以很直观地转换成
Core Data模型


49
00:02:26,680 --> 00:02:28,682 line:-2
用Model Editor
和Xcode


50
00:02:29,316 --> 00:02:32,252 line:-1
这里定义了模型类型的组成


51
00:02:32,319 --> 00:02:35,155 line:-1
以及它们的关系


52
00:02:35,956 --> 00:02:38,859 line:-1
比如附件和对应数据的关系


53
00:02:38,926 --> 00:02:40,160 line:-1
是一对一


54
00:02:40,661 --> 00:02:43,630 line:-2
就是说一个附件背后
只能有一个图像数据


55
00:02:43,697 --> 00:02:46,166 line:-1
一个图像数据也只能代表一个附件


56
00:02:47,434 --> 00:02:49,102 line:-1
模型中可以告诉Core Data


57
00:02:49,169 --> 00:02:50,737 line:-1
如果附件被删除


58
00:02:50,804 --> 00:02:53,407 line:-1
图像数据也要自动清除


59
00:02:53,473 --> 00:02:56,176 line:-1
这就是串联删除规则


60
00:02:57,644 --> 00:03:01,315 line:-1
双箭头表示一对多的关系


61
00:03:01,381 --> 00:03:03,283 line:-1
一个post可能有多个附件


62
00:03:03,350 --> 00:03:07,187 line:-1
但一个附件只能属于一个post


63
00:03:07,888 --> 00:03:10,490 line:-1
最后 post可能带多个标签


64
00:03:10,557 --> 00:03:12,359 line:-1
标签可以加到不同的post中


65
00:03:12,426 --> 00:03:14,194 line:-1
这是多对多的关系


66
00:03:17,164 --> 00:03:19,633 line:-1
以上就定义了一个托管对象模型


67
00:03:19,700 --> 00:03:22,336 line:-2
但我们还要了解
更多的Core Data类型


68
00:03:22,402 --> 00:03:24,204 line:-1
在搭建app之前


69
00:03:25,072 --> 00:03:27,774 line:-1
模型通过PersistentStoreCoordinator调用


70
00:03:27,841 --> 00:03:29,309 line:-1
如字面意思


71
00:03:29,376 --> 00:03:32,212 line:-1
它负责管理持久化存储


72
00:03:32,713 --> 00:03:35,549 line:-1
通常 它是存在文件系统的数据库


73
00:03:35,616 --> 00:03:37,518 line:-1
但它可以一次存储多个存储


74
00:03:37,584 --> 00:03:41,755 line:-2
包括NSPersistentStore
驱动的自定义类型


75
00:03:43,056 --> 00:03:45,692 line:-1
最后花费时间最多的类型


76
00:03:45,759 --> 00:03:47,694 line:-1
是ManagedObjectContext


77
00:03:48,328 --> 00:03:49,930 line:-1
Core Data使用命令模式


78
00:03:49,997 --> 00:03:51,765 line:-1
说白了就是


79
00:03:51,832 --> 00:03:54,067 line:-1
需要上下文完成任务


80
00:03:54,334 --> 00:03:57,237 line:-2
如果请求fetch
就需要Context


81
00:03:57,604 --> 00:03:59,139 line:-1
通过ManagedObject


82
00:03:59,206 --> 00:04:02,242 line:-1
Context收到后会存为命令


83
00:04:02,943 --> 00:04:05,779 line:-2
Context
需要有协调器才能工作


84
00:04:05,846 --> 00:04:07,447 line:-1
如我之前所说


85
00:04:07,514 --> 00:04:09,149 line:-1
协调器需要知道模型的存在


86
00:04:09,216 --> 00:04:10,817 line:-1
才能理解存储


87
00:04:11,385 --> 00:04:13,120 line:-1
各个类型相互依赖


88
00:04:13,187 --> 00:04:15,522 line:-1
但协调器提供的一个类型可囊括所有


89
00:04:15,589 --> 00:04:17,291 line:-1
并代表整个堆栈


90
00:04:17,357 --> 00:04:19,259 line:-1
叫做持久化容器


91
00:04:20,093 --> 00:04:21,495 line:-1
通过持久化容器


92
00:04:21,562 --> 00:04:24,064 line:-1
用几行代码就能搭建一个堆栈


93
00:04:24,131 --> 00:04:26,266 line:-1
特别是当模型在bundle中时


94
00:04:28,235 --> 00:04:30,070 line:-1
我们要做的是通过名字引用它


95
00:04:30,137 --> 00:04:32,673 line:-1
持久化容器就会帮我们加载


96
00:04:34,608 --> 00:04:36,210 line:-1
如果通过代码生成模型


97
00:04:36,276 --> 00:04:39,546 line:-1
或需要带多个容器的同一模型


98
00:04:39,613 --> 00:04:42,816 line:-1
这个初始化器能给我们控制权


99
00:04:44,918 --> 00:04:48,188 line:-2
有了容器
我们就告诉它加载持久化存储


100
00:04:48,255 --> 00:04:50,791 line:-2
每次存储调用一次
completionBlock


101
00:04:50,858 --> 00:04:53,293 line:-1
error参数为空则成功


102
00:04:53,493 --> 00:04:57,731 line:-1
现在让我们聚焦托管对象上下文


103
00:05:00,000 --> 00:05:03,103 line:-2
Context提供
对托管数据的无缝访问


104
00:05:03,170 --> 00:05:05,772 line:-1
有些选项可以让它们更有用


105
00:05:05,839 --> 00:05:08,909 line:-1
对某些使用案例 比如视图驱动


106
00:05:10,944 --> 00:05:13,780 line:-1
第一个是查询生成


107
00:05:14,214 --> 00:05:17,351 line:-1
查询生成提供存储数据的稳定视图


108
00:05:17,417 --> 00:05:19,553 line:-1
可以安全且持续地访问对象


109
00:05:19,620 --> 00:05:23,524 line:-1
即使被其他actor修改或删除


110
00:05:24,691 --> 00:05:25,526 line:-1
为此


111
00:05:25,592 --> 00:05:28,328 line:-2
设context的查询
生成为current


112
00:05:28,862 --> 00:05:30,831 line:-1
current是一个浮动元


113
00:05:30,898 --> 00:05:33,100 line:-1
context的查询生成会固定到


114
00:05:33,166 --> 00:05:36,937 line:-2
一个具体的时间点
在访问存储的下一步中


115
00:05:38,672 --> 00:05:41,542 line:-2
现在上下文在存储中
有了稳定的数据视图


116
00:05:41,608 --> 00:05:44,344 line:-1
如果要更新到最新修改怎么办？


117
00:05:44,711 --> 00:05:45,546 line:-1
在以前


118
00:05:45,612 --> 00:05:48,215 line:-1
要注册上下文 然后保存通知


119
00:05:48,282 --> 00:05:51,018 line:-1
但上下文也可以被设置为


120
00:05:51,084 --> 00:05:54,755 line:-2
在sibling保存修改后
自动更新


121
00:05:56,023 --> 00:05:59,359 line:-2
automaticallyMergesChangesFromParent
为true


122
00:06:01,261 --> 00:06:04,131 line:-1
现在所有堆栈类型都已经设置好


123
00:06:04,198 --> 00:06:05,732 line:-1
怎么在app中使用呢？


124
00:06:06,567 --> 00:06:09,303 line:-1
最重要的是记住 在使用上下文时


125
00:06:09,369 --> 00:06:12,439 line:-1
所有对托管对象的存储请求和互动


126
00:06:12,506 --> 00:06:14,374 line:-1
都要在上下文队列中完成


127
00:06:15,175 --> 00:06:17,978 line:-1
背景上下文都单独的队列


128
00:06:18,779 --> 00:06:21,381 line:-1
可以用它们执行API


129
00:06:22,015 --> 00:06:24,651 line:-2
这里有个blocking不变量
和异步版本


130
00:06:24,718 --> 00:06:26,720 line:-1
对真正的异步工作


131
00:06:26,787 --> 00:06:30,757 line:-1
容器会为执行后台任务提供便利


132
00:06:30,824 --> 00:06:33,160 line:-1
为你创建后台上下文


133
00:06:33,227 --> 00:06:36,396 line:-1
在block返回后自动丢弃


134
00:06:39,399 --> 00:06:41,268 line:-1
那么如何给app添加数据？


135
00:06:41,335 --> 00:06:43,670 line:-1
如果我们只需要几个对象


136
00:06:43,737 --> 00:06:47,407 line:-2
最简单的是
用托管对象子类提供的初始化程序


137
00:06:47,474 --> 00:06:50,410 line:-1
由Xcode下的模型生成


138
00:06:51,178 --> 00:06:53,280 line:-1
如果子类只有一个模型使用


139
00:06:53,347 --> 00:06:55,883 line:-1
它就知道代表哪个实体


140
00:06:55,949 --> 00:06:58,418 line:-1
所以可以带上下文使用


141
00:06:58,685 --> 00:07:00,087 line:-1
带context注册后


142
00:07:00,153 --> 00:07:01,321 line:-1
就可以进行配置


143
00:07:01,388 --> 00:07:03,423 line:-1
跟其他实例变量一样


144
00:07:04,491 --> 00:07:06,260 line:-1
配置好以后


145
00:07:06,326 --> 00:07:09,429 line:-2
调用context.save
把它存入存储


146
00:07:13,200 --> 00:07:14,968 line:-1
需要更多数据怎么办？


147
00:07:15,035 --> 00:07:19,206 line:-2
大多app并不满足于
一次只导入一部分对象


148
00:07:19,573 --> 00:07:21,708 line:-1
好机会 因为你有服务器组件


149
00:07:21,775 --> 00:07:24,878 line:-1
返回成百上千的对象


150
00:07:25,279 --> 00:07:27,681 line:-1
我们可以一次存一个


151
00:07:27,748 --> 00:07:29,883 line:-1
就像刚才做的那样


152
00:07:29,950 --> 00:07:31,852 line:-1
但这要写很多样板代码


153
00:07:31,919 --> 00:07:33,387 line:-1
更不用说大量的资源开销


154
00:07:33,453 --> 00:07:35,455 line:-1
一次把所有放进内存


155
00:07:37,558 --> 00:07:39,159 line:-1
批量插入


156
00:07:39,226 --> 00:07:42,462 line:-1
这是今天要讲的第一个新功能


157
00:07:43,063 --> 00:07:45,732 line:-1
这个代码片段有1000个对象


158
00:07:45,799 --> 00:07:48,101 line:-1
都基于反序列化负载


159
00:07:48,168 --> 00:07:51,471 line:-1
形式为带字符串密钥的字典数组


160
00:07:53,273 --> 00:07:54,675 line:-1
这些密钥要对应


161
00:07:54,741 --> 00:07:57,344 line:-1
模型中的属性名称


162
00:07:57,678 --> 00:07:58,779 line:-1
也可以留一些


163
00:07:58,846 --> 00:08:01,949 line:-1
如果不需要的话 比如唯一的限制


164
00:08:02,015 --> 00:08:04,218 line:-1
如果模型已经配置默认值


165
00:08:04,284 --> 00:08:06,186 line:-1
Core Data就会用它们


166
00:08:07,054 --> 00:08:08,589 line:-1
这里有三个字典


167
00:08:08,655 --> 00:08:12,025 line:-1
每个覆盖不同的内容和标题属性


168
00:08:13,126 --> 00:08:14,561 line:-1
回到代码


169
00:08:14,628 --> 00:08:17,264 line:-1
用字典数组创建批量插入请求


170
00:08:17,331 --> 00:08:19,600 line:-1
以及对象模型实体


171
00:08:19,666 --> 00:08:23,136 line:-1
它也可以采用托管对象子类


172
00:08:23,203 --> 00:08:25,506 line:-1
通过Xcode生成


173
00:08:27,307 --> 00:08:30,744 line:-1
执行请求 然后上下文会回复


174
00:08:30,811 --> 00:08:34,047 line:-1
一个布尔值 告诉我们操作是否成功


175
00:08:35,482 --> 00:08:36,717 line:-1
很多都免费


176
00:08:37,451 --> 00:08:39,520 line:-1
你一定在想 区别是什么


177
00:08:40,020 --> 00:08:43,090 line:-1
这里实际上并没有什么明确的界限


178
00:08:43,155 --> 00:08:44,658 line:-1
它们大多听着都类似


179
00:08:44,725 --> 00:08:47,528 line:-1
如果你用过批量更新或批量删除


180
00:08:48,729 --> 00:08:51,665 line:-1
如果有唯一限制 任何现有的对象


181
00:08:51,732 --> 00:08:53,834 line:-1
匹配字典的 都会从数据库中拿出


182
00:08:53,901 --> 00:08:56,203 line:-1
更新为新的值


183
00:08:57,871 --> 00:09:00,674 line:-1
可选的或设置为默认值的属性


184
00:09:00,741 --> 00:09:03,143 line:-1
也可以从字典中删除


185
00:09:03,544 --> 00:09:06,046 line:-1
在用唯一限制更新对象时


186
00:09:06,113 --> 00:09:08,549 line:-1
现有值不会被更改


187
00:09:10,417 --> 00:09:12,553 line:-1
这对关系也适用


188
00:09:12,786 --> 00:09:15,556 line:-1
批量插入不能用于设置关系


189
00:09:15,956 --> 00:09:18,258 line:-1
但如果批量插入在现有对象中更新


190
00:09:18,325 --> 00:09:19,693 line:-1
由于唯一限制


191
00:09:19,760 --> 00:09:22,162 line:-1
现有关系不会被修改


192
00:09:22,963 --> 00:09:25,799 line:-1
最后 与其他批量操作一样


193
00:09:25,866 --> 00:09:29,970 line:-2
批量插入不会生成
contextDidSaveNotification


194
00:09:30,037 --> 00:09:31,972 line:-1
所以你要自己完成


195
00:09:32,606 --> 00:09:35,209 line:-1
有了数据后 我们讲讲如何满足


196
00:09:35,275 --> 00:09:36,877 line:-1
控制器的需求


197
00:09:37,811 --> 00:09:40,180 line:-1
控制器要做的第一件事


198
00:09:40,247 --> 00:09:41,915 line:-1
是抓取和显示数据


199
00:09:41,982 --> 00:09:43,584 line:-1
这就来看看


200
00:09:44,618 --> 00:09:47,387 line:-2
通过fetchRequest
从存储中获取对象


201
00:09:47,688 --> 00:09:50,290 line:-1
就像创建新对象时获取实体一样


202
00:09:50,357 --> 00:09:52,559 line:-1
托管对象子类有个方法


203
00:09:52,626 --> 00:09:54,027 line:-1
由Xcode生成


204
00:09:54,094 --> 00:09:56,597 line:-2
提供配置好的
fetchRequest


205
00:09:58,632 --> 00:10:02,102 line:-2
添加predicate给
request可以优化结果


206
00:10:02,169 --> 00:10:05,606 line:-1
这里就能通过名称抓取标签


207
00:10:07,708 --> 00:10:09,409 line:-1
执行请求后


208
00:10:09,476 --> 00:10:12,613 line:-1
获取结果并用来配置视图


209
00:10:14,515 --> 00:10:16,350 line:-1
这也适用于不可变数据


210
00:10:16,416 --> 00:10:19,620 line:-2
如果在视图打开时
标签名称或颜色改了怎么办


211
00:10:20,120 --> 00:10:21,288 line:-1
托管对象上下文


212
00:10:21,355 --> 00:10:23,957 line:-1
会确保更新对象的属性


213
00:10:24,024 --> 00:10:25,425 line:-1
但我们还没有深入


214
00:10:25,492 --> 00:10:27,628 line:-1
观察这些修改


215
00:10:29,062 --> 00:10:29,897 line:-1
如你们所知


216
00:10:29,963 --> 00:10:32,566 line:-1
托管对象支持关键值观察


217
00:10:32,633 --> 00:10:34,268 line:-1
一直以来都是


218
00:10:34,334 --> 00:10:36,937 line:-1
但是本周宣布的组合框架


219
00:10:37,004 --> 00:10:40,040 line:-1
让在Swift中使用KVO更简单


220
00:10:40,340 --> 00:10:44,645 line:-2
从对象中给每个要布线的属性
一个publisher


221
00:10:45,212 --> 00:10:48,649 line:-2
然后将数据流同步到视图的
assignment subscriber


222
00:10:49,283 --> 00:10:50,617 line:-1
对于标签颜色


223
00:10:50,684 --> 00:10:53,854 line:-1
要多做一步映射 对应各个类型


224
00:10:54,855 --> 00:10:56,790 line:-1
这就是所有要写的代码


225
00:10:56,857 --> 00:10:59,193 line:-1
这样视图内容就会自动更新


226
00:10:59,259 --> 00:11:01,662 line:-1
随着底层对象的修改


227
00:11:06,567 --> 00:11:09,736 line:-2
联合框架很优秀
但这也只是冰山一角


228
00:11:09,803 --> 00:11:10,704 line:-1
框架的表面


229
00:11:10,771 --> 00:11:13,974 line:-2
它还提供了其他更多
有用的数据流功能


230
00:11:14,041 --> 00:11:17,678 line:-1
欲了解更多 请观看演讲721


231
00:11:18,979 --> 00:11:21,849 line:-1
你可能注意到 代码中有个小骗局


232
00:11:21,915 --> 00:11:23,250 line:-1
就是细节视图


233
00:11:23,317 --> 00:11:25,619 line:-1
几乎从不真正抓取对象


234
00:11:25,686 --> 00:11:26,987 line:-1
显示出来


235
00:11:27,321 --> 00:11:28,422 line:-1
通常这种视图


236
00:11:28,488 --> 00:11:31,558 line:-1
会从配置为托管对象的母程序中推出


237
00:11:31,625 --> 00:11:35,929 line:-1
因此通常我们写的代码是这样的


238
00:11:36,964 --> 00:11:38,665 line:-1
细节视图的母程序


239
00:11:38,732 --> 00:11:42,703 line:-2
通常是列表视图
比如集合或表格视图


240
00:11:43,136 --> 00:11:45,205 line:-1
它也通过抓取请求获取对象


241
00:11:45,272 --> 00:11:48,041 line:-1
但我们还有几个属性没有讲到


242
00:11:48,108 --> 00:11:50,711 line:-1
是抓取多个对象的关键


243
00:11:52,546 --> 00:11:54,715 line:-2
首先是
Request.SortDescriptors


244
00:11:55,582 --> 00:11:57,985 line:-1
它定义了结果的顺序


245
00:11:58,318 --> 00:12:00,454 line:-1
这里要排序的是标签名称


246
00:12:00,521 --> 00:12:02,523 line:-1
但如果名称区别不大


247
00:12:02,589 --> 00:12:04,958 line:-2
就要在数组末尾加
另一个descriptor


248
00:12:05,025 --> 00:12:06,727 line:-1
区分开来


249
00:12:08,495 --> 00:12:10,764 line:-2
另一个有用的选项
是Batching


250
00:12:10,831 --> 00:12:14,101 line:-1
当抓取请求匹配了1400万个对象


251
00:12:14,168 --> 00:12:16,203 line:-1
我们不能把所有都放进内存


252
00:12:16,270 --> 00:12:17,738 line:-1
在同一时间


253
00:12:18,005 --> 00:12:21,108 line:-1
即使内存有个空间 当然一般没有


254
00:12:21,175 --> 00:12:22,743 line:-1
也会花很多时间


255
00:12:22,976 --> 00:12:25,078 line:-2
因此 设置一个
fetchBatchSize


256
00:12:25,145 --> 00:12:28,749 line:-2
告诉上下文
一次要向存储载入多少对象


257
00:12:29,316 --> 00:12:31,952 line:-1
这对app的响应影响很大


258
00:12:32,019 --> 00:12:33,954 line:-1
但它只能用于交互


259
00:12:34,021 --> 00:12:35,122 line:-1
NS数组结果


260
00:12:35,189 --> 00:12:38,759 line:-1
Swift的数组桥接会盖过优化


261
00:12:39,993 --> 00:12:41,295 line:-1
记住这一点


262
00:12:41,361 --> 00:12:43,764 line:-2
就很容易能设置
fetchRequest


263
00:12:44,965 --> 00:12:48,135 line:-1
抓取所有需要的标签


264
00:12:48,202 --> 00:12:50,437 line:-1
但如果其中一个变了呢


265
00:12:51,605 --> 00:12:55,242 line:-1
就像细节视图中显示的对象属性


266
00:12:55,309 --> 00:12:58,779 line:-1
需要保持对象跟随查询变化而变化


267
00:12:59,880 --> 00:13:04,051 line:-2
好在Core Data支持即时请求
FetchResultsController


268
00:13:04,885 --> 00:13:08,388 line:-2
这里配置的请求是
抓取按名称排序的所有发布


269
00:13:08,455 --> 00:13:09,790 line:-1
一次50个


270
00:13:10,791 --> 00:13:12,793 line:-1
这个请求连接一个context


271
00:13:12,860 --> 00:13:14,761 line:-1
设置的类型是我们还没讲到的


272
00:13:14,828 --> 00:13:16,797 line:-1
fetchedResultsController


273
00:13:17,364 --> 00:13:19,766 line:-2
它将修改传达给
fetchRequest


274
00:13:19,833 --> 00:13:21,802 line:-1
通过代理协议 并立刻运行


275
00:13:21,869 --> 00:13:24,805 line:-1
在发出执行fetch命令后


276
00:13:26,039 --> 00:13:26,974 line:-1
FetchedResultsController


277
00:13:27,040 --> 00:13:29,243 line:-1
你们可能都知道了


278
00:13:29,676 --> 00:13:31,545 line:-1
代理协议修改报告回调


279
00:13:31,612 --> 00:13:35,282 line:-1
这个方法说明修改何时发生


280
00:13:35,749 --> 00:13:39,820 line:-2
这一个说明
section变化的时间


281
00:13:40,320 --> 00:13:44,124 line:-1
这一个说明每个修改的对象及其变化


282
00:13:44,191 --> 00:13:47,561 line:-1
最后这个说明任务完成


283
00:13:47,628 --> 00:13:48,829 line:-1
一切了如指掌


284
00:13:49,796 --> 00:13:53,767 line:-2
这些方法旨在紧紧对应
UITableView的API


285
00:13:53,834 --> 00:13:55,936 line:-1
但还要写许多粘合代码


286
00:13:56,003 --> 00:13:59,773 line:-1
匹配请求结果给重新绘表


287
00:13:59,840 --> 00:14:01,608 line:-1
另外 新的集合视图


288
00:14:01,675 --> 00:14:03,844 line:-1
不支持这个修改回调


289
00:14:05,112 --> 00:14:07,714 line:-2
但好消息是
FetchedResultsController


290
00:14:07,781 --> 00:14:09,850 line:-1
今年学会了新技能


291
00:14:10,284 --> 00:14:11,585 line:-1
首先是代理方法


292
00:14:11,652 --> 00:14:14,855 line:-1
发布NSDiffableDataSourceSnapshot实例


293
00:14:19,459 --> 00:14:21,762 line:-1
听起来很多人都已经知道它是什么了


294
00:14:21,828 --> 00:14:24,932 line:-2
要是不知道 那它是新的
UIKit MapKit类


295
00:14:24,998 --> 00:14:27,868 line:-2
代表集合视图
或TableView的结构


296
00:14:28,268 --> 00:14:30,871 line:-2
为此 设置
TableView的数据源


297
00:14:30,938 --> 00:14:32,906 line:-1
为DiffableDataSource类


298
00:14:32,973 --> 00:14:34,141 line:-1
这也是今年的新东西


299
00:14:34,208 --> 00:14:35,876 line:-1
填入快照


300
00:14:36,643 --> 00:14:38,879 line:-1
你可以在演讲220中了解更多


301
00:14:38,946 --> 00:14:40,981 line:-1
但对于我们


302
00:14:41,048 --> 00:14:41,949 line:-1
你只要知道


303
00:14:42,015 --> 00:14:44,351 line:-1
它们可以用来更新集合视图


304
00:14:44,418 --> 00:14:45,886 line:-1
只用一行代码


305
00:14:46,453 --> 00:14:49,056 line:-2
这段代码放在这页幻灯片的
下半部分刚刚好


306
00:14:49,122 --> 00:14:50,891 line:-1
本来需要很多样板代码


307
00:14:51,592 --> 00:14:52,459 line:-1
这里要做的


308
00:14:52,526 --> 00:14:55,629 line:-2
是将快照放入
DiffableDataSource


309
00:14:55,696 --> 00:14:57,397 line:-1
数据源将快照区分于


310
00:14:57,464 --> 00:14:59,399 line:-1
之前的视图状态


311
00:14:59,466 --> 00:15:01,902 line:-2
也就是
DiffableDataSource


312
00:15:02,202 --> 00:15:05,906 line:-1
然后用计算机差异更新视图


313
00:15:09,309 --> 00:15:10,377 line:-1
等了很久了


314
00:15:12,145 --> 00:15:13,447 line:-1
DiffableDataSourceSnapshot


315
00:15:13,514 --> 00:15:16,350 line:-1
对整个集合视图的批量控制很有用


316
00:15:16,416 --> 00:15:19,653 line:-1
但是如果需要自定义


317
00:15:19,720 --> 00:15:23,223 line:-2
或需要管理的是除Table和
Collection视图外的类型


318
00:15:23,290 --> 00:15:26,927 line:-1
你可能需要另一个代理方法


319
00:15:27,361 --> 00:15:28,662 line:-1
对于Snapshots


320
00:15:28,729 --> 00:15:31,865 line:-2
它总结了所有对
FetchedResult的修改


321
00:15:31,932 --> 00:15:33,267 line:-1
用一张快照


322
00:15:33,333 --> 00:15:35,469 line:-1
但用的是不同类型 今年新出的


323
00:15:35,536 --> 00:15:36,937 line:-1
CollectionDifference


324
00:15:37,938 --> 00:15:39,239 line:-1
如字面意思


325
00:15:39,306 --> 00:15:41,542 line:-2
CollectionDifference
对差别编码


326
00:15:41,608 --> 00:15:43,911 line:-1
对比两套集合而生成


327
00:15:45,679 --> 00:15:47,648 line:-2
Swift标准库里的
Collection diffing


328
00:15:47,714 --> 00:15:50,684 line:-1
在Swift Evolution Proposal 240中引入


329
00:15:50,751 --> 00:15:52,152 line:-1
Foundation中也有


330
00:15:52,219 --> 00:15:54,955 line:-1
演讲711中有更详细的信息


331
00:15:56,256 --> 00:15:58,292 line:-1
在这里 它是个一维类型


332
00:15:58,358 --> 00:16:01,595 line:-2
只在不使用section
抓取时可用


333
00:16:01,662 --> 00:16:03,697 line:-1
就像SnapshotDelegate方法


334
00:16:03,764 --> 00:16:06,834 line:-1
与遗留修改报告方法相互排斥


335
00:16:06,900 --> 00:16:10,437 line:-2
如果要驱动
FetchedResultsController的多个内容


336
00:16:10,504 --> 00:16:13,974 line:-2
要用多个
FetchedResultsController


337
00:16:14,775 --> 00:16:15,709 line:-1
现在快速展示下


338
00:16:15,776 --> 00:16:18,745 line:-1
如何驱动集合视图上的一个部分


339
00:16:18,812 --> 00:16:20,981 line:-1
利用这些差异


340
00:16:21,648 --> 00:16:23,150 line:-1
这是代理方法


341
00:16:23,217 --> 00:16:25,919 line:-1
从最上面的批量更新开始


342
00:16:25,986 --> 00:16:28,222 line:-1
遍历diff中的修改


343
00:16:29,656 --> 00:16:31,992 line:-2
CollectionDifferences
支持两种修改


344
00:16:32,059 --> 00:16:33,694 line:-1
插入和删除


345
00:16:33,760 --> 00:16:35,562 line:-1
这两种相反的类


346
00:16:35,629 --> 00:16:38,098 line:-1
在关联中可能会互相引用


347
00:16:38,165 --> 00:16:39,867 line:-1
第一个例子中


348
00:16:39,933 --> 00:16:43,003 line:-1
一个插入关联一个删除


349
00:16:43,070 --> 00:16:46,173 line:-2
就是说对象被删除了
或至少被修改了


350
00:16:46,240 --> 00:16:49,343 line:-1
逻辑位置可能还没移走 但不要紧


351
00:16:49,409 --> 00:16:52,145 line:-2
因为CollectionView
很聪明 能看出区别


352
00:16:52,212 --> 00:16:53,714 line:-1
只要有正确的原值


353
00:16:53,780 --> 00:16:57,618 line:-2
和目标IndexPaths
就可以了


354
00:16:58,252 --> 00:16:59,119 line:-1
第二部分


355
00:16:59,186 --> 00:17:00,254 line:-1
插入了一个对象


356
00:17:00,320 --> 00:17:02,756 line:-2
之前不属于
Fetched Results


357
00:17:02,823 --> 00:17:05,025 line:-2
所以让CollectionView
去添加


358
00:17:06,093 --> 00:17:10,631 line:-2
最后 对所有不属于关联移动的
删除进行匹配


359
00:17:10,696 --> 00:17:12,665 line:-1
通过筛选新的关联


360
00:17:12,733 --> 00:17:15,035 line:-2
然后从CollectionView中
移除它们


361
00:17:15,935 --> 00:17:17,171 line:-1
就这样


362
00:17:17,237 --> 00:17:18,438 line:-1
你看这个代码


363
00:17:18,505 --> 00:17:19,373 line:-1
结构很好


364
00:17:19,439 --> 00:17:22,742 line:-1
因此它可以作为函数因子的备选


365
00:17:22,809 --> 00:17:24,411 line:-1
进一步减少样板代码


366
00:17:24,478 --> 00:17:28,715 line:-2
因为你只要有
CollectionView和差别就行


367
00:17:28,782 --> 00:17:30,150 line:-1
我想人们一定会爱上


368
00:17:30,217 --> 00:17:31,785 line:-1
这些新的代理方法


369
00:17:31,852 --> 00:17:34,054 line:-1
今年 旧的方法也有了新生


370
00:17:34,421 --> 00:17:36,790 line:-2
Swift UI框架
引入了第一方支持


371
00:17:36,857 --> 00:17:38,825 line:-1
给描述性接口


372
00:17:39,159 --> 00:17:41,461 line:-2
但不被Snapshot
或diff驱动


373
00:17:41,862 --> 00:17:46,066 line:-2
这个模型类别可衍生自
Fetched Result列表


374
00:17:46,700 --> 00:17:50,470 line:-2
现有的控制器
didChangeContentDelegate方法


375
00:17:50,737 --> 00:17:53,373 line:-2
告知Fetched Result
的每次更新


376
00:17:53,440 --> 00:17:55,075 line:-1
让我们准备更新视图


377
00:17:57,110 --> 00:17:59,580 line:-2
将Fetched Result
应用到视图不难了


378
00:17:59,646 --> 00:18:02,950 line:-1
但如果结果本身就很难抓取呢？


379
00:18:03,016 --> 00:18:07,254 line:-1
如果最后不能建立抓取请求呢？


380
00:18:07,321 --> 00:18:10,657 line:-1
如果运行出现了问题


381
00:18:10,724 --> 00:18:12,793 line:-1
在执行抓取请求的时候？


382
00:18:13,594 --> 00:18:14,595 line:-1
有些时候


383
00:18:14,661 --> 00:18:16,830 line:-1
控制器要求大过模型要求


384
00:18:16,897 --> 00:18:19,099 line:-1
只能放弃一些模型纯度


385
00:18:19,466 --> 00:18:21,101 line:-1
为了达成目标


386
00:18:21,635 --> 00:18:23,670 line:-1
这就要反范式化


387
00:18:24,538 --> 00:18:29,877 line:-2
WWDC 2018的
演讲224中有讲过


388
00:18:29,943 --> 00:18:31,011 line:-1
回顾一下


389
00:18:31,078 --> 00:18:33,814 line:-1
反范式化 指当我们保存数据副本


390
00:18:33,881 --> 00:18:35,749 line:-1
为方便访问时


391
00:18:36,316 --> 00:18:38,051 line:-1
会出现额外的负载


392
00:18:38,118 --> 00:18:39,753 line:-1
维护额外的数据


393
00:18:39,820 --> 00:18:43,123 line:-1
很多时候这种权衡很容易


394
00:18:43,957 --> 00:18:46,760 line:-1
数据库索引就是很好的例子


395
00:18:46,827 --> 00:18:50,430 line:-1
我们不再保存所有索引列的副本


396
00:18:50,497 --> 00:18:52,900 line:-1
而是通过闪电般的请求


397
00:18:53,367 --> 00:18:55,135 line:-1
当它们依存于这些索引时


398
00:18:56,003 --> 00:18:57,471 line:-1
回到app


399
00:18:57,538 --> 00:18:59,406 line:-1
反范式化还能帮助我们


400
00:18:59,473 --> 00:19:02,609 line:-1
追踪每个标签下的发布数


401
00:19:03,777 --> 00:19:08,916 line:-2
我们只要添加一个
整数属性给标签类型


402
00:19:08,982 --> 00:19:11,151 line:-1
名字为postCount


403
00:19:12,085 --> 00:19:14,755 line:-1
现在只要保证这个新属性


404
00:19:14,821 --> 00:19:17,157 line:-1
在每次发布被标签时递增


405
00:19:17,224 --> 00:19:21,161 line:-1
在每次发布删除标签时递减


406
00:19:21,428 --> 00:19:25,165 line:-2
这个代码肯定不会有漏洞
数据也会永远保持一致对吧


407
00:19:26,567 --> 00:19:27,434 line:-1
对吗


408
00:19:28,535 --> 00:19:31,171 line:-1
不对 所以要讲讲派生属性


409
00:19:32,206 --> 00:19:36,376 line:-2
派生数据是范式元数据
由Core Data维护


410
00:19:37,244 --> 00:19:38,879 line:-1
不仅是为了计数


411
00:19:38,946 --> 00:19:43,183 line:-2
它还有很多功能
文档中都能看到


412
00:19:43,917 --> 00:19:47,154 line:-1
派生属性在托管对象模型中定义


413
00:19:47,221 --> 00:19:50,457 line:-2
Xcode中的模型编辑器
为此开了一个新接口


414
00:19:50,524 --> 00:19:53,026 line:-1
你可以用代码定义派生属性


415
00:19:53,093 --> 00:19:57,197 line:-2
使用新类型
NSDerivedAttributeDescription


416
00:19:58,298 --> 00:20:00,701 line:-1
最后 派生表达式可以指向


417
00:20:00,767 --> 00:20:04,204 line:-1
下一层的一个实体的任何属性


418
00:20:05,305 --> 00:20:07,975 line:-1
派生属性让反范式化十分简单


419
00:20:08,041 --> 00:20:12,212 line:-1
现在我要展示一下如何应用它们


420
00:20:13,814 --> 00:20:16,216 line:-1
这是之前那个app


421
00:20:16,683 --> 00:20:20,621 line:-1
打开这个标签管理


422
00:20:20,687 --> 00:20:24,925 line:-1
看到三个标签和一堆发布


423
00:20:24,992 --> 00:20:27,127 line:-1
但驱动它的视图代码


424
00:20:27,194 --> 00:20:30,097 line:-1
实际上遍历了关系发布


425
00:20:30,163 --> 00:20:31,465 line:-1
获取计数


426
00:20:31,532 --> 00:20:33,834 line:-1
这是关系中默认的


427
00:20:33,901 --> 00:20:36,837 line:-1
如果有更多数据的重要性排序


428
00:20:36,904 --> 00:20:39,506 line:-1
它可能会导致运行出问题


429
00:20:39,940 --> 00:20:44,244 line:-1
我们要在模型中用派生属性修正


430
00:20:45,913 --> 00:20:47,080 line:-1
这是模型编辑器


431
00:20:47,147 --> 00:20:49,249 line:-1
我们看到的是标签类型


432
00:20:49,516 --> 00:20:56,089 line:-2
我们要在这里添加
新属性postCount


433
00:20:56,423 --> 00:20:58,258 line:-1
并设为整数类


434
00:20:59,893 --> 00:21:02,462 line:-1
现在看到这里的查看器


435
00:21:02,529 --> 00:21:06,133 line:-1
多了一个新选项derived


436
00:21:06,200 --> 00:21:07,401 line:-1
勾选它


437
00:21:07,467 --> 00:21:10,270 line:-1
出现一个框 填写衍生表达式


438
00:21:10,671 --> 00:21:14,775 line:-2
现在我们是将代码
从视图转移到了这里


439
00:21:14,842 --> 00:21:19,880 line:-2
写入posts.@counts
因为用的聚合函数


440
00:21:20,981 --> 00:21:23,417 line:-1
就可以了


441
00:21:23,483 --> 00:21:26,887 line:-2
如果重建
Xcode会重建托管对象子类


442
00:21:27,554 --> 00:21:29,089 line:-1
回到这个视图


443
00:21:29,156 --> 00:21:34,995 line:-2
会看到新的实例变量
postCount


444
00:21:35,062 --> 00:21:35,896 line:-1
但它不是可选的


445
00:21:35,963 --> 00:21:39,566 line:-1
所以要删除更多代码 避免这种情况


446
00:21:40,434 --> 00:21:44,304 line:-1
搭建并运行后 没有任何变化


447
00:21:45,572 --> 00:21:47,808 line:-1
只是更快更好了


448
00:21:47,875 --> 00:21:49,710 line:-1
我们不用更新所有内容


449
00:21:49,776 --> 00:21:52,312 line:-1
果然 就是这样


450
00:21:55,682 --> 00:21:59,820 line:-2
开发者文档中
可以找到完整的派生属性集


451
00:21:59,887 --> 00:22:02,890 line:-1
通常来说 它们分为四类


452
00:22:03,490 --> 00:22:05,325 line:-1
最简单的是全部复制


453
00:22:05,392 --> 00:22:07,794 line:-1
就像复制附件标识符


454
00:22:07,861 --> 00:22:09,563 line:-1
及其图像数据


455
00:22:10,330 --> 00:22:13,600 line:-1
另一种派生是字段转换


456
00:22:13,667 --> 00:22:18,338 line:-2
比如小写标签名称
或规范化某些Unicode字符串


457
00:22:20,507 --> 00:22:22,476 line:-1
刚才的例子里 一个聚合函数


458
00:22:22,543 --> 00:22:24,578 line:-1
在演示中跨过了多个关系


459
00:22:25,746 --> 00:22:29,349 line:-1
最后是全局函数


460
00:22:29,416 --> 00:22:31,084 line:-1
不用任何参数


461
00:22:31,151 --> 00:22:32,753 line:-1
可用于 比如


462
00:22:32,819 --> 00:22:35,355 line:-1
追踪对象最后更新的时间


463
00:22:35,689 --> 00:22:37,457 line:-1
既然控制器都讲完了


464
00:22:37,524 --> 00:22:40,394 line:-1
下面来看更高级的主题和缩放


465
00:22:40,460 --> 00:22:43,430 line:-2
PersistentHistory
是2017年引进的工具


466
00:22:43,497 --> 00:22:47,234 line:-2
处理importer
添加的数据


467
00:22:47,301 --> 00:22:51,205 line:-1
或维护多个活跃协调器的数据一致性


468
00:22:51,271 --> 00:22:52,973 line:-1
使用同一存储


469
00:22:53,841 --> 00:22:56,176 line:-1
今年新的是 我们用抓取请求


470
00:22:56,243 --> 00:22:59,379 line:-1
让你只查看需要的历史数据


471
00:23:00,881 --> 00:23:03,917 line:-1
比如你要查看一个扩展做的修改


472
00:23:03,984 --> 00:23:06,386 line:-1
或者只看影响发布的修改


473
00:23:06,453 --> 00:23:09,623 line:-1
或只看某个时间段的历史


474
00:23:09,690 --> 00:23:11,425 line:-1
想象将抓取请求的力量


475
00:23:11,491 --> 00:23:13,393 line:-1
用到PersistentHistory


476
00:23:15,529 --> 00:23:19,633 line:-2
NSPersistentHistoryTransaction
和NSPersistentHistoryChange


477
00:23:19,700 --> 00:23:20,868 line:-1
不是模型化类型


478
00:23:20,934 --> 00:23:23,403 line:-1
但它们能生成新的交叉方法


479
00:23:23,737 --> 00:23:25,873 line:-1
与fetchRequests交互


480
00:23:25,939 --> 00:23:26,874 line:-1
注意


481
00:23:26,940 --> 00:23:29,743 line:-1
新的方法与Xcode生成的很像


482
00:23:29,810 --> 00:23:32,412 line:-1
就是给托管对象子类的


483
00:23:33,313 --> 00:23:35,148 line:-2
它们包括了
entityDescription的附件


484
00:23:35,215 --> 00:23:37,251 line:-1
对应类型


485
00:23:37,317 --> 00:23:40,220 line:-2
以及产生新的预置
fetchRequest的方法


486
00:23:40,287 --> 00:23:42,589 line:-1
返回类型实例


487
00:23:42,656 --> 00:23:46,894 line:-2
NSPersistentHistoryTransaction
或NSPersistentHistoryChange


488
00:23:46,960 --> 00:23:48,428 line:-1
在执行时


489
00:23:48,962 --> 00:23:50,664 line:-2
配置fetchRequest
给predicate


490
00:23:50,731 --> 00:23:52,633 line:-1
跟抓取托管对象一样


491
00:23:52,699 --> 00:23:54,635 line:-2
但是不再执行
fetchRequest


492
00:23:54,701 --> 00:23:56,803 line:-1
直接作用于上下文


493
00:23:56,870 --> 00:24:01,441 line:-2
而是作为
PersistentHistoryRequest的一部分


494
00:24:02,643 --> 00:24:06,380 line:-2
NSPersistentHistoryChangeRequest
有新的初始程序


495
00:24:06,446 --> 00:24:08,782 line:-2
用于创建
fetchRequest的新实例


496
00:24:08,849 --> 00:24:13,453 line:-2
以及用于配置
post-talk的不可变属性


497
00:24:14,288 --> 00:24:16,623 line:-2
管理PersistentHistory
的fetchRequest


498
00:24:16,690 --> 00:24:19,126 line:-1
为app增加了粒度


499
00:24:19,193 --> 00:24:23,463 line:-2
但还有个问题
我们怎么知道历史在什么时候发生？


500
00:24:24,798 --> 00:24:28,202 line:-1
这有很多方法 但都有缺陷


501
00:24:28,268 --> 00:24:30,904 line:-1
我们可以对修改进行存储


502
00:24:30,971 --> 00:24:33,073 line:-1
但这很难调整解决方案


503
00:24:33,140 --> 00:24:36,009 line:-1
平衡徒劳无功


504
00:24:36,076 --> 00:24:38,478 line:-1
和在修改被发现前出现的延迟


505
00:24:39,346 --> 00:24:42,316 line:-2
文件系统监控系统 比如
Dispatch Sources


506
00:24:42,382 --> 00:24:46,486 line:-2
和FSEvents也有用
但它们只用于文档后备存储


507
00:24:46,787 --> 00:24:48,021 line:-1
它们不容易应用


508
00:24:48,088 --> 00:24:50,224 line:-1
还会出现很多通知


509
00:24:50,290 --> 00:24:53,193 line:-1
并不能对应存储的变化


510
00:24:53,260 --> 00:24:55,495 line:-1
因此还是会做很多无用功


511
00:24:56,897 --> 00:24:58,198 line:-1
虽然跟创可贴一样有用


512
00:24:58,265 --> 00:25:00,100 line:-1
但它们都不是最佳解决方案


513
00:25:00,167 --> 00:25:03,504 line:-2
解决其他协调器修改存储时
通知的问题


514
00:25:05,639 --> 00:25:08,609 line:-1
今年有新的通知功能


515
00:25:08,675 --> 00:25:11,712 line:-1
可以当作是跨协调器保存通知


516
00:25:11,778 --> 00:25:13,614 line:-1
但事件是异步传达的


517
00:25:13,680 --> 00:25:17,518 line:-1
所以更像是跨协调器更改通知


518
00:25:18,118 --> 00:25:20,521 line:-1
我们叫做远程修改通知


519
00:25:22,289 --> 00:25:24,358 line:-1
要启用远程修改通知


520
00:25:24,424 --> 00:25:26,159 line:-2
用新的
PersistentStore


521
00:25:26,226 --> 00:25:30,531 line:-2
叫做
NSPersistentStoreRemoteChangeNotificationPostOptionKey


522
00:25:32,432 --> 00:25:33,500 line:-1
设置它为存储描述


523
00:25:33,567 --> 00:25:36,170 line:-2
然后加载
PersistentStore到协调器


524
00:25:36,236 --> 00:25:39,540 line:-2
然后协调器就会听取
对存储做出的远程修改


525
00:25:40,374 --> 00:25:42,176 line:-1
它还告诉协调器


526
00:25:42,242 --> 00:25:44,611 line:-1
它要发送远程修改通知


527
00:25:44,678 --> 00:25:47,247 line:-1
在变化发生的时候


528
00:25:47,314 --> 00:25:50,684 line:-1
如果要修改通知 就要用


529
00:25:50,751 --> 00:25:54,555 line:-1
NSPersistentStoreRemoteChangeNotificationPostOptionKey


530
00:25:54,621 --> 00:25:56,590 line:-1
给所有的协调器


531
00:25:56,657 --> 00:25:59,493 line:-1
不仅是给要应用修改的协调器


532
00:25:59,560 --> 00:26:02,229 line:-2
可能还要开启
PersistentHistory


533
00:26:02,296 --> 00:26:06,567 line:-2
因为 虽然远程修改通知
可以告诉你哪个存储被改了


534
00:26:06,633 --> 00:26:08,936 line:-1
通过NSPersistentStoreURLkey


535
00:26:09,002 --> 00:26:11,138 line:-1
在notification.UserInfo中


536
00:26:11,205 --> 00:26:12,806 line:-2
但如果开启了
PersistentHistory


537
00:26:12,873 --> 00:26:16,243 line:-2
它还会包括该事务创建的
新的历史令牌


538
00:26:16,710 --> 00:26:18,579 line:-1
它会十分有用 特别是当结合


539
00:26:18,645 --> 00:26:20,781 line:-2
新的PersistentHistory
抓取功能时


540
00:26:20,848 --> 00:26:22,583 line:-1
我们刚刚讲过的


541
00:26:23,817 --> 00:26:28,322 line:-1
远程修改通知类似于推送通知


542
00:26:28,388 --> 00:26:31,425 line:-1
有时候修改会让它们一起崩溃


543
00:26:31,491 --> 00:26:32,559 line:-1
如果一下子很多的话


544
00:26:32,626 --> 00:26:34,761 line:-1
只有最有一个修改能被传达


545
00:26:34,828 --> 00:26:36,663 line:-1
如果随意启动app


546
00:26:36,730 --> 00:26:39,399 line:-2
怎么知道哪个是当前的
PersistentHistory令牌


547
00:26:39,466 --> 00:26:42,836 line:-2
新方法就是
PersistentStoreCoordinator


548
00:26:44,104 --> 00:26:46,507 line:-1
叫做CurrentPersistentHistoryToken


549
00:26:46,573 --> 00:26:49,610 line:-1
集合这些新东西在一起 就能解开


550
00:26:49,977 --> 00:26:51,612 line:-1
过去的未解之谜


551
00:26:52,179 --> 00:26:54,948 line:-1
我们不仅能及时更新


552
00:26:55,015 --> 00:26:57,050 line:-2
PersistentHistory
还能只关注


553
00:26:57,117 --> 00:26:59,620 line:-1
影响到工作的修改


554
00:27:00,821 --> 00:27:02,956 line:-1
我想最好的讲解方法


555
00:27:03,023 --> 00:27:04,625 line:-1
是做个演示


556
00:27:04,992 --> 00:27:07,628 line:-1
看看app里的样子


557
00:27:09,463 --> 00:27:11,431 line:-1
这是个控制器


558
00:27:11,498 --> 00:27:14,134 line:-1
负责让视图上下文保持最新


559
00:27:14,201 --> 00:27:16,170 line:-1
无论协调器何时改变


560
00:27:16,236 --> 00:27:19,640 line:-2
storeRemoteChange
已经设为


561
00:27:20,174 --> 00:27:23,644 line:-1
在收到远程修改通知时调用


562
00:27:25,078 --> 00:27:28,315 line:-2
打开后可以获得新的
PersistentHistory令牌


563
00:27:28,382 --> 00:27:31,285 line:-1
保存在userInfo之外


564
00:27:31,618 --> 00:27:33,820 line:-1
然后抓取要更新的上下文


565
00:27:33,887 --> 00:27:35,656 line:-1
进入perform block


566
00:27:38,325 --> 00:27:40,827 line:-2
首先 要将
PersistentHistory


567
00:27:40,894 --> 00:27:42,863 line:-1
减到需要的内容


568
00:27:43,330 --> 00:27:47,534 line:-2
根据上一个历史令牌
创建predicate


569
00:27:47,601 --> 00:27:49,403 line:-1
在这个app的例子里


570
00:27:49,469 --> 00:27:51,672 line:-2
是当前的
PersistentHistory令牌


571
00:27:52,472 --> 00:27:56,610 line:-1
然后将所有事务前置 或等同于


572
00:27:56,677 --> 00:27:58,979 line:-1
通知给的新历史令牌


573
00:28:02,683 --> 00:28:05,352 line:-2
如果使用transaction author
应该用


574
00:28:05,419 --> 00:28:07,187 line:-1
可以创建一个predicate


575
00:28:07,254 --> 00:28:09,156 line:-1
允许我们查看仅限于


576
00:28:09,223 --> 00:28:12,693 line:-1
其他协调器创建的事务


577
00:28:13,961 --> 00:28:16,663 line:-2
然后创建
historyFetchedRequest


578
00:28:16,730 --> 00:28:18,699 line:-1
获取事务


579
00:28:18,999 --> 00:28:22,002 line:-2
设置predicate为
CompoundPredicate


580
00:28:22,069 --> 00:28:23,937 line:-1
对刚创建的所有predicate


581
00:28:24,004 --> 00:28:26,507 line:-1
现在看到的事务就仅限于


582
00:28:26,573 --> 00:28:30,477 line:-2
其他协调器编写的
夹在之前看到的


583
00:28:30,544 --> 00:28:33,247 line:-1
和刚包含的新的之间


584
00:28:35,315 --> 00:28:37,684 line:-1
创建NSPersistentHistoryChangeRequest


585
00:28:37,751 --> 00:28:40,721 line:-2
设置为刚创建的
fetchedRequest


586
00:28:41,188 --> 00:28:43,724 line:-1
然后对上下文执行


587
00:28:44,925 --> 00:28:49,096 line:-1
结果是一个未更新事务的列表


588
00:28:49,162 --> 00:28:50,397 line:-1
对每个来说


589
00:28:50,464 --> 00:28:55,102 line:-2
可以将
objectIDNotificationuserInfo


590
00:28:55,402 --> 00:28:57,171 line:-1
传递给


591
00:28:57,237 --> 00:29:01,742 line:-2
ManagedObjectContext.mergeChanges
fromRemoteContextSave


592
00:29:02,242 --> 00:29:04,745 line:-1
2017年引入


593
00:29:05,579 --> 00:29:07,214 line:-1
所有事务处理完毕后


594
00:29:07,281 --> 00:29:11,752 line:-1
视图就与最新的磁盘数据保持一致了


595
00:29:12,319 --> 00:29:16,423 line:-2
这几乎是实时完成的
因为推送在本地


596
00:29:16,490 --> 00:29:17,758 line:-1
速度很快


597
00:29:18,792 --> 00:29:22,729 line:-1
最后 为确保下一次不会做无用功


598
00:29:22,796 --> 00:29:26,099 line:-2
要记住最后处理的
PersistentHistory令牌


599
00:29:26,834 --> 00:29:29,837 line:-1
现在就能继续下一个远程修改通知了


600
00:29:31,505 --> 00:29:34,441 line:-2
好了 以上就是
PersistentHistory抓取


601
00:29:34,508 --> 00:29:36,677 line:-1
和远程修改通知


602
00:29:40,214 --> 00:29:41,648 line:-1
最后


603
00:29:41,715 --> 00:29:44,785 line:-1
我要讲一下测试


604
00:29:45,519 --> 00:29:47,454 line:-1
大家可能会运行测试


605
00:29:47,521 --> 00:29:51,225 line:-2
用多种配置 比如
sanitizer和发布


606
00:29:51,291 --> 00:29:54,428 line:-2
我想针对Core Data
提点建议


607
00:29:56,263 --> 00:29:58,665 line:-1
第一是要了解运行目标


608
00:29:58,932 --> 00:30:00,300 line:-1
联系人app会要测试


609
00:30:00,367 --> 00:30:03,003 line:-1
至少几万个对象


610
00:30:03,070 --> 00:30:04,705 line:-1
但对于这个运行目标


611
00:30:04,771 --> 00:30:07,741 line:-2
可能实际要在桌面硬件上
使用线性算法


612
00:30:07,808 --> 00:30:08,809 line:-1
有的时候


613
00:30:09,810 --> 00:30:11,178 line:-1
图库app就不同


614
00:30:11,245 --> 00:30:13,180 line:-1
它的测试是要验证所有工作都正确


615
00:30:13,247 --> 00:30:15,349 line:-1
因为有几百万个对象


616
00:30:15,415 --> 00:30:17,718 line:-1
这样的规模下 任何对数时间的延迟


617
00:30:17,784 --> 00:30:19,419 line:-1
都能卡顿app


618
00:30:19,486 --> 00:30:21,154 line:-1
因此重要的是


619
00:30:21,221 --> 00:30:22,689 line:-1
飞速测试


620
00:30:22,756 --> 00:30:26,827 line:-1
运行所有带性能数据集的集成测试


621
00:30:28,829 --> 00:30:31,765 line:-1
集成测试也要运行优化配置


622
00:30:31,832 --> 00:30:34,835 line:-1
用于测试和显示其他问题


623
00:30:35,369 --> 00:30:37,371 line:-2
使用Core Data的
app应该


624
00:30:37,437 --> 00:30:40,841 line:-1
利用框架内置的并发调式


625
00:30:41,341 --> 00:30:43,977 line:-1
Scheme Editor中开启


626
00:30:44,044 --> 00:30:47,848 line:-1
设置com.apple.CoreData.ConcurrencyDebug 1


627
00:30:48,182 --> 00:30:49,850 line:-1
在过程参数列表中


628
00:30:52,119 --> 00:30:54,521 line:-1
在多个配置中运行测试


629
00:30:54,588 --> 00:30:55,722 line:-1
会很费时


630
00:30:55,789 --> 00:30:58,959 line:-1
同样 单元测试也要尽可能快


631
00:30:59,026 --> 00:31:04,865 line:-2
当测试运行时间为关键时
用内存存储是个不错的办法


632
00:31:05,165 --> 00:31:09,870 line:-2
这里单指
SqLightStores内存模式


633
00:31:10,470 --> 00:31:13,407 line:-2
SqLightStore
一直支持内存模式


634
00:31:13,707 --> 00:31:14,675 line:-1
通过它


635
00:31:14,741 --> 00:31:17,444 line:-1
在创建持续化容器和加载存储之间


636
00:31:17,511 --> 00:31:18,912 line:-1
可以拉取存储描述


637
00:31:18,979 --> 00:31:21,882 line:-2
将URL属性设为指向
dev/null


638
00:31:23,250 --> 00:31:25,719 line:-1
这会创建一个极为性能化的堆栈


639
00:31:25,786 --> 00:31:28,922 line:-1
但内存存储不能在协调器之间共享


640
00:31:28,989 --> 00:31:32,125 line:-1
为了验证远程修改通知的工作


641
00:31:32,192 --> 00:31:33,193 line:-1
刚刚完成的


642
00:31:33,260 --> 00:31:36,897 line:-1
要利用命名的内存存储


643
00:31:37,364 --> 00:31:41,902 line:-2
命名的内存存储 通过在
dev/null后添加路径组件而定义


644
00:31:41,969 --> 00:31:45,873 line:-2
同一进程中的任何带URL的
其他SqLightStore


645
00:31:45,939 --> 00:31:48,408 line:-1
会连接到共享的内存数据库


646
00:31:49,776 --> 00:31:52,646 line:-1
共享一个内存存储的不同的协调器


647
00:31:52,713 --> 00:31:55,249 line:-1
会给彼此分发远程修改通知


648
00:31:55,315 --> 00:31:57,551 line:-1
让我们能测试所有逻辑


649
00:31:59,086 --> 00:32:01,488 line:-1
最后 用sanitizer


650
00:32:01,922 --> 00:32:04,424 line:-1
每个至少省了一次


651
00:32:04,491 --> 00:32:05,759 line:-2
我见过
address sanitizer


652
00:32:05,826 --> 00:32:08,662 line:-1
能立刻识别一个字节的缓冲溢出


653
00:32:08,729 --> 00:32:10,998 line:-1
以前可能要几个月才能隔离


654
00:32:11,064 --> 00:32:14,234 line:-2
同样 thread sanitizer
能理解临界段代码


655
00:32:14,301 --> 00:32:18,539 line:-1
能告诉你内部无法复制的线程痕迹


656
00:32:18,605 --> 00:32:22,176 line:-2
最后UBSan可以
在漏洞出现前解决它们


657
00:32:22,242 --> 00:32:25,846 line:-2
通过识别未来可能有变化的
未定义行为


658
00:32:25,913 --> 00:32:29,349 line:-2
今天我们讲了如何用
Core Data配置


659
00:32:29,416 --> 00:32:33,086 line:-1
如何利用新的和旧的API编写


660
00:32:33,153 --> 00:32:37,357 line:-2
模型和控制器之间
无缝、紧凑、稳健的集成


661
00:32:37,424 --> 00:32:40,460 line:-1
我们探索了多个协调器之间的同步


662
00:32:40,527 --> 00:32:43,630 line:-1
并对此定义需求和测试代码


663
00:32:43,697 --> 00:32:45,966 line:-1
我们变得更自信


664
00:32:46,867 --> 00:32:48,569 line:-1
我们乐于解你的想法


665
00:32:48,635 --> 00:32:50,904 line:-1
请通过反馈助手告诉我们


666
00:32:51,705 --> 00:32:54,975 line:-1
更多信息请登录开发者官网


667
00:32:55,409 --> 00:32:57,811 line:-1
本场演讲的网页上有今天提到过的


668
00:32:57,878 --> 00:32:59,346 line:-1
其他演讲的链接


669
00:32:59,847 --> 00:33:02,482 line:-1
明天的实验室见 谢谢参与

