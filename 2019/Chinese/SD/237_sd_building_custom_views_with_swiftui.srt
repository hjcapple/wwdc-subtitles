1
00:00:07,808 --> 00:00:10,844 line:-2
（在SwiftUI中创建自定义视
图 图形效果和布局）


2
00:00:15,849 --> 00:00:19,920 line:-2
大家好 很高兴再次在WWDC
与你们见面


3
00:00:20,687 --> 00:00:25,526 line:-2
我是Dave 如果你曾看过
关于SwiftUI的其它演讲


4
00:00:25,592 --> 00:00:29,763 line:-2
你就知道把app的
各个部分装配起来


5
00:00:29,830 --> 00:00:30,931 line:-1
并让app开始运行是多么简单


6
00:00:31,765 --> 00:00:36,570 line:-1
今天我和John要介绍如何实现


7
00:00:36,637 --> 00:00:41,742 line:-2
从创建功能性app
到拥有精美布局的app


8
00:00:42,075 --> 00:00:45,579 line:-1
漂亮的图形和一些很酷的动画


9
00:00:47,915 --> 00:00:50,784 line:-2
我们会介绍SwiftUI的
两个子系统


10
00:00:51,752 --> 00:00:55,022 line:-2
然后John会上台来
用这两个子系统创建自定义控制


11
00:00:56,256 --> 00:00:57,224 line:-1
让我们开始吧


12
00:00:57,658 --> 00:01:03,764 line:-2
从你着手使用SwiftUI开始
你就已经在体验


13
00:01:03,830 --> 00:01:04,831 line:-1
布局系统了


14
00:01:05,265 --> 00:01:08,535 line:-2
你在预览编辑器中的文本四周
看到的那个蓝框


15
00:01:09,136 --> 00:01:10,571 line:-1
是它的边界


16
00:01:11,004 --> 00:01:13,807 line:-2
布局就是在屏幕上
规定某个东西的边界


17
00:01:14,975 --> 00:01:18,178 line:-1
让我们用这个例子


18
00:01:18,245 --> 00:01:19,279 line:-1
看一下底层发生了什么


19
00:01:21,582 --> 00:01:24,451 line:-1
从技术上说 这里有三个视图


20
00:01:25,018 --> 00:01:27,921 line:-1
分别是视图等级底部的文本


21
00:01:29,923 --> 00:01:34,995 line:-2
你的内容视图 它总是拥有
与它的主体文本一样的边界


22
00:01:35,996 --> 00:01:40,868 line:-2
最后是根视图
在这个例子中是设备的尺寸


23
00:01:40,934 --> 00:01:43,971 line:-1
减去安全区域尺寸


24
00:01:44,638 --> 00:01:47,441 line:-2
那么如果你在手机顶部
看到了这样的东西


25
00:01:47,841 --> 00:01:49,176 line:-1
比如它不含在内


26
00:01:51,144 --> 00:01:57,618 line:-2
小技巧 你仍可在那个区中安排东西
通过使用这个修饰器 好的


27
00:01:57,951 --> 00:02:00,120 line:-1
但默认情况下 你处于安全区


28
00:02:01,388 --> 00:02:07,794 line:-2
我们总是把任意带有主体的
视图的顶层叫做中性布局


29
00:02:08,228 --> 00:02:11,899 line:-2
因此它的边界
是由它的主体的边界定义的


30
00:02:11,965 --> 00:02:13,333 line:-1
对它们的操作一样


31
00:02:13,767 --> 00:02:16,103 line:-1
因此你真的可以为了布局目的


32
00:02:16,170 --> 00:02:17,871 line:-1
把它们当作同一个视图


33
00:02:18,572 --> 00:02:21,675 line:-1
因此这里其实只有两个视图


34
00:02:22,042 --> 00:02:24,478 line:-1
布局过程有三个步骤


35
00:02:26,346 --> 00:02:30,684 line:-1
第一步 根视图提供文本、推荐尺寸


36
00:02:31,185 --> 00:02:33,620 line:-1
由那两个又大又宽的箭头表示


37
00:02:34,288 --> 00:02:38,458 line:-2
因为它是根视图
它提供的是整个安全区的尺寸


38
00:02:40,427 --> 00:02:43,697 line:-2
下一步 文本回应
嗯 它对你慷慨得多


39
00:02:43,764 --> 00:02:46,533 line:-1
但我真的 我只能做这么大


40
00:02:47,134 --> 00:02:52,206 line:-2
在SwiftUI中 不能给子视图
强制规定一个尺寸


41
00:02:52,272 --> 00:02:54,141 line:-1
而是由父视图来决定


42
00:02:56,210 --> 00:03:00,447 line:-2
现在根视图说了
好了 我需要把你放在哪


43
00:03:00,714 --> 00:03:02,182 line:-1
那么我要把你放在中间


44
00:03:03,951 --> 00:03:04,952 line:-1
那么就是这样


45
00:03:05,485 --> 00:03:09,556 line:-2
这是个简单的例子
但每个布局交互表现方式都一样


46
00:03:09,623 --> 00:03:13,026 line:-1
在父视图和子视图之间


47
00:03:13,327 --> 00:03:15,696 line:-1
并且整个布局的行为


48
00:03:15,896 --> 00:03:18,599 line:-1
从这些父-子视图交互中浮现出来


49
00:03:20,868 --> 00:03:23,437 line:-1
但我想强调一下第二步


50
00:03:23,670 --> 00:03:26,473 line:-1
因为它与你所熟悉的不一样


51
00:03:27,007 --> 00:03:29,443 line:-1
它对你非常重要


52
00:03:30,611 --> 00:03:33,680 line:-1
它意味着你的视图有尺寸调整行为


53
00:03:35,649 --> 00:03:40,420 line:-2
因为每个视图都控制自己的尺寸
它意味着当你创建视图时


54
00:03:40,721 --> 00:03:43,657 line:-2
你就要决定
如何以及何时重调它的尺寸


55
00:03:44,391 --> 00:03:49,730 line:-2
比如 这个视图是不可修正的
50乘10点


56
00:03:50,063 --> 00:03:53,033 line:-1
由于它的根视图中框架尺寸是固定的


57
00:03:54,501 --> 00:03:59,806 line:-2
而这个是可灵活调整的视图
但高度和宽度总会一样


58
00:04:00,574 --> 00:04:03,043 line:-1
因此它的长宽比总是一比一


59
00:04:03,510 --> 00:04:06,880 line:-1
因此尺寸被封装到了视图定义中


60
00:04:08,415 --> 00:04:10,384 line:-1
我们还看到它也适用于文本


61
00:04:11,485 --> 00:04:16,356 line:-2
那么在SwiftUI中
文本的边界从不会超出


62
00:04:16,423 --> 00:04:18,257 line:-1
它所显示的行的高度和宽度


63
00:04:18,759 --> 00:04:21,894 line:-2
我们稍后讲堆栈时再了解
它为什么这么重要


64
00:04:23,530 --> 00:04:29,870 line:-2
在布局中还有最后一步
对于获得漂亮的UI来说至关重要


65
00:04:29,937 --> 00:04:35,175 line:-2
在SwiftUI中
你真的不用担心这个问题


66
00:04:35,242 --> 00:04:39,947 line:-2
因为我们会替你处理
但值得了解一下SwiftUI


67
00:04:40,013 --> 00:04:42,816 line:-2
把你的视图圆角化为一个
最接近的像素


68
00:04:43,483 --> 00:04:49,923 line:-2
你不会得到像这样锯齿形的边
而是利落的、清晰的边


69
00:04:50,791 --> 00:04:55,529 line:-2
这只是每个好app
需要了解的许多细节之一


70
00:04:56,196 --> 00:05:00,167 line:-2
但SwiftUI会替你分担
以你的方式 是的！


71
00:05:03,704 --> 00:05:06,773 line:-2
从而你可以重点关注
让你的app变得更特别的东西


72
00:05:08,041 --> 00:05:13,647 line:-2
好的 现在我们了解了基础知识
让我们看看


73
00:05:13,714 --> 00:05:15,415 line:-1
是否可以把它变得更好


74
00:05:17,150 --> 00:05:21,755 line:-2
我要把示例中的文本
修改成一些随机文本 比如


75
00:05:22,322 --> 00:05:25,325 line:-2
我不知道
Avocado Toast？


76
00:05:26,727 --> 00:05:27,728 line:-1
你们饿了吗？


77
00:05:28,929 --> 00:05:32,599 line:-2
不饿？好的
让我试试让它变得更诱人


78
00:05:33,000 --> 00:05:35,068 line:-1
我要在这里添加漂亮的绿色背景


79
00:05:35,936 --> 00:05:42,242 line:-2
现在这个背景修饰器在背景视图中
包裹了文本视图


80
00:05:42,609 --> 00:05:44,811 line:-1
颜色视图作为第二子视图


81
00:05:47,481 --> 00:05:51,818 line:-1
现在绿色背景精准匹配文本的边界


82
00:05:52,886 --> 00:05:58,425 line:-2
第二个小技巧
把背景或边界颜色扔到视图上


83
00:05:58,592 --> 00:06:02,329 line:-2
是个非常有用的技巧
如果你想观察视图的边界


84
00:06:02,563 --> 00:06:04,965 line:-1
并且没有便利的预览画布的话


85
00:06:06,300 --> 00:06:11,205 line:-2
好的 现在我想在绿框内的文本四周
留出更多的空间


86
00:06:11,271 --> 00:06:15,409 line:-1
因此我要在那插入一些内边距


87
00:06:17,444 --> 00:06:23,116 line:-2
现在SwiftUI选择了许多
适合我们的平台、


88
00:06:23,183 --> 00:06:25,319 line:-1
动态类型尺寸和环境的内边距


89
00:06:26,420 --> 00:06:30,290 line:-2
当你不传递任何参数时
你会得到适应性内边距


90
00:06:30,557 --> 00:06:36,330 line:-2
与SwiftUI适应性地调整
选择器或按钮的方式一样


91
00:06:36,396 --> 00:06:37,931 line:-1
取决于它所处的情境


92
00:06:39,233 --> 00:06:42,836 line:-2
并且如果我们只想适应性地填充
左右内边距


93
00:06:43,337 --> 00:06:44,705 line:-1
嗯 我们也可以实现


94
00:06:46,607 --> 00:06:50,444 line:-1
适应性修饰器是调整布局的最佳方式


95
00:06:50,711 --> 00:06:54,715 line:-2
因为你避免了把代码复杂化
避免在开发早期


96
00:06:54,781 --> 00:06:56,049 line:-1
在一些细节上浪费时间


97
00:06:56,350 --> 00:06:59,119 line:-2
并避免硬编码常量
这可能会在其它地方不合时宜


98
00:07:00,787 --> 00:07:06,193 line:-2
但因为我们在这里控制着这些细节
假如有个规范


99
00:07:06,260 --> 00:07:10,497 line:-1
要求所有内边距都是十个点


100
00:07:11,732 --> 00:07:13,166 line:-1
好的 你可以明确地写出来


101
00:07:14,635 --> 00:07:18,739 line:-2
这个例子比Hello World
更有意思一点


102
00:07:19,373 --> 00:07:22,476 line:-2
让我们在这个例子中看看
布局过程是如何运作的


103
00:07:23,911 --> 00:07:28,882 line:-2
首先 根视图为背景视图提供了
它的整个尺寸


104
00:07:29,716 --> 00:07:35,189 line:-2
与吐司视图类似
背景视图是中性布局


105
00:07:35,722 --> 00:07:38,225 line:-1
因此它会把那个建议尺寸


106
00:07:38,292 --> 00:07:40,394 line:-1
传递给内边距视图


107
00:07:42,696 --> 00:07:48,235 line:-2
内边距视图知道它要给它子视图的
每个边都添加十个点的内边距


108
00:07:48,435 --> 00:07:53,240 line:-2
因此它给它的子视图文本视图
提供的要少得多


109
00:07:55,309 --> 00:07:59,513 line:-2
文本占据了它所需要的宽度
并把那个值返回给内边距视图


110
00:08:00,614 --> 00:08:04,852 line:-2
内边距视图就知道每一边都要
比它的子视图要大十个点


111
00:08:04,918 --> 00:08:08,589 line:-2
并且它把文本恰当地放到了
它的坐标空间中


112
00:08:11,158 --> 00:08:14,061 line:-1
现在我们说过背景视图是中性布局


113
00:08:14,127 --> 00:08:16,230 line:-1
因此它只需要向上报告那个尺寸即可


114
00:08:16,563 --> 00:08:22,936 line:-2
但在此之前 它把那个尺寸提供给
它的第二个子视图 颜色视图


115
00:08:24,605 --> 00:08:28,775 line:-1
颜色在布局时非常顺从


116
00:08:29,142 --> 00:08:31,378 line:-1
它们接受提供给它们的尺寸


117
00:08:31,545 --> 00:08:35,649 line:-1
因此尺寸的颜色与内边距视图的一样


118
00:08:36,984 --> 00:08:40,153 line:-2
最后背景视图把它的尺寸
报告给根视图


119
00:08:40,587 --> 00:08:44,825 line:-2
并且根视图会跟以前一样
让它居中显示


120
00:08:45,158 --> 00:08:46,493 line:-1
这就是整个过程


121
00:08:47,728 --> 00:08:49,029 line:-1
准备好看另一个例子了吗？


122
00:08:49,263 --> 00:08:52,299 line:-1
这个例子更简单 但它很重要


123
00:08:53,734 --> 00:09:00,040 line:-2
那么在这个例子中 视图的主题
只是一张固定的20乘20的图片


124
00:09:01,275 --> 00:09:07,281 line:-2
SwiftUI中 除非在资产目录
或代码中你把图片标记为尺寸可调


125
00:09:07,514 --> 00:09:09,750 line:-1
否则就是固定尺寸


126
00:09:10,951 --> 00:09:15,489 line:-2
现在我希望视图
整个视图变大为原来的1.5倍


127
00:09:15,656 --> 00:09:19,660 line:-2
让我们添加一个30乘30的
框架修饰器 就像这个一样


128
00:09:21,495 --> 00:09:26,700 line:-1
现在你可能注意到了


129
00:09:26,767 --> 00:09:30,470 line:-2
图片虽然确实很可口
它的尺寸没有发生改变


130
00:09:32,306 --> 00:09:34,208 line:-1
但不应该太惊讶 是吗？


131
00:09:34,508 --> 00:09:35,843 line:-1
我们说过它是固定尺寸


132
00:09:37,277 --> 00:09:40,814 line:-2
在它周围你会发现一个
30乘30的框架


133
00:09:41,348 --> 00:09:45,185 line:-2
那是视图主体的尺寸
因此我们定义的视图


134
00:09:45,252 --> 00:09:49,590 line:-2
实际上比我们之前添加的修饰器
要大50%


135
00:09:51,725 --> 00:09:56,330 line:-1
因此框架尺寸与图片尺寸不匹配


136
00:09:56,396 --> 00:09:57,497 line:-1
这是个矛盾吗？


137
00:09:59,132 --> 00:10:00,234 line:-1
实际上不是


138
00:10:00,968 --> 00:10:03,570 line:-1
这是布局系统正在做它应该做的事


139
00:10:04,805 --> 00:10:10,644 line:-2
认出框架不是SwiftUI中的
一个约束非常重要


140
00:10:11,311 --> 00:10:12,412 line:-1
它只是个视图


141
00:10:12,479 --> 00:10:14,982 line:-1
你可以把它看作是一个图片框架


142
00:10:16,450 --> 00:10:21,889 line:-2
它给它的子视图推荐固定尺寸
但和其它视图不同


143
00:10:21,955 --> 00:10:24,925 line:-1
子视图最终会选择自己的尺寸


144
00:10:26,126 --> 00:10:32,299 line:-2
从这层意义上来说 SwiftUI
布局比你熟悉的更灵活


145
00:10:33,567 --> 00:10:37,304 line:-2
好处是
在SwiftUI中没有欠约束的


146
00:10:37,371 --> 00:10:42,276 line:-2
或超出约束的系统
意味着你能表达的一切


147
00:10:42,342 --> 00:10:43,744 line:-1
都拥有一个定义良好的效果


148
00:10:45,078 --> 00:10:48,081 line:-1
那么完全没有什么不正确的布局


149
00:10:48,715 --> 00:10:50,317 line:-1
除非你不喜欢你所得到的结果


150
00:10:52,486 --> 00:10:55,455 line:-1
好的 现在我们了解了一些基础信息


151
00:10:56,089 --> 00:10:58,926 line:-1
让我们讨论一下强大的工具 堆栈


152
00:11:00,494 --> 00:11:06,400 line:-1
现在HStack和VStack


153
00:11:06,466 --> 00:11:07,668 line:-1
分别以行或列安排它们的子视图


154
00:11:08,635 --> 00:11:11,538 line:-2
我把这个列表网格和四个堆栈
放到一起


155
00:11:11,605 --> 00:11:13,106 line:-1
只需要几行代码就能实现


156
00:11:14,641 --> 00:11:15,943 line:-1
这是那个布局的代码


157
00:11:17,110 --> 00:11:22,015 line:-1
顶层是HStack有两个子视图


158
00:11:22,282 --> 00:11:26,253 line:-1
第一个是VStack约束星形评级


159
00:11:28,856 --> 00:11:34,795 line:-2
另一个子视图还是一个VStack
它的两个子视图左对齐


160
00:11:36,330 --> 00:11:39,299 line:-2
其中第一个子视图
又是另一个HStack


161
00:11:40,067 --> 00:11:46,240 line:-2
约束标题、有弹性的间隔器
和牛油果图片


162
00:11:48,809 --> 00:11:51,211 line:-1
好了 四个堆栈


163
00:11:51,879 --> 00:11:52,980 line:-1
让我们把它们重新放到一起


164
00:12:01,555 --> 00:12:05,926 line:-2
我希望你注意到
SwiftUI没有粗暴地


165
00:12:05,993 --> 00:12:06,994 line:-1
把堆栈的子视图都堆砌在一起


166
00:12:07,361 --> 00:12:12,499 line:-2
它在两个子视图之间留出了一些空间
因为适应性间隔生效了


167
00:12:13,800 --> 00:12:17,304 line:-2
你还会发现的邻近文本的
基线到基线的空间


168
00:12:17,938 --> 00:12:23,010 line:-2
与Apple的人性化界面指南
完全相匹配


169
00:12:24,111 --> 00:12:26,413 line:-1
而基线到边界的空间也一样


170
00:12:26,947 --> 00:12:30,951 line:-2
因为我们把这些规则加密到了
SwiftUI的布局系统中


171
00:12:32,519 --> 00:12:37,357 line:-2
这里的一般规则是最简单、
最简洁的代码


172
00:12:37,558 --> 00:12:41,028 line:-1
也可以产生漂亮的结果


173
00:12:42,462 --> 00:12:48,702 line:-2
但如果你需要控制
一如既往 SwiftUI会支持你


174
00:12:49,136 --> 00:12:52,272 line:-2
它有旋钮 你可以打开或关闭
以获得你想要的结果


175
00:12:54,708 --> 00:12:59,313 line:-2
哦 我几乎忘了
SwiftUI还替你处理另一件事


176
00:12:59,780 --> 00:13:04,985 line:-2
若你的app定位在一个从右到左的
书写系统中 比如阿拉伯语


177
00:13:05,385 --> 00:13:06,854 line:-1
并且你修改了系统语言


178
00:13:08,021 --> 00:13:11,091 line:-1
SwiftUI会替你调整水平坐标


179
00:13:11,558 --> 00:13:13,293 line:-1
因此你不需要重新编写布局


180
00:13:19,499 --> 00:13:24,104 line:-2
如果你一直在思考 我们为什么说
leading和trailing


181
00:13:24,338 --> 00:13:26,740 line:-2
而不是left和right
现在你了解了吧


182
00:13:27,307 --> 00:13:29,676 line:-1
这样你的布局


183
00:13:29,743 --> 00:13:31,044 line:-1
会自动国际化


184
00:13:32,713 --> 00:13:36,550 line:-1
好的 让我们具体看看堆栈布局


185
00:13:37,584 --> 00:13:43,323 line:-2
现在 我们目前所看到的
绝大多数视图


186
00:13:43,390 --> 00:13:44,391 line:-1
实际上都是子视图的直链


187
00:13:44,658 --> 00:13:46,326 line:-1
但堆栈很有意思


188
00:13:46,660 --> 00:13:50,931 line:-1
因为子视图必须平等竞争一个空间


189
00:13:52,165 --> 00:13:58,839 line:-2
在这个堆栈中 我们已经说过
文本不应该超过一行


190
00:14:00,541 --> 00:14:05,812 line:-2
意思是如果堆栈被要求适应
较少的空间


191
00:14:07,581 --> 00:14:09,950 line:-1
嗯 文本将被缩短以适应它


192
00:14:11,151 --> 00:14:14,621 line:-1
但让我们从父视图


193
00:14:14,688 --> 00:14:16,957 line:-1
提供了足够空间的情况开始看好吗？


194
00:14:18,158 --> 00:14:22,529 line:-1
首先堆栈要计算出内部空间需求


195
00:14:23,397 --> 00:14:30,070 line:-2
并从建议宽度中提取那个信息
以便为我们提供未分配的空间的尺寸


196
00:14:30,404 --> 00:14:34,241 line:-2
现在我们有三个子视图
我们不知道它们的尺寸


197
00:14:36,210 --> 00:14:41,315 line:-1
因此我们决定把空间平均分成三等份


198
00:14:41,548 --> 00:14:45,986 line:-2
然后我们提议把其中一份作为
最不灵活的子视图的尺寸


199
00:14:47,187 --> 00:14:50,224 line:-2
现在 我们说过图片是固定尺寸
对吗？


200
00:14:50,591 --> 00:14:53,060 line:-1
那它就是最不灵活的那个


201
00:14:54,595 --> 00:15:01,401 line:-2
那么图片占据了这么多空间
是它所要求的尺寸


202
00:15:01,735 --> 00:15:05,205 line:-1
我们把那个尺寸从未分配空间中扣除


203
00:15:07,107 --> 00:15:08,108 line:-1
并重复这个过程


204
00:15:08,709 --> 00:15:14,147 line:-2
好的 我们现在有两个
未规定尺寸的子视图


205
00:15:14,214 --> 00:15:19,152 line:-2
因此我们把余下的空间分成两份
并把其中一半提供给


206
00:15:19,219 --> 00:15:20,921 line:-2
没有尺寸的较不灵活的子视图
即Delicious


207
00:15:22,489 --> 00:15:27,261 line:-2
Delicious占了这么多空间
你看到它占的空间比提供给它的少


208
00:15:27,694 --> 00:15:28,695 line:-1
记住这一点


209
00:15:30,364 --> 00:15:34,134 line:-1
把它从未分配空间中扣除


210
00:15:34,668 --> 00:15:39,206 line:-2
给Avocado Toast
留下了这么多空间


211
00:15:39,640 --> 00:15:41,008 line:-1
你可以看到 空间充足


212
00:15:42,576 --> 00:15:44,378 line:-1
好的 最后一步


213
00:15:46,380 --> 00:15:49,249 line:-1
现在所有子视图都有尺寸了


214
00:15:50,184 --> 00:15:53,754 line:-2
堆栈通过之前的间隔
把它们排列起来


215
00:15:54,922 --> 00:15:57,658 line:-1
因为代码没有指定对齐方式


216
00:15:58,125 --> 00:16:00,060 line:-1
默认生效的是居中对齐


217
00:16:00,861 --> 00:16:04,665 line:-1
因此堆栈使用居中对齐


218
00:16:04,731 --> 00:16:05,999 line:-1
把所有子视图垂直地居中显示


219
00:16:07,768 --> 00:16:13,240 line:-2
最后堆栈选择自己的尺寸
从而可以完全封装子视图


220
00:16:15,075 --> 00:16:18,846 line:-1
现在如果你思考一下 你可能会想


221
00:16:18,912 --> 00:16:22,349 line:-2
为什么文本的边界不会超出
它们所显示的宽度


222
00:16:23,584 --> 00:16:28,488 line:-2
请看 如果Delicious
接受了提供给它的全部空间


223
00:16:28,555 --> 00:16:31,859 line:-2
减少为Avocado Toast
提供的空间从而会迫使它截短图片


224
00:16:32,292 --> 00:16:37,097 line:-2
尽管事实是一切都要合适
有足够的空间


225
00:16:38,765 --> 00:16:41,201 line:-1
实际上 相对于这里的两段文本


226
00:16:41,602 --> 00:16:44,938 line:-2
Avocado Toast
明显更重要 对吧？


227
00:16:45,172 --> 00:16:46,173 line:-1
它是主题


228
00:16:46,907 --> 00:16:49,810 line:-2
Delicious只是个附属
它可以做出牺牲


229
00:16:51,979 --> 00:16:53,380 line:-1
因此这并不是个好结果


230
00:16:54,481 --> 00:16:59,219 line:-2
但现在我想了一下
那意味着空间的大小


231
00:16:59,286 --> 00:17:02,856 line:-1
所提供的空间比理想空间小


232
00:17:03,524 --> 00:17:08,095 line:-2
我们之前见过的截短行为很可能
也不完全是我们希望得到的


233
00:17:09,530 --> 00:17:11,365 line:-1
如果提供这么窄的空间


234
00:17:11,431 --> 00:17:13,733 line:-1
我们宁愿保留主题完整


235
00:17:14,101 --> 00:17:16,770 line:-1
并截短附属物


236
00:17:18,571 --> 00:17:20,907 line:-2
好的 为此我们有另一个
强大的工具


237
00:17:21,508 --> 00:17:27,146 line:-2
我们把Avocado Toast
的布局优先级从默认的零


238
00:17:27,580 --> 00:17:28,582 line:-1
提高到一


239
00:17:34,922 --> 00:17:38,225 line:-2
因此当堆栈中的子视图
有不同的布局优先级时


240
00:17:38,592 --> 00:17:41,228 line:-1
堆栈获取未分配的空间


241
00:17:41,995 --> 00:17:46,600 line:-2
它给所有优先级较低的子视图
留出最小宽度


242
00:17:47,067 --> 00:17:51,438 line:-2
然后把其余空间分配给
优先级最高的子视图


243
00:17:52,973 --> 00:17:55,676 line:-2
在这个例子中只有一个是最高优先级
就是Avocado Toast


244
00:17:57,878 --> 00:18:01,048 line:-1
并且会给它提供全部可用空间


245
00:18:01,381 --> 00:18:06,486 line:-1
扣除图片宽度


246
00:18:06,553 --> 00:18:09,456 line:-2
和把Delicious缩减到
最小后保留的三个点


247
00:18:11,091 --> 00:18:16,029 line:-2
好的 通过最高级布局优先级
调整所有子视图的尺寸后


248
00:18:16,096 --> 00:18:20,234 line:-1
堆栈继续给下一个


249
00:18:20,467 --> 00:18:23,203 line:-2
布局优先级最高的子视图
分配余下的空间 如此反复


250
00:18:24,671 --> 00:18:28,609 line:-2
好的 我还要给你们展示最后一个
强大的工具


251
00:18:30,010 --> 00:18:31,011 line:-1
对齐


252
00:18:31,845 --> 00:18:37,484 line:-2
现在我知道你对于我们能底边对齐
这个堆栈并不惊讶


253
00:18:39,987 --> 00:18:41,722 line:-1
那样看起来很不错 对吧？


254
00:18:42,990 --> 00:18:48,629 line:-2
但请考虑一下
当我们把Delicious的字号


255
00:18:48,695 --> 00:18:49,863 line:-1
改小时会怎么样


256
00:18:52,432 --> 00:18:55,169 line:-1
嗯 我觉得还不错 但我知道什么？


257
00:18:55,769 --> 00:18:57,070 line:-1
我只是个app开发人员


258
00:18:57,738 --> 00:19:02,242 line:-2
我很确定我的UI设计师
Crusty会觉得它是个问题


259
00:19:06,880 --> 00:19:08,749 line:-1
是的 他会一直放大


260
00:19:08,815 --> 00:19:11,185 line:-1
并开始像这样选择详细信息


261
00:19:12,252 --> 00:19:16,723 line:0
他会说 Bucky 首先你有
Delicious的基线 就在此


262
00:19:17,357 --> 00:19:20,127 line:0
然后图片的底边在下边


263
00:19:20,694 --> 00:19:24,831 line:0
然后Avocado Toast的
基线却在上边


264
00:19:25,265 --> 00:19:28,402 line:0
没有一个对齐的 我是怎么教你的？


265
00:19:33,607 --> 00:19:36,743 line:0
幸运的是我们可以
在SwiftUI中解决它了


266
00:19:37,878 --> 00:19:40,614 line:0
基于文本的排列工具始终是对齐


267
00:19:40,848 --> 00:19:43,617 line:0
比如上下对齐


268
00:19:45,552 --> 00:19:51,258 line:0
如果我们以文本的基线对齐文本
它就灵巧地解决了这个问题


269
00:19:57,764 --> 00:19:58,832 line:-1
那图片怎么办呢？


270
00:19:59,499 --> 00:20:04,671 line:-2
请看 图片中没有文本
但每个对齐都有默认值


271
00:20:04,938 --> 00:20:07,808 line:-1
并且最后一行文本基线的默认值


272
00:20:07,875 --> 00:20:12,613 line:-1
正是视图的底边 那我就得到了


273
00:20:12,679 --> 00:20:14,014 line:-1
Crusty要求我实现的效果


274
00:20:15,549 --> 00:20:22,356 line:-2
哦 哦 再看一下
我非常确定我感觉很不好


275
00:20:22,422 --> 00:20:26,627 line:-2
我非常确定他会告诉我说
上边有一个可见的基线


276
00:20:26,827 --> 00:20:29,530 line:-1
距离底部还有87.4%的距离


277
00:20:31,365 --> 00:20:37,971 line:-2
通过告诉SwiftUI 如何给
图片计算最后一行文本基线来实现


278
00:20:38,405 --> 00:20:41,775 line:-1
按照它的其它对齐方式


279
00:20:42,809 --> 00:20:43,810 line:-1
很酷 对吗？


280
00:20:48,815 --> 00:20:51,285 line:-2
但我们还没有完全利用
对齐工具的功能


281
00:20:52,085 --> 00:20:54,321 line:-1
让我们返回到内嵌堆栈例子中


282
00:20:55,756 --> 00:21:01,562 line:-2
假如我们想对齐这些星星
和标题的中心位置 就像这样


283
00:21:05,432 --> 00:21:11,104 line:-1
现在请记住 讨论中的文本


284
00:21:11,371 --> 00:21:12,573 line:-1
嵌在视图等级的两个不同的分支中


285
00:21:14,875 --> 00:21:19,346 line:-2
那么 嗯 居中对齐
那个顶层HStack的子视图


286
00:21:19,413 --> 00:21:23,951 line:-2
并不会切割它
因为它是默认的 是的


287
00:21:24,017 --> 00:21:25,586 line:-1
那么我们已经快搞定了


288
00:21:25,652 --> 00:21:27,521 line:-1
你可以看到那些子视图已经对齐了


289
00:21:28,222 --> 00:21:34,962 line:-2
不 我们要的对齐方式
和居中对齐不一样


290
00:21:35,028 --> 00:21:36,830 line:-2
标记星星的中间位置
和标题的中间位置


291
00:21:38,298 --> 00:21:42,903 line:-2
我们需要定义自己的对齐方式
实际上就是如此简单


292
00:21:43,504 --> 00:21:47,708 line:-2
只需要六行代码就能实现
我们在垂直对齐上实施一个扩展


293
00:21:49,610 --> 00:21:54,515 line:-1
首先我们定义遵循对齐ID的枚举


294
00:21:55,148 --> 00:21:56,917 line:-1
有一个要求


295
00:21:57,851 --> 00:22:00,921 line:-1
告诉SwiftUI如何计算默认值


296
00:22:03,757 --> 00:22:07,995 line:-2
现在在这个例子中
我们选了什么其实不重要


297
00:22:08,061 --> 00:22:11,565 line:-1
因为默认值不会超出那些内部的堆栈


298
00:22:12,099 --> 00:22:17,337 line:-2
但我把这个默认定义为底部
从而你可以看到


299
00:22:17,404 --> 00:22:23,310 line:-1
它就像定义对齐指南修饰器一样


300
00:22:24,011 --> 00:22:28,715 line:-1
最后我们定义垂直对齐的静态实体


301
00:22:29,283 --> 00:22:32,686 line:-1
把枚举类型作为它的参数


302
00:22:35,455 --> 00:22:38,425 line:-1
现在我们可以用它来对齐堆栈


303
00:22:40,093 --> 00:22:45,666 line:-2
明确地把它设定到
星星和标题的中间位置


304
00:22:48,769 --> 00:22:53,106 line:-1
现在我们所设置的明确的对齐值


305
00:22:53,173 --> 00:22:57,778 line:-2
穿过了所嵌入的堆栈的两个层
允许外部的HStack


306
00:22:57,845 --> 00:22:58,846 line:-1
对齐那些内部的部分


307
00:23:00,013 --> 00:23:01,348 line:-1
那么这就是自定义对齐


308
00:23:07,754 --> 00:23:12,593 line:-2
一个强大的工具
帮助你取悦最挑剔的UI设计师


309
00:23:13,460 --> 00:23:17,664 line:-2
现在我要邀请
John Harper上台


310
00:23:17,731 --> 00:23:20,467 line:-2
讲讲SwiftUI中的图形效果
John


311
00:23:25,806 --> 00:23:26,807 line:-1
谢谢Dave


312
00:23:27,274 --> 00:23:30,844 line:-2
是的 我要讲
SwiftUI的一些图形功能


313
00:23:30,911 --> 00:23:35,482 line:-1
以及如何使用它们在app中


314
00:23:35,549 --> 00:23:36,550 line:-1
创建交互性控制


315
00:23:38,085 --> 00:23:41,421 line:-1
这是我们想要创建的效果的示例


316
00:23:41,655 --> 00:23:45,826 line:-1
你之前见过 但只是几个普通的控制


317
00:23:45,893 --> 00:23:50,931 line:-2
然后在中间有这个大戒指的图形
四周有渐变


318
00:23:51,131 --> 00:23:52,366 line:-1
底部是一个条形图


319
00:23:52,432 --> 00:23:56,537 line:-1
如果你想在app中实现这种效果


320
00:23:56,603 --> 00:24:00,207 line:-2
你必须深入到图形系统内部
也许是核心动画或核心图形


321
00:24:02,209 --> 00:24:05,612 line:-2
我们认为在SwiftUI中
我们有一个好方法可以实现这种效果


322
00:24:05,679 --> 00:24:09,283 line:-1
我们先看个小例子


323
00:24:09,349 --> 00:24:12,286 line:-2
但在我们做任何复杂的操作之前
我们需要先了解基础知识


324
00:24:13,020 --> 00:24:15,756 line:-2
如果我们想绘制一个红色圆圈
我们该如何做？


325
00:24:16,123 --> 00:24:17,925 line:-2
嗯 我们首先要创建一个
自定义视图类型


326
00:24:17,991 --> 00:24:19,560 line:-1
因为我们知道所有一切都是视图


327
00:24:20,294 --> 00:24:23,497 line:-2
然后我们要把像这样的东西放进去
在这里我们说


328
00:24:23,564 --> 00:24:27,901 line:-2
如果给我一个图形和颜色
我能填充 把那两种东西填充到一起


329
00:24:27,968 --> 00:24:30,137 line:-1
屏幕上有一个红色的圆圈了


330
00:24:31,772 --> 00:24:34,441 line:-2
但这里有个非常有意思的事
就是我们没有给它提供位置尺寸


331
00:24:34,508 --> 00:24:38,378 line:-1
那是因为我们依赖于布局系统来实现


332
00:24:38,445 --> 00:24:41,682 line:-2
就是Dave讲的那些
让布局系统替我们布局我们的视图


333
00:24:41,748 --> 00:24:43,450 line:-1
即使我们就在这个绘图模型中


334
00:24:44,451 --> 00:24:51,158 line:-2
那么图形会反应给布局系统
并产生视图


335
00:24:51,225 --> 00:24:54,561 line:-2
事实上 现在我们的绘图核心
如果你那样认为它们的话


336
00:24:54,628 --> 00:24:58,198 line:-2
实际上只是视图 然后那其实意味着
SwiftUI中一切都适用于绘图


337
00:24:58,265 --> 00:25:01,001 line:-2
因为SwiftUI中的
一切都是视图


338
00:25:01,335 --> 00:25:05,506 line:-2
因此你所看到的全部修饰器
关于布局和动画、滤镜效果的修饰器


339
00:25:05,572 --> 00:25:09,610 line:-2
一切的一切所适用的绘图方式
都与适用于视图的绘图方式相同


340
00:25:10,110 --> 00:25:13,914 line:-2
但类似地 我们添加了大量的
新自定义修饰器


341
00:25:14,147 --> 00:25:16,750 line:-1
专用于图形绘制 比如模糊和阴影


342
00:25:17,551 --> 00:25:21,321 line:-2
但因为绘制的图形只是个视图
它们都适用于常规视图


343
00:25:21,388 --> 00:25:22,589 line:-1
以及图形视图


344
00:25:23,423 --> 00:25:27,394 line:-2
因此 我们认为这种统一的常规控制
比如视图和图形


345
00:25:27,461 --> 00:25:30,063 line:-1
会随着我们的进步变得非常强大


346
00:25:31,331 --> 00:25:33,700 line:-1
好的 但让我们具体看一下


347
00:25:34,301 --> 00:25:39,706 line:-2
基础模型是有一个形状和一个样式、
一种颜色或其它要素


348
00:25:39,907 --> 00:25:42,209 line:-1
其中两者的结合产生一个视图


349
00:25:42,943 --> 00:25:47,414 line:-2
我们在这里有一些形状
正如我们所看到的 我可以填充红色


350
00:25:47,481 --> 00:25:48,482 line:-1
并得到一个红色圆圈


351
00:25:49,416 --> 00:25:52,386 line:-2
但同时我们可以使用不同的操作
比如说不同的形状


352
00:25:52,452 --> 00:25:55,122 line:-1
和胶囊 比如用红色描绘


353
00:25:55,556 --> 00:25:57,357 line:-2
在那种情况下
我们不会得到一个填充的形状


354
00:25:57,424 --> 00:25:59,226 line:-1
我们填充的是形状的轮廓


355
00:26:00,794 --> 00:26:04,264 line:-2
但这就是我们经常想要得到的
但有时候我们发现我们可能想要


356
00:26:04,331 --> 00:26:08,068 line:-2
稍微有些不同的描绘 因此我们还可
比如说描绘形状的边框


357
00:26:08,135 --> 00:26:10,237 line:-1
而不是描绘形状


358
00:26:10,637 --> 00:26:11,638 line:-1
这只是个变体


359
00:26:13,173 --> 00:26:16,009 line:-1
这也表示所有这些描绘操作


360
00:26:16,076 --> 00:26:19,947 line:-2
都可以要么像第一个例子一样
占据一行的宽度


361
00:26:20,013 --> 00:26:23,617 line:-2
要么都是标准的描绘参数 比如
你很可能在其它图形API中看到的


362
00:26:23,684 --> 00:26:26,887 line:-1
破折号和终止符以及线段连接符


363
00:26:28,522 --> 00:26:31,058 line:-2
好的 那么我们已经了解了图形
并且我们已经了解了如何填充它们


364
00:26:31,592 --> 00:26:33,393 line:-1
但在这一点上 我们只使用了颜色


365
00:26:34,127 --> 00:26:36,763 line:-2
但其实还有其它
可以用来填充图形的功能


366
00:26:37,264 --> 00:26:41,068 line:-2
我们可以使用拼接图片
并且我们可以使用各种渐变色


367
00:26:42,703 --> 00:26:43,804 line:-1
来填充图形


368
00:26:44,805 --> 00:26:47,107 line:-1
这是一个使用渐变色的例子


369
00:26:47,474 --> 00:26:51,545 line:-2
所有渐变色样式都使用了这个
基础样式


370
00:26:51,778 --> 00:26:54,014 line:-1
它只提供了一维的颜色梯度


371
00:26:54,448 --> 00:26:56,783 line:-2
在这个例子中
我们给它提供七种颜色


372
00:26:56,850 --> 00:26:59,052 line:-1
它将平均地把它们排列到连续线上


373
00:26:59,253 --> 00:27:00,721 line:-1
正好为我们提供了梯度


374
00:27:01,255 --> 00:27:04,258 line:-2
一旦完成 我们可以选择
其中一种渐变样式


375
00:27:04,324 --> 00:27:06,727 line:-1
在这个例子中 我们要使用角渐变


376
00:27:07,261 --> 00:27:10,564 line:-2
我们为它提供颜色梯度 然后我们
在这个例子中 使用角渐变


377
00:27:10,631 --> 00:27:13,300 line:-1
我们为它提供中心点以及起始角


378
00:27:13,734 --> 00:27:17,905 line:-1
然后它就会在那个圆圈周围填充颜色


379
00:27:17,971 --> 00:27:22,743 line:-1
并把它们推到无穷以提供颜色填充


380
00:27:23,243 --> 00:27:27,347 line:-2
但很明显 我们可使用刚做好的样式
并把它应用到圆圈中


381
00:27:27,714 --> 00:27:29,550 line:-2
在这个例子中 执行填充
跟我们之前见过的一样


382
00:27:29,616 --> 00:27:31,084 line:-1
现在我们拥有这个颜色漂亮的轮子


383
00:27:31,151 --> 00:27:32,519 line:-1
而不是红色圆圈


384
00:27:33,520 --> 00:27:37,124 line:-1
但当然了 填充只是其中一个操作


385
00:27:37,191 --> 00:27:39,359 line:-2
同样地 我们刚才也只提到描绘边框
并得到一个填充颜色的戒指


386
00:27:47,734 --> 00:27:51,638 line:-2
好的 这就是基础信息
我们已经了解了绘制单一物体


387
00:27:52,039 --> 00:27:54,274 line:-2
但现在我们想继续
并使用多个绘图操作


388
00:27:54,341 --> 00:27:56,476 line:-1
创建更复杂的东西 多个视图


389
00:27:57,277 --> 00:27:59,680 line:-2
这是我们要在接下来的演讲中
使用的例子


390
00:27:59,746 --> 00:28:02,149 line:-2
它其实是一段时期代码
你可以下载


391
00:28:02,349 --> 00:28:04,952 line:-1
并且它是个交互性的饼图


392
00:28:05,886 --> 00:28:08,822 line:-2
它由一群颜色楔形构成
你可以添加并移除它们


393
00:28:08,889 --> 00:28:10,824 line:-1
它们可以动态出入


394
00:28:12,292 --> 00:28:16,964 line:-2
好的 在我们了解如何绘制它之前
我们需要看一下数据


395
00:28:17,564 --> 00:28:22,569 line:-2
我们的示例app给我们提供了一个
数据模型 并且它非常简单


396
00:28:22,636 --> 00:28:26,106 line:-1
它只是个卡扣 代表其中一个楔形


397
00:28:26,740 --> 00:28:30,310 line:-2
并且每个楔形都包含代表
视图的集合图形和颜色的


398
00:28:30,377 --> 00:28:31,845 line:-1
一些属性


399
00:28:32,346 --> 00:28:35,649 line:-2
然后我们有一大堆楔形
通过ID进行追踪


400
00:28:35,716 --> 00:28:38,952 line:-2
最后是一组ID
从而我们知道要按哪个顺序


401
00:28:39,019 --> 00:28:40,020 line:-1
把它们绘制进去


402
00:28:40,454 --> 00:28:42,689 line:-1
现在我们可以继续并考虑如何绘制了


403
00:28:44,691 --> 00:28:48,228 line:-2
正如我们之前所看到的
我们真的希望它能与布局系统相交互


404
00:28:48,695 --> 00:28:52,699 line:-2
因此我们要假设整个整个控制
都有一个布局边界


405
00:28:53,700 --> 00:28:56,670 line:-2
因为我们希望它能重新调整尺寸
并按预期四处移动


406
00:28:57,337 --> 00:28:59,840 line:-1
如果你思考一下要如何实现


407
00:29:00,007 --> 00:29:02,643 line:-2
我们可以分别绘制
每一个带颜色的楔形


408
00:29:02,910 --> 00:29:05,312 line:-1
只要它们适合同一个布局边界即可


409
00:29:05,379 --> 00:29:09,082 line:-2
然后我们把它们组合到一起
它们就可以无缝对齐了


410
00:29:10,317 --> 00:29:12,486 line:-2
那其实意味着我们只需要
考虑一个就可以了


411
00:29:13,554 --> 00:29:16,990 line:-2
我们之前看到过这样的东西了
其实就是一些图形


412
00:29:17,057 --> 00:29:18,091 line:-1
填充了一些渐变色


413
00:29:18,892 --> 00:29:20,594 line:-1
在这个例子中 一个这样的图形


414
00:29:21,395 --> 00:29:25,265 line:-2
但我们其实不想要这个在
SwiftUI工具箱中嵌入的图形


415
00:29:25,332 --> 00:29:29,069 line:-1
但那不是问题 我们可以继续


416
00:29:29,136 --> 00:29:30,137 line:-1
并定义一个自定义图形


417
00:29:31,138 --> 00:29:34,041 line:-1
自定义图形与自定义视图很相似


418
00:29:34,508 --> 00:29:36,944 line:-1
是遵守协议的类型


419
00:29:37,411 --> 00:29:39,713 line:-2
除了 在这个例子中
我们不遵守视图协议


420
00:29:39,780 --> 00:29:41,248 line:-1
我们使用图形协议


421
00:29:42,015 --> 00:29:43,917 line:-1
形状协议有一个的要求


422
00:29:43,984 --> 00:29:45,886 line:-1
就是路径和矩形函数


423
00:29:46,386 --> 00:29:48,922 line:-1
你在这里看到的矩形是布局边界


424
00:29:49,323 --> 00:29:50,324 line:-1
或引用框架 我猜是这样


425
00:29:50,724 --> 00:29:52,426 line:-1
然后它会返回贝塞尔曲线路径


426
00:29:53,560 --> 00:29:57,064 line:-2
因此对于自定义图形来说
我们给它提供一个属性


427
00:29:57,130 --> 00:29:59,399 line:-1
即楔形描述 包含几何图形


428
00:30:00,100 --> 00:30:02,936 line:-1
此外 我们只需要创建一条空路径


429
00:30:03,003 --> 00:30:04,571 line:-2
因为我们要在它里面放东西
然后稍后再返回它


430
00:30:05,539 --> 00:30:10,177 line:-2
为了稍微简化这个过程
我还用了帮助


431
00:30:10,244 --> 00:30:14,681 line:-2
它提取了我们要绘制的图形的
一些几何图形


432
00:30:14,748 --> 00:30:16,016 line:-1
只是为了隐藏正弦和余弦


433
00:30:16,083 --> 00:30:19,386 line:-1
因为这是圆形 以及诸如此类的操作


434
00:30:19,720 --> 00:30:21,989 line:-1
但它定义了某些变量


435
00:30:22,155 --> 00:30:25,259 line:-1
我们接下来可以在这个函数中使用


436
00:30:26,727 --> 00:30:29,329 line:-1
首先我们要添加一个内弧形


437
00:30:30,264 --> 00:30:34,134 line:-2
然后在路径中添加一条线
连接内外圆形


438
00:30:35,035 --> 00:30:37,604 line:-1
然后另一个弧线 在外侧


439
00:30:38,272 --> 00:30:41,308 line:-2
最后 我们就可以告诉路径说
嘿 关闭当前子路径


440
00:30:41,542 --> 00:30:44,344 line:-1
那将会把终点和起点连接起来


441
00:30:44,745 --> 00:30:45,746 line:-1
然后我们就画好形状了


442
00:30:47,648 --> 00:30:49,516 line:-2
现在我们可以继续
并着手绘制这个图形了


443
00:30:50,017 --> 00:30:54,121 line:-2
我们可以填充渐变色
大多数情况下会这样做


444
00:30:54,788 --> 00:30:56,190 line:-1
但我们还有一件事要做


445
00:30:56,723 --> 00:30:59,626 line:-2
我们在动画中看到了
我们希望图形是动态的


446
00:31:00,327 --> 00:31:02,229 line:-1
如果我们只按原样使用图形


447
00:31:02,596 --> 00:31:05,832 line:-1
SwiftUI没办法让它动起来


448
00:31:05,899 --> 00:31:06,900 line:-1
因为它不了解足够多的类型


449
00:31:07,367 --> 00:31:10,871 line:-2
因此我们可以继续并给我们的自定义
图形添加一个额外的属性


450
00:31:10,938 --> 00:31:12,306 line:-1
叫做可动画数据


451
00:31:12,673 --> 00:31:16,610 line:-1
这会提供一个矢量 包含浮点型数字


452
00:31:16,810 --> 00:31:19,346 line:-1
是系统可以插入的矢量


453
00:31:20,013 --> 00:31:23,650 line:-2
在这个例子中 我们要把这个责任
委托给数据模型


454
00:31:23,717 --> 00:31:26,253 line:-1
因为它替我们实施这个属性


455
00:31:26,320 --> 00:31:28,856 line:-1
但其实非常简单


456
00:31:28,922 --> 00:31:32,826 line:-1
获取三个属性和楔形描述


457
00:31:32,893 --> 00:31:35,495 line:-2
然后把它们结合到一个
可以进行插入的值中


458
00:31:37,064 --> 00:31:40,501 line:-2
好的 现在我们的图形其实已完成
我们可以把它绘制出来


459
00:31:41,201 --> 00:31:44,505 line:-2
我们可以退一步思考我们如何
把这些堆砌在一起做成图表


460
00:31:45,973 --> 00:31:49,943 line:-2
我们可以看到我们可以使用渐变色
角渐变色


461
00:31:50,143 --> 00:31:51,144 line:-1
用它来填充我们的图形


462
00:31:51,812 --> 00:31:52,813 line:-1
但这只是其中一个形状


463
00:31:52,880 --> 00:31:57,050 line:-2
我们想要要八个形状
并把它们组合在一起


464
00:31:57,284 --> 00:32:02,022 line:-2
我们可以通过一个
ZStack来实现


465
00:32:02,089 --> 00:32:05,359 line:-2
类似Dave讲过的HStack和
VStack 但它把东西堆砌一起


466
00:32:05,425 --> 00:32:07,928 line:-1
深度对应空间


467
00:32:08,862 --> 00:32:12,799 line:-2
我们要创建另一个自定义视图
这一次我们的视图


468
00:32:12,866 --> 00:32:14,201 line:-1
将通过环境获取数据模型


469
00:32:14,268 --> 00:32:15,602 line:-1
我们已经在其它地方设置好了


470
00:32:16,336 --> 00:32:17,971 line:-1
我们要从创建Zstack开始


471
00:32:19,106 --> 00:32:24,044 line:-2
现在我们看到在数据模型上
它提供了一组楔形ID


472
00:32:25,512 --> 00:32:29,483 line:-2
因此我们可以在SwiftUI中
结合ForEach视图来使用它们


473
00:32:29,750 --> 00:32:34,087 line:-1
那会映像到那组ID


474
00:32:34,321 --> 00:32:37,624 line:-2
并为每一个我们想要创建的楔形
都创建一个视图


475
00:32:38,292 --> 00:32:40,327 line:-1
这个楔形视图非常简单


476
00:32:40,394 --> 00:32:45,799 line:-2
它其实只是一个陈述视图
创建自定义图形


477
00:32:45,866 --> 00:32:46,867 line:-1
并填充渐变色


478
00:32:48,468 --> 00:32:50,370 line:-1
好的 几乎要完成了


479
00:32:51,104 --> 00:32:53,440 line:-2
由于SwiftUI
对依赖关系的追踪方式


480
00:32:53,507 --> 00:32:55,876 line:-2
当我们的数据模型更新时
视图也会更新


481
00:32:55,943 --> 00:32:59,179 line:-2
因为Zstack
处理插入和移除转换


482
00:32:59,346 --> 00:33:01,949 line:-1
它们会干净利落地淡入和淡出


483
00:33:02,216 --> 00:33:04,818 line:-1
这对于这样一个app来说非常好


484
00:33:04,885 --> 00:33:06,854 line:-1
但我们还要做一些其它的操作


485
00:33:07,654 --> 00:33:10,591 line:-2
我们在动画中看到了
我们希望能在你轻触楔形时


486
00:33:10,657 --> 00:33:11,725 line:-1
删除它


487
00:33:13,126 --> 00:33:14,862 line:-2
我们可以添加一个
叫做轻触操作的功能


488
00:33:15,095 --> 00:33:17,197 line:-1
这是视图的一个事件处理器


489
00:33:17,497 --> 00:33:22,035 line:-2
它表达的是如果你轻触
视图的形状的内部 就运行闭包


490
00:33:22,302 --> 00:33:26,406 line:-2
在那种情况下
我们要使用的闭包是启动动画


491
00:33:26,473 --> 00:33:29,142 line:-2
然后请求数据模型说
嘿 移除这个楔形ID


492
00:33:29,743 --> 00:33:31,712 line:-2
一旦我们完成
我们就可以轻触楔形了


493
00:33:33,013 --> 00:33:34,982 line:-1
现在我还要在这里做最后一个操作


494
00:33:35,182 --> 00:33:38,519 line:-1
我说过默认转换是淡入淡出效果


495
00:33:38,785 --> 00:33:40,954 line:-2
这对于许多东西来说都很不错
但在我们的例子中


496
00:33:41,021 --> 00:33:44,725 line:-2
我们想要实现更有趣的效果
我们要让楔形朝中心按比例缩小


497
00:33:44,791 --> 00:33:45,893 line:-1
并淡出它们


498
00:33:46,627 --> 00:33:49,796 line:-2
我们可以通过添加一个叫做
scaleAndFade的自定义转换实现


499
00:33:50,364 --> 00:33:52,466 line:-1
这是需要我们自己创建的东西


500
00:33:53,767 --> 00:33:56,837 line:-1
好的 思考一下这个转换是什么效果


501
00:33:57,337 --> 00:34:01,108 line:-2
我们希望当添加视图时
我们希望它们从缩小的比例开始


502
00:34:01,175 --> 00:34:05,012 line:-1
并淡出 以动画效果进入


503
00:34:05,412 --> 00:34:06,613 line:-1
它们将进入并放大到常规状态


504
00:34:07,247 --> 00:34:08,415 line:-1
然而它们位于视图等级中


505
00:34:08,482 --> 00:34:11,784 line:-1
它们正好会坐落在那里


506
00:34:11,851 --> 00:34:13,320 line:-2
最后当移除它们时
转换效果相反


507
00:34:14,221 --> 00:34:17,324 line:-2
如果你思考一下 很明显
我们不需要定义全部那些框架


508
00:34:17,391 --> 00:34:19,493 line:-1
因为我们有动画系统


509
00:34:20,027 --> 00:34:23,463 line:-1
因此我们只需要定义结束状态


510
00:34:23,530 --> 00:34:24,531 line:-1
动画系统会替我们执行其余操作


511
00:34:25,199 --> 00:34:29,570 line:-2
但当然了 在这个例子中
实际上有一个对称转换


512
00:34:29,969 --> 00:34:31,605 line:-1
因此我们实际上有两个结束状态


513
00:34:31,672 --> 00:34:36,109 line:-1
我们设置了转换和移除状态


514
00:34:36,476 --> 00:34:39,179 line:-2
并且我们有常规状态
但其实并没有发生什么


515
00:34:40,614 --> 00:34:43,784 line:-2
那么现在我们知道要定义哪个状态
我们可以在代码中定义它们


516
00:34:44,784 --> 00:34:47,688 line:-2
在SwiftUI中我们的实现方式
是通过一个叫做视图修饰器的工具


517
00:34:48,188 --> 00:34:50,924 line:-1
现在视图修饰器有点像视图一样


518
00:34:50,991 --> 00:34:53,126 line:-1
在视图修饰器中定义了一些视图等级


519
00:34:53,460 --> 00:34:56,362 line:-1
但它是根据一些其它视图进行定义的


520
00:34:56,897 --> 00:35:00,000 line:-1
这就是它所表达的东西


521
00:35:00,567 --> 00:35:03,604 line:-2
它有主体方法
与视图有主体属性一样


522
00:35:03,971 --> 00:35:06,840 line:-2
但在这个例子中
主体方法是另一个视图的函数


523
00:35:06,907 --> 00:35:08,675 line:-1
这就是内容参数


524
00:35:09,176 --> 00:35:13,413 line:-2
在这里我们可以做的是把这个应用到
任意其它视图中并应用一些变更


525
00:35:13,747 --> 00:35:16,450 line:-1
在我们的例子中我们想要转换效果


526
00:35:16,817 --> 00:35:20,187 line:-2
我们有两个转换状态
我们为它提供一个布尔值属性


527
00:35:20,254 --> 00:35:21,588 line:-1
比如转换是活跃的吗？


528
00:35:22,189 --> 00:35:26,960 line:-2
当转换是活跃的时
我们将应用两个现有的修饰器


529
00:35:27,394 --> 00:35:31,198 line:-2
来修改即将进入的视图
使其采用转换效果


530
00:35:31,265 --> 00:35:33,734 line:-1
我们把那叫做按比例缩小


531
00:35:33,800 --> 00:35:36,770 line:-1
并且当它设置妥了之后就让它淡出


532
00:35:38,305 --> 00:35:41,408 line:-1
好的 这就是如何定义转换


533
00:35:41,475 --> 00:35:43,110 line:-1
但我们还有最后一步


534
00:35:44,444 --> 00:35:47,714 line:-2
我们现在有视图修饰器 但我们需要
为系统提供视图修饰器的两个值


535
00:35:47,781 --> 00:35:51,351 line:-1
活跃值和不活跃值


536
00:35:51,718 --> 00:35:55,889 line:-2
从而SwiftUI可以
把它们打包到一次转换中


537
00:35:56,089 --> 00:35:57,591 line:-1
然后当添加或移除时


538
00:35:57,658 --> 00:36:01,028 line:-1
选择正确的值在正确的时间应用


539
00:36:01,094 --> 00:36:02,529 line:-2
然后在动画过程中
在它们之间进行插入


540
00:36:03,864 --> 00:36:06,033 line:-1
这就是我们可以继续并使用的东西


541
00:36:06,633 --> 00:36:08,836 line:-2
完成上述一切操作之后
我们现在可以看到我们创建了什么


542
00:36:09,036 --> 00:36:10,037 line:-1
作为一个演示


543
00:36:11,538 --> 00:36:17,144 line:-2
好的 你可以下载这个app
我要运行它 但愿如此 是的


544
00:36:17,211 --> 00:36:18,412 line:-1
那么这里是窗口


545
00:36:20,047 --> 00:36:22,115 line:-1
目前是空的 因为数据模型是空的


546
00:36:22,549 --> 00:36:23,750 line:-1
但我可以添加


547
00:36:24,518 --> 00:36:26,320 line:-2
你可以看到它们正在采用
我刚创建的转换


548
00:36:26,386 --> 00:36:28,755 line:-1
它们按比例放大并淡入


549
00:36:29,289 --> 00:36:33,327 line:-1
最棒的是我们可以轻触并移除它们


550
00:36:33,627 --> 00:36:36,797 line:-2
正如你所看到的 当我从中间移除
某个楔形时 它会进行漂亮的旋转


551
00:36:36,864 --> 00:36:38,999 line:-1
这是由于我们定义形状的方式


552
00:36:39,666 --> 00:36:41,835 line:-1
然后我可以开启这里的背景动画


553
00:36:42,870 --> 00:36:46,106 line:-2
然后在背景动画上运行着
物理仿真图形


554
00:36:46,507 --> 00:36:49,910 line:-1
它随机穿行在参数空间中


555
00:36:51,411 --> 00:36:52,880 line:-1
这是个很好的小app


556
00:36:53,213 --> 00:36:55,616 line:-2
即使它是动态的
但很明显它仍然是交互式的


557
00:36:55,682 --> 00:36:58,619 line:-1
测试是正确地运行


558
00:36:59,219 --> 00:37:03,457 line:-2
有意思的是当你思考
我们是如何渲染这个时


559
00:37:03,991 --> 00:37:07,528 line:-2
SwiftUI会为出现在屏幕上的
每一个元素


560
00:37:07,594 --> 00:37:11,298 line:-2
都创建一个原生的平台视图
比如UI指示器NSView


561
00:37:11,832 --> 00:37:13,901 line:-1
因此这与按钮类似


562
00:37:14,401 --> 00:37:18,005 line:-2
一般来说 这就是我们想要的效果
因为我们大部分时候是


563
00:37:18,071 --> 00:37:20,040 line:-1
处理常规控件之类的东西


564
00:37:20,908 --> 00:37:25,045 line:-2
但对于诸如所显示的这个图形
一样的东西


565
00:37:25,546 --> 00:37:29,216 line:-2
如果你在UIKit或
AppKit中绘制了它


566
00:37:29,283 --> 00:37:32,052 line:-2
这很可能不是你会做的事
你很可能不会


567
00:37:32,119 --> 00:37:34,321 line:-2
为每一个元素都创建
一个NSView


568
00:37:34,621 --> 00:37:36,890 line:-2
原因是
一旦你开始创建那么多NSView


569
00:37:37,491 --> 00:37:39,293 line:-1
性能可能会很差


570
00:37:39,359 --> 00:37:40,827 line:-1
这并不是个问题


571
00:37:40,894 --> 00:37:43,230 line:-2
因为我们并不打算
这么用NSView


572
00:37:44,198 --> 00:37:46,466 line:-1
我们在SwiftUI中有个方案


573
00:37:47,167 --> 00:37:50,871 line:-2
就是我们可以把一切
都放到这里的ZStack中


574
00:37:51,905 --> 00:37:53,473 line:-1
放在一个绘制小组内


575
00:37:54,341 --> 00:37:56,543 line:-1
绘制小组是一种特殊的渲染方式


576
00:37:56,877 --> 00:37:58,312 line:-1
仅适用于诸如图形这样的元素


577
00:37:58,545 --> 00:38:00,814 line:-1
那么图形和文本和图片 类似这样的


578
00:38:01,348 --> 00:38:04,985 line:-2
当我们这么做之后 我们实际上
会把所有SwiftUI视图


579
00:38:05,052 --> 00:38:09,056 line:-2
扁平化到NSViewer UI视图中
并用Metal对它们进行渲染


580
00:38:09,523 --> 00:38:12,125 line:-2
因此当我开始这样做时
你可以看到它的动作完全相同


581
00:38:12,192 --> 00:38:14,695 line:-1
因为它不是行为上的变化


582
00:38:15,329 --> 00:38:18,732 line:-2
但一旦我开始增加元素的数量时
你们可以看到


583
00:38:18,799 --> 00:38:20,300 line:-1
性能变得更好了 因为…


584
00:38:28,208 --> 00:38:32,846 line:-2
这仅仅是因为只有一个视图
就是视图系统想要的视图


585
00:38:33,046 --> 00:38:39,219 line:-2
但所发生的绘制
仅适用了一次硬件加速


586
00:38:40,821 --> 00:38:43,357 line:-1
那么我想这就是全部内容了 很酷


587
00:38:55,636 --> 00:38:59,506 line:-2
好的 在本场演讲中
我们了解了一些图形修饰器


588
00:38:59,573 --> 00:39:02,543 line:-1
但我想指出其实还有更多修饰器


589
00:39:02,910 --> 00:39:06,113 line:-1
我们做了很多工作来实施


590
00:39:06,180 --> 00:39:07,681 line:-2
你能在常规的2D绘图系统中
所能找到的一切


591
00:39:08,048 --> 00:39:10,484 line:-1
正如我们所说的 它们都适用于视图


592
00:39:10,751 --> 00:39:14,354 line:-2
因此如果这个 如果你需要
本场演讲中的某些信息 请查看文档


593
00:39:15,989 --> 00:39:20,027 line:-2
我认为这真的清晰地讲明了
我们所创建的模型的功能


594
00:39:20,093 --> 00:39:26,166 line:-1
并且我们想使用这些图形


595
00:39:26,233 --> 00:39:28,902 line:-1
但是要与其余的API一起使用


596
00:39:28,969 --> 00:39:32,005 line:-1
比如布局、动画和交互


597
00:39:32,072 --> 00:39:35,776 line:-2
SwiftUI的主旨就是我们围绕
一个视图协议统一了全部区域


598
00:39:35,843 --> 00:39:40,147 line:-1
在同样的程序包中我你提供一切功能


599
00:39:40,981 --> 00:39:44,651 line:-2
我们认为这将非常强大
我们真的已经迫不及待地看到


600
00:39:44,718 --> 00:39:46,053 line:-1
你们即将把它带到哪里去


601
00:39:46,386 --> 00:39:47,387 line:-1
谢谢大家


602
00:39:54,628 --> 00:39:55,929 line:-1
我们今天还有一场演讲


603
00:39:55,996 --> 00:39:59,800 line:-2
距离开始不到一小时了
因此如果你有任何疑问


604
00:39:59,867 --> 00:40:02,135 line:-1
请参加我们的演讲 谢谢

