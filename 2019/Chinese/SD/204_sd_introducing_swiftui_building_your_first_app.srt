1
00:00:06,406 --> 00:00:09,376 line:0
（引入SwiftUI
创建你的首个App）


2
00:00:15,616 --> 00:00:16,517 line:-1
大家好


3
00:00:17,184 --> 00:00:20,320 line:-2
我是Jacob Xiao 稍后
Kyle Macomber会上台


4
00:00:20,921 --> 00:00:23,357 line:-2
我们要跟大家分享SwiftUI
我们感到非常激动


5
00:00:23,423 --> 00:00:26,627 line:-2
它是创建更好、更快的app的
一种革命性的新方式


6
00:00:28,295 --> 00:00:30,764 line:-2
我们认为了解
SwiftUI的最佳方式


7
00:00:30,831 --> 00:00:32,833 line:-1
是实际创建一个app


8
00:00:34,001 --> 00:00:36,270 line:-2
使用SwiftUI
感觉像是魔法一样


9
00:00:36,336 --> 00:00:38,639 line:-2
但为了让大家明白
我袖子里没有藏东西


10
00:00:39,206 --> 00:00:41,074 line:-1
我想带大家一起看一下整个过程


11
00:00:41,141 --> 00:00:43,644 line:-2
在SwiftUI中
从零开始创建app


12
00:00:45,412 --> 00:00:46,947 line:-1
那么我们要做哪种app呢？


13
00:00:47,614 --> 00:00:48,882 line:-1
嗯 让我来为你打好基础


14
00:00:49,616 --> 00:00:51,051 line:-1
这里有人讨厌开会吗？


15
00:00:52,052 --> 00:00:54,087 line:-1
是吗？嗯 我们也是


16
00:00:54,821 --> 00:00:57,858 line:-2
但我和Kyle发现有些东西
可以让会议变得更能忍受


17
00:00:57,925 --> 00:01:00,394 line:-2
那就是在非常漂亮、
非常精致的会议室内开会


18
00:01:01,495 --> 00:01:03,897 line:-2
因此我们列出了一个
我们所能找到的最佳会议室的列表


19
00:01:03,964 --> 00:01:06,433 line:-1
并且我们想给它做一个app


20
00:01:08,101 --> 00:01:09,069 line:-1
那么让我们开始吧


21
00:01:10,637 --> 00:01:13,674 line:-1
好的 我要从创建新项目开始


22
00:01:17,177 --> 00:01:18,478 line:-1
我们把它命名为Rooms


23
00:01:21,815 --> 00:01:23,784 line:-2
并确保勾选了
那个Use SwiftUI


24
00:01:30,090 --> 00:01:33,493 line:-2
现在Xcode已经启动了
有一个视图


25
00:01:33,694 --> 00:01:36,463 line:-2
通过这个视图我们就可以
开始创建我们的UI了


26
00:01:40,634 --> 00:01:42,436 line:-1
我们的代码在左侧


27
00:01:44,171 --> 00:01:45,606 line:-1
右侧是Canvas


28
00:01:46,874 --> 00:01:50,077 line:-2
如果你熟悉Interface Builder
或Storyboard


29
00:01:50,143 --> 00:01:51,945 line:-1
你可能会觉得这并不新鲜


30
00:01:52,012 --> 00:01:55,148 line:-2
一侧有一些代码 然后另一侧
有可见的Canvas 对吗？


31
00:01:56,283 --> 00:01:57,951 line:-1
嗯 有一个非常重要的不同点


32
00:01:58,652 --> 00:02:01,855 line:-1
对于StoryBoards来说


33
00:02:02,222 --> 00:02:04,024 line:-1
你要在使用可视化编辑器创建更好


34
00:02:04,391 --> 00:02:06,527 line:-2
还是使用代码创建UI更好
之间做出选择


35
00:02:07,394 --> 00:02:09,596 line:-2
并且如果你选择了一个
然后稍后又改变主意了


36
00:02:10,197 --> 00:02:11,598 line:-1
那么你就要重新开始


37
00:02:12,499 --> 00:02:14,501 line:-2
但对于SwiftUI来说
完全不用担心这个问题


38
00:02:15,435 --> 00:02:18,205 line:-1
现在视图定义总会是Swift代码


39
00:02:18,705 --> 00:02:21,341 line:-1
你总是可以选择直接编辑代码


40
00:02:21,708 --> 00:02:23,143 line:-1
或使用可视化编辑器


41
00:02:23,510 --> 00:02:24,811 line:-1
并且你总是可以来回切换


42
00:02:25,979 --> 00:02:27,881 line:-2
因此如果我们在Canvas中
选中了某些东西


43
00:02:28,849 --> 00:02:31,251 line:-2
那么也会在代码中反映出
你所选择的内容


44
00:02:32,152 --> 00:02:33,820 line:-1
并且如果你修改了代码


45
00:02:34,922 --> 00:02:37,024 line:-2
那么这个修改也会在Canvas中
反映出来


46
00:02:37,524 --> 00:02:38,959 line:-1
它们无缝衔接 共同发挥作用


47
00:02:40,794 --> 00:02:42,829 line:-1
那么让我具体来讲讲该如何使用它


48
00:02:43,697 --> 00:02:46,333 line:-2
Canvas给我们显示了
视图代码的预览


49
00:02:47,034 --> 00:02:49,403 line:-2
它甚至帮助我们编辑和了解
那段代码


50
00:02:50,304 --> 00:02:53,473 line:-1
Xcode通过编译真实代码


51
00:02:53,640 --> 00:02:55,509 line:-2
并运行它来生成结果
从而显示这些预览


52
00:02:56,376 --> 00:02:58,145 line:-1
但对于预览我最喜欢的事情之一是


53
00:02:58,212 --> 00:03:00,581 line:-2
它们也可以使用
SwiftUI代码来创建


54
00:03:00,981 --> 00:03:02,783 line:-1
在这种情况下 代码在这里


55
00:03:04,785 --> 00:03:07,187 line:-2
稍后 我们将了解它如何为我们
提供那么大的能力


56
00:03:07,254 --> 00:03:08,722 line:-1
来自定义预览


57
00:03:10,157 --> 00:03:12,860 line:-2
现在我们的app
将会显示一个会议室的列表


58
00:03:13,093 --> 00:03:14,695 line:-1
那么让我们为列表创建网格吧


59
00:03:16,029 --> 00:03:18,532 line:-2
我要添加这段文本的下方
添加另一段文本


60
00:03:18,799 --> 00:03:20,534 line:-1
显示每间房间的更多详情


61
00:03:21,602 --> 00:03:24,938 line:-2
我只需要把它
拖动到我的Canvas上就能添加


62
00:03:27,107 --> 00:03:30,611 line:-2
并且Xcode甚至给我显示出
当我把它放在不同位置上时会怎样


63
00:03:32,012 --> 00:03:33,313 line:-1
现在当我释放它时


64
00:03:33,380 --> 00:03:37,317 line:-2
预览会更新以显示我的新文本
但更棒的是


65
00:03:37,718 --> 00:03:40,387 line:-2
Xcode实际上编辑了我的代码
以添加那段文本


66
00:03:41,421 --> 00:03:44,324 line:-2
Xcode把这些视图
嵌入到了一个Vstack中


67
00:03:44,391 --> 00:03:45,459 line:-1
从而获得我想要的布局


68
00:03:46,493 --> 00:03:48,495 line:-1
现在Vstack或垂直堆栈


69
00:03:48,562 --> 00:03:51,031 line:-2
是SwiftUI中
常用布局元素中的一种


70
00:03:51,732 --> 00:03:53,433 line:-1
它可以让你垂直叠加视图


71
00:03:54,067 --> 00:03:56,670 line:-1
还有一个Hstack水平叠加视图


72
00:03:57,738 --> 00:03:59,039 line:-1
并且这些堆栈都是容器


73
00:03:59,473 --> 00:04:01,875 line:-2
我可以在它们里边放入
任何我想要放入的视图


74
00:04:03,844 --> 00:04:06,680 line:-2
现在我要替换Xcode
为我提供的这个占位符


75
00:04:06,747 --> 00:04:08,549 line:-1
占位符内包含关于房间的更多信息


76
00:04:09,583 --> 00:04:11,285 line:-1
我们要显示它所能容纳的人数


77
00:04:11,652 --> 00:04:13,720 line:-1
现在 让我们使用一个硬编码的值


78
00:04:15,255 --> 00:04:17,958 line:-2
接下来
让我们在文本旁边添加一张图片


79
00:04:19,426 --> 00:04:22,362 line:-2
我可以在代码中进行编辑
就像在编辑器中一样简单


80
00:04:22,696 --> 00:04:24,965 line:-2
那么让我们在Hstack中
嵌入我们的视图


81
00:04:25,465 --> 00:04:27,467 line:-1
我可以命令点击我的视图


82
00:04:28,035 --> 00:04:29,937 line:-1
并选择嵌入一个HStack


83
00:04:31,038 --> 00:04:33,173 line:-1
然后Xcode更新了代码


84
00:04:34,208 --> 00:04:36,643 line:-2
现在我可以在Vstack旁边
添加一张图片


85
00:04:37,444 --> 00:04:38,812 line:-1
稍后我们要添加一些资产


86
00:04:39,112 --> 00:04:41,582 line:-1
但现在我只使用一个SF象征图像


87
00:04:41,648 --> 00:04:42,950 line:-1
让项目运作起来


88
00:04:47,621 --> 00:04:49,623 line:-1
SF象征是iOS 13中的新东西


89
00:04:49,990 --> 00:04:51,892 line:-1
它们是Apple提供的一大批图像


90
00:04:51,959 --> 00:04:53,260 line:-1
你可以在你的app中使用


91
00:04:54,695 --> 00:04:56,964 line:-1
我们已经有了一个基本版的网格


92
00:04:57,631 --> 00:05:00,667 line:-2
现在我要使用Canvas给网格
设计一个我想要的样式


93
00:05:02,002 --> 00:05:03,604 line:-1
我可以命令点击我的堆栈


94
00:05:04,404 --> 00:05:05,439 line:-1
并选择检查


95
00:05:05,973 --> 00:05:08,275 line:-2
用于了解我可以修改
这个堆栈的哪些属性


96
00:05:09,443 --> 00:05:11,311 line:-2
我要把它的对齐方式
设为leading


97
00:05:13,280 --> 00:05:15,816 line:-1
再一次 Xcode更新了我的代码


98
00:05:15,883 --> 00:05:16,783 line:-1
从而实现那个修改


99
00:05:18,519 --> 00:05:21,488 line:-2
现在我还可以命令点击我的文本
来检查它


100
00:05:24,024 --> 00:05:25,659 line:-1
让我们把字体变小点儿


101
00:05:26,860 --> 00:05:28,128 line:-1
我要使用子标题


102
00:05:30,063 --> 00:05:32,599 line:-2
对于Xcode修改代码的一件
很棒的事情


103
00:05:32,966 --> 00:05:35,002 line:-1
是它帮助我了解SwiftUI


104
00:05:36,370 --> 00:05:39,406 line:-2
比如它在这里添加了这段代码
来修改字体


105
00:05:40,107 --> 00:05:42,109 line:-1
我们把这种方法叫做修饰器


106
00:05:42,543 --> 00:05:46,146 line:-2
它们在SwiftUI中用于
自定义视图的外观或行为


107
00:05:47,581 --> 00:05:49,816 line:-1
我要在代码中添加另一个修饰器


108
00:05:50,517 --> 00:05:51,785 line:-1
用于设置前景颜色…


109
00:05:53,053 --> 00:05:54,087 line:-1
使它变成次生色


110
00:05:58,091 --> 00:05:59,026 line:-1
好的


111
00:05:59,493 --> 00:06:01,728 line:-2
现在网格做好了
让我们把它放到列表中


112
00:06:02,796 --> 00:06:05,332 line:-1
为此 我要命令点击我的网格


113
00:06:06,333 --> 00:06:07,634 line:-1
并选择转换为列表


114
00:06:08,836 --> 00:06:12,206 line:-2
这将把我的网格打包到一个列表中
并显示它的五次迭代


115
00:06:18,712 --> 00:06:20,214 line:-1
操作起来如此简单真是太棒了


116
00:06:20,881 --> 00:06:23,650 line:-2
这些代码就是在app中
显示列表所需要的全部代码


117
00:06:23,984 --> 00:06:25,886 line:-1
不需要什么委托或数据源


118
00:06:26,153 --> 00:06:27,588 line:-1
就是列表中的视图


119
00:06:29,056 --> 00:06:30,757 line:-1
接下来让我们把它与一些数据挂钩


120
00:06:32,526 --> 00:06:33,594 line:-1
我要拖入…


121
00:06:34,695 --> 00:06:37,130 line:-2
一些资产和我之前创建的一个
模型文件


122
00:06:43,103 --> 00:06:45,672 line:-2
现在我的模型有几个信息的字段
我们要使用它们


123
00:06:46,773 --> 00:06:48,842 line:-2
并在SwiftUI中的列表中
使用这个模型


124
00:06:49,209 --> 00:06:51,178 line:-1
我只需把这个类型变成可识别即可


125
00:06:55,782 --> 00:06:58,285 line:-1
这会告诉列表有什么东西进入了


126
00:06:59,219 --> 00:07:01,722 line:-2
并且我所需要的就是一个ID属性
而我们已经有了


127
00:07:03,457 --> 00:07:05,692 line:-2
现在这个模型文件还包含一些
测试数据


128
00:07:05,759 --> 00:07:07,094 line:-1
我可以用来调试app


129
00:07:09,229 --> 00:07:10,531 line:-1
现在让我们返回到我们的视图…


130
00:07:12,399 --> 00:07:13,534 line:-1
让我们传入数据


131
00:07:14,635 --> 00:07:15,702 line:-1
我要给房间…


132
00:07:16,937 --> 00:07:17,938 line:-1
添加一个属性


133
00:07:21,575 --> 00:07:23,143 line:-1
关于预览 其中一件非常棒的事


134
00:07:23,210 --> 00:07:24,745 line:-2
就是它们可以使用
它们自己的测试数据


135
00:07:25,345 --> 00:07:27,347 line:-2
因此我只需要在这里传入
我的测试数据


136
00:07:30,784 --> 00:07:32,819 line:-1
现在你可能已经注意到


137
00:07:32,886 --> 00:07:33,854 line:-1
预览上方出现了这个横幅


138
00:07:34,888 --> 00:07:36,590 line:-1
当我对键入内容做出重大修改时


139
00:07:36,890 --> 00:07:38,926 line:-1
比如在视图中添加房间属性


140
00:07:39,426 --> 00:07:42,663 line:-2
Xcode会暂停预览
直到我已经做好重新更新的准备


141
00:07:43,463 --> 00:07:45,132 line:-1
并且我只需要点击按钮来重新更新


142
00:07:46,867 --> 00:07:48,735 line:-1
接下来让我们使用数据来驱动列表


143
00:07:49,536 --> 00:07:51,438 line:-1
我们将向列表传入房间…


144
00:07:53,240 --> 00:07:55,709 line:-1
然后我会更新文本以显示房间名称


145
00:07:57,244 --> 00:08:00,547 line:-1
我们还要在文本中使用这里的功能


146
00:08:07,120 --> 00:08:08,589 line:-1
现在我们有真实的图片


147
00:08:08,655 --> 00:08:10,691 line:-1
对于图片 让我们使用房间缩略图


148
00:08:16,864 --> 00:08:17,831 line:-1
很棒


149
00:08:25,739 --> 00:08:27,908 line:-2
你可能已经注意到
列表中所发生的微妙变更


150
00:08:27,975 --> 00:08:28,876 line:-1
当我们这样做时


151
00:08:29,343 --> 00:08:32,179 line:-2
刚开始时我们的网格高度
是标准的44点


152
00:08:33,080 --> 00:08:34,881 line:-1
但当我们做了这些很大的修改之后


153
00:08:35,315 --> 00:08:38,085 line:-2
网格自动扩展了
从而确保能容纳那些图片


154
00:08:38,418 --> 00:08:39,453 line:-1
而不需要做任何额外的工作


155
00:08:42,155 --> 00:08:43,155 line:-1
非常酷


156
00:08:45,993 --> 00:08:47,761 line:-1
现在这些图片已经在情境中了


157
00:08:48,061 --> 00:08:49,162 line:-1
它们看起来有点儿格格不入


158
00:08:49,763 --> 00:08:51,598 line:-1
因此让我们给图片添加圆角半径


159
00:08:51,665 --> 00:08:52,666 line:-1
使用另一个修饰器


160
00:08:53,800 --> 00:08:56,203 line:-1
如果你不确定有哪些修饰器可用


161
00:08:56,837 --> 00:08:59,706 line:-2
你可以从修饰器列表中浏览和筛选
就在这里 在修饰器库中


162
00:09:00,774 --> 00:09:03,944 line:-2
让我们找到圆角半径
我们只需要把它拖到图片上


163
00:09:12,619 --> 00:09:13,921 line:-1
然后我们可以修改值


164
00:09:14,388 --> 00:09:15,489 line:-1
看起来有点儿太大了


165
00:09:17,157 --> 00:09:17,991 line:-1
很棒


166
00:09:18,625 --> 00:09:20,627 line:-2
现在我们的网格和列表
看起来都很不错


167
00:09:21,228 --> 00:09:23,597 line:-1
接下来我们要做的就是能轻触网格


168
00:09:23,664 --> 00:09:24,598 line:-1
以查看更多详情


169
00:09:25,599 --> 00:09:28,735 line:-2
为此 让我们把列表打包到一个
导航视图中


170
00:09:30,404 --> 00:09:32,539 line:-1
导航视图显示一个导航栏


171
00:09:33,040 --> 00:09:34,975 line:-1
以及一个可以叠加视图的堆栈


172
00:09:36,343 --> 00:09:38,312 line:-1
让我们也设置一个导航栏标题


173
00:09:39,112 --> 00:09:41,048 line:-2
我们只需要一些文本
比如说Rooms…


174
00:09:42,282 --> 00:09:43,684 line:-1
在导航栏中显示房间


175
00:09:46,687 --> 00:09:48,922 line:-2
现在让我们设置
要叠加到这个堆栈中的网格


176
00:09:50,090 --> 00:09:53,360 line:-2
为此 我要把网格内容打包到一个
导航按钮中


177
00:09:55,629 --> 00:09:57,564 line:-1
导航按钮有一个目的地


178
00:09:58,232 --> 00:10:00,033 line:-1
是一个要叠加到堆栈中的视图


179
00:10:01,101 --> 00:10:02,769 line:-1
首先 我们要使用一些文本


180
00:10:03,070 --> 00:10:04,104 line:-1
用于显示房间名称


181
00:10:05,205 --> 00:10:07,441 line:-1
然后我们要把网格的全部内容


182
00:10:07,908 --> 00:10:09,309 line:-1
放在那个导航按钮内…


183
00:10:10,878 --> 00:10:11,778 line:-1
然后就搞定了


184
00:10:12,479 --> 00:10:14,414 line:-1
请注意我们的UI已经进行了更新


185
00:10:14,481 --> 00:10:16,250 line:-1
从而自动显示这些UI指示器


186
00:10:17,184 --> 00:10:19,820 line:-2
SwiftUI会像这样
自动处理细节


187
00:10:19,887 --> 00:10:21,955 line:-2
因此我的UI在默认情况下
看起来就很棒


188
00:10:23,957 --> 00:10:26,059 line:-2
现在让我们也检查
网格用起来是否没问题


189
00:10:26,894 --> 00:10:29,096 line:-1
我只需要点击预览中的播放按钮


190
00:10:29,563 --> 00:10:30,697 line:-1
就会把我带到实时模式中


191
00:10:31,732 --> 00:10:33,867 line:-1
此时 Xcode会编译我的代码


192
00:10:34,635 --> 00:10:35,903 line:-1
并把它发送给模拟器


193
00:10:36,136 --> 00:10:38,539 line:-1
运行它并显示全部结果


194
00:10:38,605 --> 00:10:39,673 line:-1
就在Canvas中


195
00:10:40,007 --> 00:10:41,542 line:-1
意思是我可以与视图进行交互


196
00:10:42,509 --> 00:10:45,512 line:-1
因此我可以轻触一个网格来确保


197
00:10:45,579 --> 00:10:46,780 line:-1
一切都像我期待的那样压入和取出


198
00:10:48,315 --> 00:10:49,750 line:-1
并且如果我滑动


199
00:10:50,217 --> 00:10:53,320 line:-2
你会注意到SwiftUI会为我
自动提供一种高级行为


200
00:10:53,954 --> 00:10:55,455 line:-1
我们的网格保持突显


201
00:10:55,956 --> 00:10:58,592 line:-2
随着我的滑动
它们会交互性地不再突显


202
00:10:58,659 --> 00:10:59,960 line:-1
而我们不需要做任何额外的操作


203
00:11:08,735 --> 00:11:10,037 line:-1
好的 我们已经有了列表


204
00:11:10,404 --> 00:11:11,605 line:-1
并且它已经能用了


205
00:11:12,439 --> 00:11:14,174 line:-1
但这段视图代码现在变多了


206
00:11:14,875 --> 00:11:17,344 line:-2
并且我非常希望把网格分解出来
作为它自己的视图


207
00:11:18,145 --> 00:11:20,414 line:-2
Xcode通过一个简单的操作
帮助我实现了我的愿望


208
00:11:21,248 --> 00:11:23,784 line:-1
我只需命令点击我想要的视图


209
00:11:23,851 --> 00:11:25,185 line:-1
并选择提取子视图即可


210
00:11:28,021 --> 00:11:29,156 line:-1
很神奇


211
00:11:33,293 --> 00:11:35,729 line:-1
所有的视图代码都被提取到了这里


212
00:11:36,129 --> 00:11:38,065 line:-1
我甚至可以为新视图选择名称


213
00:11:38,398 --> 00:11:39,499 line:-1
让我们叫它Room Cell


214
00:11:43,570 --> 00:11:44,571 line:-1
谢谢


215
00:11:45,806 --> 00:11:47,875 line:-1
现在让我们给房间再添加一个属性


216
00:11:49,576 --> 00:11:50,878 line:-1
我们要把它传到这里


217
00:11:54,515 --> 00:11:56,149 line:-1
这是一个很神奇的流程改进


218
00:11:56,650 --> 00:11:58,986 line:-2
通过SwiftUI
视图变得非常轻量级


219
00:11:59,052 --> 00:12:01,121 line:-1
因此你再也不用担心创建附加视图


220
00:12:01,421 --> 00:12:03,257 line:-1
来得到更好的压缩或分离逻辑了


221
00:12:05,092 --> 00:12:07,194 line:-1
好的 接下来让我们创建详情视图


222
00:12:08,362 --> 00:12:09,796 line:-1
我要创建一个新视图…


223
00:12:10,831 --> 00:12:12,399 line:-1
并确保使用SwiftUI模板


224
00:12:13,901 --> 00:12:16,136 line:-2
让我们把新视图命名为
Room Detail


225
00:12:20,240 --> 00:12:22,843 line:-2
Xcode自动为我提供了一个
新ViewStruct


226
00:12:23,343 --> 00:12:25,212 line:-1
以及要创建它的预览代码


227
00:12:26,413 --> 00:12:29,349 line:-2
因为我希望这个详情视图
显示关于房间的更多信息


228
00:12:29,950 --> 00:12:31,218 line:-1
我要为房间添加一个属性


229
00:12:33,487 --> 00:12:34,521 line:-1
正如我之前所做的那样


230
00:12:34,788 --> 00:12:38,225 line:-1
我要更新我的预览代码


231
00:12:38,292 --> 00:12:39,293 line:-2
以便从房间的测试数据中
传入一个房间


232
00:12:43,263 --> 00:12:45,132 line:-1
然后让我们创建UI


233
00:12:46,233 --> 00:12:49,603 line:-2
我们使用一张图片…
并且要显示房间的图片名称


234
00:12:53,440 --> 00:12:54,975 line:-1
好的 现在我们显示了图片


235
00:12:55,342 --> 00:12:56,977 line:-1
但它对于视图来说有点儿太大了


236
00:12:57,678 --> 00:12:59,980 line:-2
默认情况下
SwiftUI会以内容的尺寸


237
00:13:00,047 --> 00:13:01,248 line:-1
显示全部图片…


238
00:13:01,715 --> 00:13:04,484 line:-1
从而防止图片产生缩放的视觉效果


239
00:13:05,853 --> 00:13:07,020 line:-1
但对于这样的照片来说


240
00:13:07,354 --> 00:13:08,922 line:-1
我们希望能把它的尺寸变小


241
00:13:09,389 --> 00:13:11,658 line:-1
我们可以使用一个图片专用的修饰器


242
00:13:12,392 --> 00:13:13,694 line:-1
叫做Resizable来实现


243
00:13:15,128 --> 00:13:16,663 line:-1
那么我只需把它拖到视图上…


244
00:13:18,732 --> 00:13:22,202 line:-2
好的 现在它已经重新调整了尺寸
以匹配我们所拥有的尺寸


245
00:13:22,903 --> 00:13:25,873 line:-1
但我们真的希望它保持原始长宽比


246
00:13:26,540 --> 00:13:28,075 line:-1
这次我们可以通过另一个修饰器实现


247
00:13:28,876 --> 00:13:30,410 line:-1
长宽比


248
00:13:33,080 --> 00:13:36,183 line:-2
长宽比修饰器可以让我
在.fill或.fit之间选择


249
00:13:37,017 --> 00:13:41,488 line:-2
.fill扩展图片
采用它的整个框架


250
00:13:42,656 --> 00:13:44,558 line:-1
.fit确保图片匹配到框架内


251
00:13:46,927 --> 00:13:49,229 line:-1
预览让我非常简明地看到和了解


252
00:13:49,296 --> 00:13:51,098 line:-1
这些不同模式之间的不同点


253
00:13:51,798 --> 00:13:53,967 line:-2
让我们使用.fit
这样我们能看到完整图片


254
00:13:55,569 --> 00:13:56,670 line:-1
让我们返回到列表…


255
00:13:57,538 --> 00:13:59,406 line:-1
并更新网格生成新详情视图


256
00:14:01,842 --> 00:14:03,143 line:-1
我们要创建房间详情视图


257
00:14:04,378 --> 00:14:05,913 line:-1
我们要传入当前房间


258
00:14:08,415 --> 00:14:10,717 line:-1
现在我要把预览切换回实时模式


259
00:14:12,219 --> 00:14:14,254 line:-1
我可以轻触网格查看图片


260
00:14:15,556 --> 00:14:16,890 line:-1
但现在我正在这里预览


261
00:14:16,957 --> 00:14:19,626 line:-2
我可以看到
我忘记在导航栏中设置标题了


262
00:14:20,327 --> 00:14:22,196 line:-1
因此让我们返回详情视图修改一下


263
00:14:25,332 --> 00:14:26,366 line:-1
跟以前一样


264
00:14:26,667 --> 00:14:29,903 line:-1
我可以用导航栏标题来设置标题…


265
00:14:31,371 --> 00:14:33,841 line:-1
我们要传入房间名称作为标题


266
00:14:35,309 --> 00:14:36,610 line:-1
但在我之前的预览中


267
00:14:36,677 --> 00:14:37,978 line:-1
我们只看到了视图自身


268
00:14:38,445 --> 00:14:40,614 line:-2
我真的希望可以快速验证
我所做的变更


269
00:14:41,682 --> 00:14:44,751 line:-2
因为预览可以使用SwiftUI
视图所拥有的全部功能


270
00:14:45,018 --> 00:14:45,953 line:-1
我们完全可以实现


271
00:14:47,221 --> 00:14:48,355 line:-1
我可以把预览设置为…


272
00:14:48,989 --> 00:14:50,557 line:-1
位于导航视图内…


273
00:14:51,258 --> 00:14:53,160 line:-2
使用我能在其它任何地方
使用的同样的代码


274
00:14:53,861 --> 00:14:56,797 line:-1
现在视图的预览已经处于导航栏内了


275
00:15:04,438 --> 00:15:05,506 line:-1
我看到它在这儿


276
00:15:05,572 --> 00:15:08,442 line:-2
对于详情视图来说
这个大标题看起来有点儿太大了


277
00:15:09,209 --> 00:15:10,944 line:-1
因此让我们更新一下导航栏标题


278
00:15:11,778 --> 00:15:13,313 line:-1
把显示模式设置为行内显示


279
00:15:15,215 --> 00:15:16,250 line:-1
好多了


280
00:15:17,050 --> 00:15:18,852 line:-1
现在当我选择一间会议室时


281
00:15:19,186 --> 00:15:20,587 line:-1
有一件事非常重要


282
00:15:21,522 --> 00:15:22,723 line:-1
房间必须得有一张好桌子


283
00:15:23,423 --> 00:15:25,092 line:-1
我不能集中注意力听某人在讲什么


284
00:15:25,158 --> 00:15:26,727 line:-1
如果桌子的质量不好的话


285
00:15:29,096 --> 00:15:31,331 line:-1
我可以看到这间房间内有一些桌子


286
00:15:31,899 --> 00:15:33,667 line:-2
但我实际上不能很清楚地看到
它的细节


287
00:15:34,601 --> 00:15:36,036 line:-1
但当图片是.fill时


288
00:15:37,271 --> 00:15:38,438 line:-1
我就可以近距离看到它很漂亮


289
00:15:38,872 --> 00:15:40,007 line:-1
看那种木纹


290
00:15:42,242 --> 00:15:44,611 line:-2
因此我希望能在.fill
和.fit之间来回切换


291
00:15:44,878 --> 00:15:46,113 line:-1
.fill可以查看房间详情


292
00:15:46,647 --> 00:15:48,549 line:-1
.fit可以立刻了解一切


293
00:15:50,250 --> 00:15:53,020 line:-1
但我到底该如何从视图内


294
00:15:53,320 --> 00:15:54,354 line:-1
修改这个长宽比的内容模式呢？


295
00:15:55,189 --> 00:15:56,557 line:-1
嗯 要了解如何实现


296
00:15:56,823 --> 00:16:00,127 line:-2
我们一定要了解视图是如何
在SwiftUI中运作的及为什么


297
00:16:00,827 --> 00:16:03,564 line:-1
因此我要邀请Kyle上台来谈谈


298
00:16:03,997 --> 00:16:04,831 line:-1
Kyle？


299
00:16:05,365 --> 00:16:07,167 line:-1
嗯 大家好


300
00:16:07,234 --> 00:16:08,402 line:-1
视图的运作方式


301
00:16:12,773 --> 00:16:14,608 line:-2
目前大家是怎么认为
SwiftUI的呢？


302
00:16:17,177 --> 00:16:18,745 line:-1
是的 我也非常激动


303
00:16:19,847 --> 00:16:21,014 line:-1
有点儿不可思议


304
00:16:21,515 --> 00:16:23,450 line:-1
那么在我们继续讲其它内容之前


305
00:16:23,517 --> 00:16:24,751 line:-1
我们要退一步


306
00:16:25,185 --> 00:16:28,522 line:-2
谈谈视图在SwiftUI中的
运作方式以及它为什么如此运作


307
00:16:30,424 --> 00:16:32,860 line:-2
那么我们刚才谈到了
实施Room Detail视图


308
00:16:34,094 --> 00:16:38,298 line:-2
在SwiftUI中
视图是一种遵守视图协议的结构


309
00:16:38,765 --> 00:16:42,135 line:-2
而不是和UI视图一样
是一个继承自基础类的类


310
00:16:43,403 --> 00:16:46,039 line:-2
这意味着视图不会继承
任何所存储的属性


311
00:16:46,673 --> 00:16:49,243 line:-1
它分配在堆栈上并按值传递


312
00:16:50,577 --> 00:16:52,179 line:-2
Room Detail
只存储了一间房间


313
00:16:52,746 --> 00:16:54,681 line:-1
那么它是一间房间的尺寸和比重


314
00:16:55,249 --> 00:16:58,018 line:-1
没有任何额外的分配或引用计算在内


315
00:16:59,853 --> 00:17:01,989 line:-1
在幕后 SwiftUI


316
00:17:02,055 --> 00:17:03,824 line:-1
把你的视图等级坍缩到


317
00:17:04,258 --> 00:17:06,260 line:-2
一个很有效的数据结构中
用于渲染


318
00:17:07,094 --> 00:17:12,199 line:-2
藉此 我们在SwiftUI中
可任意使用小且单一目标的视图


319
00:17:12,633 --> 00:17:13,500 line:-1
并且你们也可以


320
00:17:14,601 --> 00:17:17,436 line:-2
我希望你们从最后几张幻灯片中
了解的内容是


321
00:17:17,938 --> 00:17:21,909 line:-2
SwiftUI中的视图
是令人难以置信的轻量级视图


322
00:17:22,776 --> 00:17:23,877 line:-1
正如Jacob所说的那样


323
00:17:23,944 --> 00:17:27,381 line:-2
你永远不要犹豫
重构SwiftUI代码


324
00:17:27,881 --> 00:17:31,518 line:-1
因为提取子视图事实上不需要花时间


325
00:17:33,687 --> 00:17:35,289 line:-1
是的 你可以为此而鼓掌 非常棒


326
00:17:35,355 --> 00:17:36,423 line:-1
（一个视图定义了一个UI）


327
00:17:39,193 --> 00:17:43,397 line:-2
那么SwiftUI中的视图
和传统UI框架中的视图


328
00:17:43,463 --> 00:17:44,965 line:-1
实现的是同样的主要功能


329
00:17:45,699 --> 00:17:47,568 line:-1
它们定义一个UI


330
00:17:49,503 --> 00:17:52,039 line:-1
视图协议 只有一个要求：


331
00:17:52,439 --> 00:17:53,407 line:-1
一个body属性


332
00:17:53,774 --> 00:17:54,975 line:-1
它自身就是一个视图


333
00:17:56,743 --> 00:18:00,080 line:-2
在SwiftUI中 通过把小视图
组合到一起来创建大视图


334
00:18:00,681 --> 00:18:03,684 line:-2
我们创建了Room Detail
通过组合图片、


335
00:18:04,251 --> 00:18:06,186 line:-1
拥有原生分辨率的图片的视图…


336
00:18:07,654 --> 00:18:11,758 line:-2
可调整大小
可以让它适应任何一种规格


337
00:18:12,659 --> 00:18:16,196 line:-2
以及长宽比 一个能恰当地缩放
它的子视图的视图


338
00:18:17,965 --> 00:18:19,733 line:-1
对你所创建的任意视图的渲染


339
00:18:20,033 --> 00:18:21,468 line:-1
只是渲染它的主体


340
00:18:23,804 --> 00:18:26,840 line:-2
因此如果你设置了分割点
并且调试器停在那儿了


341
00:18:28,876 --> 00:18:30,344 line:-1
渲染的意思就是框架决定


342
00:18:30,410 --> 00:18:32,212 line:-1
它需要渲染视图


343
00:18:34,915 --> 00:18:35,949 line:-1
Tada


344
00:18:37,918 --> 00:18:39,753 line:-1
好的 那么视图—


345
00:18:40,087 --> 00:18:43,257 line:-1
框架知道何时取回视图的新渲染


346
00:18:43,624 --> 00:18:47,728 line:-2
因为除了定义UI之外
在SwiftUI中


347
00:18:47,794 --> 00:18:49,429 line:-1
视图还决定自己的依赖关系


348
00:18:49,496 --> 00:18:50,731 line:-1
（视图决定自己的依赖关系）


349
00:18:51,331 --> 00:18:54,301 line:-2
让我们扩展Room Detail
允许用户…


350
00:18:54,601 --> 00:18:56,770 line:-1
在适应…


351
00:18:58,338 --> 00:19:00,073 line:-1
和填充可用空间之间进行切换


352
00:19:00,407 --> 00:19:02,609 line:-2
从而可以让Jacob
看到漂亮的木纹


353
00:19:04,344 --> 00:19:07,047 line:-2
因此我们所需要的第一个东西
就是属性


354
00:19:07,381 --> 00:19:08,482 line:-1
但它是个特别的属性


355
00:19:09,082 --> 00:19:12,319 line:-2
它是一个状态属性
它表明图片是否被放大


356
00:19:13,520 --> 00:19:16,390 line:-2
当SwiftUI看到一个
带有状态变量的视图时


357
00:19:16,456 --> 00:19:19,359 line:-2
它会以视图的名义
为那个变量分配存储空间


358
00:19:19,826 --> 00:19:22,996 line:-2
在这个Memory图表中
绿色部分是你的app的内存


359
00:19:23,530 --> 00:19:25,866 line:-1
紫色是SwiftUI所管理的内存


360
00:19:26,266 --> 00:19:29,837 line:-2
那么放大变量的这个值
把你包含在内


361
00:19:33,173 --> 00:19:36,677 line:-2
因此如果根据那个变量
决定填充或适应


362
00:19:38,212 --> 00:19:41,148 line:-2
那么当它放大时我们会得到一个
像这样渲染的视图


363
00:19:42,616 --> 00:19:43,650 line:-1
当它不放大时就像这样子


364
00:19:45,853 --> 00:19:47,654 line:-2
那么现在我们所需要的
就是一个tapAction…


365
00:19:50,157 --> 00:19:52,559 line:-1
用于在两种状态之间来回切换


366
00:19:52,860 --> 00:19:55,562 line:-2
那么如果轻触
图片将被放大用于填充…


367
00:19:57,631 --> 00:19:58,932 line:-1
并被缩小用于适应


368
00:20:08,842 --> 00:20:13,580 line:-2
那么当我们轻触这里
到底会发生什么呢？


369
00:20:15,282 --> 00:20:18,151 line:-1
嗯 状态变量的一个特别属性


370
00:20:18,552 --> 00:20:21,188 line:-2
就是SwiftUI
可以观察何时被读写


371
00:20:21,788 --> 00:20:25,158 line:-2
因为SwiftUI知道这里的那个
Zoom 它是从body中读取的


372
00:20:26,026 --> 00:20:28,095 line:-1
它知道视图的渲染取决于它


373
00:20:28,595 --> 00:20:29,630 line:-1
意思就是…


374
00:20:30,864 --> 00:20:32,165 line:-1
当变量改变时


375
00:20:32,599 --> 00:20:34,768 line:-1
框架会再次请求body…


376
00:20:35,435 --> 00:20:36,737 line:-1
使用新状态值


377
00:20:38,639 --> 00:20:40,574 line:-1
因此这一次它会刷新渲染


378
00:20:41,108 --> 00:20:42,409 line:-1
以不同的内容模式


379
00:20:44,311 --> 00:20:45,579 line:-1
（事实在哪里？）


380
00:20:46,113 --> 00:20:48,682 line:-1
那么传统UI框架不区分


381
00:20:48,749 --> 00:20:51,351 line:-1
状态变量和普通的旧属性


382
00:20:51,785 --> 00:20:54,988 line:-1
但我发现这个区别非常清楚


383
00:20:57,357 --> 00:21:01,929 line:-2
在SwiftUI中
UI可能会处于的每个可能的状态


384
00:21:02,529 --> 00:21:04,131 line:-1
滚动视图的偏移


385
00:21:04,898 --> 00:21:06,133 line:-1
按钮的不突显


386
00:21:07,568 --> 00:21:09,336 line:-1
导航堆栈的内容


387
00:21:10,170 --> 00:21:12,606 line:-1
它衍生自权威数据


388
00:21:13,073 --> 00:21:15,375 line:-1
通常叫做事实来源


389
00:21:16,276 --> 00:21:19,046 line:-1
状态变量和模型共同


390
00:21:19,346 --> 00:21:21,014 line:-1
构成整个app的


391
00:21:21,281 --> 00:21:22,616 line:-1
事实来源


392
00:21:24,351 --> 00:21:26,653 line:-1
刚才我提到过对长宽比的调用


393
00:21:26,720 --> 00:21:27,588 line:-1
会生成视图


394
00:21:28,789 --> 00:21:30,457 line:-1
它的定义看起来类似这样


395
00:21:31,592 --> 00:21:34,728 line:-2
内容模式是一个普通的
旧Swift属性


396
00:21:36,496 --> 00:21:38,699 line:-1
你可以简洁地把每一个属性归类为


397
00:21:39,166 --> 00:21:42,336 line:-1
一个事实来源或一个衍生值


398
00:21:43,537 --> 00:21:46,240 line:-1
Zoom状态变量是一个事实来源


399
00:21:47,808 --> 00:21:50,310 line:-2
Content Mode属性
就衍生自它


400
00:21:52,079 --> 00:21:56,083 line:-2
回调SwiftUI
可以观察何时读写变量


401
00:21:56,483 --> 00:21:57,784 line:-1
那么当其中一个发生变更时


402
00:21:57,851 --> 00:21:59,586 line:-1
它就知道该刷新哪个渲染


403
00:22:00,854 --> 00:22:02,389 line:-1
框架通过请求新body


404
00:22:02,689 --> 00:22:04,224 line:-1
刷新渲染


405
00:22:04,892 --> 00:22:07,761 line:-1
重新生成一个新的长宽比视图


406
00:22:08,328 --> 00:22:11,565 line:-2
从而覆盖Content Mode
以及所存储的其它属性


407
00:22:13,367 --> 00:22:17,004 line:-2
这就是作用机制
SwiftUI中的全部衍生值


408
00:22:17,070 --> 00:22:18,105 line:-1
都保持是最新值


409
00:22:20,107 --> 00:22:23,544 line:-2
那么我们已经了解了
如何声明事实来源


410
00:22:23,977 --> 00:22:25,078 line:-1
通过状态变量


411
00:22:26,513 --> 00:22:29,550 line:-2
并且那个非常普通的旧属性
是一个衍生值


412
00:22:30,417 --> 00:22:32,352 line:-1
我们就不在这里举例说明了


413
00:22:32,819 --> 00:22:34,788 line:-2
但Swift为你提供了一个
叫做Binding的工具


414
00:22:36,056 --> 00:22:38,458 line:-1
它是一个传递读写衍生值的好工具


415
00:22:39,293 --> 00:22:41,061 line:-1
从技术角度来说任何常量


416
00:22:41,128 --> 00:22:44,164 line:-1
都可以作为完美的只读事实来源


417
00:22:44,231 --> 00:22:46,600 line:-2
正如我们在测试数据驱动预览时
所看到的那样


418
00:22:47,668 --> 00:22:49,203 line:-1
我还要指出另外一点


419
00:22:49,269 --> 00:22:52,973 line:-1
我刚才提到状态变量


420
00:22:53,040 --> 00:22:55,976 line:-2
和模型共同构成了
整个app的事实来源


421
00:22:56,610 --> 00:22:58,846 line:-1
那么我们有这个可绑定的对象协议


422
00:22:58,912 --> 00:23:00,180 line:-1
Jacob刚才用过了


423
00:23:00,247 --> 00:23:04,017 line:-2
从而告诉SwiftUI
要如何观察模型中所发生的变更


424
00:23:06,420 --> 00:23:08,255 line:-1
我们讲的可能很快


425
00:23:08,322 --> 00:23:11,725 line:-1
本周稍后会有一整场演讲


426
00:23:11,792 --> 00:23:15,629 line:-1
专门讲发展对不同流程基元的直觉


427
00:23:17,097 --> 00:23:18,065 line:-1
（管理依赖关系很难）


428
00:23:18,131 --> 00:23:20,467 line:-1
好的 让我们退回来接着讲


429
00:23:22,302 --> 00:23:23,470 line:-1
这与你在传统框架中


430
00:23:23,904 --> 00:23:26,306 line:-1
所做的非常不一样


431
00:23:26,773 --> 00:23:28,208 line:-1
传统框架中的视图自身非常固执


432
00:23:28,475 --> 00:23:30,444 line:-2
你最大努力地尝试
让它们保持是最新视图


433
00:23:32,746 --> 00:23:33,947 line:-1
你可能没从这方面思考过


434
00:23:34,214 --> 00:23:36,483 line:-1
当你使用传统UI框架时


435
00:23:36,917 --> 00:23:39,686 line:-1
但每一次视图读取数据时


436
00:23:40,120 --> 00:23:42,022 line:-1
它都会创建一个隐性依赖关系


437
00:23:42,789 --> 00:23:45,092 line:-2
它是一个依赖关系
因为当那个数据发生变更时


438
00:23:45,792 --> 00:23:48,529 line:-1
视图需要更新从而反映新值


439
00:23:49,096 --> 00:23:50,330 line:-1
如果它失败了


440
00:23:51,265 --> 00:23:52,199 line:-1
就说明有错误


441
00:23:53,267 --> 00:23:56,270 line:-2
SwiftUI会以你的名义
自动管理依赖关系


442
00:23:57,337 --> 00:23:59,840 line:-1
通过重新计算恰当的衍生值


443
00:23:59,907 --> 00:24:01,308 line:-1
因此再也不会出现那种情况


444
00:24:08,682 --> 00:24:13,554 line:-2
当然对于app中的单一依赖关系
我们不是只管理一次


445
00:24:14,121 --> 00:24:15,389 line:-1
我们的app很大


446
00:24:16,223 --> 00:24:17,291 line:-1
非常复杂


447
00:24:18,325 --> 00:24:20,360 line:-1
当提到你要在脑子里记住多少东西


448
00:24:20,794 --> 00:24:22,763 line:-1
以及犯错是多么容易


449
00:24:23,330 --> 00:24:25,699 line:-2
提到我们目前
手动管理依赖关系的方式


450
00:24:26,099 --> 00:24:27,034 line:-1
那非常困难


451
00:24:27,768 --> 00:24:29,036 line:-1
尽管我已经做了最大的努力


452
00:24:29,469 --> 00:24:33,173 line:-2
我所发布的每个app的每次更新
仍然存在UI错误


453
00:24:34,107 --> 00:24:36,844 line:-2
这些行上的每一个项
都是一个依赖关系


454
00:24:38,679 --> 00:24:39,780 line:-1
而这只是个开始


455
00:24:42,115 --> 00:24:45,986 line:-2
我觉得对于管理视图的复杂性来说
最困难的事


456
00:24:46,720 --> 00:24:50,290 line:-2
就是处理所有不同回调函数
可能被调用的顺序


457
00:24:50,691 --> 00:24:54,394 line:-2
这是一个老版
Room Detail视图


458
00:24:54,661 --> 00:24:56,563 line:-1
它是通过UIKit实施的


459
00:24:58,565 --> 00:25:01,201 line:-2
它与目前我们所看到的那个视图
拥有同样的功能


460
00:25:01,535 --> 00:25:02,536 line:-1
但它比那个还多一个功能


461
00:25:04,872 --> 00:25:05,973 line:-1
有时


462
00:25:06,306 --> 00:25:08,375 line:-1
当我们放大会议室图片时


463
00:25:08,876 --> 00:25:11,345 line:-1
桌子上的木纹太模糊了


464
00:25:12,412 --> 00:25:15,349 line:-1
因此我们决定添加一个特殊功能


465
00:25:15,749 --> 00:25:17,684 line:-1
使用神经网络和机器学习


466
00:25:18,185 --> 00:25:21,221 line:-1
因此我们可以在轻触时增强图片


467
00:25:21,588 --> 00:25:22,823 line:-1
在后台线程上


468
00:25:23,857 --> 00:25:26,793 line:-1
选择正确的会议室


469
00:25:29,630 --> 00:25:30,697 line:-1
好的 是的


470
00:25:31,365 --> 00:25:32,499 line:-1
过度设计了 是吗？


471
00:25:33,634 --> 00:25:35,435 line:-2
那么对于这个功能来说
只有一个问题


472
00:25:36,236 --> 00:25:37,504 line:-1
就是它有一个错误


473
00:25:37,571 --> 00:25:39,873 line:-2
我们得到了一份
关于偏离活动指示器的报告


474
00:25:40,174 --> 00:25:41,208 line:-1
它从不停止运转


475
00:25:42,643 --> 00:25:43,644 line:-1
这是怎么发生的呢？


476
00:25:44,111 --> 00:25:47,814 line:-1
嗯 原来如果事件按特定顺序发生…


477
00:25:50,584 --> 00:25:52,386 line:-1
我们忘记清理那个活动指示器了


478
00:25:53,020 --> 00:25:55,355 line:-1
在这种情况下 如果用户执行放大


479
00:25:55,422 --> 00:25:59,026 line:-1
并轻触增强按钮 它会消失


480
00:25:59,426 --> 00:26:01,228 line:-1
活动指示器会卡住


481
00:26:02,129 --> 00:26:05,732 line:-1
我们很容易犯这种错误


482
00:26:06,033 --> 00:26:09,403 line:-2
当你直接从事件处理器回调中
修改子视图时


483
00:26:09,803 --> 00:26:11,972 line:-1
而不是更新事实来源


484
00:26:12,840 --> 00:26:15,275 line:-1
而不是更新事实来源并从中衍生UI


485
00:26:17,644 --> 00:26:20,681 line:-2
我们犯这种错误是因为
当我们编写这段代码时


486
00:26:20,747 --> 00:26:22,950 line:-1
很容易只考虑到主逻辑


487
00:26:23,851 --> 00:26:25,185 line:-1
就是那些很容易记起来的东西


488
00:26:26,720 --> 00:26:29,523 line:-2
并且很容易忽略
很难记起来的其它东西


489
00:26:30,123 --> 00:26:33,327 line:-1
问题是随着视图要响应的


490
00:26:33,660 --> 00:26:36,730 line:-1
可能的事件的数量的增加


491
00:26:37,097 --> 00:26:39,299 line:-1
会暴露更多容易忽略的东西


492
00:26:40,868 --> 00:26:42,903 line:-1
假如你拥有全部四个事件


493
00:26:43,770 --> 00:26:45,572 line:-1
有多少可能存在的不同的顺序呢…


494
00:26:45,639 --> 00:26:46,773 line:-1
可能的传入顺序？


495
00:26:47,908 --> 00:26:50,644 line:-1
嗯 实际上有24种顺序


496
00:26:50,911 --> 00:26:52,212 line:-1
对于任意四个事件来说


497
00:26:52,946 --> 00:26:54,882 line:-1
实际情况更糟糕


498
00:26:55,249 --> 00:26:57,985 line:-1
因为每个事件可以出现一次以上


499
00:26:58,519 --> 00:27:01,188 line:-1
比如说用户多次轻触增强按钮


500
00:27:02,456 --> 00:27:04,825 line:-1
你们应该很熟悉这种情况


501
00:27:04,892 --> 00:27:07,694 line:-2
如果你们曾经实施过
可中断的动画的话


502
00:27:08,028 --> 00:27:10,964 line:-2
完成处理器可能会在一个
非常不期待的时间进入


503
00:27:12,366 --> 00:27:16,970 line:-2
如果我能告诉五年前的自己
关于我工作的任何事


504
00:27:17,037 --> 00:27:20,574 line:-1
那可能是UI编程非常难


505
00:27:20,941 --> 00:27:23,177 line:-1
就和无日志并发一样困难


506
00:27:25,045 --> 00:27:27,347 line:-1
你们中有多少人写过多线程代码？


507
00:27:28,448 --> 00:27:30,384 line:-1
很可能有2000人 是的


508
00:27:30,817 --> 00:27:32,719 line:-1
那么没有人认为它简单


509
00:27:33,287 --> 00:27:35,622 line:-1
我花了好几个月的时间来解决


510
00:27:35,689 --> 00:27:37,691 line:-1
某些多线程代码中的所有错误


511
00:27:37,758 --> 00:27:40,561 line:-2
即便这样我仍然不能
100%保证它的正确性


512
00:27:42,129 --> 00:27:45,065 line:-1
许多UI代码实际上就像那样


513
00:27:45,666 --> 00:27:47,301 line:-1
只不过不会发生崩溃


514
00:27:47,968 --> 00:27:49,369 line:-1
而是视图会出现在错误的地方


515
00:27:49,703 --> 00:27:50,737 line:-1
或者丢失


516
00:27:51,305 --> 00:27:54,575 line:-1
这是因为竞争条件和UI不一致性


517
00:27:54,842 --> 00:27:57,110 line:-1
分担了同样潜在的复杂性来源


518
00:27:58,712 --> 00:28:00,447 line:-1
这些容易忽略的顺序


519
00:28:02,149 --> 00:28:03,750 line:-1
我们大家都会使用的许多视图的


520
00:28:04,251 --> 00:28:06,587 line:-1
事件远远多于四个


521
00:28:08,355 --> 00:28:10,858 line:-1
你知道的 比如模型通知、


522
00:28:11,158 --> 00:28:13,026 line:-1
委托方法、目标操作、


523
00:28:13,493 --> 00:28:15,529 line:-1
完成处理器 这些都是事件


524
00:28:16,230 --> 00:28:21,034 line:-2
有12个事件的视图所产生的
可能的顺序大概是12的阶乘


525
00:28:21,568 --> 00:28:22,936 line:-1
几乎是五亿种


526
00:28:25,339 --> 00:28:27,908 line:-2
我们都使用过
拥有12个事件处理器的视图


527
00:28:29,309 --> 00:28:32,012 line:-1
那时你只能在你脑子里装太多东西


528
00:28:35,048 --> 00:28:38,852 line:-2
是的 这条虚线是
app中的一个视图


529
00:28:40,854 --> 00:28:43,423 line:-2
你们认为这两个点之间
有什么区别呢？


530
00:28:45,492 --> 00:28:46,627 line:-1
有人发言吗？


531
00:28:47,528 --> 00:28:48,962 line:-1
那些是报错 是的


532
00:28:49,963 --> 00:28:51,798 line:-1
随着新功能的添加


533
00:28:51,865 --> 00:28:54,735 line:-2
我们需要考虑到的
可能的顺序的数量


534
00:28:55,602 --> 00:28:57,337 line:-1
也会呈指数方式增长


535
00:28:57,404 --> 00:28:58,839 line:-1
如果我们忽略了其中一个


536
00:29:00,140 --> 00:29:00,974 line:-1
结果一样


537
00:29:01,275 --> 00:29:02,376 line:-1
不可避免


538
00:29:04,311 --> 00:29:07,147 line:-1
如今当你编程时


539
00:29:07,781 --> 00:29:11,485 line:-1
那么我想你们中有许多人凭直觉


540
00:29:11,552 --> 00:29:12,519 line:-2
找到了UIKit或AppKit中
处理这种复杂性的方式


541
00:29:12,819 --> 00:29:16,523 line:-2
就是把所有视图更新代码
收集到一个单一的方法中


542
00:29:17,457 --> 00:29:19,159 line:-1
然后从这些事件处理器回调中


543
00:29:19,426 --> 00:29:20,761 line:-1
调用那个方法


544
00:29:21,428 --> 00:29:24,631 line:-1
这可以很好地帮助你回避这种复杂性


545
00:29:25,332 --> 00:29:28,602 line:-2
SwiftUI从这个最佳实践中
受到了很多启发


546
00:29:29,803 --> 00:29:33,774 line:-1
如今当你以这种方式在UI中实施时


547
00:29:33,841 --> 00:29:35,909 line:-1
你需要考虑许多棘手的情况


548
00:29:36,009 --> 00:29:38,345 line:-1
比如从视图等级中添加或移除子视图


549
00:29:38,645 --> 00:29:40,480 line:-1
或堆叠和溢放导航堆栈


550
00:29:40,881 --> 00:29:42,482 line:-1
或更新表视图


551
00:29:42,916 --> 00:29:45,452 line:-1
我从来没自己独立


552
00:29:45,519 --> 00:29:46,453 line:-1
解决过这些情况


553
00:29:47,254 --> 00:29:50,691 line:-2
嗯 我们已经花了很多时间
做了很多工作


554
00:29:50,958 --> 00:29:54,595 line:-2
并且我们也以你的名义把这个
最佳范例编译到了SwiftUI中


555
00:29:55,195 --> 00:29:58,732 line:-1
视图协议只有一个要求：body


556
00:29:58,799 --> 00:30:01,768 line:-1
框架要调用一个单入口点


557
00:30:02,236 --> 00:30:07,241 line:-1
意思是只能以一种顺序调用


558
00:30:17,584 --> 00:30:20,554 line:-1
由于这种为发生变更的UI部分


559
00:30:20,621 --> 00:30:22,189 line:-1
简单地提取新视图的模式


560
00:30:23,123 --> 00:30:25,759 line:-1
SwiftUI释放了你的大脑


561
00:30:26,593 --> 00:30:29,129 line:-1
从根本上消除了UI不一致性


562
00:30:30,597 --> 00:30:31,598 line:-1
好的


563
00:30:31,965 --> 00:30:34,568 line:-2
让我们返回到演示中
并完成Room Detail视图


564
00:30:35,068 --> 00:30:35,969 line:-1
Jacob？


565
00:30:41,808 --> 00:30:43,143 line:-1
好的 让我们完成这个app


566
00:30:44,411 --> 00:30:46,747 line:-2
现在我们了解了
如何设置视图使其放大


567
00:30:47,981 --> 00:30:49,183 line:-1
我们添加了一个状态属性


568
00:30:52,219 --> 00:30:55,055 line:-2
并且我们把它命名为Zoomed
并默认把它设为假


569
00:30:56,523 --> 00:30:58,125 line:-1
然后在长宽比中…


570
00:30:59,092 --> 00:31:00,327 line:-1
我们要恰当地使用Zoomed


571
00:31:00,861 --> 00:31:03,897 line:-2
在填充（当放大时）
和适应（相反）之间变换


572
00:31:05,265 --> 00:31:09,303 line:-2
最后我们要添加tapAction
来切换那个Zoomed属性


573
00:31:12,940 --> 00:31:14,708 line:-2
现在让我们在实时模式中
试着运行一下


574
00:31:19,346 --> 00:31:21,582 line:-2
太棒了 我们可以在这两种
不同的模式之间切换


575
00:31:22,983 --> 00:31:24,418 line:-1
但还缺点儿什么东西


576
00:31:24,885 --> 00:31:25,953 line:-1
有人看出来了吗？


577
00:31:27,788 --> 00:31:29,289 line:-1
是的 它需要一个动画


578
00:31:30,824 --> 00:31:33,293 line:-2
对于SwiftUI来说
添加动画非常简单


579
00:31:34,528 --> 00:31:37,297 line:-2
我只需把变更打包到一个
对WithAnimation的调用中即可


580
00:31:42,102 --> 00:31:43,837 line:-1
现在变更有动画效果了


581
00:31:51,111 --> 00:31:52,179 line:-1
不仅如此


582
00:31:52,246 --> 00:31:54,348 line:-1
动画是完全交互式并可中断的


583
00:31:54,781 --> 00:31:56,717 line:-2
因此我总是可以
在不同的状态之间变换


584
00:31:57,251 --> 00:31:58,819 line:-1
并且它总是会显示在正确的位置


585
00:32:01,889 --> 00:32:02,890 line:-1
是的 很棒


586
00:32:06,159 --> 00:32:08,128 line:-1
接下来我要添加增强按钮


587
00:32:08,695 --> 00:32:11,098 line:-1
但事实是Kyle培训模型的方式


588
00:32:11,164 --> 00:32:13,200 line:-1
只能用于他所展示的那一张图片


589
00:32:15,402 --> 00:32:16,970 line:-1
因此我要添加一些更有用的东西


590
00:32:17,938 --> 00:32:19,540 line:-1
我们有一个伦敦的同事


591
00:32:19,907 --> 00:32:22,242 line:-2
我们经常想要了解哪间房间内
有视频会议


592
00:32:23,210 --> 00:32:25,846 line:-2
因此让我在详情视图顶部
为它添加一个图标


593
00:32:27,214 --> 00:32:30,717 line:-2
我可以用Zstack
显示堆叠的视图


594
00:32:34,521 --> 00:32:36,957 line:-2
我要把当前图片放到
那个Zstack内


595
00:32:37,991 --> 00:32:39,660 line:-1
然后我要添加另一张图片…


596
00:32:40,460 --> 00:32:42,696 line:-2
显示一个图标
表示房间是否有视频会议


597
00:32:44,598 --> 00:32:45,866 line:-1
我就用一张象征图像吧…


598
00:32:47,601 --> 00:32:48,936 line:-1
然后我们使用Video.fill


599
00:32:51,538 --> 00:32:54,074 line:-1
好的 这里有图标了 但它有点儿小


600
00:32:55,209 --> 00:32:58,312 line:-2
但象征图像会自动使用当前字号
调整自己的尺寸


601
00:32:58,679 --> 00:33:01,582 line:-2
因此我可以非常方便地通过修饰器
把它修改为一个较大好的字体


602
00:33:03,383 --> 00:33:06,220 line:-2
我们把它拖动到代码中
并把它应用到图片中


603
00:33:07,287 --> 00:33:08,388 line:-1
标题看起来不错


604
00:33:09,223 --> 00:33:10,490 line:-1
现在我们有大图片了


605
00:33:11,425 --> 00:33:13,327 line:-1
接下来我希望在左上方显示这张图片


606
00:33:13,994 --> 00:33:15,629 line:-2
让我们把Zstack的
对齐方式设为…


607
00:33:17,564 --> 00:33:18,665 line:-1
topLeading


608
00:33:20,634 --> 00:33:22,636 line:-1
好的 接下来让我们添加一些内边距


609
00:33:22,703 --> 00:33:24,438 line:-1
从而避开这个边界


610
00:33:25,272 --> 00:33:27,074 line:-1
再一次 我们可以使用修饰器来实现


611
00:33:28,475 --> 00:33:30,310 line:-1
我们只需把它拖动到系统图片上即可


612
00:33:31,979 --> 00:33:34,481 line:-2
看起来All Edges
是一个不错的选择


613
00:33:35,649 --> 00:33:36,850 line:-1
好的 很接近了


614
00:33:37,251 --> 00:33:40,654 line:-2
但我真的很希望让这个图标
一直显示在视图区域的顶部


615
00:33:42,055 --> 00:33:44,825 line:-2
我们可以通过把房间图片
放到一个灵活性框架中


616
00:33:44,892 --> 00:33:46,193 line:-1
实现让视频图标在那里显示


617
00:33:47,127 --> 00:33:49,263 line:-1
框架会伸展从而填充整个屏幕


618
00:33:50,063 --> 00:33:51,298 line:-1
当它有空余空间时


619
00:33:51,365 --> 00:33:53,800 line:-1
它会居中显示它的内容


620
00:33:54,735 --> 00:33:57,171 line:-2
这意味着房间图片
仍会在正确的位置显示


621
00:33:58,205 --> 00:34:00,741 line:-1
那么我要向图片中添加灵活性框架


622
00:34:03,177 --> 00:34:07,214 line:-2
我们要使用最小宽度为零
且最大宽度为无限大


623
00:34:08,849 --> 00:34:10,516 line:-1
高度也一样


624
00:34:16,190 --> 00:34:17,123 line:-1
好了


625
00:34:17,858 --> 00:34:20,860 line:-2
如果你想了解关于
SwiftUI中的布局


626
00:34:21,128 --> 00:34:23,362 line:-2
请查看SwiftUI演讲中的
创建自定义视图


627
00:34:25,165 --> 00:34:26,266 line:-1
现在我们有图标了


628
00:34:26,766 --> 00:34:29,603 line:-2
但我们只希望
当房间有视频会议时显示它


629
00:34:30,137 --> 00:34:31,205 line:-1
那么我们该如何做呢？


630
00:34:32,105 --> 00:34:33,873 line:-1
嗯 我们要用一个陈述性语法


631
00:34:34,074 --> 00:34:35,108 line:-1
非常简单


632
00:34:35,576 --> 00:34:36,743 line:-1
我们只需要使用一个if语句


633
00:34:37,610 --> 00:34:39,545 line:-1
那么我要添加一个if语句并检查


634
00:34:40,013 --> 00:34:41,348 line:-1
房间是否有视频会议


635
00:34:42,315 --> 00:34:44,284 line:-1
只有当它为真时才会显示图片


636
00:34:46,652 --> 00:34:48,655 line:-1
现在我们可以检查它是否是通过


637
00:34:48,722 --> 00:34:52,059 line:-2
修改没有视频会议的房间的
预览数据实现的


638
00:34:52,559 --> 00:34:53,594 line:-1
那很不错


639
00:34:54,127 --> 00:34:56,263 line:-1
但如果我们可以同时设置预览


640
00:34:56,330 --> 00:34:58,632 line:-1
来显示视频的多个版本更好


641
00:35:00,000 --> 00:35:03,504 line:-2
为此 我只需要把这个视图
嵌入到一个群中即可


642
00:35:05,239 --> 00:35:07,107 line:-1
现在这里有多个视图了


643
00:35:09,309 --> 00:35:10,844 line:-1
那么让我们创建第二个版本…


644
00:35:12,045 --> 00:35:13,113 line:-1
使用不同的测试数据


645
00:35:13,981 --> 00:35:17,117 line:-1
现在一个版本是有视频会议的视图


646
00:35:17,751 --> 00:35:18,919 line:-1
另一个版本是没有视频会议的视图


647
00:35:27,327 --> 00:35:28,595 line:-1
现在让我们返回实时模式


648
00:35:31,231 --> 00:35:32,366 line:-1
当我处于Zoom状态时


649
00:35:32,666 --> 00:35:35,335 line:-2
那个图标显示在图片顶部
有点儿分散注意力


650
00:35:36,203 --> 00:35:38,472 line:-2
所以让我们更新一下
放大时不显示它


651
00:35:39,306 --> 00:35:41,308 line:-1
我们只需要更新就可以实现


652
00:35:47,481 --> 00:35:51,285 line:-2
现在图标会在缩小和放大时
自动显示和隐藏


653
00:35:51,685 --> 00:35:54,087 line:-2
但更好的是它在有动画效果
淡入和淡出


654
00:35:55,556 --> 00:35:57,691 line:-1
并且我们还可以自定义动画行为


655
00:35:58,125 --> 00:35:59,660 line:-1
通过把它设置为一个不同的转换


656
00:36:02,296 --> 00:36:05,399 line:-2
让我们试试.move
并使用leadingedge


657
00:36:07,901 --> 00:36:10,037 line:-1
现在我们的图标会滑出和滑入


658
00:36:17,544 --> 00:36:19,379 line:-1
让我把它变成一个长动画


659
00:36:19,947 --> 00:36:21,615 line:-1
通过给自定义动画


660
00:36:22,182 --> 00:36:23,617 line:-1
指定一个两秒的时长实现


661
00:36:25,352 --> 00:36:27,754 line:-1
现在我们的动画更详细了


662
00:36:29,056 --> 00:36:31,058 line:-2
并且我们还能看到
如果我们轻触它会发生什么


663
00:36:31,124 --> 00:36:32,459 line:-1
当动画仍然在持续时


664
00:36:32,993 --> 00:36:34,428 line:-1
它转了个方向并立即返回


665
00:36:35,596 --> 00:36:37,965 line:-1
再一次 动画总是具有交互性


666
00:36:38,732 --> 00:36:41,034 line:-2
并且我们可以一直轻触它
它都将呈现正确的状态


667
00:36:42,603 --> 00:36:43,704 line:-1
那么这就是我们的详情视图


668
00:36:44,271 --> 00:36:45,606 line:-2
让我们回顾一下
我们刚刚创建了什么


669
00:36:46,807 --> 00:36:49,710 line:-2
我们的详情视图配置有一个
用于展示的房间


670
00:36:50,410 --> 00:36:52,079 line:-1
请记住它是一个衍生值


671
00:36:52,145 --> 00:36:53,580 line:-1
由父视图传入


672
00:36:54,848 --> 00:36:56,250 line:-1
我们还有状态属性


673
00:36:56,884 --> 00:36:58,952 line:-1
控制视图是否被缩小或放大


674
00:37:00,554 --> 00:37:01,989 line:-1
并且由框架持续化


675
00:37:02,389 --> 00:37:03,724 line:-1
并控制长宽比


676
00:37:06,293 --> 00:37:08,195 line:-1
然后我们还有视频会议图标


677
00:37:09,296 --> 00:37:12,065 line:-1
只有有视频会议的视图


678
00:37:12,132 --> 00:37:13,400 line:-1
并且视图没被放大时才会显示


679
00:37:14,268 --> 00:37:16,170 line:-1
我们还指定了它的转换方式


680
00:37:16,503 --> 00:37:17,938 line:-1
图标滑入和滑出


681
00:37:19,273 --> 00:37:21,375 line:-1
但在那个转换中到底发生了什么？


682
00:37:22,075 --> 00:37:23,610 line:-1
嗯 当图标被移除时


683
00:37:24,411 --> 00:37:26,146 line:-1
视频要动态地显示到新位置上


684
00:37:26,747 --> 00:37:29,349 line:-2
并且SwiftUI会等待
直到它完成动画


685
00:37:29,716 --> 00:37:31,552 line:-1
从而从等级中移除视图


686
00:37:32,619 --> 00:37:33,954 line:-1
当图标再次显示时…


687
00:37:35,088 --> 00:37:36,790 line:-1
SwiftUI在后台插入


688
00:37:36,857 --> 00:37:38,659 line:-1
并以动画形式把它移回去


689
00:37:39,826 --> 00:37:42,329 line:-1
我希望能长时间执行


690
00:37:42,396 --> 00:37:44,097 line:-2
AddSubview和
RemoveSubview动画


691
00:37:44,464 --> 00:37:45,999 line:-1
我们终于能实现了 我感到很激动


692
00:37:53,140 --> 00:37:55,442 line:-1
回忆一下 动画总是具有交互性


693
00:37:55,509 --> 00:37:56,410 line:-1
立等可用


694
00:37:57,144 --> 00:37:59,346 line:-1
这就是成为数据驱动


695
00:37:59,413 --> 00:38:00,447 line:-1
而不是事件驱动的闪光点


696
00:38:00,514 --> 00:38:02,216 line:-1
Kyle刚才谈到的全部事件


697
00:38:02,482 --> 00:38:03,817 line:-1
都可能会发生 因为这个是动态的


698
00:38:04,451 --> 00:38:07,154 line:-2
并且动画的开始和结束
有更多的事件


699
00:38:07,888 --> 00:38:10,190 line:-1
在事件驱动的世界中


700
00:38:10,257 --> 00:38:11,491 line:-1
创建一个这样的动画非常困难


701
00:38:11,992 --> 00:38:13,894 line:-2
但在SwiftUI中
只需要一行代码


702
00:38:17,030 --> 00:38:20,067 line:-2
现在让我们返回到房间列表
并完成这个app


703
00:38:23,937 --> 00:38:26,940 line:-2
随时间流逝
我们需要能修改会议室列表


704
00:38:27,441 --> 00:38:28,742 line:-1
因此让我们添加一些编辑支持


705
00:38:29,710 --> 00:38:31,645 line:-2
反正我们也在这里了
让我们也把数据模型


706
00:38:31,845 --> 00:38:32,679 line:-1
变得更真实一些吧


707
00:38:33,514 --> 00:38:36,550 line:-1
目前app中的数据是完全静态数据


708
00:38:38,418 --> 00:38:40,787 line:-2
我们有这一组房间
我们运作app的一切


709
00:38:40,854 --> 00:38:41,855 line:-1
都是我们一直有的东西


710
00:38:42,856 --> 00:38:45,225 line:-2
因此让我们更新模型
添加一个根存储对象


711
00:38:45,592 --> 00:38:48,262 line:-1
容纳我们的房间并可以随时修改


712
00:38:50,097 --> 00:38:52,966 line:-2
我要拖入一个预制模型文件
它含有一个房间商店


713
00:39:01,608 --> 00:39:04,144 line:-1
请注意商店是一个可变的对象


714
00:39:04,411 --> 00:39:05,846 line:-1
包含我们所需要的房间


715
00:39:06,580 --> 00:39:09,883 line:-2
为此我们所需要做的全部操作就是
当它发生变更时告诉SwiftUI


716
00:39:11,018 --> 00:39:13,787 line:-2
为此 我要让它遵守
可绑定的对象协议


717
00:39:14,755 --> 00:39:16,857 line:-2
它要求我拥有一个
DidChange属性


718
00:39:23,030 --> 00:39:24,932 line:-1
今年新增加了Combine框架


719
00:39:25,199 --> 00:39:26,867 line:-1
它包含许多组件


720
00:39:26,934 --> 00:39:28,502 line:-1
你可以用它把你的数据连接在一起


721
00:39:29,169 --> 00:39:31,238 line:-2
在这里我们要使用
传递publisher


722
00:39:31,638 --> 00:39:33,173 line:-2
它是来自Combine的
一个传递主体


723
00:39:33,841 --> 00:39:36,476 line:-2
为我们提供一个本地对象
我们可以订阅它


724
00:39:36,543 --> 00:39:39,046 line:-1
和给它发送更新 类似通知中心


725
00:39:41,982 --> 00:39:44,685 line:-1
然后… 我们要更新房间…


726
00:39:46,086 --> 00:39:47,187 line:-1
给它添加一个DidSet…


727
00:39:48,322 --> 00:39:50,557 line:-2
从而使我们可以在房间发生变更时
通知主体


728
00:39:55,295 --> 00:39:57,064 line:-2
如果你有兴趣
了解Combine的更多信息


729
00:39:57,130 --> 00:39:59,633 line:-2
本周有两场演讲
带你了解全部详细信息


730
00:40:01,301 --> 00:40:02,970 line:-1
现在让我们返回到视图…


731
00:40:04,671 --> 00:40:05,873 line:-1
并更新它 从而使用我们的商店


732
00:40:07,107 --> 00:40:09,943 line:-2
我们要把这个Rooms属性
修改成Store属性


733
00:40:12,379 --> 00:40:13,814 line:-1
我们要把它变成对象绑定的属性…


734
00:40:14,481 --> 00:40:16,984 line:-2
从而告诉SwiftUI
监测这个属性的变更


735
00:40:17,918 --> 00:40:20,420 line:-1
再一次 Kyle刚才提到的


736
00:40:20,487 --> 00:40:22,623 line:-1
SwiftUI的数据流演讲有许多


737
00:40:22,689 --> 00:40:24,725 line:-2
关于如何进行对象绑定
以及其它操作的相关信息


738
00:40:26,193 --> 00:40:28,829 line:-2
让我们也更新一下预览
从而创建新商店类型


739
00:40:31,632 --> 00:40:32,733 line:-1
使用我们的测试数据


740
00:40:34,568 --> 00:40:37,437 line:-2
我们还要更新列表
以便从商店外拖入房间


741
00:40:39,973 --> 00:40:41,842 line:-1
很棒 现在我们使用了新模型


742
00:40:41,909 --> 00:40:43,010 line:-1
无论何时当它更新时


743
00:40:43,076 --> 00:40:44,578 line:-1
视图都会创建一个新鲜的渲染


744
00:40:46,046 --> 00:40:47,948 line:-2
这意味着我们已经准备好
添加编辑支持了


745
00:40:48,815 --> 00:40:51,818 line:-2
让我们从向列表中添加一个
可以添加新房间的按钮开始


746
00:40:53,220 --> 00:40:55,789 line:-1
目前我们使用了单一集合来驱动列表


747
00:40:56,456 --> 00:40:58,559 line:-2
对于完全是数据驱动的列表来说
没什么问题


748
00:40:59,159 --> 00:41:01,795 line:-2
但当我需要更多时
SwiftUI还会允许我


749
00:41:02,062 --> 00:41:04,965 line:-2
在列表中和其它容器中
把静态和动态内容混合在一起


750
00:41:06,633 --> 00:41:10,504 line:-2
因此我可以用ForEach的集合
来替换这个列表


751
00:41:12,706 --> 00:41:15,475 line:-2
ForEach为它的每个集合项
都创建一个视图


752
00:41:17,678 --> 00:41:21,215 line:-2
因此现在我要在这个ForEach
旁边添加一个静态元素


753
00:41:22,716 --> 00:41:24,451 line:-1
我要进入库并找到一个按钮


754
00:41:27,688 --> 00:41:30,624 line:-2
然后我可以把它拖动到代码中
并把它添加到列表中


755
00:41:33,727 --> 00:41:35,762 line:-2
让我们更新一下它的文本
从而显示Add Room


756
00:41:37,130 --> 00:41:38,799 line:-2
让我们添加一个新方法
从而添加那个新房间


757
00:41:43,504 --> 00:41:46,607 line:-2
好的 我们要告诉Store
附加一个新房间


758
00:41:49,076 --> 00:41:50,677 line:-1
就让我们使用我们所在的房间吧


759
00:41:52,513 --> 00:41:55,616 line:-2
它叫做Hall 2
并且我认为大约有2000人


760
00:41:59,119 --> 00:42:02,055 line:-2
最后 让我们更新按钮
以使用新的Add Room方法


761
00:42:04,525 --> 00:42:06,760 line:-2
好的 现在让我们进入实时模式
尝试一下我们的新按钮


762
00:42:08,695 --> 00:42:10,230 line:-1
它在那儿 就在数据旁边


763
00:42:11,031 --> 00:42:12,599 line:-1
当我轻触它时 我们得到了新房间


764
00:42:13,500 --> 00:42:14,434 line:-1
很棒


765
00:42:22,342 --> 00:42:25,212 line:-2
那么就像那样
我们可以添加这个单一静态元素


766
00:42:25,279 --> 00:42:26,947 line:-1
在数据驱动的集合的旁边


767
00:42:27,981 --> 00:42:30,617 line:-2
SwiftUI可以
让我们简单地描述这些强大的组合


768
00:42:31,285 --> 00:42:33,687 line:-2
从而让创建复杂的列表UI
变得更加简单


769
00:42:34,154 --> 00:42:35,756 line:-1
再也不用担心索引路径报错了


770
00:42:38,892 --> 00:42:40,527 line:-2
但我想调整一下它的样式
让它看起来更好看一些


771
00:42:41,428 --> 00:42:43,797 line:-1
让我们把Add按钮和全部内容


772
00:42:43,864 --> 00:42:44,865 line:-1
都放到独立的分区中去


773
00:42:46,033 --> 00:42:47,601 line:-1
我们可以修改列表的样式…


774
00:42:49,736 --> 00:42:50,637 line:-1
让它分类显示…


775
00:42:53,473 --> 00:42:55,175 line:-2
然后就有了这种
很漂亮的分类显示的外观


776
00:42:56,009 --> 00:42:58,946 line:-2
然后我们要在按钮旁
添加一个分区容器


777
00:43:02,583 --> 00:43:04,151 line:-2
并在ForEach旁
添加另一个分区容器


778
00:43:07,354 --> 00:43:08,922 line:-1
很棒 现在我们有独立的分区


779
00:43:10,591 --> 00:43:12,626 line:-1
接下来让我们把删除与列表挂钩


780
00:43:13,694 --> 00:43:14,728 line:-1
我们要添加一个方法…


781
00:43:16,463 --> 00:43:18,198 line:-1
用来删除一组房间


782
00:43:18,999 --> 00:43:21,902 line:-2
我们会传入一些
表明在哪里删除它们的偏移量


783
00:43:24,204 --> 00:43:25,606 line:-1
然后我们就要告诉商店


784
00:43:26,540 --> 00:43:28,575 line:-1
移除那些带有偏移量的房间


785
00:43:32,679 --> 00:43:36,283 line:-2
然后我们在ForEach上添加
一个修饰器 叫做OnDelete


786
00:43:37,885 --> 00:43:41,388 line:-2
并且我们可以向那个修饰器
传入删除方法


787
00:43:43,123 --> 00:43:44,858 line:-1
现在如果我们返回到实时模式中


788
00:43:46,860 --> 00:43:49,263 line:-1
我们可以滑动其中一行并删除它


789
00:43:49,329 --> 00:43:50,163 line:-1
就像那样


790
00:43:57,704 --> 00:44:00,607 line:-2
这个ForEach现在的配置是
调用回调函数


791
00:44:01,575 --> 00:44:03,610 line:-1
无论何时当从中移除列表项时


792
00:44:04,411 --> 00:44:07,080 line:-2
然后我们的回调函数就会
调用Store来移除那些项


793
00:44:07,915 --> 00:44:08,916 line:-1
然后视图更新


794
00:44:10,918 --> 00:44:12,986 line:-1
好的 现在我们希望能把列表


795
00:44:13,053 --> 00:44:15,489 line:-2
放在编辑模式中
以防只允许滑动删除


796
00:44:16,456 --> 00:44:19,159 line:-1
那么让我们设置一个导航栏项


797
00:44:19,626 --> 00:44:22,262 line:-2
并且我们可以采用与设置导航栏
标题的同样的方式来实现…


798
00:44:22,329 --> 00:44:23,363 line:-1
用另一个修饰器


799
00:44:26,233 --> 00:44:27,434 line:-1
并创建Edit按钮


800
00:44:27,768 --> 00:44:29,169 line:-1
嗯 我们要创建一个Edit按钮


801
00:44:30,804 --> 00:44:31,905 line:-1
它在那儿 在我们的UI中


802
00:44:33,140 --> 00:44:35,342 line:-2
既然我们已经到这儿了
让我们再添加一个重排序支持


803
00:44:36,577 --> 00:44:39,880 line:-2
再一次 我只需添加一个简单的方法
来移动列表项


804
00:44:41,148 --> 00:44:42,583 line:-1
我们要把它从源…


805
00:44:45,586 --> 00:44:46,620 line:-1
移动到目的地


806
00:44:49,223 --> 00:44:51,358 line:-2
我们只需调用
Store的Rooms


807
00:44:52,292 --> 00:44:53,227 line:-1
并告诉它移动即可


808
00:44:57,331 --> 00:44:58,165 line:-1
好的


809
00:44:58,632 --> 00:45:00,067 line:-1
那么就跟以前一样


810
00:45:00,367 --> 00:45:01,568 line:-1
我们要添加另一个修饰器


811
00:45:01,635 --> 00:45:02,636 line:-1
这次是Move


812
00:45:03,837 --> 00:45:06,340 line:-1
并告诉它调用我们刚添加的方法


813
00:45:07,875 --> 00:45:09,276 line:-1
现在让我们再次运行app


814
00:45:11,044 --> 00:45:12,513 line:-1
我们可以切换列表的编辑模式


815
00:45:13,480 --> 00:45:16,149 line:-1
请注意所有的数据行都有编辑控件


816
00:45:16,450 --> 00:45:17,451 line:-1
但按钮却没有


817
00:45:18,151 --> 00:45:20,721 line:-1
SwiftUI会在需要编辑控件的


818
00:45:21,421 --> 00:45:22,456 line:-1
正确的位置上自动显示


819
00:45:22,956 --> 00:45:24,424 line:-1
而我们不需要做任何额外的工作


820
00:45:27,227 --> 00:45:28,395 line:-1
是的 很酷


821
00:45:30,864 --> 00:45:35,035 line:-2
当然现在我们可以拖动来重排序
请轻触列表项来移除它们


822
00:45:38,305 --> 00:45:39,206 line:-1
谢谢


823
00:45:43,110 --> 00:45:44,811 line:-2
那么让我们快速回顾一下
我们刚刚添加了什么


824
00:45:45,979 --> 00:45:48,582 line:-1
我们自定义了列表使其显示多个分区


825
00:45:49,883 --> 00:45:51,485 line:-2
并通过把它的列表样式设为
分类显示实现


826
00:45:52,319 --> 00:45:53,687 line:-1
并且我们把这个静态按钮


827
00:45:54,221 --> 00:45:56,990 line:-2
与来自Rooms的数据驱动的集合
混合到了一起


828
00:45:58,058 --> 00:46:00,394 line:-2
我们还了解了
如何仅通过这些修饰器


829
00:46:00,460 --> 00:46:02,462 line:-1
向列表中迅速添加编辑操作


830
00:46:02,763 --> 00:46:04,698 line:-1
以及几个修改数据的函数


831
00:46:06,500 --> 00:46:09,002 line:-2
还记得我们之前是如何
让房间类型变得可识别的吗？


832
00:46:09,837 --> 00:46:13,407 line:-2
嗯 ForEach自动监测
它集合中的变更


833
00:46:13,841 --> 00:46:16,710 line:-1
并合成正确的插入、删除


834
00:46:16,777 --> 00:46:17,711 line:-1
和修改


835
00:46:18,111 --> 00:46:20,814 line:-2
因此我们再也不用告诉列表
添加和移除行了


836
00:46:21,181 --> 00:46:22,416 line:-1
这意味着我们再也不用担心


837
00:46:22,482 --> 00:46:24,551 line:-1
数据源不一致异常了


838
00:46:26,353 --> 00:46:27,487 line:-1
是 对


839
00:46:31,191 --> 00:46:32,192 line:-1
那么这就是我们的列表


840
00:46:32,259 --> 00:46:34,228 line:-1
我们仅通过这段非常少的视图代码


841
00:46:34,561 --> 00:46:36,763 line:-1
制作了这整个复杂的列表UI


842
00:46:39,266 --> 00:46:42,436 line:-2
好的 现在我们可以
迅速创建好这个app了


843
00:46:43,237 --> 00:46:45,138 line:-2
但你可能会想
我们还是需要做很多工作


844
00:46:45,205 --> 00:46:46,907 line:-1
才能让它上线面对客户


845
00:46:47,708 --> 00:46:51,245 line:-2
这些天、对动态类型的支持、
深色模式、可用性、地点


846
00:46:51,311 --> 00:46:53,881 line:-1
这些都是app中所需要的东西


847
00:46:55,082 --> 00:46:58,285 line:-2
但对于SwiftUI
你可以自动获得这些行为的更多支持


848
00:46:59,086 --> 00:47:01,688 line:-2
我们可以使用预览来进行
非常迅速的测试


849
00:47:02,890 --> 00:47:05,692 line:-2
因此让我们打开预览
并添加更多视图


850
00:47:07,427 --> 00:47:10,330 line:-2
再一次 我要添加一个群
可以让我们拥有多个子群


851
00:47:12,332 --> 00:47:14,668 line:-1
然后我要添加视图的另一个版本


852
00:47:16,403 --> 00:47:18,472 line:-1
这一次我们要修改一下环境…


853
00:47:21,141 --> 00:47:25,546 line:-2
使用一个尺寸类别
它是一个较大的尺寸


854
00:47:26,780 --> 00:47:27,814 line:-1
让我们运行看看它是什么样子


855
00:47:28,248 --> 00:47:29,917 line:-1
一切都很棒 都是自动的


856
00:47:31,785 --> 00:47:33,353 line:-1
现在…是的


857
00:47:34,588 --> 00:47:35,756 line:-1
我们能免费得到这些太好了


858
00:47:37,391 --> 00:47:40,561 line:-2
现在环境是你
设置情境信息的一种方式


859
00:47:40,627 --> 00:47:43,197 line:-1
情境信息与视图等级中的视图有关


860
00:47:43,263 --> 00:47:46,033 line:-2
也是同时修改任意所包含的视图的
不同方面的一种方式


861
00:47:46,867 --> 00:47:49,002 line:-1
修改大量视图很棒


862
00:47:49,436 --> 00:47:51,338 line:-1
并且自定义预览也很棒


863
00:47:51,705 --> 00:47:53,240 line:-1
可以在不同的情境中浏览视图


864
00:47:54,741 --> 00:47:56,476 line:-1
让我们添加视图的另一个版本…


865
00:47:58,545 --> 00:47:59,713 line:-1
并更新环境…


866
00:48:00,480 --> 00:48:02,482 line:-1
把它的色系变成暗色


867
00:48:05,052 --> 00:48:06,520 line:-1
一切都没问题


868
00:48:13,026 --> 00:48:15,229 line:-1
最后 让我们再看看


869
00:48:15,295 --> 00:48:16,296 line:-1
其它语种的app怎么样


870
00:48:17,598 --> 00:48:20,200 line:-2
我有一些英文字符串文件
我要把它们拖进app中


871
00:48:27,174 --> 00:48:29,009 line:-2
并且我会告诉Xcode
对它们进行本地化


872
00:48:34,114 --> 00:48:35,983 line:-1
然后我进入我的项目文件…


873
00:48:38,051 --> 00:48:40,854 line:-1
导出一个阿拉伯语的本地化文件


874
00:48:47,060 --> 00:48:48,262 line:-1
现在让我们返回到视图中


875
00:48:48,562 --> 00:48:49,663 line:-1
再添加一个预览


876
00:48:55,769 --> 00:49:00,140 line:-2
现在如果我们先把布局方向
设置为从右到左


877
00:49:02,776 --> 00:49:05,245 line:-2
我们可以看到它会自动生效
不需要任何额外的工作


878
00:49:06,413 --> 00:49:08,282 line:-1
但如果我把区域也设为…


879
00:49:11,518 --> 00:49:13,187 line:-1
阿拉伯地区…


880
00:49:16,757 --> 00:49:18,425 line:-1
你可以看到一切都被本地化了


881
00:49:26,233 --> 00:49:28,402 line:-1
更棒的是 如果我们返回去看代码


882
00:49:28,669 --> 00:49:30,771 line:-2
我们不需要任何额外的操作
来支持这些功能


883
00:49:31,505 --> 00:49:34,041 line:-2
为了让文本可本地化
我们不需要标记


884
00:49:34,107 --> 00:49:35,776 line:-2
哪些字符串需要进行本地化
而哪些不需要


885
00:49:36,276 --> 00:49:37,778 line:-1
SwiftUI会自动推断


886
00:49:38,679 --> 00:49:41,949 line:-2
对于使用字符串文字的文本
它默认就是可进行本地化


887
00:49:43,383 --> 00:49:45,485 line:-2
对于那些通过传入字符串
而生成的文本来说


888
00:49:45,919 --> 00:49:47,354 line:-1
它默认就是按照原来的样子使用


889
00:49:48,222 --> 00:49:51,358 line:-2
这意味着app的全部文本
比如Rooms和Add Room


890
00:49:51,692 --> 00:49:52,559 line:-1
都能被本地化


891
00:49:53,060 --> 00:49:55,896 line:-2
但我们的全部内容
比如这些房间名称


892
00:49:56,697 --> 00:49:57,965 line:-1
仍会被正确地传入


893
00:49:58,298 --> 00:50:01,168 line:-2
但更好的是 你终于可以
使用字符串插值了


894
00:50:01,235 --> 00:50:02,569 line:-1
并让它们正确地进行本地化


895
00:50:09,376 --> 00:50:11,144 line:-1
我喜欢字符串插值 非常棒


896
00:50:12,746 --> 00:50:15,282 line:-2
我们很期待你们通过SwiftUI
开始创建app


897
00:50:15,582 --> 00:50:17,551 line:-1
你可以免费获得所有这些行为


898
00:50:17,618 --> 00:50:19,653 line:-1
你可以着重关注app的独特部分


899
00:50:20,020 --> 00:50:22,055 line:-1
并更快地为客户们创建更好的app


900
00:50:23,156 --> 00:50:24,625 line:-2
我们在这里创建的是一个
iPhone app


901
00:50:25,259 --> 00:50:27,294 line:-1
但你可以在全部Apple平台上


902
00:50:27,361 --> 00:50:28,729 line:-1
使用同样的API和技巧


903
00:50:29,696 --> 00:50:31,431 line:-1
并且你会在全部平台上


904
00:50:31,498 --> 00:50:32,432 line:-1
获得诸如此类的自动化行为


905
00:50:33,934 --> 00:50:35,969 line:-2
好的 让我们最后再看一次
我们的app


906
00:50:36,036 --> 00:50:38,572 line:-2
回顾一下我们创建了什么功能
并确保一切都运行无误


907
00:50:39,907 --> 00:50:41,041 line:-1
我是深色模式的忠实粉丝


908
00:50:41,441 --> 00:50:42,442 line:-1
因此让我们使用深色模式


909
00:50:45,212 --> 00:50:46,547 line:-1
好的 我们有房间列表


910
00:50:46,880 --> 00:50:48,081 line:-1
我们可以轻触其中一项


911
00:50:48,549 --> 00:50:49,616 line:-1
了解更多信息


912
00:50:50,450 --> 00:50:52,953 line:-2
并且在详情视图中
我们可以轻触使其放大到全屏显示


913
00:50:53,287 --> 00:50:55,189 line:-2
那会通过一个转换
隐藏我们的视频会议图标


914
00:50:55,956 --> 00:50:57,691 line:-1
并且那个动画总是具有交互性


915
00:51:00,160 --> 00:51:02,729 line:-1
并且我们还可以编辑列表做出修改


916
00:51:04,965 --> 00:51:06,033 line:-1
让我们把这个移动到下边…


917
00:51:07,267 --> 00:51:09,770 line:-2
我不认为有人会希望
使用像地牢一样的会议室


918
00:51:13,640 --> 00:51:16,243 line:-2
实际上我不确定Kyle为什么
会添加这个棘手的房间


919
00:51:16,310 --> 00:51:17,744 line:-1
让我们把那个也去掉


920
00:51:18,779 --> 00:51:20,814 line:-1
最后 让我们添加我们的会议室


921
00:51:21,715 --> 00:51:22,850 line:-1
太棒了 这就是我们的app


922
00:51:30,190 --> 00:51:31,925 line:-1
但我还要指出最后一点


923
00:51:31,992 --> 00:51:33,427 line:-1
是我们没有看到的东西


924
00:51:33,961 --> 00:51:35,629 line:-1
我们刚刚创建了整个app


925
00:51:35,996 --> 00:51:37,598 line:-1
并测试了全部行为


926
00:51:37,965 --> 00:51:39,900 line:-1
而一次也没有创建和运行app


927
00:51:40,601 --> 00:51:43,437 line:-2
Xcode预览可以让我们浏览、
编辑和调试app


928
00:51:43,770 --> 00:51:45,472 line:-1
比之前的速度更快


929
00:51:46,607 --> 00:51:47,708 line:-1
那么谢谢大家


930
00:51:47,774 --> 00:51:49,710 line:-2
我希望你们跟我一样
喜欢用SwiftUI


931
00:51:50,010 --> 00:51:50,844 line:-1
很有意思


932
00:51:55,349 --> 00:51:59,553 line:-2
那么我们对SwiftUI的目标是
为你们提供一个最短路径


933
00:51:59,620 --> 00:52:02,122 line:-2
让你们创建
能满足最多受众的很棒的app


934
00:52:03,223 --> 00:52:07,528 line:-2
我们今天了解了SwiftUI的
四个主要设计原则


935
00:52:07,794 --> 00:52:09,696 line:-1
我们了解了它的陈述性语法


936
00:52:10,230 --> 00:52:13,066 line:-1
可以唤起你所创建的UI


937
00:52:13,133 --> 00:52:15,035 line:-1
并处理那些交互式细节


938
00:52:15,102 --> 00:52:16,637 line:-1
比如以你的名义


939
00:52:16,937 --> 00:52:17,838 line:-1
添加和移除子视图


940
00:52:18,472 --> 00:52:20,274 line:-1
我们了解了组合


941
00:52:20,607 --> 00:52:23,243 line:-2
以及如何把内容、修饰器和容器
组合到一起


942
00:52:23,310 --> 00:52:27,214 line:-1
来创建你所期待的那个UI


943
00:52:28,348 --> 00:52:30,817 line:-2
我们了解了你所得到的全部
自动化行为


944
00:52:31,151 --> 00:52:34,555 line:-2
我们不需要做很多
大部分都交给框架来实现


945
00:52:35,255 --> 00:52:37,224 line:-1
我们了解了SwiftUI如何


946
00:52:37,291 --> 00:52:39,626 line:-1
让视图保持一致状态


947
00:52:39,927 --> 00:52:42,462 line:-2
因此再也不会发生视图丢失
或出现在错误的位置上了


948
00:52:43,197 --> 00:52:45,265 line:-2
当然了 我们还了解了
SwiftUI的


949
00:52:45,332 --> 00:52:47,134 line:-1
很棒的可中断的动画


950
00:52:47,434 --> 00:52:49,336 line:-1
那是我最喜欢的功能之一


951
00:52:49,403 --> 00:52:53,540 line:-2
以前我总是感觉
必须在拥有闪亮的动画


952
00:52:53,941 --> 00:52:56,276 line:-2
和随之而来的毁灭性的复杂度之间
犹豫万分


953
00:52:56,343 --> 00:52:57,444 line:-1
再也不会发生这种情况了


954
00:52:59,179 --> 00:53:01,915 line:-2
SwiftUI的目标是 等一下
我们还没有再看一次app


955
00:53:01,982 --> 00:53:02,883 line:-1
它很酷 对吗？


956
00:53:03,350 --> 00:53:05,085 line:-1
好的 SwiftUI的目标是


957
00:53:05,385 --> 00:53:06,987 line:-1
以我们的名义替我们处理…


958
00:53:07,120 --> 00:53:11,425 line:-1
每一个app都需要的基础功能


959
00:53:11,491 --> 00:53:13,060 line:-1
因为当你创建app时


960
00:53:13,126 --> 00:53:15,329 line:-1
你添加的并不只是基础功能


961
00:53:15,395 --> 00:53:18,131 line:-1
你拥有特别的、独特的功能


962
00:53:18,198 --> 00:53:20,267 line:-2
那样才能让app成为
你自己的app


963
00:53:21,068 --> 00:53:23,871 line:-1
目标是替我们承担更多的责任


964
00:53:24,438 --> 00:53:27,841 line:-2
替我们分担每一个很棒的app
都需要的东西


965
00:53:29,076 --> 00:53:31,545 line:-1
让你把时间更多地花在让你的app


966
00:53:31,612 --> 00:53:32,713 line:-1
变得更特别的东西上


967
00:53:33,814 --> 00:53:37,518 line:-2
我希望你们都喜欢
我们对SwiftUI的介绍


968
00:53:37,751 --> 00:53:39,520 line:-1
请参加我们的讨论会


969
00:53:39,920 --> 00:53:42,089 line:-2
我们今天下午会在那儿
整个一周都会在那儿


970
00:53:43,056 --> 00:53:45,726 line:-2
我们还会主持其它演讲
UI数据流演讲


971
00:53:45,792 --> 00:53:47,060 line:-1
和创建自定义视图


972
00:53:47,127 --> 00:53:49,730 line:-1
学习SwiftUI的下一站


973
00:53:49,963 --> 00:53:51,832 line:-1
应该是SwiftUI要领演讲


974
00:53:52,099 --> 00:53:54,168 line:-1
我们将会讲关于语法的方方面面


975
00:53:54,535 --> 00:53:57,037 line:-1
以及一切你可以组合在一起


976
00:53:57,104 --> 00:53:58,539 line:-1
让视图原汁原味地呈现的东西


977
00:53:59,039 --> 00:54:00,374 line:-1
那么我希望能在那里看到你们


978
00:54:00,440 --> 00:54:04,311 line:-2
希望大家度过一个愉快的WWDC
并希望你们能享受SwiftUI

