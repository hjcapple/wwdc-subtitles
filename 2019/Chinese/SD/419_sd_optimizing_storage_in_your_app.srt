1
00:00:07,040 --> 00:00:12,145 line:0
（在你的app中优化存储空间
更好的性能和效率）


2
00:00:16,884 --> 00:00:20,420 line:-2
嗨 我是Kai Kaahaaina 今天
我同Alejandro Lucena一起


3
00:00:20,487 --> 00:00:23,524 line:-2
我们会介绍如何为你的app优化
存储空间


4
00:00:24,858 --> 00:00:28,228 line:-2
就像CPU内存一样 存储是一个
有限资源


5
00:00:29,363 --> 00:00:31,398 line:-1
当一个app最佳使用存储空间时


6
00:00:31,798 --> 00:00:37,538 line:-2
我们能更好地保证更长时间
的电池寿命、更好的性能、


7
00:00:39,439 --> 00:00:42,676 line:-2
减少app的内存占用和
保持设备的良好健康状态


8
00:00:45,412 --> 00:00:48,949 line:-2
今天我们主要要讲的优化主题是
高效率的图片资源


9
00:00:50,017 --> 00:00:55,822 line:-2
同步至硬盘 序列化数据文件
Core Data和SQLite


10
00:00:59,193 --> 00:01:00,661 line:-1
首先 高效率的图片资源


11
00:01:01,028 --> 00:01:04,031 line:-1
当屏幕尺寸变得大一些了


12
00:01:04,096 --> 00:01:05,899 line:-1
图片资源的尺寸也相应地增大了


13
00:01:09,169 --> 00:01:12,539 line:-2
在我们的演讲中 我们创建了一个
简单的示例app来整理目录


14
00:01:12,606 --> 00:01:13,707 line:-1
和最爱的图片


15
00:01:15,409 --> 00:01:17,711 line:-1
不过 甚至是在预加载一些照片时


16
00:01:17,778 --> 00:01:20,814 line:-2
我们的app也增大了24.6
百万字节的内存大小


17
00:01:21,849 --> 00:01:25,319 line:-2
我们现在来了解优化
我们app的尺寸的两种方式


18
00:01:27,321 --> 00:01:28,622 line:-1
首先是HEIC


19
00:01:29,022 --> 00:01:31,391 line:-1
HEIC有时也被称为HEIF


20
00:01:31,892 --> 00:01:34,561 line:-1
它更有效率且能够取代JPEG


21
00:01:36,597 --> 00:01:40,634 line:-2
相同画质下 HEIC的文件大小
比JPEG小了50%


22
00:01:41,001 --> 00:01:46,206 line:-2
当然 它意味着一个
更小的磁盘空间和更小的文件大小


23
00:01:46,273 --> 00:01:48,509 line:-1
从网络上上传或下载变得更容易了


24
00:01:50,077 --> 00:01:52,379 line:-1
它们也能被更快的加载和保持到硬盘


25
00:01:55,716 --> 00:01:58,118 line:-2
HEIC也提供了很多JPEG
没有的其他功能


26
00:01:58,285 --> 00:02:01,054 line:-1
比如存储包含了深度和视差信息


27
00:02:01,121 --> 00:02:02,289 line:-1
的辅助图片的能力


28
00:02:04,124 --> 00:02:07,094 line:-1
HEIC也支持阿尔法和无损压缩


29
00:02:09,096 --> 00:02:13,000 line:-2
HEIC甚至允许你在单独的容器中
存储多张图片


30
00:02:15,636 --> 00:02:17,804 line:-2
iOS从iOS 11起
支持HEIC


31
00:02:17,871 --> 00:02:20,507 line:-2
MacOS从macOS High Sierra
开始支持HEIC


32
00:02:21,475 --> 00:02:23,243 line:-1
它在其他操作系统也同样可用


33
00:02:26,380 --> 00:02:29,416 line:-2
那么 回到我们的示例app
我们从使用JPEG资源开始


34
00:02:29,483 --> 00:02:32,352 line:-1
它在磁盘中占据24.6兆字节


35
00:02:34,188 --> 00:02:37,724 line:-2
用HEIC取代JPEG格式后
我们能缩减这个app的尺寸


36
00:02:37,791 --> 00:02:39,259 line:-1
到17.9兆字节


37
00:02:39,960 --> 00:02:42,863 line:-2
通过使用HEIC就减少了27%
的占有量


38
00:02:46,533 --> 00:02:49,903 line:-2
另一个减少我们app
内存占用的方式是使用资源目录


39
00:02:50,504 --> 00:02:54,341 line:-2
资源目录是管理你app的资源
的一个很好的方式


40
00:02:55,175 --> 00:02:56,643 line:-1
比如app图标 设备和你的


41
00:02:58,478 --> 00:03:00,514 line:-1
不同尺寸的图片资源


42
00:03:01,048 --> 00:03:04,318 line:-2
资源目录提供了一个非常容易的
存储方式


43
00:03:04,384 --> 00:03:05,352 line:-1
具有多级分辨率的图片


44
00:03:05,919 --> 00:03:08,922 line:-2
这让它非常简单就能
支持很多不同的设备


45
00:03:10,924 --> 00:03:14,261 line:-2
我们也能使用资源目录来为
随需应变的资源做标记


46
00:03:14,828 --> 00:03:16,797 line:-1
这样用户就不需要看见它们下载


47
00:03:17,197 --> 00:03:18,265 line:-1
直到他们需要使用它们时


48
00:03:21,301 --> 00:03:23,504 line:-1
通过使用资源目录


49
00:03:23,570 --> 00:03:25,072 line:-1
我们同时获取了存储和性能的优点


50
00:03:27,007 --> 00:03:28,842 line:-1
我们首先减少了磁盘的内存占有量


51
00:03:28,909 --> 00:03:32,946 line:-2
因为资源目录使用了单一的经过优化
的格式来存储我们所有的图片资源


52
00:03:33,013 --> 00:03:34,448 line:-1
而不是个别文件


53
00:03:36,884 --> 00:03:40,220 line:-2
App Store也使用了
你资源目录的元数据来帮助支持


54
00:03:40,287 --> 00:03:41,822 line:-1
你的iOS app的app分割


55
00:03:43,323 --> 00:03:45,559 line:-2
这样当一个用户从商店下载
你的app时


56
00:03:45,926 --> 00:03:48,395 line:-2
他们只会获取到他们自己设备所需
的资源


57
00:03:48,762 --> 00:03:50,330 line:-1
这减轻了下载量


58
00:03:50,397 --> 00:03:52,900 line:-1
也节省了用户下载app的时间


59
00:03:52,966 --> 00:03:54,868 line:-1
他们很快就能开始使用你的app


60
00:03:57,271 --> 00:03:58,539 line:-1
我们的性能也得到了提升


61
00:03:59,406 --> 00:04:02,609 line:-2
再一次 由于资源目录优化了
我们图片资源的保存格式


62
00:04:02,676 --> 00:04:05,646 line:-1
图片能被更快地加载了


63
00:04:05,946 --> 00:04:08,649 line:-1
在app启动时优化效果尤其明显


64
00:04:09,683 --> 00:04:11,051 line:-1
特别是Mac上的硬件驱动


65
00:04:11,118 --> 00:04:14,755 line:-2
我们看到了app启动时性能提升了
10%


66
00:04:17,457 --> 00:04:21,261 line:-2
资源目录也让基于GPU的压缩
的适配变得很简单


67
00:04:22,196 --> 00:04:27,367 line:-2
这个压缩默认是无损的
但也支持有损格式的压缩


68
00:04:29,803 --> 00:04:32,039 line:-1
所有的都能使用硬件加速的解压


69
00:04:33,140 --> 00:04:37,077 line:-1
有一个选项甚至提供了一个减少


70
00:04:37,144 --> 00:04:38,212 line:-1
你图片资源的内存占用的功能


71
00:04:41,849 --> 00:04:43,016 line:-1
那么回到我们的示例app


72
00:04:43,083 --> 00:04:46,587 line:-2
早些时候我们看到通过使用HEIC
我们能够将app


73
00:04:46,653 --> 00:04:47,654 line:-1
的体积减少至17.9兆字节


74
00:04:48,889 --> 00:04:51,425 line:-1
现在 也通过适配资源目录


75
00:04:51,491 --> 00:04:55,429 line:-2
主要通过app分割功能
我们就能更进一步地将


76
00:04:55,495 --> 00:04:57,331 line:-2
这个app的内存占用减少
至14.9兆字节


77
00:04:58,532 --> 00:05:02,336 line:-2
只需简单地使用了
HEIC和资源目录


78
00:05:02,636 --> 00:05:03,737 line:-2
就比我们开始时减少了40%
的内存占用


79
00:05:05,939 --> 00:05:08,175 line:-1
所以如果你还没使用HEIC


80
00:05:08,242 --> 00:05:10,444 line:-1
和资源目录来管理你的图片资源


81
00:05:10,611 --> 00:05:11,845 line:-1
我们非常推荐你调研使用它们


82
00:05:11,912 --> 00:05:14,147 line:-2
它们是一个很棒又简单的
方式来获得更高的效率


83
00:05:14,314 --> 00:05:15,516 line:-1
和更小的app内存占用率


84
00:05:19,219 --> 00:05:21,455 line:-2
接下来 我想要简单地聊一下
文件系统的元数据


85
00:05:25,425 --> 00:05:28,662 line:-2
我们示例app包含了一个小的
plist文件来追踪上一次


86
00:05:28,729 --> 00:05:29,796 line:-1
app被启动的时间


87
00:05:30,230 --> 00:05:32,766 line:-2
app每次被启动时
我们在plist文件中读取它


88
00:05:33,200 --> 00:05:36,270 line:-2
更新last_app_launch时间属性
将这个更新后的plist文件


89
00:05:36,336 --> 00:05:37,337 line:-1
重写回磁盘中


90
00:05:39,306 --> 00:05:42,376 line:-2
如果我们观察到这个行为表现
像是在使用文件活跃状态仪表


91
00:05:42,442 --> 00:05:44,344 line:-2
Alejandro将在之后演讲中
介绍关于它的一些信息


92
00:05:45,212 --> 00:05:47,114 line:-1
我们能看到这个行为导致了一次读取


93
00:05:47,347 --> 00:05:49,416 line:-2
它很有道理
我们读取了plist文件


94
00:05:50,551 --> 00:05:52,219 line:-1
但它导致了三个写入操作


95
00:05:52,386 --> 00:05:55,322 line:-2
你可能会有点吃惊
因为我们只对一个文件进行了写入


96
00:05:56,757 --> 00:05:59,526 line:-2
我们也看到了一个fsync操作
这些开销很大


97
00:05:59,593 --> 00:06:02,729 line:-2
为什么那样操作开销会很大
我们之后会介绍更多内容


98
00:06:04,765 --> 00:06:06,500 line:-2
所以 为什么不是不是一次
而是三次写入呢？


99
00:06:07,167 --> 00:06:09,036 line:-1
那么 答案就是文件系统元数据


100
00:06:10,037 --> 00:06:14,007 line:-2
文件系统元数据是我们每次
创建或删除一个文件时


101
00:06:14,074 --> 00:06:16,043 line:-1
文件系统需要更新的数据


102
00:06:16,109 --> 00:06:20,914 line:-2
当前案例中 写入了plist文件
创建了文件 这导致了额外的操作


103
00:06:23,650 --> 00:06:25,118 line:-1
所以什么是文件系统元数据？


104
00:06:25,652 --> 00:06:28,455 line:-1
文件系统元数据是文件系统


105
00:06:28,522 --> 00:06:29,590 line:-1
需要追踪的关于我们文件的信息


106
00:06:29,656 --> 00:06:34,328 line:-1
比如文件名字 尺寸 位置


107
00:06:35,629 --> 00:06:38,098 line:-2
以及日期 比如创建的日期
或上次修改的时间的信息


108
00:06:38,866 --> 00:06:39,867 line:-1
还有更多的


109
00:06:42,069 --> 00:06:44,104 line:-2
为了更好地理解每次
当我们创建一个文件时


110
00:06:44,171 --> 00:06:45,239 line:-1
文件系统要实现什么


111
00:06:45,772 --> 00:06:47,774 line:-1
我们来了解一下APFS要做什么


112
00:06:47,841 --> 00:06:50,143 line:-2
当我们将NSDictionary
文件写入磁盘时


113
00:06:51,712 --> 00:06:55,749 line:-2
好的 APFS要做的第一件事是
更新文件系统树


114
00:06:56,149 --> 00:06:58,118 line:-1
它会通过更新它的一个节点来实现


115
00:06:59,253 --> 00:07:02,322 line:-1
不过 因为APFS的即写即拷性质


116
00:07:02,890 --> 00:07:07,027 line:-2
我们实际上并未更新一个已有的节点
我们创建了一个已有节点的备份


117
00:07:07,461 --> 00:07:08,529 line:-1
我们来深入了解一下


118
00:07:09,630 --> 00:07:11,265 line:-1
这是我们已有的文件系统树


119
00:07:13,534 --> 00:07:16,136 line:-1
我们看到了一个已有节点的备份


120
00:07:18,338 --> 00:07:20,908 line:-2
这个新的节点和原始节点
名字怎么不一样了


121
00:07:20,974 --> 00:07:22,576 line:-1
它其实和原始节点的名字一样


122
00:07:22,976 --> 00:07:26,213 line:-2
但是新节点增加了内容
或至少增加了不同的事务ID


123
00:07:26,747 --> 00:07:29,583 line:-2
它的这个不同的事务ID可以让
APFS来支持


124
00:07:29,650 --> 00:07:31,485 line:-1
高阶的功能 比如截屏


125
00:07:33,487 --> 00:07:37,724 line:-2
那么返回到上一级 现在我们有了
我们已更新的文件系统树


126
00:07:38,325 --> 00:07:41,562 line:-2
APFS需要更新这个对象地图
那么它会留意新的节点


127
00:07:42,029 --> 00:07:44,865 line:-2
那么 总体来说 为了支持写入新的
文件


128
00:07:45,032 --> 00:07:47,301 line:-1
APFS需要实现两个单独的操作


129
00:07:48,468 --> 00:07:50,237 line:-1
总共8K的写入I/O


130
00:07:51,772 --> 00:07:56,176 line:-2
4K用来更新文件系统树
另外4K用来更新对象地图


131
00:07:57,744 --> 00:07:59,346 line:-1
我们还是需要写入这个文件本身


132
00:07:59,580 --> 00:08:03,684 line:-2
当前场景下 它虽只是240字节
的NSDictionary数据


133
00:08:04,117 --> 00:08:07,588 line:-2
我们向一个iOS设备磁盘
能写入的最小的文件大小是4K


134
00:08:07,855 --> 00:08:08,856 line:-1
所以它被四舍五入了


135
00:08:10,591 --> 00:08:15,829 line:-2
总体来说 须向磁盘写入12K的
数据存储240字节的NSDictionary


136
00:08:17,164 --> 00:08:18,532 line:-1
只有大约2%的效率


137
00:08:19,266 --> 00:08:21,969 line:-2
所以示例不仅向我们展示了APFS
为了跟踪文件创建需要实现的工作


138
00:08:22,035 --> 00:08:26,006 line:-1
它也高亮了在文件系统的独立文件中


139
00:08:26,073 --> 00:08:29,309 line:-1
存储量极小的数据的成本


140
00:08:33,313 --> 00:08:36,650 line:-2
那么 在我们刚看到的示例
我们看到在APFS创建一个文件


141
00:08:36,717 --> 00:08:38,784 line:-1
需要8K的I/O


142
00:08:40,419 --> 00:08:42,322 line:-2
那么删除一个文件呢？
它是8K


143
00:08:42,722 --> 00:08:46,093 line:-2
另一个常见的操作
比如重命名一个文件是16K


144
00:08:46,860 --> 00:08:49,429 line:-1
修改一个已有文件是8K


145
00:08:52,366 --> 00:08:55,102 line:-2
这里最重要的是文件系统更新
并不是免费的


146
00:08:55,435 --> 00:08:58,639 line:-2
事实上 它们涉及到
比数据存储更多的I/O使用量


147
00:08:59,606 --> 00:09:02,042 line:-2
作为一个结果
关于如何创建 修改和删除文件


148
00:09:02,109 --> 00:09:03,143 line:-1
我们需要有选择性地操作


149
00:09:04,044 --> 00:09:05,846 line:-1
我们想要尝试避免高昂的行为操作


150
00:09:05,913 --> 00:09:08,282 line:-1
比如快速地创建和删除文件


151
00:09:11,852 --> 00:09:15,189 line:-2
如果我们有一个使用场景
需要在文件系统中保存暂时数据


152
00:09:15,389 --> 00:09:17,791 line:-1
对于暂存数据来说


153
00:09:17,858 --> 00:09:18,859 line:-1
这是一个减少系统耗费的一种好方式


154
00:09:19,226 --> 00:09:23,664 line:-2
首先 创建你的文件
但保持它打开和非接入状态


155
00:09:25,098 --> 00:09:26,366 line:-1
不要为它调用fsync


156
00:09:26,967 --> 00:09:29,236 line:-1
这样做会给文件系统一个它需要


157
00:09:29,303 --> 00:09:31,872 line:-2
在OS缓冲中需要尽可能长时间地
保留暂存文件


158
00:09:32,105 --> 00:09:35,642 line:-2
以及不要将它可能需要频繁地
写入到磁盘的提示


159
00:09:37,244 --> 00:09:40,147 line:-2
如果你想要了解更多关于APFS
文件系统的元数据


160
00:09:40,214 --> 00:09:42,416 line:-2
我们的开发者网站上有一个
很棒的参考文档


161
00:09:42,583 --> 00:09:43,951 line:-1
我非常推荐你查看它


162
00:09:48,488 --> 00:09:49,623 line:-1
接下来 同步到磁盘


163
00:09:52,726 --> 00:09:54,761 line:-1
当它开始管理我们的数据在哪存储时


164
00:09:54,828 --> 00:09:58,866 line:-2
为了最佳的性能表现 我们想要保存
我们缓存中离CPU最近的数据


165
00:09:59,633 --> 00:10:04,671 line:-2
但当我们需要它时 我们也想要能够
从磁盘中获取到我们的数据


166
00:10:05,873 --> 00:10:07,774 line:-2
首先 我们来了解一下我们有的
不同的缓存


167
00:10:09,409 --> 00:10:10,677 line:-1
首先 这是OS缓存


168
00:10:10,744 --> 00:10:13,447 line:-2
这是我们为了最佳性能表现想要
保存的我们的数据


169
00:10:14,848 --> 00:10:17,417 line:-2
对OS缓存进行读写操作
就是前面提到的逻辑I/O


170
00:10:18,218 --> 00:10:19,887 line:-1
因为这个缓存依靠内存


171
00:10:19,953 --> 00:10:22,556 line:-1
逻辑I/O操作完成得非常快速


172
00:10:23,323 --> 00:10:25,526 line:-1
在OS缓存中保存数据通常对


173
00:10:25,592 --> 00:10:27,694 line:-1
频繁使用和修改数据有利


174
00:10:30,531 --> 00:10:31,565 line:-1
接下来 我们有了磁盘缓存


175
00:10:31,632 --> 00:10:34,701 line:-2
磁盘缓存实际上
被物理存储在存储设备上


176
00:10:36,503 --> 00:10:38,372 line:-1
最后 我们有了永久存储


177
00:10:38,438 --> 00:10:41,241 line:-2
这实际上是物理媒介
它会长久持续


178
00:10:41,308 --> 00:10:42,309 line:-1
保存数据


179
00:10:42,376 --> 00:10:45,245 line:-2
在iOS设备和最新的Mac上
它是NAND


180
00:10:48,182 --> 00:10:51,285 line:-2
物理I/O在物理存储器上
被读取和写入


181
00:10:51,552 --> 00:10:56,723 line:-2
这些I/O会抵达或去往磁盘缓存
或永久存储


182
00:10:58,825 --> 00:11:01,828 line:-2
那么 现在我们已经了解了一些
缓存和持久存储


183
00:11:02,196 --> 00:11:05,632 line:-2
我们来了解一下最通用的API
我们使用它从OS缓存中移动数据


184
00:11:05,899 --> 00:11:06,900 line:-1
到存储设备上


185
00:11:08,669 --> 00:11:09,670 line:-1
首先 是fsync


186
00:11:11,705 --> 00:11:14,708 line:-2
fsync会让数据从OS缓存中
移动到磁盘缓存


187
00:11:16,643 --> 00:11:18,412 line:-1
但它不保证数据


188
00:11:18,478 --> 00:11:20,414 line:-1
将会被立刻永久存储


189
00:11:20,981 --> 00:11:24,384 line:-2
若软件没有更进一步输入
它会到达设备的固件


190
00:11:24,451 --> 00:11:27,221 line:-2
来查明数据何时会从磁盘缓存中
被移动到永久存储


191
00:11:28,622 --> 00:11:30,257 line:-1
它也不能保证写命令


192
00:11:31,024 --> 00:11:33,961 line:-2
就是说OS缓存中的数据
写入磁盘缓存中的命令


193
00:11:34,027 --> 00:11:37,231 line:-1
可能不太会和数据被磁盘缓存


194
00:11:37,297 --> 00:11:39,233 line:-1
写入至永久存储时的命令一样


195
00:11:41,101 --> 00:11:43,370 line:-2
如果我们过度使用fsync时
它的开销也很大


196
00:11:44,204 --> 00:11:48,942 line:-2
当我们在OS缓存中有数据时
OS缓存能够轻易地接受


197
00:11:49,009 --> 00:11:50,944 line:-1
重写或改动同样的数据


198
00:11:51,278 --> 00:11:53,413 line:-2
只要我们使用了fsync
它会移动至磁盘缓存


199
00:11:54,681 --> 00:11:56,884 line:-1
基于我们需要保证我们的数据


200
00:11:56,950 --> 00:11:57,951 line:-1
被移动到磁盘缓存的节奏


201
00:11:58,519 --> 00:12:00,821 line:-1
手动调用fsync可能并不必要


202
00:12:00,888 --> 00:12:03,023 line:-1
OS会为我们周期性地实现


203
00:12:07,895 --> 00:12:11,498 line:-1
从OS缓存中将数据移动至永久存储


204
00:12:11,565 --> 00:12:14,501 line:-2
最主要的方式是通过F controls的
FFULLFSYNC


205
00:12:15,636 --> 00:12:18,572 line:-2
这会导致驱动中的磁盘缓存的数据
会被刷新


206
00:12:20,107 --> 00:12:22,709 line:-2
不过 这会导致磁盘缓存中
所有的数据会被刷新


207
00:12:23,277 --> 00:12:25,913 line:-1
所以我们不只是想要移动到永久存储


208
00:12:25,979 --> 00:12:29,383 line:-1
的数据会被移动到永久存储


209
00:12:29,683 --> 00:12:31,485 line:-1
磁盘缓存中的所有数据都会被移动


210
00:12:32,719 --> 00:12:33,787 line:-1
最后 它的耗费量很大


211
00:12:34,188 --> 00:12:36,256 line:-2
因为它可能有很多数据
它会耗费很多时间


212
00:12:37,891 --> 00:12:40,460 line:-2
再一次 它可能实际上并不需要
手动操作


213
00:12:41,061 --> 00:12:43,697 line:-1
OS会为我们周期性地实现了


214
00:12:46,667 --> 00:12:50,704 line:-2
如我们用FFULLFSYNC
最重要的原因是为了保证I/O命令


215
00:12:51,038 --> 00:12:53,974 line:-2
一个更好更有效的替代方式是使用
F BARRIERFSYNC


216
00:12:55,175 --> 00:12:57,311 line:-2
F BARRIERFSYNC
强制实行I/O命令


217
00:12:58,946 --> 00:13:01,915 line:-2
将F BARRIERFSYNC
从根本上作为有着障碍的fsync


218
00:13:02,082 --> 00:13:06,486 line:-2
可能是最好的思考方法 这个障碍是
一则给Apple SSD执行


219
00:13:06,553 --> 00:13:10,757 line:-1
在障碍之前收到的所有iOS的提示


220
00:13:10,824 --> 00:13:12,793 line:-1
在障碍之后才会收到它们


221
00:13:14,361 --> 00:13:16,830 line:-2
最后 它比F FULLFSYNC
的耗费要小很多


222
00:13:17,431 --> 00:13:20,868 line:-2
不用将所有磁盘缓存中
的数据存储至永久存储


223
00:13:20,934 --> 00:13:22,936 line:-1
就得到了我们想要的相同的结果


224
00:13:24,705 --> 00:13:27,708 line:-2
所以如果你对I/O命令有所顾虑
请用F BARRIERFSYNC


225
00:13:27,774 --> 00:13:28,842 line:-1
而不是F FULLFSYNC


226
00:13:28,909 --> 00:13:31,979 line:-2
它是更快速和有效的方式
来访问你在磁盘的数据


227
00:13:34,848 --> 00:13:36,316 line:-1
序列化的数据文件


228
00:13:37,050 --> 00:13:38,285 line:-1
序列化的数据文件


229
00:13:39,086 --> 00:13:41,788 line:-2
文件比如plist、XML
和JSON 它们很棒


230
00:13:42,055 --> 00:13:43,290 line:-1
它们用起来很方便


231
00:13:43,657 --> 00:13:47,060 line:-2
它们是存储不常用的修改后的数据
非常好的方式


232
00:13:47,995 --> 00:13:49,463 line:-1
它们解析起来相当容易


233
00:13:50,531 --> 00:13:52,699 line:-2
然而 除了所有这些简易操作的方面
它还有一些不足之处


234
00:13:55,269 --> 00:13:57,905 line:-2
每次我们对这个文件
做出一点改动时


235
00:13:57,971 --> 00:14:01,008 line:-2
整个文件会被重新序列化
重写至磁盘


236
00:14:02,176 --> 00:14:03,810 line:-1
结果就是 它们的扩展性不佳


237
00:14:04,945 --> 00:14:07,648 line:-2
因为它们使用起来非常方便
所以它们很容易被误用


238
00:14:08,749 --> 00:14:11,151 line:-2
因为只要有一个改动
我们就必须替换这个文件


239
00:14:11,218 --> 00:14:13,120 line:-1
它们是非常集中的文件系统元数据


240
00:14:15,989 --> 00:14:18,325 line:-1
它们并不意味着能取代一个数据库


241
00:14:20,594 --> 00:14:23,263 line:-1
查看文件活跃状态仪表的截图


242
00:14:23,330 --> 00:14:26,867 line:-2
我们能看到创建
读取和修改plist文件的行为


243
00:14:27,501 --> 00:14:29,603 line:-1
导致了12次分散的I/O操作


244
00:14:30,037 --> 00:14:32,439 line:-1
这对于四行代码可能有点多


245
00:14:34,608 --> 00:14:36,777 line:-2
如果我们在这个有点略微不同的视图
我们会看到每次


246
00:14:36,844 --> 00:14:38,879 line:-2
我们调用NSDictionary
来自动地写入文件


247
00:14:40,314 --> 00:14:42,850 line:-2
这个操作同一个fsync
操作一起结束


248
00:14:43,217 --> 00:14:45,619 line:-2
代表在该NSDictionary
存储的所有数据


249
00:14:45,686 --> 00:14:48,822 line:-2
我们推送至磁盘 它永远不会
运用OS缓存的好处了


250
00:14:51,225 --> 00:14:55,529 line:-2
最后 非常大的数据集
或频繁被改动的数据集


251
00:14:55,829 --> 00:14:59,366 line:-2
它们在一个序列化plist格式中
并不非常有效


252
00:15:01,969 --> 00:15:03,604 line:-1
如果你的数据量很大


253
00:15:03,670 --> 00:15:06,773 line:-2
或需要频繁改动
Core Data是很棒的替代品


254
00:15:09,476 --> 00:15:13,146 line:-2
Core Data管理创建在SQLite上
它提供了一个在SQLite数据源


255
00:15:13,213 --> 00:15:16,283 line:-2
和你app的模型层之间的
很好的抽象层


256
00:15:18,485 --> 00:15:21,488 line:-2
Core data自动地管理
对象视图和它们之间的关系


257
00:15:23,323 --> 00:15:25,526 line:-1
支持变化追踪和通知


258
00:15:27,528 --> 00:15:30,497 line:-1
自动地版本追踪和多次写入冲突解决


259
00:15:30,931 --> 00:15:34,401 line:-1
Core Data甚至会自动地


260
00:15:34,568 --> 00:15:36,303 line:-1
为多个并行操作建立联系


261
00:15:37,871 --> 00:15:41,775 line:-2
iOS 13新加入的Core Data
支持CloudKit的集成


262
00:15:41,842 --> 00:15:43,710 line:-2
对于Core Data适配者来说
这是一个很大帮助


263
00:15:45,245 --> 00:15:47,147 line:-2
Core Data
同时支持实时查询


264
00:15:47,214 --> 00:15:49,216 line:-1
它允许你快速集成查询


265
00:15:49,883 --> 00:15:52,653 line:-1
那么 你不必提前手写你觉得你可能


266
00:15:52,719 --> 00:15:53,854 line:-1
需要的所有的SQLite查询代码


267
00:15:55,989 --> 00:15:58,292 line:-2
Core Data
也提供了自动内存管理


268
00:15:59,793 --> 00:16:01,428 line:-1
状态聚合和数据处理


269
00:16:03,096 --> 00:16:08,936 line:-2
模式迁移和iOS 13新加入的
数据非规范化


270
00:16:10,237 --> 00:16:11,338 line:-1
等其他更多


271
00:16:12,973 --> 00:16:14,975 line:-2
我们也观察到了
Core Data的适配者


272
00:16:15,042 --> 00:16:18,579 line:-2
必须写50%到70%的少量代码
来支持他们的模型视图


273
00:16:19,313 --> 00:16:22,516 line:-1
那段代码无需写入、修改或调试


274
00:16:23,016 --> 00:16:26,053 line:-2
不过 如果你有一个使用场景
它需要直接使用SQLite


275
00:16:26,286 --> 00:16:28,255 line:-1
我们有一些最佳实践想要分享给你


276
00:16:30,023 --> 00:16:33,060 line:-2
这是一个更大的话题 所以我们有
一些子话题包括连接


277
00:16:33,560 --> 00:16:38,332 line:-2
日志登载 数据处理
文件大小和隐私 和部分索引


278
00:16:40,834 --> 00:16:41,835 line:-1
或子连接


279
00:16:43,270 --> 00:16:45,506 line:-1
SQLite的稳健性保证并不是免费的


280
00:16:45,973 --> 00:16:48,675 line:-2
打开和关闭一个数据库
会导致相当大的开销操作


281
00:16:48,742 --> 00:16:52,379 line:-2
比如持续检查 日志恢复和
日志检查和日志检验指示


282
00:16:54,715 --> 00:16:57,384 line:-2
最后 我们实际上推荐不要使用
一个更传统的数据库模型


283
00:16:57,451 --> 00:17:00,087 line:-1
来每次按需打开和关闭一个数据库


284
00:17:01,088 --> 00:17:02,556 line:-1
取而代之 我们推荐相反的方式


285
00:17:03,123 --> 00:17:07,160 line:-2
让数据库尽可能地一直保存打开
当有必要时才断开链接


286
00:17:08,028 --> 00:17:10,230 line:-1
对于多线程的处理 建立连接


287
00:17:10,297 --> 00:17:12,733 line:-1
这样 只要一个线程还需要数据库


288
00:17:12,799 --> 00:17:14,101 line:-1
数据库就会保持打开状态


289
00:17:14,800 --> 00:17:17,871 line:-1
这帮助分担了多次打开和


290
00:17:17,938 --> 00:17:18,939 line:-1
关闭一个数据库成本


291
00:17:21,942 --> 00:17:22,943 line:-1
接下来 日志登载


292
00:17:25,078 --> 00:17:27,714 line:-2
删除模式日志登载是SQLite
默认的志登载模式


293
00:17:27,948 --> 00:17:29,683 line:-1
但它并不是最高效的


294
00:17:30,150 --> 00:17:33,854 line:-2
为了知道为什么 我们来看一下
删除模式日志登载是怎样工作的


295
00:17:35,422 --> 00:17:37,925 line:-2
我们有一个数据库
我们想要修改其中的四页


296
00:17:39,459 --> 00:17:42,095 line:-2
发生的第一件事是
我们复制这四页


297
00:17:42,162 --> 00:17:43,163 line:-1
到一个日志文件结束后


298
00:17:45,933 --> 00:17:48,502 line:-2
接下来我们能在数据库中
修改这四页


299
00:17:49,436 --> 00:17:52,706 line:-1
完成之后 日志文件就会被删除


300
00:17:53,440 --> 00:17:57,578 line:-2
所以如果我们想一想
我们必须写入两遍


301
00:17:57,644 --> 00:18:01,882 line:-2
我们需要修改的页面
我们所有的文件系统对这个


302
00:18:01,949 --> 00:18:03,650 line:-2
只做了一次数据处理的短时间
的日志文件的开销


303
00:18:05,886 --> 00:18:10,023 line:-2
幸运的是 SQLite为预写日志
或WAL模式日志登载


304
00:18:10,090 --> 00:18:11,391 line:-1
提供了一个更加高效的替代品


305
00:18:11,892 --> 00:18:15,095 line:-2
WAL模式日志登载提供了
一个减少写入的好方式


306
00:18:15,529 --> 00:18:18,999 line:-2
它允许我们在同一页上将
多次写入操作结合在一起


307
00:18:19,333 --> 00:18:20,467 line:-1
它使用了更少的障碍物


308
00:18:21,301 --> 00:18:23,504 line:-1
它能同时支持多个读入和写入操作


309
00:18:24,004 --> 00:18:25,239 line:-1
以及支持截屏


310
00:18:26,273 --> 00:18:27,741 line:-2
我们来看一下WAL模式日志
是如何工作的


311
00:18:29,142 --> 00:18:31,578 line:-2
所以再一次 我们有一个数据库
我们想要修改其中的四页


312
00:18:32,179 --> 00:18:34,348 line:-1
它们被写入预写日志文件


313
00:18:34,681 --> 00:18:36,517 line:-1
而不是直接地在数据库中修改


314
00:18:37,084 --> 00:18:39,152 line:-1
以及 我们有了额外的数据处理


315
00:18:39,786 --> 00:18:42,122 line:-2
这些页面也被添加至
预写日志文件里了


316
00:18:42,789 --> 00:18:45,325 line:-1
直到预写日志文件变得相当大之后


317
00:18:45,392 --> 00:18:46,393 line:-1
它才会为它开始检查点


318
00:18:47,528 --> 00:18:50,497 line:-2
当我们为它开始检查点时 我们能使
用WAL模式的很多优点中的一个


319
00:18:51,131 --> 00:18:55,702 line:-2
在删除模式数据库里
还没被多次修改的页面


320
00:18:56,170 --> 00:18:59,706 line:-2
所有这些在同一页面的改动
在WAL检查点的工程中被合并了


321
00:18:59,773 --> 00:19:02,242 line:-1
同一页面只需被写入一次


322
00:19:04,511 --> 00:19:07,714 line:-2
当我们完成后 一个简单的
WAL文件的标题重写


323
00:19:07,781 --> 00:19:09,950 line:-1
是所有将来所需用到的


324
00:19:10,217 --> 00:19:13,320 line:-2
因此要减少文件系统维护这个
预写日志文件的成本


325
00:19:15,689 --> 00:19:19,793 line:-2
多数SQLite的使用场景中
我们可以看到WAL模式更加高效


326
00:19:19,860 --> 00:19:22,596 line:-2
如果你还没为SQLite数据库
使用WAL模式


327
00:19:22,663 --> 00:19:24,598 line:-1
我们非常建议你切换至WAL模式


328
00:19:25,098 --> 00:19:28,235 line:-2
它是为你的app提升性能
的很好的方式


329
00:19:29,603 --> 00:19:31,805 line:-1
使用多次插入 更新和删除声明


330
00:19:31,872 --> 00:19:35,475 line:-2
在一次数据处理中是为SQLite
提供更多信息的一个很好的方式


331
00:19:35,542 --> 00:19:37,945 line:-1
这样它能更有效地为你运行


332
00:19:39,279 --> 00:19:42,950 line:-1
通过多次声明 在相同的数据处理下


333
00:19:43,016 --> 00:19:45,586 line:-2
被多次修改的文章
只会在磁盘中被写入一次


334
00:19:47,120 --> 00:19:49,590 line:-2
在这个示例中
我们有三次单独数据处理


335
00:19:49,656 --> 00:19:52,292 line:-2
每一个都在数据库中修改相同页面的
一项声明


336
00:19:53,060 --> 00:19:55,963 line:-2
我们会看到数据库中的同一页面
被修改了三次


337
00:19:57,698 --> 00:20:01,001 line:-2
不过 如果我们在这三个声明中
对其中一个的数据做修改


338
00:20:01,602 --> 00:20:04,204 line:-2
所有的这些改变会被结合在一起
以及数据库中的页面


339
00:20:04,271 --> 00:20:05,472 line:-1
只会被重写一次


340
00:20:07,674 --> 00:20:10,911 line:-2
最后 在单个SQLite
数据修改中使用多次声明


341
00:20:10,978 --> 00:20:13,547 line:-1
是聚合多次变动的一个很好的方式


342
00:20:17,751 --> 00:20:18,919 line:-1
文件大小和隐私


343
00:20:21,154 --> 00:20:22,990 line:-2
所以当我们在数据库中删除数据时
会发生什么呢？


344
00:20:23,957 --> 00:20:26,527 line:-2
空间包含了被标记为
被删除的空闲数据


345
00:20:26,960 --> 00:20:28,829 line:-1
当它不再是数据库的一部分时


346
00:20:28,896 --> 00:20:30,230 line:-2
从技术角度来看
它其实仍在磁盘上


347
00:20:31,398 --> 00:20:34,868 line:-2
所以如果我们要如何更高效
安全地删除敏感信息？


348
00:20:37,271 --> 00:20:39,373 line:-2
我们推荐使用
secure_delete=Fast


349
00:20:39,907 --> 00:20:41,308 line:-2
secure_delete=Fast
非常好用


350
00:20:42,743 --> 00:20:44,478 line:-1
它自动地清理被删除的数据


351
00:20:45,012 --> 00:20:47,080 line:-1
对于相同页面数据并没有成本损失


352
00:20:47,147 --> 00:20:49,750 line:-2
我们在头文件中修改过的
用来标记空闲数据


353
00:20:50,551 --> 00:20:53,787 line:-2
现在它也是iOS 13中
SQLite的默认行为表现了


354
00:20:54,721 --> 00:20:57,391 line:-1
如果你需要它来创建老版本的iOS


355
00:20:57,457 --> 00:21:00,561 line:-2
请注意secure_delete=FAST
的编译指示


356
00:21:03,964 --> 00:21:06,433 line:-2
当它被用来管理
我们数据库文件的大小时


357
00:21:06,767 --> 00:21:09,102 line:-2
我们强烈建议你
不要使用VACUUM


358
00:21:10,604 --> 00:21:14,007 line:-2
VACUUM是一个非常慢的内存
以及I/O的密集型操作


359
00:21:14,341 --> 00:21:17,344 line:-2
为了更好理解为什么 我们来看看
VACUUM是如何为SQLite


360
00:21:17,411 --> 00:21:18,378 line:-1
数据库工作的


361
00:21:19,913 --> 00:21:22,649 line:-2
那么 假如我们有一个数据库
我们想要清除所有的空闲页面


362
00:21:24,618 --> 00:21:26,820 line:-2
发生了什么呢？我们最后为我们的
数据库打开一扇缓存的门


363
00:21:26,887 --> 00:21:30,557 line:-2
创建了一个日志文件 接下来
我们结束了一个从数据库


364
00:21:30,924 --> 00:21:32,492 line:-1
到日志文件的SQLite转储


365
00:21:32,993 --> 00:21:36,296 line:-2
为我们的数据库拷贝了所有
的有效数据至日志文件


366
00:21:37,664 --> 00:21:40,100 line:-2
接下来 当为日志文件实行
检查点时


367
00:21:40,601 --> 00:21:43,303 line:-2
为了符合日志文件的大小
数据库将被删减


368
00:21:44,171 --> 00:21:47,574 line:-2
日志中的所有数据都会被重新插入
到数据库


369
00:21:49,009 --> 00:21:51,411 line:-2
接下来当它完成时
日志文件会被丢弃


370
00:21:54,081 --> 00:21:55,582 line:-1
如我们看到的 这个开销很大


371
00:21:55,649 --> 00:21:58,952 line:-2
我们数据库中的这些
所有有效数据都被至少写入了两次


372
00:21:59,152 --> 00:22:00,220 line:-1
一次被写入到了日志文件


373
00:22:00,287 --> 00:22:02,422 line:-1
接着再一次回到了数据库


374
00:22:04,858 --> 00:22:08,128 line:-2
如果数据库工作的这一边太大
而不能放置内存中


375
00:22:08,462 --> 00:22:12,766 line:-2
SQLite其实会利用多余的文件
帮助管理额外的数据


376
00:22:13,100 --> 00:22:14,568 line:-1
直到操作完成


377
00:22:18,238 --> 00:22:21,575 line:-2
很幸运 SQLite中有很多
更有效的替代品


378
00:22:22,009 --> 00:22:24,344 line:-2
在当前情况下 就是
auto_vacuum=INCREMENTAL


379
00:22:24,912 --> 00:22:26,547 line:-1
auto_vacuum的增量很棒


380
00:22:26,613 --> 00:22:29,316 line:-2
因为它不仅允许我们更高效地
管理数据库文件的大小


381
00:22:29,383 --> 00:22:33,220 line:-1
它还让我们确认页数


382
00:22:33,287 --> 00:22:34,922 line:-1
我们想要清空数据库


383
00:22:35,589 --> 00:22:39,326 line:-2
为数据库保留之后会用到的
空闲页数提供一个选项


384
00:22:43,530 --> 00:22:45,599 line:-2
我们来看一下auto_vacuum=INCREMENTAL
是如何工作的


385
00:22:46,867 --> 00:22:49,970 line:-2
那么 在这个例子中 我们会清空
两个页面


386
00:22:50,838 --> 00:22:53,073 line:-2
然而 当我们从WAL文件的
数据库中


387
00:22:53,140 --> 00:22:54,541 line:-1
移出我们所有的数据之前


388
00:22:55,976 --> 00:22:59,112 line:-2
为了增量自动清理
我们要做的是转移数据库最后


389
00:22:59,279 --> 00:23:01,582 line:-1
的两页到预写日志


390
00:23:02,249 --> 00:23:07,921 line:-2
在调整数据库树的时候
任何被修改的父节点


391
00:23:07,988 --> 00:23:09,489 line:-1
也会被写入预写日志


392
00:23:10,490 --> 00:23:13,093 line:-1
接下来 当预写日志获得了检查点


393
00:23:14,261 --> 00:23:16,129 line:-1
数据库文件本身会被删除


394
00:23:17,197 --> 00:23:19,166 line:-1
我们从数据库的最后迁移的页面


395
00:23:19,233 --> 00:23:20,534 line:-1
将会去到之前的空闲页面


396
00:23:20,601 --> 00:23:23,470 line:-2
任何被更新的父节点会被写入到
数据库中


397
00:23:24,271 --> 00:23:26,640 line:-2
那么 就像你看到的
在我们必须将我们的数据移入


398
00:23:26,707 --> 00:23:28,876 line:-2
和移出数据库之前
现在我们简单地


399
00:23:28,942 --> 00:23:31,044 line:-1
在数据库中修改页面的一个子集


400
00:23:31,945 --> 00:23:33,146 line:-1
这非常有效率


401
00:23:34,781 --> 00:23:38,218 line:-2
最后 我们相当推荐使用
增量自动清理


402
00:23:38,285 --> 00:23:41,288 line:-2
通过快速安全地删除
来管理你的SQLite


403
00:23:41,355 --> 00:23:42,623 line:-1
数据库文件大小和隐私


404
00:23:48,128 --> 00:23:49,129 line:-1
部分索引


405
00:23:51,832 --> 00:23:52,833 line:-1
索引很棒


406
00:23:53,066 --> 00:23:56,370 line:-2
索引允许更快的排序分组
和WHERE查询子句


407
00:23:57,104 --> 00:23:58,405 line:-1
不幸的是 他们不能被免费使用


408
00:23:58,572 --> 00:24:00,641 line:-1
数据库需要支持索引


409
00:24:00,707 --> 00:24:01,942 line:-1
这些会有一定量的开销


410
00:24:02,609 --> 00:24:04,011 line:-1
在我们添加了更多的索引之后


411
00:24:04,244 --> 00:24:07,948 line:-2
每个新写入到数据库的数据开销
会更大


412
00:24:09,950 --> 00:24:11,685 line:-1
幸运的是 它有更有效率的


413
00:24:11,752 --> 00:24:12,953 line:-1
部分索引形式的替代品


414
00:24:13,587 --> 00:24:16,490 line:-1
部分索引允许你使用WHERE


415
00:24:16,557 --> 00:24:18,492 line:-1
查询子句来描述你想要索引


416
00:24:19,259 --> 00:24:22,729 line:-2
这很棒 因为现在你能获取到
一个索引的益处了


417
00:24:22,796 --> 00:24:26,967 line:-2
当你想要它 但又不想为索引
付出没有必要的代价


418
00:24:27,034 --> 00:24:28,335 line:-1
当它不能为你带来任何好处时


419
00:24:33,540 --> 00:24:34,942 line:-1
那么 SQLite的总结


420
00:24:37,110 --> 00:24:39,580 line:-1
请尽可能长时间保持数据库连接打开


421
00:24:41,515 --> 00:24:44,117 line:-2
使用WAL日志登载模式
而不是删除日志登载模式


422
00:24:45,919 --> 00:24:48,355 line:-2
可能的话 在每个数据处理时
使用多次声明


423
00:24:48,422 --> 00:24:51,058 line:-1
这是SQLite为我们做的优化


424
00:24:53,060 --> 00:24:55,462 line:-1
使用快速安全删除和自动清理增量


425
00:24:55,696 --> 00:24:58,165 line:-2
来同时管理你数据库的
文件大小和隐私


426
00:24:59,333 --> 00:25:02,069 line:-2
如果可行的话
使用部分的索引


427
00:25:02,135 --> 00:25:03,303 line:-1
而不是一般的常规索引


428
00:25:05,706 --> 00:25:09,610 line:-2
如果你真的不关心SQLite
的这些细节


429
00:25:09,676 --> 00:25:11,879 line:-2
我们强烈建议你
只使用Core Data


430
00:25:11,945 --> 00:25:14,448 line:-2
Core Data为你解决了
所有的这些难题


431
00:25:15,048 --> 00:25:17,251 line:-2
因为Core Data
已被多次改进


432
00:25:17,651 --> 00:25:20,554 line:-2
Core Data的适配者
也会免费得到这些好处


433
00:25:25,292 --> 00:25:27,160 line:-2
接下来 Alejandro
将为我们展示如何使用


434
00:25:27,227 --> 00:25:28,795 line:-1
最新版的文件活跃状态仪表


435
00:25:29,496 --> 00:25:32,966 line:-2
为我们展示现实世界中我们应该
如何为app剖析和优化I/O


436
00:25:33,534 --> 00:25:34,535 line:-1
Alejandro


437
00:25:38,038 --> 00:25:39,706 line:0
（文件活跃状态仪表）


438
00:25:41,942 --> 00:25:44,645 line:-1
好的 谢谢Kai 大家早上好


439
00:25:44,811 --> 00:25:47,014 line:-2
欢迎大家参加本次关于优化内存
的演讲


440
00:25:48,448 --> 00:25:50,417 line:-2
我想介绍我们对
文件活跃状态仪表


441
00:25:50,484 --> 00:25:52,152 line:-1
所做的一些提升


442
00:25:52,219 --> 00:25:55,155 line:-2
来看看我们如何使用它
优化我们的app的存储空间


443
00:25:55,923 --> 00:25:56,890 line:-1
那么我们开始吧


444
00:25:57,357 --> 00:25:59,259 line:-1
文件活跃状态仪表有哪些改变？


445
00:26:01,061 --> 00:26:03,297 line:-1
我们做的第一件事是为所有的


446
00:26:03,363 --> 00:26:04,531 line:-1
Apple设备增加了支持


447
00:26:04,865 --> 00:26:07,734 line:-2
所以这意味着你可以使用
统一的分析经验


448
00:26:07,801 --> 00:26:12,105 line:-2
在你的iOS设备 Mac
Watch TV等等


449
00:26:15,409 --> 00:26:18,011 line:-1
文件活跃状态仪表也允许你


450
00:26:18,078 --> 00:26:21,114 line:-2
追踪除了你自己的app之外
还有整个系统


451
00:26:21,415 --> 00:26:25,853 line:-2
这样你就能看到你的app的行为
只针对I/O的子系统


452
00:26:26,119 --> 00:26:28,689 line:-1
以及它如何同剩下的系统交互


453
00:26:28,755 --> 00:26:30,390 line:-1
这样你能看到正在进行中的不同交互


454
00:26:32,726 --> 00:26:35,329 line:-1
接下来 Kai提到过的


455
00:26:35,395 --> 00:26:36,396 line:-1
逻辑和物理I/O之间是有差别的


456
00:26:36,697 --> 00:26:39,766 line:-2
了解它们是如何相互交互的
实际上对了解


457
00:26:40,100 --> 00:26:42,102 line:-1
你的I/O使用量是非常重要的


458
00:26:42,402 --> 00:26:45,172 line:-2
文件活跃状态仪表让我们
可以将它们结合在一起查看


459
00:26:47,274 --> 00:26:50,177 line:-2
最后 我们也添加了
对自动推理的支持


460
00:26:50,611 --> 00:26:53,447 line:-1
自动推理有各种不同的机制


461
00:26:53,514 --> 00:26:55,249 line:-1
那么我想要非常简短地介绍一下它


462
00:26:57,451 --> 00:27:00,554 line:-2
首先 自动推理的其中一个是
反模式检测


463
00:27:00,621 --> 00:27:03,156 line:-2
我们添加它实际上是想要过度的
物理权利


464
00:27:03,590 --> 00:27:07,094 line:-2
那么当你在追踪时 文件活跃
状态仪表若监测到了你app中的


465
00:27:07,160 --> 00:27:10,497 line:-2
一些过度活动行为时
它实际上会提示你


466
00:27:10,564 --> 00:27:12,399 line:-1
你可以从仪表中直接跳转


467
00:27:12,466 --> 00:27:13,700 line:-1
来查看是什么导致它发生的


468
00:27:16,703 --> 00:27:20,007 line:-2
当查看某个I/O相关的系统
的直接调用或是你自己的调用时


469
00:27:20,073 --> 00:27:22,709 line:-1
我们对此也加入了支持


470
00:27:22,776 --> 00:27:24,611 line:-1
因为这个框架已经失败了


471
00:27:25,012 --> 00:27:27,648 line:-2
这些是需要了解的重要的内容
除了I/O之外


472
00:27:27,714 --> 00:27:29,349 line:-1
你app中的正确性也同样重要


473
00:27:31,885 --> 00:27:35,756 line:-2
最后 Kai提到过F FULLFSYNC的
fsync和F control


474
00:27:35,822 --> 00:27:38,992 line:-1
我们也有一个检查次优缓存的机制


475
00:27:39,293 --> 00:27:42,696 line:-2
这样你就能看到 你的app可能会
表现出某些行为是因为


476
00:27:42,930 --> 00:27:45,299 line:-1
没有非常好地利用OS缓存


477
00:27:46,066 --> 00:27:47,568 line:-1
那么我们从文件活跃状态仪表开始


478
00:27:47,634 --> 00:27:48,635 line:-1
来看它是什么样子的


479
00:27:49,803 --> 00:27:53,607 line:-2
使用Instruments 11 当我们打开
Instruments 我们看到


480
00:27:53,674 --> 00:27:56,910 line:-2
文件活跃状态的图标还是和之前相似
但在底部多了一行新的字符


481
00:27:56,977 --> 00:27:58,812 line:-1
这是它所能做的一个总结


482
00:27:59,880 --> 00:28:03,083 line:-2
如果我们接下来选择它
我们看到了一些新的轨道


483
00:28:03,951 --> 00:28:06,153 line:-1
首先是文件系统建议行踪


484
00:28:06,653 --> 00:28:08,722 line:-1
这个轨道是所有的这些反模式


485
00:28:08,789 --> 00:28:10,958 line:-1
和自动推理建议的行踪


486
00:28:12,025 --> 00:28:14,061 line:-2
在它下面
我们有文件系统活跃状态


487
00:28:14,361 --> 00:28:16,997 line:-1
文件系统活跃状态会打断逻辑的读取


488
00:28:17,064 --> 00:28:18,065 line:-1
逻辑的写入


489
00:28:18,365 --> 00:28:21,301 line:-2
它会为你展示这些操作发生次数
的数量


490
00:28:21,635 --> 00:28:25,739 line:-2
你也能更深入地了解调用的次数
谁调用了它们


491
00:28:25,806 --> 00:28:27,007 line:-1
和某些其他的统计


492
00:28:27,875 --> 00:28:30,210 line:-1
相似地 在磁盘使用量的正下方


493
00:28:30,277 --> 00:28:32,980 line:-1
你可以看到相同的读入和写入差别


494
00:28:33,046 --> 00:28:34,214 line:-1
除了物理的层级之外


495
00:28:34,982 --> 00:28:38,051 line:-2
最后 磁盘I/O的延时
这样我们能看某些物理


496
00:28:38,118 --> 00:28:39,486 line:-1
I/O的时长


497
00:28:40,287 --> 00:28:43,056 line:-2
那么 我们开始吧
我们回到这个示例app


498
00:28:43,724 --> 00:28:46,960 line:-2
我想实现的第一件事实际上是
为照片标记最爱


499
00:28:47,427 --> 00:28:50,130 line:-2
那么 在这些图片中
每个右侧底部都有一个星星


500
00:28:50,397 --> 00:28:52,733 line:-1
我想要实现的是能选择那个星星


501
00:28:52,799 --> 00:28:54,368 line:-1
来标记一张图片为最爱


502
00:28:54,935 --> 00:28:57,938 line:-2
比如 我能选择一张香蕉蛞蝓图片
为我的最爱


503
00:28:59,439 --> 00:29:00,541 line:-1
这些摩天大楼也是


504
00:29:01,275 --> 00:29:04,111 line:-2
我会做的第一步是
每次当我们标记一张为最爱时


505
00:29:04,178 --> 00:29:07,080 line:-1
通过打开和关闭数据库来实现


506
00:29:07,714 --> 00:29:10,083 line:-1
Kai讲过这不是最佳的实现方案


507
00:29:10,150 --> 00:29:13,320 line:-2
但我还是觉得将它导入到文件
活跃状态仪表轨迹中很实用


508
00:29:13,520 --> 00:29:15,923 line:-2
我们有一条基线
我们能看到正在发生的一些事情


509
00:29:18,058 --> 00:29:19,760 line:-1
在我后面 的确是那样


510
00:29:19,826 --> 00:29:23,163 line:-2
我运行文件活跃状态仪表
每次操作时通过打开


511
00:29:23,230 --> 00:29:25,299 line:-1
和关闭数据库对照相同的工作流


512
00:29:25,966 --> 00:29:28,902 line:-2
我想要关注磁盘使用量的第一条轨迹
因为这是所有物理的


513
00:29:28,969 --> 00:29:30,337 line:-1
I/O信息所在的地方


514
00:29:31,004 --> 00:29:35,108 line:-2
我们在物理地写入列
或物理地写入行中看到


515
00:29:35,175 --> 00:29:37,277 line:-1
我们看到物理I/O的数量不一致


516
00:29:37,344 --> 00:29:41,582 line:-2
在当前情况下 在工具提示文字中
这个特别的列有54个


517
00:29:42,182 --> 00:29:43,851 line:-1
但在它的正下方是详情视图


518
00:29:43,917 --> 00:29:45,586 line:-2
详情视图是所有额外的统计信息
所在的地方


519
00:29:45,652 --> 00:29:48,522 line:-2
那么我将进到这里
这样我们能看到我们获取到


520
00:29:48,589 --> 00:29:49,590 line:-1
的一些东西


521
00:29:50,958 --> 00:29:54,628 line:-1
通过放大 我想要知道


522
00:29:54,695 --> 00:29:56,330 line:-1
这个工作流中的最爱照片


523
00:29:56,563 --> 00:29:59,099 line:-1
每次操作通过打开和关闭数据库


524
00:29:59,266 --> 00:30:02,002 line:-2
我们有1,002次不同的
物理I/O操作


525
00:30:02,069 --> 00:30:04,271 line:-1
总共占有低于6兆字节的内存


526
00:30:05,038 --> 00:30:07,708 line:-2
这看上去没有很多
但当我们和其他的相比


527
00:30:07,774 --> 00:30:11,078 line:-1
我们能更好地了解


528
00:30:11,144 --> 00:30:12,145 line:-1
为什么这个如此糟糕


529
00:30:12,813 --> 00:30:16,817 line:-2
那么这里我们有一些关于
延时和平均延时的统计信息


530
00:30:17,284 --> 00:30:19,553 line:-1
但我想要切换回总视图


531
00:30:20,053 --> 00:30:22,556 line:-2
因为我也注意到
在文件系统建议轨道中


532
00:30:22,623 --> 00:30:25,492 line:-1
我们有一些仪表给我们的通知


533
00:30:25,792 --> 00:30:28,862 line:-2
我想要进到里面
这样我们就能看到发生了什么


534
00:30:29,630 --> 00:30:31,431 line:-1
在底部 我们的详情视图


535
00:30:31,498 --> 00:30:33,534 line:-1
这里的详情视图的数量列


536
00:30:33,700 --> 00:30:36,403 line:-1
告诉我们一共有12条通知


537
00:30:37,704 --> 00:30:40,841 line:-2
如果我们到下拉框
我们会看到这些通知


538
00:30:40,908 --> 00:30:43,076 line:-1
是过度物理写入的精准描述


539
00:30:43,710 --> 00:30:47,080 line:-2
我们知道打开和关闭数据库不一定
是一件好事


540
00:30:47,147 --> 00:30:49,516 line:-1
我们将要尝试其他技术来实现


541
00:30:49,816 --> 00:30:53,153 line:-2
但我想从这个有着12则
文件系统通知的基线开始


542
00:30:53,220 --> 00:30:54,388 line:-1
文件活跃状态仪表


543
00:30:57,357 --> 00:31:00,761 line:-2
最后 我也想要聊一下
实际的文件系统活跃状态轨迹


544
00:31:01,161 --> 00:31:03,997 line:-2
我们能从中看到被调用的操作的
统计信息


545
00:31:04,064 --> 00:31:08,635 line:-2
比如写入和读入等等
但在这个表格这里


546
00:31:08,802 --> 00:31:11,839 line:-2
我们也获取到了我们app的
不同的逻辑的I/O视图


547
00:31:12,339 --> 00:31:14,107 line:-1
这里默认是文件系统统计信息


548
00:31:14,174 --> 00:31:17,444 line:-2
但我们也能找到下面的
文件描述符信息


549
00:31:21,048 --> 00:31:23,317 line:-1
好的 记住这一点 现在我要切回


550
00:31:23,383 --> 00:31:26,353 line:-2
到一个不同的模式
它会按需打开和关闭数据库


551
00:31:27,120 --> 00:31:30,023 line:-2
特别地 我会回到磁盘
使用量详情视图


552
00:31:30,557 --> 00:31:32,159 line:-1
我想要做的第一件事是


553
00:31:32,226 --> 00:31:35,395 line:-1
我们从1,002次物理I/O操作


554
00:31:35,462 --> 00:31:39,766 line:-2
跌到至54次 我们从6兆字节
的磁盘占有量


555
00:31:39,933 --> 00:31:43,003 line:-2
跌到288千字节
它的效果非常明显


556
00:31:43,070 --> 00:31:45,572 line:-1
当我们打开和关闭我们的数据库时


557
00:31:45,639 --> 00:31:47,841 line:-1
只用改变使用量模型就能轻易实现


558
00:31:49,610 --> 00:31:52,546 line:-1
更进一步 再次关注文件系统建议


559
00:31:52,846 --> 00:31:56,617 line:-2
我们从之前这么做的时候
是从12开始的


560
00:31:57,851 --> 00:31:58,952 line:-1
但现在我们只有3个了


561
00:31:59,353 --> 00:32:02,389 line:-2
这个还不是最理想的使用方式
我们还可以进一步优化


562
00:32:02,456 --> 00:32:05,325 line:-2
我们实现了不同的行为表现比如
日志登载


563
00:32:05,392 --> 00:32:06,393 line:-1
我们会看到这个数字改变


564
00:32:07,895 --> 00:32:10,397 line:-2
说到这 我们来开始介绍删除模式
日志登载


565
00:32:10,564 --> 00:32:12,032 line:-2
就像Kai提过的
删除模式日志登载


566
00:32:12,099 --> 00:32:13,534 line:-1
是SQLite默认设置


567
00:32:14,501 --> 00:32:17,871 line:-1
所以这里的这个统计页面和我之前


568
00:32:17,938 --> 00:32:20,741 line:-2
按需打开和关闭数据库所
展示的那个一样


569
00:32:21,041 --> 00:32:24,811 line:-2
所以我不会再展示整个轨迹
但我想要回收这些数字


570
00:32:25,179 --> 00:32:28,182 line:-2
54物理I/O操作
一共是288千字节


571
00:32:31,051 --> 00:32:33,353 line:-2
但当我们切换至使用WAL
模式日志登载的模型时


572
00:32:33,420 --> 00:32:35,589 line:-1
我想要讲一下一些有趣的现象


573
00:32:37,257 --> 00:32:40,194 line:-1
首先 现在我们在文件系统


574
00:32:40,260 --> 00:32:41,762 line:-1
建议轨道上有0个建议


575
00:32:42,362 --> 00:32:44,798 line:-2
我们之前有12条 最后变为3个
现在是0个


576
00:32:44,865 --> 00:32:48,068 line:-1
我们只是简单地使用了WAL模式


577
00:32:48,135 --> 00:32:49,136 line:-1
日志登载就做出了非常巨大的优化


578
00:32:50,337 --> 00:32:53,874 line:-1
我想讲的第二点是逻辑的


579
00:32:53,941 --> 00:32:55,175 line:-1
和物理的I/O之间的交互


580
00:32:55,676 --> 00:32:58,512 line:-2
特别要说的是
在这里的文件活跃状态轨道


581
00:32:58,579 --> 00:33:02,816 line:-2
我们看到了很多逻辑I/O
但没有看到一个物理I/O


582
00:33:02,883 --> 00:33:05,152 line:-1
直到我们停止app的轨迹


583
00:33:05,786 --> 00:33:06,887 line:-1
这为什么重要呢？


584
00:33:07,287 --> 00:33:09,389 line:-1
当我们和之前实现的比较时


585
00:33:09,623 --> 00:33:11,425 line:-1
使用删除模式日志登载


586
00:33:12,359 --> 00:33:13,560 line:-1
注意在删除模式日志登载里


587
00:33:13,627 --> 00:33:16,597 line:-2
每次我们有了文件系统活跃状态
逻辑I/O也是


588
00:33:16,663 --> 00:33:19,032 line:-2
我们也有了一个和它
相应的物理I/O


589
00:33:19,499 --> 00:33:21,969 line:-2
然而使用WAL模式日志登载
它非常好地利用了OS缓存


590
00:33:22,035 --> 00:33:24,872 line:-1
为我们提供了很多很棒的性能表现


591
00:33:26,773 --> 00:33:27,808 line:-1
想要更为仔细地了解它


592
00:33:27,875 --> 00:33:31,712 line:-2
我们能再一次回到文件系统活跃轨迹
关注详情视图


593
00:33:32,946 --> 00:33:35,549 line:-2
使用WAL模式日志登载
我们只有一个fsync调用


594
00:33:36,016 --> 00:33:38,919 line:-2
然而使用删除模式日志登载
我们一共有16个


595
00:33:39,753 --> 00:33:43,190 line:-2
所以WAL模式非常好地利用了
OS缓存的优势


596
00:33:46,693 --> 00:33:49,029 line:-1
接下来 我想讲的是我们如何实现


597
00:33:49,096 --> 00:33:50,097 line:-1
删除照片功能


598
00:33:50,163 --> 00:33:52,032 line:-2
我们讲过设置最爱
但我们也需要在app中移除


599
00:33:52,099 --> 00:33:53,700 line:-1
照片


600
00:33:54,501 --> 00:33:57,271 line:-2
我们要讲的第一件事是
调用单个声明数据处理


601
00:33:57,337 --> 00:33:59,673 line:-1
Kai也提到过的


602
00:34:00,407 --> 00:34:02,776 line:-2
特别地 当我们想要选择删除一张
照片


603
00:34:02,843 --> 00:34:04,678 line:-1
我们会选择左下脚的符号


604
00:34:05,078 --> 00:34:07,614 line:-2
我们会向数据库发送
一条删除查询语句


605
00:34:08,148 --> 00:34:10,184 line:-2
现在我们可以将这认为是一个
单个声明数据修改


606
00:34:10,250 --> 00:34:13,286 line:-2
因为我们在每张照片执行
这条删除查询


607
00:34:13,353 --> 00:34:15,188 line:-1
我们自己不会做任何合并


608
00:34:17,757 --> 00:34:20,494 line:-2
使用这个模型
这里的单个声明数据修改方式


609
00:34:20,561 --> 00:34:23,864 line:-2
我们也使用一些文件系统活跃状态
就和一些磁盘使用量一样


610
00:34:24,864 --> 00:34:26,766 line:-1
但值得关注的一点是这个方式


611
00:34:26,833 --> 00:34:29,503 line:-1
我们有111次不同的文件系统操作


612
00:34:31,304 --> 00:34:33,005 line:-1
到达磁盘使用量轨道


613
00:34:33,072 --> 00:34:36,710 line:-2
我们有12次写入
总共有72千字节的内存占用


614
00:34:39,246 --> 00:34:42,014 line:-2
接下来 我想要聊一下多次声明
数据修改


615
00:34:42,081 --> 00:34:44,717 line:-1
通过这些照片中的每一个


616
00:34:44,952 --> 00:34:46,286 line:-1
甚至是一个逻辑的视角


617
00:34:46,520 --> 00:34:49,456 line:-2
我们不想一次只删除这些照片中
的一个


618
00:34:49,523 --> 00:34:51,958 line:-2
合乎逻辑地 我们想要将它们
一次全部删除


619
00:34:52,359 --> 00:34:54,695 line:-2
我们为它使用SQLite
做了一种模拟


620
00:34:54,761 --> 00:34:57,531 line:-2
通过合并所有这些删除声明至一次
数据修改


621
00:34:57,731 --> 00:34:59,633 line:-2
所以我们在一个单次的数据修改中
做了多次声明


622
00:35:00,534 --> 00:35:04,137 line:-2
如果我们这样做
我们减少到了37次文件系统操作


623
00:35:04,204 --> 00:35:05,873 line:-1
所以我们显著地减少了工作量


624
00:35:06,974 --> 00:35:09,810 line:-2
除此之外 如果我们
查看磁盘使用量


625
00:35:10,611 --> 00:35:14,581 line:-2
我们的写入减少到了4个
内存减少至了24千字节


626
00:35:16,416 --> 00:35:17,684 line:-1
把它们并排一起看


627
00:35:18,185 --> 00:35:20,621 line:-1
我们开始一共有111次单个


628
00:35:20,687 --> 00:35:22,155 line:-1
声明数据修改的文件系统活动


629
00:35:22,489 --> 00:35:25,292 line:-2
我们使用多次声明数据修改
减少到了37次


630
00:35:26,260 --> 00:35:29,296 line:-2
回到这个这个是如何
转换到实际的物理的磁盘使用量


631
00:35:29,863 --> 00:35:33,000 line:-2
我们开始时有12次写入
一共72千字节


632
00:35:33,233 --> 00:35:35,502 line:-2
现在我们使用多次声明数据修改
减少至只有4次写入


633
00:35:35,569 --> 00:35:36,970 line:-1
一共24千字节


634
00:35:39,072 --> 00:35:41,975 line:-2
因为我们在介绍关于删除的话题
我们也应该了解清除


635
00:35:42,042 --> 00:35:44,044 line:-2
应为我们想保持我们的数据
被压缩


636
00:35:44,111 --> 00:35:45,479 line:-1
或尽可能紧凑


637
00:35:45,979 --> 00:35:47,414 line:-1
我们从一个全面的清理开始了解


638
00:35:47,948 --> 00:35:49,983 line:-2
在当前使用案例中 每次当我们
发出一条删除声明时


639
00:35:50,050 --> 00:35:51,618 line:-1
我们会发出一条清理声明


640
00:35:52,119 --> 00:35:55,656 line:-2
Kai告诉过我们全面清理
并不是实现它的最佳方案


641
00:35:55,722 --> 00:35:58,692 line:-2
但我们能看到它在文件活跃状态仪表
实际上是如何工作的


642
00:36:00,060 --> 00:36:04,631 line:-2
特别地 通过实现这个
我们一共有27次不同的I/O操作


643
00:36:04,698 --> 00:36:07,334 line:-2
发出一条全面的清理
使用了一共168千字节


644
00:36:09,736 --> 00:36:12,506 line:-1
但如果我们切换至使用增量清除呢


645
00:36:13,540 --> 00:36:14,608 line:-1
我们有一些不同的数字


646
00:36:15,342 --> 00:36:19,346 line:-2
我们为72千字节的存储占用
一共实现了12次I/O操作


647
00:36:22,549 --> 00:36:24,151 line:-1
再一次 把它们并排看


648
00:36:25,052 --> 00:36:27,588 line:-2
使用一个全面清理
I/O操作是27次


649
00:36:27,654 --> 00:36:29,790 line:-2
使用增量清理
I/O操作下降到了12


650
00:36:30,090 --> 00:36:35,395 line:-2
从全面清除的168K的总磁盘占用
减到了72


651
00:36:36,129 --> 00:36:38,232 line:-1
通过在SQLite中使用这些模式


652
00:36:38,298 --> 00:36:39,733 line:-1
它获取了颇多利益


653
00:36:44,271 --> 00:36:46,073 line:-1
那么 我现在想要总结一下


654
00:36:46,139 --> 00:36:49,376 line:-2
第一点是我想要你
吸取这些教训


655
00:36:49,443 --> 00:36:53,113 line:-2
无论你是在使用Core Data
SQLite或plist等等


656
00:36:53,180 --> 00:36:56,083 line:-2
我们想要你吸取这些教训
但也不只是这样


657
00:36:56,149 --> 00:36:59,152 line:-2
我们也希望你能使用文件
活跃状态仪表来验证它们


658
00:36:59,653 --> 00:37:02,022 line:-1
现在文件活跃状态仪表可能会


659
00:37:02,089 --> 00:37:04,958 line:-2
通过提供这些功能来帮你
但你可能有其他的一些


660
00:37:05,025 --> 00:37:07,728 line:-2
你甚至不知道的建议
文件活跃状态仪表


661
00:37:07,794 --> 00:37:10,531 line:-2
会将它们以可视化的方式提供给你
让你留意它们


662
00:37:12,399 --> 00:37:15,536 line:-2
记住这些 我们也希望你能持续
优化内存


663
00:37:15,869 --> 00:37:19,006 line:-1
除了眼前的这些内容之外还有更多


664
00:37:19,072 --> 00:37:20,440 line:-2
我们希望这些教训和
我们提供的这些工具


665
00:37:20,641 --> 00:37:22,242 line:-1
能为每个人带来好的体验


666
00:37:24,511 --> 00:37:27,981 line:-2
想要了解更多信息 今天晚些时候
我们会有一个关于性能的实验室


667
00:37:28,048 --> 00:37:31,051 line:-2
今年的WWDC
我们还有一个演讲是


668
00:37:31,118 --> 00:37:32,286 line:-2
关于使用Core Data
来创作app


669
00:37:32,352 --> 00:37:35,022 line:-2
如果你想要了解更多
关于如何使用它的话


670
00:37:37,691 --> 00:37:39,726 line:-2
感谢大家参加
请好好享受接下来的演讲

