1
00:00:00,506 --> 00:00:05,500
[音乐]


2
00:00:09,516 --> 00:00:12,616
[掌声]	


3
00:00:13,116 --> 00:00:14,076
>> 我是 Joe


4
00:00:14,076 --> 00:00:15,666
稍后我的同事


5
00:00:15,666 --> 00:00:17,276
Simon 和 Scott 也会加入


6
00:00:17,696 --> 00:00:19,766
我们来自 Core OS 组


7
00:00:19,766 --> 00:00:21,246
我们想告诉你关于


8
00:00:21,296 --> 00:00:22,816
macOS 10.15 Catalina 中


9
00:00:22,816 --> 00:00:26,046
内核扩展的一些新开发


10
00:00:28,276 --> 00:00:31,266
内核扩展或 Kext


11
00:00:31,266 --> 00:00:32,896
这项技术从一开始


12
00:00:32,896 --> 00:00:34,786
就是 macOS 的一部分


13
00:00:36,046 --> 00:00:37,796
使用 kexts


14
00:00:37,846 --> 00:00:39,846
你可以构建功能强大且创新的 App


15
00:00:40,246 --> 00:00:43,846
以扩展操作系统的内置功能


16
00:00:44,406 --> 00:00:47,386
这种扩展系统的能力


17
00:00:47,836 --> 00:00:51,246
是使 Mac 成为 Mac 的重要部分


18
00:00:51,806 --> 00:00:54,866
但是内核扩展


19
00:00:54,866 --> 00:00:55,926
存在一些问题


20
00:00:57,326 --> 00:00:59,166
它们很难开发


21
00:00:59,166 --> 00:01:02,406
而且调试时


22
00:01:02,456 --> 00:01:04,846
它们可能对机器的安全性


23
00:01:04,846 --> 00:01:07,086
和隐私性造成风险


24
00:01:07,086 --> 00:01:08,676
并且它们可能对系统的可靠性构成风险


25
00:01:09,756 --> 00:01:11,356
是时候升级了


26
00:01:12,816 --> 00:01:15,076
macOS Catalina 引入了


27
00:01:15,076 --> 00:01:17,066
两项新技术


28
00:01:17,066 --> 00:01:18,916
名为系统扩展和 DriverKit


29
00:01:20,106 --> 00:01:22,566
使用它们 你的 App 可以


30
00:01:22,736 --> 00:01:24,486
扩展操作系统


31
00:01:24,486 --> 00:01:26,656
比以往任何时候都


32
00:01:26,656 --> 00:01:29,436
更可靠 更安全


33
00:01:29,706 --> 00:01:30,536
更容易开发


34
00:01:31,056 --> 00:01:34,936
这就是我们今天要谈的内容


35
00:01:35,466 --> 00:01:37,136
首先我会介绍这些技术


36
00:01:37,136 --> 00:01:40,196
并向你们展示它们是如何避免


37
00:01:40,196 --> 00:01:42,676
内核扩展问题的


38
00:01:43,896 --> 00:01:46,166
然后 Simon 将向我们


39
00:01:46,166 --> 00:01:49,366
展示如何使用 DriverKit 构建驱动扩展


40
00:01:51,056 --> 00:01:53,176
Scott 将向我们展示如何


41
00:01:53,236 --> 00:01:55,526
编写和调试一个简单的 USB 驱动器


42
00:01:57,016 --> 00:01:58,346
然后我会告诉你们


43
00:01:58,346 --> 00:02:02,166
如何在 App 中包含系统扩展


44
00:02:02,166 --> 00:02:04,576
我们开始吧


45
00:02:04,656 --> 00:02:07,466
系统扩展是我们


46
00:02:07,466 --> 00:02:08,895
在 macOS Catalina 中的


47
00:02:08,946 --> 00:02:09,425
第一项新技术


48
00:02:10,126 --> 00:02:14,326
系统扩展是你 App 的一部分


49
00:02:14,326 --> 00:02:18,176
它以类似于内核扩展的方式


50
00:02:18,176 --> 00:02:20,176
扩展操作系统的功能


51
00:02:20,176 --> 00:02:22,456
但运行在内核之外的用户空间中


52
00:02:24,376 --> 00:02:26,256
在 Catalina 中 可以构建


53
00:02:26,256 --> 00:02:28,266
三种系统扩展


54
00:02:28,956 --> 00:02:30,656
它们是网络扩展


55
00:02:31,246 --> 00:02:34,936
驱动程序和端点安全程序扩展


56
00:02:36,826 --> 00:02:40,956
网络扩展是网络内核扩展的替代


57
00:02:42,616 --> 00:02:44,316
它们可以过滤和重新路由


58
00:02:44,316 --> 00:02:47,330
网络流量或连接到 VPN


59
00:02:48,516 --> 00:02:50,026
有关网络扩展的更多信息


60
00:02:50,026 --> 00:02:51,866
周五上午


61
00:02:51,866 --> 00:02:53,726
有一个专门针对它们的会议


62
00:02:56,596 --> 00:02:59,446
端点安全扩展替代的是


63
00:02:59,446 --> 00:03:03,066
可以使用 KAUTH 接口


64
00:03:03,066 --> 00:03:05,346
拦截和监视与安全


65
00:03:05,346 --> 00:03:06,636
相关事件的 Kext


66
00:03:07,616 --> 00:03:08,836
你可以通过这种方式


67
00:03:08,836 --> 00:03:10,866
构建的一些 App


68
00:03:10,866 --> 00:03:13,306
进行端点检测和响应以及数据丢失保护


69
00:03:14,406 --> 00:03:17,456
如果你对端点安全扩展感兴趣


70
00:03:17,456 --> 00:03:18,956
请访问安全实验室


71
00:03:19,476 --> 00:03:20,966
现在有一个正在进行中


72
00:03:20,966 --> 00:03:22,566
并在这次演讲后继续


73
00:03:23,056 --> 00:03:24,696
还有一个是在周四下午


74
00:03:25,276 --> 00:03:29,796
第三种类型的扩展是


75
00:03:29,796 --> 00:03:31,826
驱动扩展


76
00:03:31,826 --> 00:03:33,526
它可以替代使用 IOKit 


77
00:03:33,526 --> 00:03:34,856
的设备驱动 Kext 


78
00:03:35,576 --> 00:03:38,326
在 Catalina 中你可以控制


79
00:03:38,446 --> 00:03:41,396
USB 串口 网络接口


80
00:03:41,526 --> 00:03:43,206
和人机接口设备


81
00:03:45,056 --> 00:03:47,146
驱动扩展是


82
00:03:47,186 --> 00:03:49,196
用 DriverKit 构建的


83
00:03:49,196 --> 00:03:51,146
这是我们在 Catalina 中的第二项技术


84
00:03:52,566 --> 00:03:56,636
DriverKit 是一个新的 SDK 


85
00:03:56,636 --> 00:03:59,896
包含所有基于 IOKit 的新框架


86
00:03:59,976 --> 00:04:01,726
但经过了更新和变革


87
00:04:03,106 --> 00:04:04,566
旨在使用内核之外的


88
00:04:04,566 --> 00:04:07,836
用户空间构建驱动扩展


89
00:04:08,446 --> 00:04:11,386
现在我们已经遇到了这些新技术


90
00:04:11,386 --> 00:04:15,056
让我们看看它们是如何避免


91
00:04:15,056 --> 00:04:17,396
内核扩展的问题的


92
00:04:19,036 --> 00:04:20,826
在这两个定义中


93
00:04:20,826 --> 00:04:23,046
我都用了一个短语


94
00:04:23,046 --> 00:04:24,946
在内核之外的用户空间


95
00:04:26,016 --> 00:04:27,046
为什么这很重要？


96
00:04:28,386 --> 00:04:30,136
内核是一个非常苛刻


97
00:04:30,136 --> 00:04:32,806
且难以编程的环境


98
00:04:33,286 --> 00:04:36,816
内核管理着机器上


99
00:04:36,926 --> 00:04:38,146
发生的一切


100
00:04:38,146 --> 00:04:40,946
所以它永远不能停止运行


101
00:04:40,946 --> 00:04:43,016
永远不能等任何事情发生


102
00:04:43,016 --> 00:04:45,386
绝不能崩溃


103
00:04:46,776 --> 00:04:49,216
内核中的代码必须快速


104
00:04:49,216 --> 00:04:53,186
必须是可预测的


105
00:04:53,186 --> 00:04:56,706
必须节约使用内存等资源


106
00:04:56,706 --> 00:04:58,116
而且本质上不能有漏洞


107
00:04:59,316 --> 00:05:00,796
要编写满足


108
00:05:00,856 --> 00:05:02,526
所有这些限制的代码


109
00:05:02,576 --> 00:05:03,256
非常困难


110
00:05:05,236 --> 00:05:07,326
系统扩展在内核外的


111
00:05:07,326 --> 00:05:09,516
用户空间中运行


112
00:05:09,516 --> 00:05:11,246
这意味着它们运行在


113
00:05:11,246 --> 00:05:13,046
舒适的现代编程环境中


114
00:05:14,516 --> 00:05:16,596
这使得它们比 Kext 


115
00:05:16,596 --> 00:05:19,606
更容易开发


116
00:05:19,606 --> 00:05:21,816
因为内核代码对何时


117
00:05:21,816 --> 00:05:23,556
以及如何在线程之间


118
00:05:23,556 --> 00:05:25,186
分配内存或同步有限制


119
00:05:26,326 --> 00:05:27,736
这意味着它


120
00:05:27,736 --> 00:05:29,526
不能使用大多数系统框架


121
00:05:29,526 --> 00:05:31,106
比如 Foundation


122
00:05:31,106 --> 00:05:32,656
因为它们不是为在这种环境中运行而设计的


123
00:05:33,946 --> 00:05:35,416
Kext 开发中唯一支持的


124
00:05:35,416 --> 00:05:38,526
语言是 C 和 C++


125
00:05:39,906 --> 00:05:41,536
而另一方面 系统扩展


126
00:05:41,536 --> 00:05:43,456
没有这样的限制


127
00:05:44,006 --> 00:05:45,206
这意味着它们可以


128
00:05:45,566 --> 00:05:49,506
使用 macOS SDK 中的任何框架结构


129
00:05:50,026 --> 00:05:51,496
并且可以用包括


130
00:05:51,496 --> 00:05:53,056
Swift 在内的任何语言编写


131
00:05:54,516 --> 00:05:58,446
[掌声]


132
00:05:58,946 --> 00:06:00,266
但有一个例外


133
00:06:00,926 --> 00:06:02,706
驱动扩展由于


134
00:06:02,706 --> 00:06:04,046
与硬件关系密切


135
00:06:04,076 --> 00:06:06,866
仍然存在一些限制


136
00:06:08,026 --> 00:06:09,386
它们必须使用 


137
00:06:09,386 --> 00:06:11,526
DriverKit 框架并运行在


138
00:06:11,526 --> 00:06:13,476
并在定制的 Runtime 中运行


139
00:06:13,576 --> 00:06:16,026
从而将它们与系统的其余部分隔开


140
00:06:16,216 --> 00:06:18,356
驱动扩展必须


141
00:06:18,356 --> 00:06:20,126
用 C 或 C++ 编写


142
00:06:20,206 --> 00:06:22,736
而默认为 C++17


143
00:06:23,516 --> 00:06:27,586
[掌声]


144
00:06:28,086 --> 00:06:29,436
系统扩展也比


145
00:06:29,436 --> 00:06:31,796
内核扩展更容易调试


146
00:06:32,716 --> 00:06:34,326
将调试器附加到内核


147
00:06:34,326 --> 00:06:36,296
会使内核和整个机器


148
00:06:36,296 --> 00:06:39,166
包括调试器停止运行


149
00:06:40,126 --> 00:06:41,456
这意味着你通常


150
00:06:41,456 --> 00:06:43,616
需要第二台机器进行调试


151
00:06:43,616 --> 00:06:44,886
你可能需要


152
00:06:44,886 --> 00:06:47,286
特殊的线缆或网络配置来连接机器


153
00:06:47,816 --> 00:06:53,376
构建 测试和调试 Kext 的周期可能很慢


154
00:06:53,496 --> 00:06:55,146
因为 Kext 中的任何崩溃


155
00:06:55,146 --> 00:06:56,556
都意味着整个系统


156
00:06:56,556 --> 00:06:57,006
必须重新启动


157
00:06:57,656 --> 00:07:01,646
内核调试器的支持有限


158
00:07:01,976 --> 00:07:02,956
它无法执行


159
00:07:02,956 --> 00:07:04,646
诸如计算表达式或


160
00:07:04,646 --> 00:07:05,906
打印对象值之类的操作


161
00:07:06,346 --> 00:07:09,686
另一方面 系统扩展


162
00:07:09,686 --> 00:07:13,946
在调试的同时可以保持


163
00:07:14,196 --> 00:07:15,396
内核继续运行


164
00:07:16,966 --> 00:07:18,526
如果扩展程序崩溃


165
00:07:18,526 --> 00:07:19,706
无需重新启动


166
00:07:20,836 --> 00:07:22,796
你可以在一台具有


167
00:07:23,016 --> 00:07:25,966
完全调试支持的机器上构建 测试和调试所有内容


168
00:07:26,556 --> 00:07:30,246
但是与内核扩展相比


169
00:07:30,246 --> 00:07:32,246
系统扩展的最大改进


170
00:07:32,246 --> 00:07:37,316
是在安全性 私密性和可靠性方面


171
00:07:37,936 --> 00:07:42,436
内核有许多工作


172
00:07:42,436 --> 00:07:44,196
但最重要的一项是


173
00:07:44,196 --> 00:07:46,746
定义和执行


174
00:07:46,746 --> 00:07:48,276
系统安全策略的规则


175
00:07:49,266 --> 00:07:51,186
内核将 App 彼此分开


176
00:07:51,186 --> 00:07:53,836
并将 App 与对硬件的直接访问分开


177
00:07:54,606 --> 00:07:56,126
然后它允许它们


178
00:07:56,126 --> 00:07:57,816
遵循安全策略的规则


179
00:07:58,036 --> 00:08:00,706
共享数据和系统服务


180
00:08:01,226 --> 00:08:04,436
加载内核扩展时


181
00:08:04,846 --> 00:08:06,786
它将成为内核的一部分


182
00:08:07,896 --> 00:08:10,186
它可以访问机器上的所有内容


183
00:08:11,066 --> 00:08:13,186
这就是 Kext 强大的原因


184
00:08:13,686 --> 00:08:16,566
但它也可能是种危险


185
00:08:16,716 --> 00:08:18,886
因为内核扩展是


186
00:08:18,886 --> 00:08:22,936
制定安全规则的内核的一部分


187
00:08:22,936 --> 00:08:23,686
所以它在规则之上


188
00:08:24,256 --> 00:08:27,576
如果 Kext 有一个漏洞


189
00:08:27,576 --> 00:08:30,396
允许它被入侵


190
00:08:30,396 --> 00:08:34,576
它就可以接管整个机器


191
00:08:34,576 --> 00:08:36,556
做开发人员和用户从未想过


192
00:08:36,556 --> 00:08:37,176
要做的事情


193
00:08:37,916 --> 00:08:40,486
没有任何安全规则可以约束它


194
00:08:41,626 --> 00:08:43,166
这意味着 Kext 中的


195
00:08:43,166 --> 00:08:45,996
任何漏洞都可能是一个关键性的安全问题


196
00:08:46,546 --> 00:08:51,406
Kext 中的任何漏洞都可能十分危险


197
00:08:52,416 --> 00:08:55,226
发生了什么?


198
00:08:55,226 --> 00:08:56,166
我的幻灯片呢?


199
00:08:57,376 --> 00:09:01,066
Kext 中的任何漏洞都可能


200
00:09:01,066 --> 00:09:02,746
是一个关键的可靠性问题


201
00:09:03,516 --> 00:09:05,596
[掌声]


202
00:09:06,096 --> 00:09:08,116
因为内核不仅会崩溃


203
00:09:08,116 --> 00:09:09,956
还会发生致命错误


204
00:09:09,956 --> 00:09:11,236
并且整个机器都必须重启


205
00:09:11,916 --> 00:09:13,846
如果你是 Kext 开发人员


206
00:09:13,846 --> 00:09:15,476
你肯定会看到很多这个对话框


207
00:09:15,976 --> 00:09:19,186
不幸的是我们的用户也会看到


208
00:09:19,726 --> 00:09:22,166
让我们看看情况如何随着


209
00:09:22,166 --> 00:09:23,876
系统扩展而变化


210
00:09:25,136 --> 00:09:27,776
系统扩展在用户空间中运行


211
00:09:28,386 --> 00:09:30,406
与其他 App 一样


212
00:09:30,406 --> 00:09:32,796
它必须遵守系统安全策略的规则


213
00:09:33,746 --> 00:09:35,476
和其他 App 不一样的是


214
00:09:35,476 --> 00:09:37,166
系统扩展被授予


215
00:09:37,166 --> 00:09:39,106
执行特殊任务的特权


216
00:09:40,126 --> 00:09:42,726
比如 它可以直接访问


217
00:09:42,726 --> 00:09:44,786
相关的硬件设备


218
00:09:44,786 --> 00:09:46,706
或使用特殊的 API 


219
00:09:46,706 --> 00:09:48,256
与内核直接通信


220
00:09:49,706 --> 00:09:51,356
如果系统扩展崩溃


221
00:09:52,016 --> 00:09:53,636
系统和 App 的其余部分


222
00:09:53,636 --> 00:09:58,736
不受影响并继续运行


223
00:09:58,966 --> 00:10:00,906
基于所有这些原因


224
00:10:00,906 --> 00:10:02,916
我们认为系统扩展是


225
00:10:02,916 --> 00:10:04,976
Mac 平台向前迈出的一大步


226
00:10:05,566 --> 00:10:09,906
事实上我们认为它的改进效果十分显著


227
00:10:09,906 --> 00:10:11,426
我们建议你立刻采用


228
00:10:12,016 --> 00:10:14,726
正如 Sebastian 昨天


229
00:10:14,726 --> 00:10:17,006
在 Platforms State of the Union 中所说


230
00:10:17,006 --> 00:10:20,196
我们已经开始弃用内核扩展的进程


231
00:10:20,926 --> 00:10:23,256
macOS 10.15 Catalina 将是


232
00:10:23,256 --> 00:10:25,446
最后一个完全


233
00:10:25,446 --> 00:10:27,416
支持内核扩展的版本


234
00:10:28,516 --> 00:10:32,036
[掌声]


235
00:10:32,536 --> 00:10:33,946
具体来说


236
00:10:33,946 --> 00:10:35,876
对于系统扩展所支持的功能


237
00:10:35,876 --> 00:10:37,296
和 DriverKit


238
00:10:37,296 --> 00:10:39,036
支持的设备系列


239
00:10:39,646 --> 00:10:41,246
使用内核扩展来执行


240
00:10:41,246 --> 00:10:43,506
相同的工作现在已被弃用


241
00:10:44,336 --> 00:10:46,026
未来的 macOS 版本


242
00:10:46,026 --> 00:10:48,846
将不会加载这些种类的内核扩展


243
00:10:49,416 --> 00:10:53,326
在未来的版本中


244
00:10:53,326 --> 00:10:55,196
我们将向 DriverKit 添加


245
00:10:55,446 --> 00:10:56,776
更多种类的系统扩展


246
00:10:56,776 --> 00:10:57,406
和更多的设备系列


247
00:10:58,576 --> 00:11:00,536
反过来这些类型的


248
00:11:00,536 --> 00:11:02,976
内核扩展也将被弃用


249
00:11:07,046 --> 00:11:10,356
所以这是对系统扩展的简要介绍


250
00:11:11,726 --> 00:11:13,566
它们通过在用户空间中运行


251
00:11:13,566 --> 00:11:15,406
来避免内核编程的困难


252
00:11:15,406 --> 00:11:17,336
这使得你的 App 能够


253
00:11:17,336 --> 00:11:19,266
以更易于开发和


254
00:11:19,266 --> 00:11:22,176
调试的方式扩展系统


255
00:11:22,866 --> 00:11:25,856
从而保护用户数据的


256
00:11:25,856 --> 00:11:28,766
安全性和可靠性


257
00:11:29,246 --> 00:11:32,666
现在我想把它交给 Simon


258
00:11:32,666 --> 00:11:34,136
他将向你展示如何使用新的


259
00:11:34,136 --> 00:11:35,696
DriverKit Runtime


260
00:11:35,956 --> 00:11:37,606
构建驱动扩展


261
00:11:38,516 --> 00:11:44,546
[掌声]


262
00:11:45,046 --> 00:11:46,986
谢谢 Joe


263
00:11:47,696 --> 00:11:50,006
正如 Joe 刚才所说


264
00:11:50,006 --> 00:11:51,276
驱动扩展是一种


265
00:11:51,276 --> 00:11:53,296
新型的系统扩展


266
00:11:53,296 --> 00:11:55,236
它控制硬件设备并使其服务


267
00:11:55,236 --> 00:11:57,386
在整个 OS 中可用


268
00:11:58,726 --> 00:11:59,676
我们将这些新的


269
00:11:59,676 --> 00:12:01,346
驱动扩展称为 Dext


270
00:12:02,726 --> 00:12:03,726
我们的目标是


271
00:12:03,726 --> 00:12:05,046
尽可能简化


272
00:12:05,046 --> 00:12:08,496
从内核扩展到驱动扩展的过渡


273
00:12:10,306 --> 00:12:11,286
为了向你展示


274
00:12:11,286 --> 00:12:12,826
驱动扩展是如何工作的


275
00:12:12,826 --> 00:12:14,356
以及如何构建自己的扩展或从 Kext 过渡


276
00:12:14,356 --> 00:12:17,000
我们将讨论四件事


277
00:12:19,736 --> 00:12:21,466
我们将讨论它们的


278
00:12:21,806 --> 00:12:22,126
生命周期


279
00:12:22,976 --> 00:12:25,000
它们如何匹配和启动


280
00:12:31,266 --> 00:12:32,766
以及它们如何与 Kext 竞争


281
00:12:33,246 --> 00:12:34,616
我们将讨论如何


282
00:12:34,616 --> 00:12:36,856
使用新的 DriverKit SDK 构建它们


283
00:12:36,856 --> 00:12:39,596
我们将讨论一些安全特性


284
00:12:39,596 --> 00:12:41,656
比如权限


285
00:12:42,206 --> 00:12:44,486
最后我们来讨论有关


286
00:12:44,486 --> 00:12:45,816
兼容性问题


287
00:12:45,816 --> 00:12:47,146
如何将 App 部署到 macOS Catalina


288
00:12:47,726 --> 00:12:49,546
和 Mojave 上


289
00:12:55,596 --> 00:12:56,276
首先让我们来讨论


290
00:12:56,276 --> 00:12:57,526
Kext 的生命周期


291
00:13:02,066 --> 00:13:04,396
我们看看当具有驱动扩展的设备出现时


292
00:13:04,396 --> 00:13:05,626
发生的过程


293
00:13:06,566 --> 00:13:07,956
我们从 IOKit 匹配开始


294
00:13:07,956 --> 00:13:09,596
创建一个代表


295
00:13:09,596 --> 00:13:10,746
你服务的内核服务


296
00:13:11,406 --> 00:13:12,386
这是 Apple 编写的


297
00:13:13,076 --> 00:13:17,856
然后我们启动一个托管驱动的进程


298
00:13:17,856 --> 00:13:19,236
并对你的 DriverKit 类


299
00:13:19,236 --> 00:13:20,266
进行实例化


300
00:13:20,876 --> 00:13:23,936
并且该进程同时也包含


301
00:13:23,936 --> 00:13:26,896
其使用的任何服务的代理对象


302
00:13:27,116 --> 00:13:28,096
比如它的提供者


303
00:13:29,446 --> 00:13:32,636
此设备正在使用 USB 设备或设备


304
00:13:33,136 --> 00:13:34,776
这个设备使用 USB 设备


305
00:13:34,776 --> 00:13:36,846
所以它有一个用于调用的代理对象


306
00:13:36,846 --> 00:13:38,706
代表内核设备


307
00:13:39,246 --> 00:13:41,796
这意味着 DriverKit


308
00:13:42,306 --> 00:13:43,866
驱动程序与


309
00:13:43,866 --> 00:13:45,876
内核扩展一样


310
00:13:45,876 --> 00:13:47,286
可以竞争内核驱动的匹配


311
00:13:47,956 --> 00:13:50,126
你可以使用像 IOReg 等工具


312
00:13:50,496 --> 00:13:52,186
在注册表中查看它们


313
00:13:52,186 --> 00:13:54,286
并且可以将 IOKit 框架 API


314
00:13:54,966 --> 00:13:56,986
与它们一起使用


315
00:13:57,186 --> 00:13:58,966
由于 DriverKit 驱动程序


316
00:13:58,966 --> 00:14:00,566
与内核相互分离


317
00:14:00,566 --> 00:14:02,606
因此另一个设备将


318
00:14:02,606 --> 00:14:03,946
拥有自己的进程


319
00:14:03,946 --> 00:14:08,256
和另一个驱动实例


320
00:14:08,416 --> 00:14:11,326
在 macOS Catalina 中 Apple 已经


321
00:14:11,326 --> 00:14:14,256
开始将自己的几个驱动迁移到驱动扩展中


322
00:14:15,566 --> 00:14:16,886
在这里你可以看到


323
00:14:16,886 --> 00:14:18,526
一个托管 USB 网络设备的进程


324
00:14:18,526 --> 00:14:21,006
该设备在注册表中


325
00:14:21,006 --> 00:14:22,736
作为普通以太网设备


326
00:14:22,736 --> 00:14:26,896
对 OS 的其余部分可见


327
00:14:26,896 --> 00:14:27,966
你还可以在注册表中


328
00:14:27,966 --> 00:14:31,936
看到托管 HID 和串行驱动程序的其他进程


329
00:14:31,936 --> 00:14:35,806
现在我们将讨论如何


330
00:14:35,806 --> 00:14:36,896
使用 DriverKit SDK


331
00:14:36,896 --> 00:14:40,006
构建驱动扩展


332
00:14:42,056 --> 00:14:44,756
我们想让构建驱动扩展


333
00:14:44,756 --> 00:14:46,136
对于目前正在构建 Kext 的人来说


334
00:14:46,136 --> 00:14:47,866
是一个简单的过渡


335
00:14:48,276 --> 00:14:50,396
所以我们从你熟悉的 


336
00:14:50,396 --> 00:14:52,406
IOKit C++ API 开始


337
00:14:53,556 --> 00:14:55,206
DriverKit API 是 IOKit API


338
00:14:55,206 --> 00:14:57,816
在用户空间的扩展


339
00:14:58,366 --> 00:14:59,436
我们将它们收集到一个


340
00:14:59,436 --> 00:15:01,496
新的 DriverKit SDK 中


341
00:15:01,496 --> 00:15:04,916
它独立于 macOS SDK


342
00:15:05,166 --> 00:15:07,456
此 SDK 有一个用于可靠性


343
00:15:07,646 --> 00:15:09,186
和安全性的有限 API 外表


344
00:15:09,186 --> 00:15:12,036
并且没有对文件系统


345
00:15:12,036 --> 00:15:15,536
网络或模拟消息的直接访问


346
00:15:16,166 --> 00:15:19,306
这使得 Apple 能够根据


347
00:15:19,306 --> 00:15:21,066
正在运行的驱动程序


348
00:15:21,066 --> 00:15:24,666
调整用户空间进程


349
00:15:24,666 --> 00:15:25,726
并赋予其更高的优先级


350
00:15:25,726 --> 00:15:26,306
和更强的功能


351
00:15:27,026 --> 00:15:30,006
让我们来谈谈


352
00:15:30,006 --> 00:15:31,536
DriverKit SDK 中的一些类


353
00:15:32,326 --> 00:15:35,686
首先 IOService 类


354
00:15:35,686 --> 00:15:37,146
存在于 DriverKit 中


355
00:15:37,146 --> 00:15:40,736
与 IOKit 类非常相似


356
00:15:40,916 --> 00:15:42,706
还有 IOMemoryDescriptor


357
00:15:42,706 --> 00:15:45,356
和 IOBufferMemoryDescriptor 类


358
00:15:45,356 --> 00:15:49,556
与 IOKit 非常相似


359
00:15:49,656 --> 00:15:52,286
IOKit 中的 IOWorkLoop 


360
00:15:50,886 --> 00:15:52,286
和 EventSource 类


361
00:15:52,286 --> 00:15:53,376
也有对应的替代


362
00:15:54,176 --> 00:15:57,546
最后还有一个名为


363
00:15:57,546 --> 00:15:59,746
OSAction 的新类


364
00:15:59,746 --> 00:16:01,316
表示 C 函数指针


365
00:16:04,716 --> 00:16:06,246
那让我们来看看


366
00:16:06,246 --> 00:16:11,396
仔细看看其中的一些类


367
00:16:11,466 --> 00:16:13,196
IOService 类具有 IOKit 的


368
00:16:13,196 --> 00:16:14,876
生命周期 API


369
00:16:14,876 --> 00:16:16,186
如开始 暂停和终止


370
00:16:17,596 --> 00:16:22,096
对于同步


371
00:16:22,256 --> 00:16:23,846
每个 IOService 都有一个


372
00:16:23,846 --> 00:16:26,366
默认的 DispatchQueue 


373
00:16:26,366 --> 00:16:27,816
所有的方法都在一个队列上调用


374
00:16:27,816 --> 00:16:28,856
包括中断 定时器


375
00:16:28,856 --> 00:16:33,246
以及完成 IODispatchQueue 是基于


376
00:16:33,246 --> 00:16:36,286 
Grand Central Dispatch 代码之上的


377
00:16:36,286 --> 00:16:38,846
是针对在受限 DriverKit 环境中运行


378
00:16:38,846 --> 00:16:39,406
而优化的特殊版本


379
00:16:40,876 --> 00:16:42,556
驱动可以控制其他队列


380
00:16:42,556 --> 00:16:44,746
并知道调用哪些方法


381
00:16:44,746 --> 00:16:47,086
在哪些队列上进行高级使用


382
00:16:47,656 --> 00:16:52,336
事件 API 类似于


383
00:16:52,336 --> 00:16:53,776
IOKit 中的 IOWorkLoop 模型


384
00:16:53,776 --> 00:17:00,136
但现在基于 Grand Central Dispatch API


385
00:17:00,336 --> 00:17:01,876
其中包含用于中断和计时器的


386
00:17:01,876 --> 00:17:02,936
队列和调度源


387
00:17:04,256 --> 00:17:09,056
块 API 替代了 IOCommandGate


388
00:17:09,056 --> 00:17:10,866
GCD 提供了易于使用的同步参数


389
00:17:10,866 --> 00:17:13,736
这些参数你可能非常熟悉


390
00:17:15,056 --> 00:17:16,146
还有一个


391
00:17:16,146 --> 00:17:18,006
IOSharedDataQueueDispatchSource 类


392
00:17:18,006 --> 00:17:19,806
它提供了一个


393
00:17:19,806 --> 00:17:23,425
共享内存缓冲区


394
00:17:23,425 --> 00:17:24,476
用于快速低开销的消息传递


395
00:17:24,776 --> 00:17:28,556
我们将讨论的最后一个类


396
00:17:28,556 --> 00:17:31,636
是 OSAction 


397
00:17:31,636 --> 00:17:32,906
它封装了


398
00:17:32,906 --> 00:17:34,986
IOKit API 的回调


399
00:17:35,576 --> 00:17:38,196
它们总是异步的


400
00:17:38,196 --> 00:17:39,686
并且私有地保存回调


401
00:17:39,686 --> 00:17:40,566
客户端的状态


402
00:17:41,236 --> 00:17:43,806
它们允许以


403
00:17:43,806 --> 00:17:45,086
任意方式定义回调参数


404
00:17:45,086 --> 00:17:48,166
和在编译和运行时中的类型检查


405
00:17:48,806 --> 00:17:51,036
所以 DriverKit 中


406
00:17:51,036 --> 00:17:52,136
有一些类


407
00:17:52,366 --> 00:17:53,396
让我们看看


408
00:17:53,396 --> 00:17:55,046
如何定义这些与


409
00:17:55,046 --> 00:17:56,726
IOKit 略有不同的类


410
00:17:58,576 --> 00:17:59,996
DriverKit 接口使用


411
00:17:59,996 --> 00:18:04,876
扩展名为 .iig 的新文件类型进行描述


412
00:18:04,876 --> 00:18:06,396
并且它们由名为


413
00:18:06,396 --> 00:18:08,000
IIG 的工具处理


414
00:18:09,116 --> 00:18:11,376
IIG 文件是一个


415
00:18:11,376 --> 00:18:12,976
编译的类定义


416
00:18:12,976 --> 00:18:15,086
可以导入常见类型


417
00:18:15,086 --> 00:18:18,596
和结构的的 C 和 C++ 头文件


418
00:18:19,166 --> 00:18:21,796
但是它的类和方法的定义中


419
00:18:21,796 --> 00:18:23,006
确实有额外的属性


420
00:18:23,006 --> 00:18:25,016
允许使用它


421
00:18:25,016 --> 00:18:27,396
用于从单独的


422
00:18:27,396 --> 00:18:29,046
地址空间调用


423
00:18:29,516 --> 00:18:35,346
在这里你可以看到一个基本的类定义


424
00:18:35,346 --> 00:18:37,356
它看起来很普通


425
00:18:37,356 --> 00:18:39,296
但是有一些额外的属性


426
00:18:39,296 --> 00:18:40,706
比如类中的 KERNEL


427
00:18:40,706 --> 00:18:41,696
这意味着类是在内核中定义的


428
00:18:42,856 --> 00:18:44,146
以及一些方法声明中的 LOCAL


429
00:18:44,146 --> 00:18:45,846
这意味着


430
00:18:45,846 --> 00:18:47,576
方法是在用户驱动中实现的


431
00:18:47,576 --> 00:18:51,646
今天 macOS Catalina 开发人员预览版中


432
00:18:51,646 --> 00:18:54,006
提供的一些系列包括


433
00:18:54,006 --> 00:18:56,266
是用于创建网络接口的


434
00:18:56,266 --> 00:18:58,836
NetworkingDriverKit


435
00:19:00,276 --> 00:19:01,936
用于创建 HID 设备的  


436
00:19:01,936 --> 00:19:02,606
HIDDriverKit


437
00:19:04,836 --> 00:19:07,336
用于为操作系统提供 USB 


438
00:19:07,476 --> 00:19:09,306
串行设备的 USBSerialDriverKit


439
00:19:09,306 --> 00:19:12,756
以及用于在驱动程序中


440
00:19:12,786 --> 00:19:14,486
使用 USB 设备提供程序的


441
00:19:14,486 --> 00:19:15,166
USBDriverKit


442
00:19:17,326 --> 00:19:18,226
Scott 一会儿


443
00:19:18,226 --> 00:19:20,016
会演示 USBDriverKit


444
00:19:20,536 --> 00:19:22,506
对 USB 设备的支持


445
00:19:22,506 --> 00:19:26,456
现在我们将讨论


446
00:19:26,456 --> 00:19:28,376
开发驱动扩展的


447
00:19:28,596 --> 00:19:30,186
一些安全性方面


448
00:19:30,866 --> 00:19:34,196
你的驱动扩展


449
00:19:34,276 --> 00:19:37,636
需要获得一些类型的授权


450
00:19:38,976 --> 00:19:40,346
有些授权是所有驱动扩展


451
00:19:40,346 --> 00:19:42,886
都必须获得的


452
00:19:42,886 --> 00:19:44,466
还有一种被称为


453
00:19:44,466 --> 00:19:45,886
传输授权


454
00:19:46,626 --> 00:19:48,376
是特定于某类设备的


455
00:19:48,926 --> 00:19:53,206
还有一个系列的授权


456
00:19:53,206 --> 00:19:56,086
是向操作系统提供服务所需的权限


457
00:19:56,786 --> 00:19:58,256
Joe 稍后将在本次会议中


458
00:19:58,296 --> 00:19:59,716
讨论代码签名


459
00:19:59,716 --> 00:20:01,976
和获取这些授权的批准过程


460
00:20:02,716 --> 00:20:07,466
现在我们将快速了解部署


461
00:20:07,466 --> 00:20:10,276
适用于所有 macOS 版本的产品


462
00:20:11,866 --> 00:20:15,806
为 macOS Catalina 和较早的版本


463
00:20:15,806 --> 00:20:17,756
部署产品需要


464
00:20:17,756 --> 00:20:21,806
为旧版本安装内核扩展


465
00:20:21,806 --> 00:20:23,476
但要在 macOS Catalina 上


466
00:20:23,476 --> 00:20:25,366
使用系统扩展框架并


467
00:20:25,366 --> 00:20:26,356
提供驱动扩展


468
00:20:27,026 --> 00:20:29,876
现在 Scott 将演示


469
00:20:29,876 --> 00:20:33,096
如何使用新的 USBDriverKit 框架


470
00:20:34,096 --> 00:20:41,936
谢谢 Scott [掌声]


471
00:20:42,436 --> 00:20:43,366
>> 谢谢 Simon


472
00:20:43,686 --> 00:20:45,116
那么今天我将向你展示如何


473
00:20:45,116 --> 00:20:47,396
构建一个简单的 USB 驱动


474
00:20:47,396 --> 00:20:48,356
该驱动使用新的


475
00:20:48,356 --> 00:20:50,156
USBDriverKit 框架


476
00:20:50,156 --> 00:20:52,016
从中断端点读取数据


477
00:20:52,316 --> 00:20:53,786
我们将简要介绍


478
00:20:53,786 --> 00:20:55,396
如何使用 DriverKit 模板


479
00:20:55,396 --> 00:20:56,626
在 Xcode 中创建一个新项目


480
00:20:57,376 --> 00:20:58,636
之后我们将看一个


481
00:20:58,636 --> 00:21:00,916
内核类和 DriverKit 类的对比


482
00:21:01,786 --> 00:21:02,816
然后接下来我将


483
00:21:02,816 --> 00:21:04,966
详细介绍 DriverKit 中的实现


484
00:21:05,326 --> 00:21:06,566
最后我将简要


485
00:21:09,326 --> 00:21:10,676
使用 LLDB 调试 Dext 


486
00:21:10,676 --> 00:21:15,776
使用 Xcode 创建一个新的 DriverKit 项目


487
00:21:15,776 --> 00:21:17,556
非常简单


488
00:21:17,556 --> 00:21:18,746
只要在 Xcode 的


489
00:21:18,746 --> 00:21:20,836
新项目工作流程中选择合适的模板


490
00:21:21,516 --> 00:21:23,126
完成后 Xcode 将


491
00:21:23,126 --> 00:21:24,316
自动生成一些文件以帮助


492
00:21:24,316 --> 00:21:28,906
你开始生成的项目包括


493
00:21:28,906 --> 00:21:29,956
成功构建所需的


494
00:21:29,956 --> 00:21:30,896
标准文件


495
00:21:30,896 --> 00:21:33,316
与内核扩展一样


496
00:21:33,416 --> 00:21:36,616
该项目包括 C++ 实现 权限和


497
00:21:36,616 --> 00:21:37,666
info.pist


498
00:21:38,866 --> 00:21:41,076
除此之外 Xcode 


499
00:21:41,076 --> 00:21:43,106
还生成了 Simon 之前提到的 


500
00:21:43,106 --> 00:21:44,286
IIG 文件


501
00:21:45,106 --> 00:21:46,206
这个文件包括含


502
00:21:46,256 --> 00:21:47,806
驱动的类定义


503
00:21:49,026 --> 00:21:49,996
因此让我们看一下


504
00:21:49,996 --> 00:21:53,146
MyUserUSBInterfaceDriver 的类定义


505
00:21:53,686 --> 00:21:56,916
你可以看到它看起来


506
00:21:56,916 --> 00:21:58,486
与内核驱动非常相似


507
00:21:59,116 --> 00:22:01,016
例如相同的公共


508
00:22:01,016 --> 00:22:02,476
IOKit 生命周期方法


509
00:22:02,476 --> 00:22:03,786
Start 和 Stop 现有的 DriverKit


510
00:22:03,786 --> 00:22:04,786
首字母将被大写


511
00:22:05,976 --> 00:22:07,866
尽管如此还是有一些


512
00:22:07,866 --> 00:22:08,966
细微但重要的区别


513
00:22:10,746 --> 00:22:12,346
首先 DriverKit 类


514
00:22:12,346 --> 00:22:13,766
需要一个带有


515
00:22:13,766 --> 00:22:14,936
附加属性的不同回调


516
00:22:15,416 --> 00:22:17,246
此属性指示


517
00:22:17,306 --> 00:22:18,346
此方法符合


518
00:22:18,346 --> 00:22:20,276
IOUSBHostPipe 对象定义的


519
00:22:20,276 --> 00:22:21,766
回调类型


520
00:22:21,766 --> 00:22:23,986
并强制执行编译时类型检查


521
00:22:24,816 --> 00:22:26,486
第二 DriverKit 类中


522
00:22:26,486 --> 00:22:28,996
没有声明实例变量


523
00:22:29,816 --> 00:22:31,786
这是因为在初始化期间


524
00:22:31,786 --> 00:22:33,296
必须由驱动


525
00:22:33,296 --> 00:22:35,086
分配所有实例变量


526
00:22:35,636 --> 00:22:36,836
让我们来看看


527
00:22:36,836 --> 00:22:37,466
MyUserUSBInterfaceDriver


528
00:22:37,466 --> 00:22:39,556
是如何完成的


529
00:22:41,116 --> 00:22:42,876
首先你需要


530
00:22:42,876 --> 00:22:44,446
声明一个结构来保存


531
00:22:44,446 --> 00:22:45,166
所有实例变量


532
00:22:45,926 --> 00:22:47,046
以前属于内核类的


533
00:22:47,046 --> 00:22:48,496
所有实例变量都应该是


534
00:22:48,496 --> 00:22:50,796
此结构的一部分


535
00:22:51,656 --> 00:22:53,096
对于这个类我们有指向


536
00:22:53,096 --> 00:22:55,726
与 Kext 相同的 USB 内核类型的指针


537
00:22:56,326 --> 00:22:58,296
例如执行 IO 的


538
00:22:58,296 --> 00:23:01,226
IOUSBHostInterface 提供者


539
00:23:01,226 --> 00:23:02,396
和 IOUSBHostPipe 对象


540
00:23:02,396 --> 00:23:05,086
还有一个 OSAction 对象


541
00:23:05,086 --> 00:23:08,196
用于封装异步 IO 的回调


542
00:23:08,776 --> 00:23:10,646
然后你只需在


543
00:23:10,646 --> 00:23:12,576
初始化例程期间分配结构


544
00:23:13,126 --> 00:23:16,536
这是 MyUserUSBInterfaceDriver 


545
00:23:16,536 --> 00:23:18,516
的初始化例程


546
00:23:19,016 --> 00:23:21,136
它以与 Kext 相同的方式 


547
00:23:21,136 --> 00:23:22,246
对父类调用 init


548
00:23:22,596 --> 00:23:24,486
然后它分配了实例变量结构


549
00:23:25,826 --> 00:23:27,546
应该注意的是


550
00:23:27,546 --> 00:23:29,116
父类定义了一个实例变量成员


551
00:23:29,646 --> 00:23:31,156
该成员必须赋值为


552
00:23:31,156 --> 00:23:32,706
分配的结果


553
00:23:33,726 --> 00:23:35,436
接下来我们将看一下


554
00:23:35,436 --> 00:23:37,206
Start 的实现


555
00:23:38,136 --> 00:23:40,216
Start 的这一部分


556
00:23:40,216 --> 00:23:43,256
负责调用父类并验证提供者


557
00:23:44,476 --> 00:23:45,756
这里的内容


558
00:23:45,756 --> 00:23:47,466
与内核实现略有不同


559
00:23:49,596 --> 00:23:50,946
你可以看到定义


560
00:23:50,946 --> 00:23:52,156
包含在宏 IMPL 中


561
00:23:52,156 --> 00:23:53,986
并且该宏需要


562
00:23:53,986 --> 00:23:55,706
支持用户进程


563
00:23:55,706 --> 00:23:58,556
和内核代理对象之间的 IPC 通信


564
00:23:59,736 --> 00:24:01,616
而且你也可以看到


565
00:24:01,616 --> 00:24:03,586
调用父类的 Start


566
00:24:04,036 --> 00:24:06,266
采取了不同的形式


567
00:24:07,236 --> 00:24:09,806
接下来使用 USBDriverKit API


568
00:24:09,806 --> 00:24:11,596
打开 IOUSB 主机接口


569
00:24:11,596 --> 00:24:16,666
并分配管道对象


570
00:24:18,826 --> 00:24:19,806
然后分配一个


571
00:24:19,806 --> 00:24:20,976
用于 IO 的内存描述


572
00:24:22,096 --> 00:24:23,286
这应该是一个


573
00:24:23,286 --> 00:24:24,606
相当熟悉的范例


574
00:24:24,606 --> 00:24:26,000
基本上与 Kext 中的相同


575
00:24:30,096 --> 00:24:31,196
在这种情况下


576
00:24:31,296 --> 00:24:32,926
我们正在执行异步 IO


577
00:24:32,926 --> 00:24:34,766
所以我们需要分配一个 OSAction 对象


578
00:24:34,856 --> 00:24:35,926
来封装回调


579
00:24:37,566 --> 00:24:38,636
然后最后剩下的


580
00:24:38,636 --> 00:24:40,136
就是将 IO 排入队列


581
00:24:41,756 --> 00:24:43,576
此时假设


582
00:24:43,576 --> 00:24:45,846
设置成功 则会


583
00:24:45,846 --> 00:24:47,136
进行异步读取完成后我们


584
00:24:47,136 --> 00:24:48,736
将调用 ReadComplete 


585
00:24:49,026 --> 00:24:50,406
此驱动的 ReadComplete 方法


586
00:24:50,406 --> 00:24:53,866
将打印传输的字节数和状态


587
00:24:54,116 --> 00:24:55,916
如果成功的话 它会重新排列 IO 队列


588
00:24:56,356 --> 00:24:58,456
接下来我们来看看


589
00:24:58,456 --> 00:25:01,536
运行中的驱动


590
00:25:02,246 --> 00:25:04,026
因此在本演示中


591
00:25:04,026 --> 00:25:05,186
你将看到我已添加到


592
00:25:05,186 --> 00:25:07,516
MyUserUSBInterfaceDriver


593
00:25:07,516 --> 00:25:11,646
的一些日志记录用来打印生命周期方法


594
00:25:15,426 --> 00:25:17,966
我还添加了一个无限循环


595
00:25:18,556 --> 00:25:20,536
我们将使用 LDB 进行调试


596
00:25:20,536 --> 00:25:23,856
然后我还制造了一个崩溃


597
00:25:23,856 --> 00:25:27,946
我们可以看到现在如何


598
00:25:27,986 --> 00:25:29,236
使用新的 DriverKit 框架


599
00:25:29,236 --> 00:25:30,326
进行恢复


600
00:25:30,956 --> 00:25:32,676
因此如果我插入设备


601
00:25:32,676 --> 00:25:34,396
你可以看到初始化开始运行


602
00:25:34,396 --> 00:25:35,416
就像在 Kext 一样


603
00:25:35,726 --> 00:25:39,176
当数据向设备转移时


604
00:25:39,246 --> 00:25:41,236
ReadComplete 被调用


605
00:25:41,236 --> 00:25:46,396
使用 PS 我们可以看到


606
00:25:46,956 --> 00:25:47,926
驱动正在运行


607
00:25:48,826 --> 00:25:50,506
现在我们已经到达了


608
00:25:50,506 --> 00:25:51,506
我添加的无限循环


609
00:25:51,506 --> 00:25:53,326
我们可以用 LDB 看看


610
00:25:53,326 --> 00:25:54,976
在驱动中发生了什么


611
00:26:02,356 --> 00:26:03,616
从前面


612
00:26:03,616 --> 00:26:06,086
我们看到 PID 是 2572


613
00:26:06,086 --> 00:26:07,586
我们需要连接到那个进程


614
00:26:15,116 --> 00:26:16,456
我们需要找到运行 


615
00:26:16,456 --> 00:26:17,906
ReadComplete 方法的线程


616
00:26:19,386 --> 00:26:22,286
可以看到是线程 2


617
00:26:24,436 --> 00:26:26,656
这里我们遇到了


618
00:26:26,656 --> 00:26:27,436
一个无限循环


619
00:26:27,496 --> 00:26:28,356
因为我们在用户空间运行


620
00:26:28,356 --> 00:26:30,976
我们可以修改我们的循环变量


621
00:26:36,306 --> 00:26:37,726
在我继续之前


622
00:26:37,726 --> 00:26:39,316
如果你仔细观察


623
00:26:39,836 --> 00:26:41,506
你会发现肯定有一个


624
00:26:41,506 --> 00:26:43,346
空指针引用


625
00:26:43,346 --> 00:26:44,276
会使驱动崩溃


626
00:26:44,796 --> 00:26:48,206
你可以看到它已经崩溃了


627
00:26:49,646 --> 00:26:51,146
但是在不影响系统其他部分的情况下


628
00:26:51,576 --> 00:26:53,036
它会立即重启


629
00:26:53,956 --> 00:26:55,716
然后在拔下设备时


630
00:26:55,716 --> 00:26:57,156
你可以看到你的 Stop 和 Free 方法


631
00:26:57,156 --> 00:26:58,206
将正常运行


632
00:27:01,516 --> 00:27:04,086
[掌声]


633
00:27:04,586 --> 00:27:08,826
所以 [掌声]


634
00:27:09,326 --> 00:27:10,476
-- 使用新的


635
00:27:10,476 --> 00:27:12,626
DriverKit 框架构建


636
00:27:12,826 --> 00:27:14,236
和调试新驱动程序是多么容易


637
00:27:14,426 --> 00:27:16,046
现在我将把这里交给 Joe


638
00:27:16,516 --> 00:27:17,936
来讨论如何在


639
00:27:17,936 --> 00:27:19,056
你的 App 中提供系统扩展


640
00:27:21,546 --> 00:27:22,586
>> 谢谢 Scott


641
00:27:23,886 --> 00:27:24,946
现在我们已经了解如何


642
00:27:24,946 --> 00:27:26,526
构建驱动扩展


643
00:27:26,526 --> 00:27:27,986
我想告诉你们如何在


644
00:27:27,986 --> 00:27:30,176
App 中部署驱动


645
00:27:30,176 --> 00:27:32,326
或其他类型的系统扩展


646
00:27:33,816 --> 00:27:35,476
我们将讨论扩展与


647
00:27:35,476 --> 00:27:36,926
App 之间的关系


648
00:27:38,486 --> 00:27:39,976
以及如何构建


649
00:27:39,976 --> 00:27:41,196
和打包扩展包


650
00:27:42,056 --> 00:27:43,406
我们将讨论


651
00:27:43,446 --> 00:27:45,886
代码签名和权限


652
00:27:45,886 --> 00:27:48,056
以及如何安装 更新和卸载


653
00:27:48,056 --> 00:27:49,066
系统扩展


654
00:27:49,666 --> 00:27:55,436
系统扩展始终是 App 的一部分


655
00:27:56,196 --> 00:27:58,326
这是设计的基本原则


656
00:27:58,926 --> 00:28:02,056
没有独立的系统扩展


657
00:28:03,586 --> 00:28:05,426
这是因为用户


658
00:28:05,426 --> 00:28:06,326
考虑的是 App


659
00:28:06,806 --> 00:28:09,056
他们购买 App


660
00:28:09,056 --> 00:28:11,196
安装并运行 App


661
00:28:12,116 --> 00:28:14,066
你的系统扩展应该是


662
00:28:14,066 --> 00:28:16,206
你的 App 的实施细节


663
00:28:17,566 --> 00:28:18,986
该 App 是用户


664
00:28:19,616 --> 00:28:22,166
与你的扩展程序进行交互和控制的方式


665
00:28:22,736 --> 00:28:25,986
一旦你将系统扩展


666
00:28:25,986 --> 00:28:28,226
打包到一个 App 中


667
00:28:28,226 --> 00:28:29,666
你就可以使用


668
00:28:29,666 --> 00:28:32,816
开发人员 ID 或


669
00:28:32,816 --> 00:28:34,366
通过 Mac App Store 


670
00:28:34,366 --> 00:28:35,646
直接将 App 分发给用户


671
00:28:35,646 --> 00:28:36,386
这是内核扩展不可能实现的


672
00:28:37,516 --> 00:28:41,256
[掌声]


673
00:28:41,756 --> 00:28:42,716
由于你的 App


674
00:28:42,716 --> 00:28:44,266
与其扩展之间


675
00:28:44,266 --> 00:28:46,556
存在密切关系


676
00:28:46,556 --> 00:28:48,646
因此用户可以识别


677
00:28:48,646 --> 00:28:52,116
你的系统扩展与 App 有关


678
00:28:52,336 --> 00:28:55,476
你应该使用扩展中的 info.plist 中的


679
00:28:55,476 --> 00:28:57,386
CFBundleDisplayName 键


680
00:28:57,386 --> 00:28:59,456
为其提供良好的本地化名称


681
00:28:59,456 --> 00:29:00,686
并为其提供


682
00:29:00,686 --> 00:29:02,496
App 主图标相关的自定义图标


683
00:29:03,246 --> 00:29:04,696
这样如果扩展


684
00:29:04,696 --> 00:29:06,106
将在用户界面中显示


685
00:29:06,106 --> 00:29:08,156
用户会将其识别为


686
00:29:08,156 --> 00:29:10,330
他们使用的 App 的一部分


687
00:29:13,096 --> 00:29:14,826
你还应该在


688
00:29:14,826 --> 00:29:16,466
扩展的 info.pList 中


689
00:29:16,466 --> 00:29:18,926
包含一个用法说明字符串


690
00:29:18,926 --> 00:29:20,536
该字符串解释了


691
00:29:20,536 --> 00:29:22,956
扩展的功能和用途


692
00:29:22,956 --> 00:29:23,866
以及用户运行它的原因


693
00:29:24,626 --> 00:29:26,076
可以将其看作


694
00:29:26,076 --> 00:29:27,516
类似于日历或


695
00:29:27,516 --> 00:29:31,816
相机访问所需的使用情况


696
00:29:33,336 --> 00:29:35,896
对于驱动扩展


697
00:29:35,896 --> 00:29:38,256
请使用 OSBundleUsageDescription 键


698
00:29:38,526 --> 00:29:41,616
对于其他类型的系统扩展


699
00:29:41,616 --> 00:29:43,896
使用 NSSystemExtensionUsageDescription


700
00:29:45,056 --> 00:29:46,656
请记住为你的 App


701
00:29:46,656 --> 00:29:48,206
支持的所有语言本地化这些字符串


702
00:29:48,206 --> 00:29:49,846
和所有其他字符串


703
00:29:50,416 --> 00:29:54,546
系统扩展本身


704
00:29:54,586 --> 00:29:56,466
是 App 的一个独立子包


705
00:29:56,466 --> 00:29:58,176
包含自己的可执行文件


706
00:29:58,176 --> 00:30:00,906
和 info.plist 


707
00:30:01,986 --> 00:30:03,436
下面是一个示例 App


708
00:30:03,436 --> 00:30:05,206
的内部视图


709
00:30:05,206 --> 00:30:06,906
它在其 Contents/Library/SystemExtensions 目录下


710
00:30:07,006 --> 00:30:09,176
展示了一个系统扩展


711
00:30:11,606 --> 00:30:14,066
驱动扩展捆绑包


712
00:30:14,066 --> 00:30:16,286
使用 .dext 文件名后缀


713
00:30:16,286 --> 00:30:17,866
和包类型 DEXT


714
00:30:18,806 --> 00:30:21,066
它们在 info.plist 中使用 OSBundle 键


715
00:30:21,066 --> 00:30:24,026
和内核扩展包类似


716
00:30:25,516 --> 00:30:27,036
驱动扩展包


717
00:30:27,036 --> 00:30:30,016
应该是扁平的 没有 Contents 文件夹


718
00:30:30,016 --> 00:30:32,756
类似于 iOS App


719
00:30:34,156 --> 00:30:35,976
其他类型的


720
00:30:35,976 --> 00:30:38,186
系统扩展包使用 .system


721
00:30:38,186 --> 00:30:40,216
扩展名文件名后缀


722
00:30:40,216 --> 00:30:43,576
和 CFBundlePackageType SYSX


723
00:30:44,386 --> 00:30:45,846
代表 System Extension


724
00:30:46,476 --> 00:30:50,496
在 Xcode 中系统扩展


725
00:30:50,496 --> 00:30:51,606
是一个单独的 Target


726
00:30:52,206 --> 00:30:56,046
Xcode 内置了用于


727
00:30:56,046 --> 00:30:59,806
网络扩展和驱动套件驱动的模版


728
00:31:01,986 --> 00:31:03,606
当你创建这样的 Target 时


729
00:31:03,606 --> 00:31:05,026
Xcode 会询问你是否


730
00:31:05,026 --> 00:31:06,686
要将其嵌入已经


731
00:31:06,686 --> 00:31:08,186
属于项目的 App 中


732
00:31:08,806 --> 00:31:11,016
如果这样做


733
00:31:11,016 --> 00:31:13,056
它将创建一个 Copy Files 面板


734
00:31:13,056 --> 00:31:14,706
将扩展构建产品复制到


735
00:31:14,706 --> 00:31:15,566
你的 App 中


736
00:31:16,166 --> 00:31:20,946
一旦构建了系统扩展


737
00:31:20,946 --> 00:31:23,346
就可以使用与 App 签名


738
00:31:23,346 --> 00:31:25,336
相同的证书对其进行签名


739
00:31:25,776 --> 00:31:27,486
不再需要特殊的


740
00:31:27,486 --> 00:31:29,936
Kext 证书


741
00:31:29,936 --> 00:31:31,346
即 Kext 特定的签名证书了


742
00:31:32,516 --> 00:31:36,146
[掌声]


743
00:31:36,646 --> 00:31:39,056
通常用于签署系统扩展


744
00:31:39,056 --> 00:31:40,526
和主 App 的团队 ID


745
00:31:40,526 --> 00:31:41,936
必须匹配


746
00:31:42,266 --> 00:31:43,486
这是一项安全措施


747
00:31:44,206 --> 00:31:45,976
但是可能


748
00:31:45,976 --> 00:31:47,676
你正在构建的扩展


749
00:31:47,676 --> 00:31:49,786
将被打包到其他开发人员的 App 中


750
00:31:50,036 --> 00:31:52,026
例如 有许多产品中


751
00:31:52,276 --> 00:31:54,596
都包含的常见 USB 


752
00:31:54,596 --> 00:31:56,956
串行接口芯片的驱动扩展


753
00:31:57,676 --> 00:31:59,206
如果是这样


754
00:31:59,246 --> 00:32:00,356
你可以在系统扩展上使用授权


755
00:32:00,356 --> 00:32:02,166
以允许它打包在


756
00:32:02,166 --> 00:32:04,866
不同的开发人员的 App 中


757
00:32:08,196 --> 00:32:09,436
如果你使用


758
00:32:09,436 --> 00:32:11,546
开发人员 ID 对系统扩展进行签名


759
00:32:11,546 --> 00:32:13,296
则必须先对进行真实性检验


760
00:32:13,296 --> 00:32:15,386
才能在用户系统上运行


761
00:32:16,416 --> 00:32:19,236
有关真实性检验的更多信息


762
00:32:19,236 --> 00:32:21,986
请观看去年的会议


763
00:32:21,986 --> 00:32:23,606
或今天下午晚些时候来


764
00:32:23,606 --> 00:32:24,296
真实性检验实验室


765
00:32:26,976 --> 00:32:29,136
系统扩展使用权限


766
00:32:29,136 --> 00:32:32,846
向操作系统描述其功能


767
00:32:32,846 --> 00:32:35,026
它是什么类型的扩展


768
00:32:35,026 --> 00:32:36,366
以及它可以做什么


769
00:32:37,236 --> 00:32:39,506
例如 DriverKit 驱动扩展


770
00:32:39,506 --> 00:32:41,626
使用了 Simon 展示的


771
00:32:41,626 --> 00:32:44,000
交通和家庭权限


772
00:32:49,686 --> 00:32:53,256
com.apple.developer.system-extension.install 权限


773
00:32:55,256 --> 00:32:56,866
有关权限的


774
00:32:56,866 --> 00:32:58,706
更多信息以及请求


775
00:32:58,706 --> 00:33:00,146
开发团队使用它们


776
00:33:00,146 --> 00:33:05,096
请访问 developer.apple.com/system-extensions


777
00:33:05,636 --> 00:33:09,106
在 Catalina 的开发者种子中


778
00:33:09,106 --> 00:33:12,276
进行本地开发时


779
00:33:12,926 --> 00:33:14,386
你可以关闭系统完整性保护


780
00:33:14,386 --> 00:33:16,346
以在测试时禁用


781
00:33:16,346 --> 00:33:17,766
某些代码签名


782
00:33:17,766 --> 00:33:19,796
和权限检查


783
00:33:21,046 --> 00:33:22,316
请记得在


784
00:33:22,316 --> 00:33:23,836
完成测试后再次打开


785
00:33:23,836 --> 00:33:24,806
系统完整性保护


786
00:33:25,446 --> 00:33:28,856
现在你已经使用系统扩展 


787
00:33:29,216 --> 00:33:30,786
构建了 App


788
00:33:31,556 --> 00:33:33,466
如何在用户的系统上


789
00:33:33,466 --> 00:33:35,066
安装扩展


790
00:33:35,796 --> 00:33:38,836
不需要安装器或包


791
00:33:39,316 --> 00:33:41,236
你的系统扩展


792
00:33:41,476 --> 00:33:43,546
保留在你的 App 包中


793
00:33:43,676 --> 00:33:45,316
你的 App 使用新的


794
00:33:45,316 --> 00:33:47,426
系统扩展框架


795
00:33:47,426 --> 00:33:50,076
并创建激活请求


796
00:33:50,076 --> 00:33:51,136
以请求扩展


797
00:33:51,136 --> 00:33:52,866
可供系统使用


798
00:33:52,866 --> 00:33:55,206
系统管理员


799
00:33:55,206 --> 00:33:58,586
将批准请求


800
00:33:59,026 --> 00:34:00,876
大多数 App 应该在


801
00:34:00,876 --> 00:34:02,746
App 启动期间创建 activationRequest


802
00:34:02,746 --> 00:34:05,636
以便立即提供扩展


803
00:34:06,306 --> 00:34:08,266
如果你的扩展


804
00:34:08,466 --> 00:34:10,716
已被激活并获得批准


805
00:34:10,716 --> 00:34:12,206
则 activationRequest 将


806
00:34:12,206 --> 00:34:13,335
快速返回 success


807
00:34:14,235 --> 00:34:16,106
但是你可能希望


808
00:34:16,106 --> 00:34:17,746
在 App 生命周期的


809
00:34:17,746 --> 00:34:18,706
不同时刻


810
00:34:18,706 --> 00:34:20,676
激活你的系统扩展


811
00:34:20,676 --> 00:34:22,346
例如在用户同意许可协议


812
00:34:22,346 --> 00:34:24,166
或进行 App 内购买后


813
00:34:24,266 --> 00:34:26,156
如果需要的话


814
00:34:28,956 --> 00:34:30,476
一旦你的扩展被激活


815
00:34:30,476 --> 00:34:32,306
系统将管理它的生命周期


816
00:34:32,306 --> 00:34:35,936
并在需要时启动它


817
00:34:36,676 --> 00:34:38,376
例如当连接到匹配的硬件设备时


818
00:34:38,376 --> 00:34:41,366
驱动扩展将启动


819
00:34:45,126 --> 00:34:47,116
要更新系统扩展名


820
00:34:47,806 --> 00:34:49,166
请更新 App 包


821
00:34:50,206 --> 00:34:52,406
用户可以安装他们


822
00:34:52,406 --> 00:34:53,496
从你的网站下载的新版本


823
00:34:53,496 --> 00:34:56,156
你的自动更新器可以


824
00:34:56,156 --> 00:34:57,616
立即更新 App 包


825
00:34:58,156 --> 00:34:59,846
或者如果你在


826
00:34:59,846 --> 00:35:01,156
App Store 上发布了一个新版本


827
00:35:01,156 --> 00:35:02,096
它将为用户更新


828
00:35:02,716 --> 00:35:06,226
下次运行 App 


829
00:35:06,226 --> 00:35:07,746
并提交激活请求时


830
00:35:08,406 --> 00:35:09,766
系统将注意到


831
00:35:09,766 --> 00:35:11,906
扩展的版本已经更改


832
00:35:12,336 --> 00:35:13,816
它将要求你的


833
00:35:13,816 --> 00:35:15,826
激活请求代理按照


834
00:35:15,826 --> 00:35:17,686
你自己的版本号规则


835
00:35:17,686 --> 00:35:19,426
比较版本号


836
00:35:20,756 --> 00:35:22,146
如果你的代理


837
00:35:22,146 --> 00:35:24,456
确定这是一次升级


838
00:35:24,456 --> 00:35:25,936
系统将停止旧版本的系统扩展


839
00:35:25,936 --> 00:35:27,986
并启动新版本


840
00:35:28,616 --> 00:35:32,546
如果用户希望卸载你的 App


841
00:35:32,546 --> 00:35:35,126
当他们将其移到


842
00:35:35,126 --> 00:35:36,716
废纸篓中时


843
00:35:36,716 --> 00:35:38,276
它的所有扩展也将


844
00:35:38,276 --> 00:35:39,606
自动停用


845
00:35:40,686 --> 00:35:42,226
如果你希望使用


846
00:35:42,286 --> 00:35:44,766
也有一个 deactivationRequest API 


847
00:35:44,766 --> 00:35:46,296
但不需要专用的


848
00:35:46,296 --> 00:35:47,086
扩展卸载程序


849
00:35:53,536 --> 00:35:56,146
因此今天我们引入了系统扩展


850
00:35:56,146 --> 00:35:58,276
它是内核扩展的替代


851
00:35:58,276 --> 00:35:59,746
使你的 App 


852
00:35:59,746 --> 00:36:04,426
能够以比以往更安全


853
00:36:04,426 --> 00:36:07,736
更易于开发的方式扩展系统


854
00:36:09,256 --> 00:36:11,406
我们看到了如何使用 DriverKit


855
00:36:11,406 --> 00:36:14,256
SDK 和框架


856
00:36:14,256 --> 00:36:16,986
这是一个重大的 IOKit 更新


857
00:36:16,986 --> 00:36:17,796
来构建驱动程序


858
00:36:18,386 --> 00:36:21,306
我们看到了如何在一台机器上


859
00:36:21,306 --> 00:36:23,696
编写并调试


860
00:36:23,696 --> 00:36:24,456
示例的 USB 驱动


861
00:36:25,786 --> 00:36:27,156
最后我们讨论了


862
00:36:27,156 --> 00:36:30,036
如何在 App 中包含系统扩展


863
00:36:32,776 --> 00:36:34,626
如果你有任何问题


864
00:36:34,626 --> 00:36:36,446
我们很乐意在 Core OS 实验室


865
00:36:36,446 --> 00:36:37,726
为你解答


866
00:36:37,946 --> 00:36:39,576
今天晚些时候还有周四早上


867
00:36:39,576 --> 00:36:40,486
都有实验室


868
00:36:41,946 --> 00:36:43,066
你可能还想访问


869
00:36:43,066 --> 00:36:45,466
正在进行的安全实验室


870
00:36:45,466 --> 00:36:46,796
或者周四下午


871
00:36:46,796 --> 00:36:48,456
和周五上午访问网络实验室


872
00:36:48,996 --> 00:36:51,726
非常感谢


873
00:36:51,726 --> 00:36:52,756
请继续观看接下来的 WWDC


874
00:36:53,516 --> 00:36:58,506
[掌声]

