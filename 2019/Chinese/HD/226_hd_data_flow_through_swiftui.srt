1
00:00:00,506 --> 00:00:04,500
[音乐]


2
00:00:08,016 --> 00:00:09,156
[掌声]


3
00:00:09,156 --> 00:00:12,186
>> 上午好 欢迎


4
00:00:12,186 --> 00:00:13,526
大家来到 SwiftUI 中的数据流


5
00:00:13,526 --> 00:00:15,986
我叫 Luca Bernardi 


6
00:00:15,986 --> 00:00:17,096
稍后会有一位我的朋友 也是我的同事


7
00:00:17,096 --> 00:00:18,096
Raj Ramamaurthy


8
00:00:18,096 --> 00:00:18,686
加入讲演


9
00:00:18,906 --> 00:00:20,486
大家对 SwiftUI 感到兴奋吗


10
00:00:20,486 --> 00:00:21,836
>> [齐声回答] 兴奋


11
00:00:21,836 --> 00:00:25,276
>> 很好 今天来到这儿


12
00:00:25,276 --> 00:00:25,996
我感到非常高兴


13
00:00:25,996 --> 00:00:28,476
SwiftUI 是制作一个优秀 App 的


14
00:00:28,476 --> 00:00:30,226
最便捷的途径


15
00:00:30,226 --> 00:00:31,896
但是我们也从头开始设计


16
00:00:32,006 --> 00:00:33,526
目标是降低


17
00:00:33,526 --> 00:00:35,096
UI 开发的复杂程度


18
00:00:35,096 --> 00:00:37,876
这就意味着数据在 SwiftUI 中


19
00:00:37,876 --> 00:00:39,376
是第一类对象


20
00:00:40,056 --> 00:00:42,856
在这次讲演中


21
00:00:42,856 --> 00:00:44,646
我们将向大家展示一个


22
00:00:44,646 --> 00:00:45,776
简单却有用的工具


23
00:00:45,776 --> 00:00:47,706
你可以用它


24
00:00:47,706 --> 00:00:48,506
使数据在视图层级中流动


25
00:00:49,306 --> 00:00:50,706
这个工具可以帮助你


26
00:00:50,706 --> 00:00:53,506
设计美观且好用的 App


27
00:00:56,046 --> 00:00:57,386
我们也将会深入内部机制


28
00:00:57,386 --> 00:00:59,526
看看 SwiftUI 如何更新视图层级


29
00:00:59,526 --> 00:01:01,166
来确保


30
00:01:01,166 --> 00:01:02,956
你可以正确而又持续地


31
00:01:02,956 --> 00:01:04,575
呈现你的数据


32
00:01:05,916 --> 00:01:07,856
最后我们将为你


33
00:01:07,986 --> 00:01:09,376
在脑海中建立一个框架


34
00:01:09,376 --> 00:01:10,996
去理解你的数据


35
00:01:10,996 --> 00:01:12,256
和可用工具


36
00:01:13,836 --> 00:01:16,176
在继续说明之前 我们必须要问


37
00:01:16,176 --> 00:01:16,906
数据是什么意思


38
00:01:18,196 --> 00:01:19,746
数据是所有


39
00:01:19,746 --> 00:01:20,666
驱动你 UI 的信息


40
00:01:21,296 --> 00:01:23,746
数据的形态结构多种多样


41
00:01:24,356 --> 00:01:25,806
一个例子是


42
00:01:25,806 --> 00:01:27,886
像 Toggle 中的状态一样
声明你的 UI


43
00:01:29,036 --> 00:01:30,766
数据还代表模型数据


44
00:01:31,306 --> 00:01:32,976
比如驱动一列信息的对象


45
00:01:36,096 --> 00:01:37,716
我们有许多工具


46
00:01:37,716 --> 00:01:39,166
供你选择


47
00:01:39,166 --> 00:01:39,746
取决于你想做什么


48
00:01:40,656 --> 00:01:41,586
你也许已经在之前的讲解中


49
00:01:41,586 --> 00:01:42,926
看到了这些工具


50
00:01:42,926 --> 00:01:44,756
如果你对它们并不熟悉


51
00:01:44,756 --> 00:01:47,206
不必担心


52
00:01:47,206 --> 00:01:48,786
我们会解释它们是什么


53
00:01:48,786 --> 00:01:49,256
以及什么时候用得到


54
00:01:50,236 --> 00:01:51,836
听完讲解后


55
00:01:51,836 --> 00:01:54,186
你就会清楚地知道使用哪个工具


56
00:01:54,306 --> 00:01:54,826
以及什么时候使用


57
00:01:55,486 --> 00:01:57,736
但是在展示工具之前


58
00:01:57,736 --> 00:01:59,316
我想先阐释


59
00:01:59,316 --> 00:02:00,866
两个指导性原则


60
00:02:00,866 --> 00:02:03,136
这两个原则启发了我们的设计


61
00:02:03,936 --> 00:02:05,266
第一个原则是


62
00:02:05,266 --> 00:02:06,996
每次你在视图中


63
00:02:06,996 --> 00:02:08,166
读取数据时


64
00:02:08,166 --> 00:02:09,776
你都在为那个视图创建一个依赖


65
00:02:10,616 --> 00:02:11,806
这是一个依赖


66
00:02:11,806 --> 00:02:13,116
因为每当数据发生变化


67
00:02:13,466 --> 00:02:14,736
你的视图也要变化


68
00:02:14,736 --> 00:02:15,576
去反映一个新的值


69
00:02:17,156 --> 00:02:18,776
举个例子


70
00:02:18,776 --> 00:02:19,876
这里蓝色的是播放控制的视图


71
00:02:19,876 --> 00:02:21,856
这个视图需要


72
00:02:21,856 --> 00:02:23,006
读取紫色的数据


73
00:02:23,806 --> 00:02:25,116
每当这个值变化时


74
00:02:25,116 --> 00:02:25,976
我们都要更新视图


75
00:02:28,666 --> 00:02:31,686
所以 定义这个依赖


76
00:02:31,686 --> 00:02:33,126
是个手动的过程


77
00:02:33,126 --> 00:02:34,696
很快就会变得复杂起来


78
00:02:35,266 --> 00:02:38,206
正如查看 SwiftUI


79
00:02:38,206 --> 00:02:40,096
数据依赖


80
00:02:40,096 --> 00:02:40,596
也是声明式的


81
00:02:40,596 --> 00:02:41,956
并不是手动


82
00:02:41,956 --> 00:02:43,696
同步或失效


83
00:02:43,696 --> 00:02:46,756
通过 SwiftUI 


84
00:02:46,756 --> 00:02:48,056
你只需用很少的工具


85
00:02:48,056 --> 00:02:50,056
把依赖描述给框架


86
00:02:50,056 --> 00:02:51,566
框架就会处理剩下的


87
00:02:51,596 --> 00:02:54,006
这就意味着你可以


88
00:02:54,056 --> 00:02:55,456
将你的注意力集中在


89
00:02:55,456 --> 00:02:57,316
为用户提供最佳体验上


90
00:03:00,096 --> 00:03:01,516
第二条原则是


91
00:03:01,516 --> 00:03:03,446
在视图层级中


92
00:03:03,446 --> 00:03:04,696
你读取的每一条数据


93
00:03:04,846 --> 00:03:05,806
都有一个数据源


94
00:03:07,016 --> 00:03:08,166
数据源存在


95
00:03:08,166 --> 00:03:08,816
在视图层级里


96
00:03:09,216 --> 00:03:10,576
比如说你有状态


97
00:03:10,576 --> 00:03:13,366
要折叠


98
00:03:13,426 --> 00:03:14,986
或者不折叠


99
00:03:14,986 --> 00:03:16,866
它也可以是外部的


100
00:03:16,916 --> 00:03:18,396
比如当你显示一个


101
00:03:18,396 --> 00:03:18,976
来自不变模型的信息时


102
00:03:21,696 --> 00:03:22,836
不论数据源在哪里


103
00:03:22,836 --> 00:03:24,876
你应该一直有一个


104
00:03:24,876 --> 00:03:27,266
单一数据源


105
00:03:29,096 --> 00:03:31,196
重复数据源会


106
00:03:31,196 --> 00:03:32,766
会产生 Bug 和不一致


107
00:03:32,986 --> 00:03:34,256
你要一直很小心


108
00:03:34,256 --> 00:03:35,766
让它们保持同步


109
00:03:36,776 --> 00:03:38,286
想一想你一直重复


110
00:03:38,286 --> 00:03:39,786
同一条数据


111
00:03:39,866 --> 00:03:42,626
比如在同级视图里重复同一条数据


112
00:03:42,626 --> 00:03:44,876
想一想消息传递


113
00:03:44,876 --> 00:03:46,186
是多么复杂


114
00:03:46,276 --> 00:03:47,626
KV 观察


115
00:03:47,626 --> 00:03:48,796
或响应一个不同的


116
00:03:48,796 --> 00:03:50,326
事件顺序


117
00:03:50,326 --> 00:03:50,876
会产生 Bug


118
00:03:52,086 --> 00:03:53,386
很容易就出错了


119
00:03:54,046 --> 00:03:55,036
它们会重复同一个错误


120
00:03:55,036 --> 00:03:56,286
很多次


121
00:03:56,866 --> 00:03:59,936
反而 你需要做的是


122
00:03:59,936 --> 00:04:01,456
把数据提取到一个


123
00:04:01,456 --> 00:04:03,386
共同的父级节点


124
00:04:03,386 --> 00:04:05,546
让两个子节点链接到父节点


125
00:04:06,836 --> 00:04:08,426
当你有一个单一数据源时


126
00:04:08,426 --> 00:04:10,066
你就消除了这种


127
00:04:10,276 --> 00:04:11,946
视图和数据


128
00:04:11,946 --> 00:04:12,596
不一致的 Bug


129
00:04:13,206 --> 00:04:14,176
你就可以用


130
00:04:14,426 --> 00:04:15,786
语言有的工具


131
00:04:15,786 --> 00:04:17,255
在你的数据中执行变量


132
00:04:17,866 --> 00:04:20,586
记住这个原则


133
00:04:20,966 --> 00:04:22,846
退一步 看看


134
00:04:22,846 --> 00:04:23,856
你代码里的所有数据源


135
00:04:23,856 --> 00:04:25,466
用这个原则


136
00:04:25,466 --> 00:04:27,376
去决定


137
00:04:27,376 --> 00:04:33,126
数据的结构


138
00:04:33,276 --> 00:04:35,696
在我来 Apple 总部


139
00:04:35,696 --> 00:04:37,016
上班的路上


140
00:04:37,016 --> 00:04:37,746
我特别喜欢听一个很棒的播客


141
00:04:37,746 --> 00:04:39,386
我觉得用 SwiftUI 


142
00:04:39,386 --> 00:04:41,646
做一个播放器是个好主意


143
00:04:41,646 --> 00:04:44,616
在这次讲解中


144
00:04:44,616 --> 00:04:45,596
我会用这个做例子


145
00:04:45,736 --> 00:04:46,926
展示所有的


146
00:04:46,926 --> 00:04:47,676
可用工具


147
00:04:48,676 --> 00:04:50,256
这是我们将要建构的 UI


148
00:04:51,506 --> 00:04:52,556
这是播放器的界面


149
00:04:52,556 --> 00:04:53,826
我们需要它显示


150
00:04:53,826 --> 00:04:55,236
节目和剧集的名字


151
00:04:55,276 --> 00:04:57,836
播放按钮


152
00:04:57,836 --> 00:04:58,496
和当前时间


153
00:04:59,096 --> 00:05:01,916
我们将一步一步


154
00:05:01,916 --> 00:05:02,796
建构这个 UI


155
00:05:03,686 --> 00:05:04,846
首先创建一个视图


156
00:05:04,846 --> 00:05:05,976
显示当前剧集的视图


157
00:05:09,386 --> 00:05:10,506
第一步是创建一个新视图


158
00:05:10,506 --> 00:05:12,536
PlayerView 


159
00:05:12,536 --> 00:05:13,636
这个视图有一个属性


160
00:05:13,636 --> 00:05:15,296
存储着当前播放剧集


161
00:05:15,936 --> 00:05:17,836
我们还想要显示


162
00:05:17,836 --> 00:05:19,466
剧集和标题


163
00:05:19,926 --> 00:05:20,986
所以在主体中


164
00:05:20,986 --> 00:05:22,956
我们会做一个 VStack 包含两个文本


165
00:05:22,956 --> 00:05:23,966
这样它们会纵向排列


166
00:05:24,536 --> 00:05:27,946
基本的 Swift 属性


167
00:05:27,946 --> 00:05:28,846
是你的第一个工具


168
00:05:29,276 --> 00:05:30,206
当你有一个视图


169
00:05:30,206 --> 00:05:31,506
需要读取所有的派生数据访问时


170
00:05:31,506 --> 00:05:33,446
它是很好用的


171
00:05:34,406 --> 00:05:35,346
这条数据会被它的父节点


172
00:05:35,346 --> 00:05:37,206
提供给视图


173
00:05:38,556 --> 00:05:40,386
现在我想让它有


174
00:05:40,386 --> 00:05:42,246
播放和暂停的功能


175
00:05:42,936 --> 00:05:46,676
我们有一个新的属性


176
00:05:46,676 --> 00:05:48,546
表明当前剧集是否在播放


177
00:05:48,546 --> 00:05:50,896
现在 显示不同片段的图像


178
00:05:50,896 --> 00:05:52,266
取决于


179
00:05:52,266 --> 00:05:53,236
isPlaying 这个值


180
00:05:53,856 --> 00:05:56,176
但是现在我想让播放键


181
00:05:56,176 --> 00:05:58,196
有交互功能


182
00:05:58,196 --> 00:05:59,556
用户按播放键时


183
00:05:59,586 --> 00:06:01,146
播放状态会切换


184
00:06:01,146 --> 00:06:02,226
图片也会随之改变


185
00:06:02,816 --> 00:06:07,636
我们可以用 Button （按钮）


186
00:06:07,786 --> 00:06:09,636
Button 包含一些内容


187
00:06:09,636 --> 00:06:10,756
运行一个动作


188
00:06:10,756 --> 00:06:11,646
当用户点击这个它时


189
00:06:12,726 --> 00:06:13,906
我们只是切换


190
00:06:13,906 --> 00:06:14,446
isPlaying


191
00:06:15,086 --> 00:06:18,726
但如果我们运行一下


192
00:06:18,726 --> 00:06:19,676
就会出现编译错误


193
00:06:20,686 --> 00:06:21,876
这是个好事情


194
00:06:21,876 --> 00:06:23,736
通过 UI 的


195
00:06:23,736 --> 00:06:24,766
其中一条普遍原则


196
00:06:24,766 --> 00:06:25,726
把我们引上正确的道路


197
00:06:25,726 --> 00:06:28,366
我们不改写视图层级


198
00:06:28,916 --> 00:06:31,606
你的 UI 每次更新


199
00:06:31,606 --> 00:06:33,536
都是因为某个视图主体


200
00:06:33,536 --> 00:06:34,726
在生成新的值


201
00:06:34,726 --> 00:06:37,266
为了处理这种情况


202
00:06:37,306 --> 00:06:38,616
我们有一个工具


203
00:06:38,616 --> 00:06:38,976
叫作 State （状态）


204
00:06:42,146 --> 00:06:43,676
我们在这个视图里创建一个主状态


205
00:06:44,256 --> 00:06:46,726
通过 isPlaying 属性上的 


206
00:06:46,726 --> 00:06:48,226
State Property Wrapper


207
00:06:48,226 --> 00:06:49,106
我们可以实现这一点


208
00:06:49,716 --> 00:06:51,006
这么做相当于


209
00:06:51,006 --> 00:06:52,106
告诉系统


210
00:06:52,186 --> 00:06:53,566
isPlaying 是个值


211
00:06:53,566 --> 00:06:55,286
它可以变化


212
00:06:55,286 --> 00:06:56,656
播放器视图会随它变化


213
00:06:58,086 --> 00:06:59,716
现在再运行一下


214
00:06:59,716 --> 00:07:00,666
就不会出现编辑错误了


215
00:07:01,106 --> 00:07:02,146
用户每轻点一次按钮


216
00:07:02,146 --> 00:07:05,196
状态值都会变化


217
00:07:05,786 --> 00:07:06,756
框架就会为这个视图


218
00:07:06,756 --> 00:07:07,846
生成一个新主体


219
00:07:08,776 --> 00:07:09,726
如果你不了解


220
00:07:09,966 --> 00:07:11,716
Property Wrapper


221
00:07:11,716 --> 00:07:14,026
它是 Swift 5.1 里非常有用的一点


222
00:07:14,606 --> 00:07:17,136
至于它们是如何运作的


223
00:07:17,136 --> 00:07:18,296
我们不再细说


224
00:07:18,776 --> 00:07:19,826
如果你想了解更多的话


225
00:07:20,026 --> 00:07:21,366
可以去看这两个很好的分会议


226
00:07:21,966 --> 00:07:24,796
在今天这个讲演中


227
00:07:24,796 --> 00:07:25,836
你只需要知道


228
00:07:25,836 --> 00:07:27,196
当你添加 Property Wrapper 时


229
00:07:27,196 --> 00:07:28,596
你就是在打包这个属性


230
00:07:28,596 --> 00:07:29,916
并当它读写时


231
00:07:29,916 --> 00:07:32,146
为它增加一些额外操作


232
00:07:32,666 --> 00:07:35,036
你可能想知道


233
00:07:35,036 --> 00:07:35,596
这是怎么实现的


234
00:07:36,216 --> 00:07:38,076
这个额外操作


235
00:07:38,646 --> 00:07:40,626
是什么


236
00:07:40,836 --> 00:07:42,836
当你声明框架


237
00:07:42,836 --> 00:07:44,206
为视图上的变量 


238
00:07:44,206 --> 00:07:45,596
分配永久存储时


239
00:07:45,596 --> 00:07:46,936
我们会追踪它为一个依赖


240
00:07:46,936 --> 00:07:49,526
因为如果系统给你


241
00:07:49,526 --> 00:07:51,936
创建了一个存储


242
00:07:51,936 --> 00:07:53,316
你必须总是明确规定


243
00:07:53,316 --> 00:07:54,376
一个初始常量值


244
00:07:54,926 --> 00:07:57,466
视图经常会被系统重建


245
00:07:57,466 --> 00:07:59,636
但是对于 State 来说


246
00:07:59,636 --> 00:08:01,436
尽管视图同样有很多次更新


247
00:08:01,436 --> 00:08:03,016
框架知道它需要


248
00:08:03,016 --> 00:08:04,686
永久存储


249
00:08:05,166 --> 00:08:08,256
这是个很好的操作


250
00:08:08,256 --> 00:08:10,006
清楚地声明状态属性


251
00:08:10,006 --> 00:08:12,296
是私有变量 


252
00:08:12,296 --> 00:08:14,366
真正实现


253
00:08:14,366 --> 00:08:16,076
状态由视图所有和管理


254
00:08:16,646 --> 00:08:19,106
但是我想深入内部结构


255
00:08:19,106 --> 00:08:20,766
让你们看看


256
00:08:20,766 --> 00:08:21,556
当用户点击按钮时


257
00:08:21,556 --> 00:08:21,976
会发生什么


258
00:08:25,346 --> 00:08:26,636
从我们刚才展示的


259
00:08:26,636 --> 00:08:27,276
视图层级开始


260
00:08:28,466 --> 00:08:30,346
我们刚才说


261
00:08:30,346 --> 00:08:31,976
当我们定义了一个状态时


262
00:08:31,976 --> 00:08:33,086
框架会为你


263
00:08:33,086 --> 00:08:34,256
分配永久存储


264
00:08:35,535 --> 00:08:36,736
状态变量的一个特殊属性是


265
00:08:36,736 --> 00:08:38,376
当它们变化时 


266
00:08:38,376 --> 00:08:40,176
SwiftUI 就开始了


267
00:08:40,176 --> 00:08:43,226
因为 SwiftUI 知道


268
00:08:43,226 --> 00:08:44,466
状态变量正在写主体


269
00:08:44,466 --> 00:08:46,506
它知道视图渲染


270
00:08:46,506 --> 00:08:47,976
取决于状态变量


271
00:08:50,586 --> 00:08:51,666
当用户和按钮互动时


272
00:08:51,666 --> 00:08:53,786
框架就会运行动作


273
00:08:53,786 --> 00:08:55,346
这个动作继而


274
00:08:55,346 --> 00:08:56,236
会和某个状态关联


275
00:08:58,476 --> 00:09:00,196
运行时数据


276
00:09:00,196 --> 00:09:01,386
状态确实会变化


277
00:09:01,386 --> 00:09:02,736
并验证状态的视图


278
00:09:02,736 --> 00:09:05,636
这也就是说


279
00:09:05,636 --> 00:09:07,166
它会重新计算那个视图的主体


280
00:09:07,306 --> 00:09:08,396
以及它所有的子类


281
00:09:09,006 --> 00:09:12,056
在这种意义上


282
00:09:12,056 --> 00:09:13,356
所有的变化都会一直


283
00:09:13,356 --> 00:09:14,046
贯穿你的视图层级 


284
00:09:14,836 --> 00:09:16,486
这样效率很高


285
00:09:16,486 --> 00:09:17,716
这是因为


286
00:09:17,716 --> 00:09:19,366
框架会比较视图


287
00:09:19,736 --> 00:09:21,766
而且只会重新渲染改变了的地方


288
00:09:22,346 --> 00:09:25,016
这正是我们


289
00:09:25,016 --> 00:09:26,306
之前提到的


290
00:09:26,306 --> 00:09:27,596
框架可以


291
00:09:27,596 --> 00:09:28,396
为你管理依赖


292
00:09:30,116 --> 00:09:32,266
我们刚才还提到数据源


293
00:09:32,266 --> 00:09:34,276
要记住


294
00:09:34,276 --> 00:09:35,856
每次你


295
00:09:35,856 --> 00:09:38,146
声明一个状态


296
00:09:38,146 --> 00:09:39,886
你就定义了一个数据源


297
00:09:39,886 --> 00:09:40,746
这个数据源是属于视图的


298
00:09:40,746 --> 00:09:43,406
这点很重要


299
00:09:43,786 --> 00:09:45,106
我用了更大的字母来强调


300
00:09:45,106 --> 00:09:47,576
另一个重要的点是


301
00:09:47,576 --> 00:09:49,426
视图是状态的


302
00:09:49,426 --> 00:09:50,896
一个函数


303
00:09:50,896 --> 00:09:53,446
而非事件顺序


304
00:09:53,576 --> 00:09:55,496
传统方法是


305
00:09:55,496 --> 00:09:57,296
通过直接修改视图层级


306
00:09:57,296 --> 00:09:58,016
响应某个事件


307
00:09:58,836 --> 00:09:59,966
比如 通过添加或者删除


308
00:09:59,966 --> 00:10:01,756
一个 subview 


309
00:10:01,756 --> 00:10:02,296
或改变 alpha


310
00:10:03,356 --> 00:10:05,806
但是在 SwiftUI 里


311
00:10:05,806 --> 00:10:08,056
你修改某个状态


312
00:10:08,056 --> 00:10:09,366
这个状态就是数据源的函数


313
00:10:09,366 --> 00:10:10,056
通过这个就可以生成视图


314
00:10:10,056 --> 00:10:12,536
这就是 SwiftUI


315
00:10:12,666 --> 00:10:15,096
声明式语法出色的地方


316
00:10:15,566 --> 00:10:17,336
你鉴于当前状态


317
00:10:17,336 --> 00:10:18,076
描述视图


318
00:10:18,076 --> 00:10:21,196
SwiftUI 就是这样


319
00:10:21,196 --> 00:10:22,786
降低了 UI 开发的复杂程度


320
00:10:22,786 --> 00:10:24,866
让你可以写一个


321
00:10:24,866 --> 00:10:26,966
好看又准确的交互界面


322
00:10:30,656 --> 00:10:31,886
你可以把 App 看作


323
00:10:31,886 --> 00:10:33,706
一个用户和设备之间的


324
00:10:33,706 --> 00:10:34,976
持续反馈循环


325
00:10:37,666 --> 00:10:38,896
一切都从用户开始


326
00:10:40,396 --> 00:10:42,246
用户和 App 交互


327
00:10:42,246 --> 00:10:46,716
生成一个动作


328
00:10:46,896 --> 00:10:48,056
动作被框架执行


329
00:10:48,056 --> 00:10:49,716
修改某个状态


330
00:10:51,126 --> 00:10:52,346
系统发现状态发生了变化


331
00:10:52,346 --> 00:10:54,146
所以它就知道


332
00:10:54,146 --> 00:10:55,676
它需要根据状态


333
00:10:55,676 --> 00:10:57,426
刷新视图


334
00:10:59,496 --> 00:11:01,436
这个刷新给了 UI 


335
00:11:01,436 --> 00:11:03,166
一个新的形式


336
00:11:03,166 --> 00:11:05,216
用户继续和新形式互动


337
00:11:06,436 --> 00:11:09,016
在这个模型中


338
00:11:09,016 --> 00:11:10,726
数据流向是单一向的


339
00:11:11,116 --> 00:11:13,276
它是所有变化的


340
00:11:13,276 --> 00:11:15,796
单一终点


341
00:11:15,796 --> 00:11:18,296
让视图刷新变得


342
00:11:18,296 --> 00:11:19,356
可预测且易理解


343
00:11:19,956 --> 00:11:22,026
现在我们弄明白了状态


344
00:11:22,116 --> 00:11:23,826
我想回到 AppWare 构建


345
00:11:23,826 --> 00:11:25,586
并做一些优化


346
00:11:26,126 --> 00:11:30,186
我想做的第一件事是


347
00:11:30,186 --> 00:11:31,916
每次用户按下


348
00:11:31,986 --> 00:11:33,996
暂停键 剧集名


349
00:11:33,996 --> 00:11:34,946
都会变成灰色


350
00:11:34,946 --> 00:11:37,516
我们已经知道怎么做了


351
00:11:38,236 --> 00:11:39,526
我们只需要用 isPlaying 状态


352
00:11:39,526 --> 00:11:41,586
选择正确的文字颜色


353
00:11:42,106 --> 00:11:45,816
接下来我想做一些重构


354
00:11:46,316 --> 00:11:47,866
如果你已经看过 SwiftUI 的
基本工具讲演


355
00:11:47,866 --> 00:11:49,646
你就已经知道


356
00:11:49,646 --> 00:11:51,186
视图在 SwiftUI 里


357
00:11:51,186 --> 00:11:52,666
是一个 Locust 阻塞


358
00:11:53,726 --> 00:11:55,636
不必害怕


359
00:11:55,636 --> 00:11:56,886
将视图中有意义的数据


360
00:11:57,316 --> 00:11:59,336
合并为可以被一起编写的 


361
00:11:59,336 --> 00:12:00,886
更小的


362
00:12:00,886 --> 00:12:01,826
可重复使用的组件


363
00:12:01,906 --> 00:12:04,196
正好可以以此为例


364
00:12:04,776 --> 00:12:07,386
这是播放按钮和暂停按钮


365
00:12:07,386 --> 00:12:08,006
的代码


366
00:12:08,606 --> 00:12:10,976
封装这个逻辑


367
00:12:10,976 --> 00:12:11,956
到它自己的视图


368
00:12:12,526 --> 00:12:13,906
命名为 PlayButton


369
00:12:15,246 --> 00:12:16,296
现在看一下


370
00:12:16,296 --> 00:12:17,676
PlayButton 的实现


371
00:12:17,816 --> 00:12:22,086
代码还是一样的


372
00:12:22,586 --> 00:12:24,196
只是封装到了一个新视图


373
00:12:25,046 --> 00:12:26,296
但是注意这里我们做了一个新状态


374
00:12:26,296 --> 00:12:29,776
但是状态不是正确的工具


375
00:12:30,856 --> 00:12:32,806
使用状态


376
00:12:32,806 --> 00:12:34,516
我们就为 isPlaying 建立了一个新数据源


377
00:12:34,516 --> 00:12:36,206
这样我们必须


378
00:12:36,206 --> 00:12:37,556
和父级 PlayerView 的状态


379
00:12:37,556 --> 00:12:38,326
保持同步


380
00:12:38,326 --> 00:12:40,096
这不是我们想要的效果


381
00:12:40,746 --> 00:12:43,406
我们想做的是


382
00:12:43,406 --> 00:12:44,636
让它成为可重复使用的组件


383
00:12:45,236 --> 00:12:46,396
所以这个视图不会拥有


384
00:12:46,396 --> 00:12:48,956
一个数据源


385
00:12:48,956 --> 00:12:50,286
它只能读取一个值


386
00:12:50,286 --> 00:12:50,896
然后改写它


387
00:12:52,006 --> 00:12:53,206
但是它不需要拥有状态


388
00:12:53,206 --> 00:12:55,476
我们有处理这种情况的工具


389
00:12:55,816 --> 00:12:56,666
这个工具叫作 Binding（绑定）


390
00:12:56,666 --> 00:13:00,466
通过 Binding Property Wrapper


391
00:13:00,506 --> 00:13:02,436
给数据源


392
00:13:02,436 --> 00:13:04,016
定义一个清楚的依赖


393
00:13:04,016 --> 00:13:05,316
而不拥有它


394
00:13:06,656 --> 00:13:07,936
而且 你不需要


395
00:13:07,936 --> 00:13:09,676
提供初始值


396
00:13:09,676 --> 00:13:11,566
因为绑定可以从状态中生成


397
00:13:12,886 --> 00:13:14,256
看一下效果如何


398
00:13:14,256 --> 00:13:15,136
是不是很适合我们的例子


399
00:13:15,746 --> 00:13:17,846
我们唯一要做的就是


400
00:13:17,846 --> 00:13:19,616
用 Binding Property Wrapper


401
00:13:19,616 --> 00:13:21,936
删除初始值


402
00:13:22,256 --> 00:13:23,086
就是这么简单


403
00:13:23,706 --> 00:13:26,216
现在来看一下


404
00:13:26,216 --> 00:13:27,936
如何通过返回 PlayerView


405
00:13:27,936 --> 00:13:29,196
为 PlayButton 提供一个绑定


406
00:13:31,756 --> 00:13:33,696
PlayerView 依旧持有状态


407
00:13:33,906 --> 00:13:35,076
这是你的数据源


408
00:13:35,686 --> 00:13:38,866
在属性名字上 


409
00:13:38,866 --> 00:13:40,296
使用美元符号


410
00:13:40,296 --> 00:13:41,826
你就可以从状态生成一个绑定


411
00:13:42,386 --> 00:13:44,936
这是你让组件


412
00:13:44,936 --> 00:13:48,436
通过绑定访问状态的方法


413
00:13:49,056 --> 00:13:51,696
美元符号是 Property Wrapper 的


414
00:13:51,696 --> 00:13:53,206
另一个特色


415
00:13:53,416 --> 00:13:54,796
如果你想了解更多


416
00:13:55,096 --> 00:13:57,486
请看现代 Swift API 设计讲演


417
00:14:00,216 --> 00:14:01,466
我想我们可以暂停一秒


418
00:14:01,466 --> 00:14:04,076
欣赏一下这是多么


419
00:14:04,476 --> 00:14:05,456
简单却有效


420
00:14:06,536 --> 00:14:08,326
PlayButton 不包含


421
00:14:08,326 --> 00:14:09,736
isPlaying 值的主体


422
00:14:10,826 --> 00:14:12,046
只是通过绑定


423
00:14:12,276 --> 00:14:14,046
作为它的引用


424
00:14:14,046 --> 00:14:16,186
所以没有必要


425
00:14:16,186 --> 00:14:17,976
让数据和视图保持同步


426
00:14:20,046 --> 00:14:21,696
我想把这个


427
00:14:21,696 --> 00:14:23,066
和我们现在使用的 UIKit GraphKit


428
00:14:23,066 --> 00:14:23,976
对比一下


429
00:14:26,256 --> 00:14:28,376
我们有一个 View Controller


430
00:14:28,376 --> 00:14:30,276
有多个视图 


431
00:14:30,276 --> 00:14:32,256
需要响应我们用户的交互


432
00:14:32,256 --> 00:14:34,106
要非常麻烦地设定目标 动作


433
00:14:34,106 --> 00:14:35,876
或者定义委托


434
00:14:36,946 --> 00:14:38,366
你需要观察模型变化


435
00:14:38,366 --> 00:14:40,486
并且也要响应事件


436
00:14:41,626 --> 00:14:43,536
每次有值变化时


437
00:14:43,826 --> 00:14:45,466
你都需要读取值


438
00:14:45,466 --> 00:14:46,796
把它设置在任何需要它的地方


439
00:14:47,416 --> 00:14:50,246
一旦你的 App 复杂起来


440
00:14:50,276 --> 00:14:52,596
这就成了大问题


441
00:14:52,596 --> 00:14:55,216
我确信


442
00:14:55,216 --> 00:14:56,606
在座诸位都知道


443
00:14:56,606 --> 00:14:57,266
我说的这种情况


444
00:14:58,086 --> 00:14:59,396
View Controller 的整体目标


445
00:14:59,396 --> 00:15:01,376
就是让你的数据


446
00:15:01,376 --> 00:15:02,866
和你的视图保持同步


447
00:15:03,746 --> 00:15:05,436
这是你我要处理的复杂难题


448
00:15:05,816 --> 00:15:08,796
但是在 SwiftUI 中不存在


449
00:15:09,476 --> 00:15:12,496
你有一个简单的工具


450
00:15:12,496 --> 00:15:14,186
来定义数据依赖


451
00:15:14,186 --> 00:15:16,146
框架会处理其他的


452
00:15:16,846 --> 00:15:18,186
你再也不需要


453
00:15:18,186 --> 00:15:19,146
View Controller 了


454
00:15:20,516 --> 00:15:27,806
[掌声 欢呼]


455
00:15:28,306 --> 00:15:30,396
这个想法非常有用


456
00:15:30,496 --> 00:15:32,906
这应用在整个框架中


457
00:15:35,806 --> 00:15:37,046
如果你看一下组件的 API


458
00:15:37,046 --> 00:15:38,376
如 Toggle


459
00:15:38,686 --> 00:15:40,946
TextField 和 Slider


460
00:15:40,946 --> 00:15:42,056
它们都需要一个绑定框架


461
00:15:42,906 --> 00:15:44,736
让你控制


462
00:15:44,736 --> 00:15:46,756
数据源在的地方


463
00:15:46,756 --> 00:15:51,056
你创建数据 


464
00:15:51,056 --> 00:15:52,106
把它给组件


465
00:15:52,106 --> 00:15:53,906
只是作为一个引用


466
00:15:53,906 --> 00:15:55,976
而不需要重复信息


467
00:15:55,976 --> 00:15:57,306
或者费力保持同步


468
00:15:57,306 --> 00:15:58,846
这真是太棒了


469
00:16:00,096 --> 00:16:02,256
在 SwiftUI 视图中


470
00:16:02,706 --> 00:16:03,886
有很多 App 可以查看


471
00:16:04,376 --> 00:16:06,626
布局 导航等


472
00:16:07,176 --> 00:16:09,106
实际上它们是你的


473
00:16:09,246 --> 00:16:10,296
单一原生组件


474
00:16:11,016 --> 00:16:12,516
它们也是好工具


475
00:16:12,516 --> 00:16:14,226
用来为单一数据 


476
00:16:14,456 --> 00:16:15,686
封装表示逻辑


477
00:16:16,866 --> 00:16:18,306
框架使你能够


478
00:16:18,306 --> 00:16:20,296
并鼓励你创建小的视图


479
00:16:20,296 --> 00:16:22,436
去呈现一条


480
00:16:22,436 --> 00:16:24,596
可以被一起编写的


481
00:16:25,856 --> 00:16:27,036
单个数据


482
00:16:27,036 --> 00:16:28,726
再一次 框架带领你


483
00:16:29,166 --> 00:16:31,006
编写小单元


484
00:16:31,006 --> 00:16:31,906
让你更清楚明白


485
00:16:31,906 --> 00:16:35,766
现在回到我们的例子


486
00:16:38,046 --> 00:16:39,056
我把这个 UI 给我的设计师看了


487
00:16:39,056 --> 00:16:40,776
她非常惊讶


488
00:16:40,776 --> 00:16:42,156
没想到这么少的代码


489
00:16:42,156 --> 00:16:42,836
就能有这些效果


490
00:16:44,256 --> 00:16:45,806
她也提出了一些优化的建议


491
00:16:47,066 --> 00:16:48,386
我们应该把播放和暂停的


492
00:16:48,386 --> 00:16:49,416
过渡变化动画化


493
00:16:50,746 --> 00:16:52,606
幸运的是


494
00:16:52,606 --> 00:16:54,926
这很简单


495
00:16:54,926 --> 00:16:56,536
因为框架追踪了


496
00:16:56,536 --> 00:16:57,736
所有变化了的东西


497
00:16:58,006 --> 00:16:59,426
难以置信


498
00:16:59,426 --> 00:17:01,776
用状态驱动动画


499
00:17:01,906 --> 00:17:03,026
是多么简单强大


500
00:17:05,336 --> 00:17:06,976
用一个动画模块


501
00:17:06,976 --> 00:17:08,646
通过打包改写给绑定


502
00:17:09,165 --> 00:17:10,646
当值改变时


503
00:17:10,646 --> 00:17:12,906
框架会动画这个过渡变化


504
00:17:13,526 --> 00:17:15,056
直到最后的状态 


505
00:17:15,056 --> 00:17:17,415
你都会一直得到正确的动画


506
00:17:18,965 --> 00:17:20,656
如果你想了解更多


507
00:17:20,656 --> 00:17:22,746
关于 SwiftUI 强大的动画和布局系统


508
00:17:22,746 --> 00:17:24,896
以及如何制作优秀 App 的信息


509
00:17:24,896 --> 00:17:26,715
我建议大家看一下


510
00:17:26,715 --> 00:17:29,616
在 SwiftUI 中构建自定义视图这个分会


511
00:17:30,166 --> 00:17:32,496
现在我们已经了解了 State 和 Binding


512
00:17:32,496 --> 00:17:35,386
但是 SwiftUI 还有一些绝活


513
00:17:35,386 --> 00:17:36,716
大家没有看到


514
00:17:37,136 --> 00:17:38,586
为了让大家了解得更多


515
00:17:38,586 --> 00:17:39,826
我现在要请 Raj 上台


516
00:17:40,276 --> 00:17:40,596
Raj


517
00:17:41,516 --> 00:17:47,500
[掌声]


518
00:17:50,316 --> 00:17:51,026
>> 谢谢你 Luca


519
00:17:51,026 --> 00:17:53,846
接下来我会介绍


520
00:17:53,846 --> 00:17:55,466
一些其他工具


521
00:17:56,056 --> 00:17:57,706
在 SwiftUI 中它们可以用来管理数据


522
00:17:58,816 --> 00:18:00,376
听了这个讲演


523
00:18:00,796 --> 00:18:02,306
你就可以设计和构建


524
00:18:02,306 --> 00:18:05,246
稳固的可重复使用的组件


525
00:18:05,336 --> 00:18:09,716
可以应用在各种数据上


526
00:18:09,866 --> 00:18:11,556
大家刚才也看到了


527
00:18:11,556 --> 00:18:13,986
我们有很多有用的工具


528
00:18:13,986 --> 00:18:15,166
可以在 SwiftUI 中处理数据


529
00:18:15,956 --> 00:18:17,776
Luca 已经介绍了一些


530
00:18:17,776 --> 00:18:19,896
比如使用 State


531
00:18:20,666 --> 00:18:22,536
Binding 


532
00:18:22,536 --> 00:18:23,346
甚至只用 Swift Property


533
00:18:23,346 --> 00:18:25,816
我会介绍


534
00:18:25,816 --> 00:18:27,446
剩下的工具


535
00:18:28,146 --> 00:18:30,036
以 SwiftUI 中的外部变化


536
00:18:30,036 --> 00:18:30,546
作为开始


537
00:18:30,546 --> 00:18:33,496
我们现在回到


538
00:18:33,496 --> 00:18:35,096
Luca 刚才为大家展示的图解


539
00:18:36,206 --> 00:18:38,266
在这个图解中


540
00:18:38,376 --> 00:18:39,886
用户和 App 互动


541
00:18:40,766 --> 00:18:42,616
这形成了一个动作


542
00:18:42,616 --> 00:18:44,176
结果是改写了状态


543
00:18:44,176 --> 00:18:48,346
这就生成了


544
00:18:48,346 --> 00:18:49,946
视图的新主体


545
00:18:49,946 --> 00:18:50,936
提供给用户


546
00:18:52,436 --> 00:18:55,506
一些事件从外部被初始化


547
00:18:55,506 --> 00:18:59,296
比如计时器和通知


548
00:19:00,756 --> 00:19:03,016
但是记住 在 SwiftUI 中


549
00:19:03,016 --> 00:19:04,896
你的视图是状态的函数


550
00:19:06,296 --> 00:19:07,926
所有的改变


551
00:19:08,106 --> 00:19:09,366
只有一个单一漏斗点


552
00:19:10,866 --> 00:19:12,666
这意味着


553
00:19:12,666 --> 00:19:14,706
SwiftUI 


554
00:19:14,706 --> 00:19:17,106
用响应用户操作的方法


555
00:19:17,146 --> 00:19:17,976
响应外部更改


556
00:19:20,556 --> 00:19:22,846
所以当计时器启动


557
00:19:22,846 --> 00:19:24,906
或者接收到通知时


558
00:19:24,906 --> 00:19:26,926
过程看起来是差不多的


559
00:19:27,876 --> 00:19:30,126
我们创建了一个动作


560
00:19:30,126 --> 00:19:33,226
执行一些状态改写


561
00:19:33,226 --> 00:19:35,486
生成视图的新副本


562
00:19:35,526 --> 00:19:36,606
重新提供给用户


563
00:19:37,196 --> 00:19:40,276
在 SwiftUI 中 


564
00:19:40,276 --> 00:19:41,766
为表述这些外部事件


565
00:19:41,766 --> 00:19:42,916
我们有单一抽象化


566
00:19:44,046 --> 00:19:45,006
它被成为 Publisher


567
00:19:45,596 --> 00:19:48,876
Publisher 来自一个新的


568
00:19:48,876 --> 00:19:49,926
组合框架


569
00:19:50,876 --> 00:19:53,456
Combine 是一个统一声明式 API


570
00:19:53,456 --> 00:19:56,186
随时间处理数据


571
00:19:57,506 --> 00:19:58,646
今天我们


572
00:19:58,646 --> 00:20:00,106
不会细说 Combine


573
00:20:00,326 --> 00:20:01,966
但是大家一定要去看


574
00:20:01,966 --> 00:20:03,416
一些相关的讲解


575
00:20:03,416 --> 00:20:04,876
这样可以了解更多


576
00:20:06,486 --> 00:20:08,156
要达到我们的目的


577
00:20:08,156 --> 00:20:09,706
需记住一点


578
00:20:09,706 --> 00:20:11,316
在 SwiftUI 里用 Publisher 时


579
00:20:12,186 --> 00:20:13,606
它们应该删除主线程


580
00:20:14,576 --> 00:20:16,606
Combine 提供了一种用操作符的简单方法


581
00:20:16,606 --> 00:20:19,136
被称为 Receive On 


582
00:20:19,746 --> 00:20:21,366
想知道更多的话


583
00:20:21,366 --> 00:20:22,706
可以去看 


584
00:20:22,706 --> 00:20:25,666
Combine and Practice 分会


585
00:20:25,816 --> 00:20:28,346
现在我们通过例子来看一下


586
00:20:28,346 --> 00:20:28,866
它是如何运行的


587
00:20:29,996 --> 00:20:32,566
有时候用户


588
00:20:32,566 --> 00:20:35,026
不知道自己听播客听到了哪儿


589
00:20:35,236 --> 00:20:36,676
他们厌倦听年轻的一代


590
00:20:36,676 --> 00:20:38,966
接连好几个小时


591
00:20:38,966 --> 00:20:41,366
大谈特谈牛油果吐司


592
00:20:42,576 --> 00:20:44,976
所以我们要为播客播放器


593
00:20:44,976 --> 00:20:46,856
加一个时间戳


594
00:20:46,856 --> 00:20:48,356
这样用户就知道


595
00:20:48,356 --> 00:20:48,986
自己听到了哪儿


596
00:20:50,696 --> 00:20:53,596
要实现这个效果


597
00:20:53,886 --> 00:20:55,236
我们要加 State 表现当前时间


598
00:20:56,116 --> 00:21:00,486
和描绘该值的文本 


599
00:21:00,636 --> 00:21:04,366
接下来我们会使用 onReceive 修饰符


600
00:21:05,296 --> 00:21:06,906
很方便 我已经构建了一个 publisher 


601
00:21:06,906 --> 00:21:09,246
当前时间一改变


602
00:21:09,246 --> 00:21:10,346
它就会启动


603
00:21:11,256 --> 00:21:12,746
我会使用那个 publisher 


604
00:21:12,746 --> 00:21:14,936
传递给 onReceive 修饰符


605
00:21:15,776 --> 00:21:17,836
另外 我还会给一个闭包


606
00:21:17,836 --> 00:21:20,216
当 publisher 删除时


607
00:21:20,216 --> 00:21:21,306
这个闭包会运行


608
00:21:22,596 --> 00:21:24,686
就是这样


609
00:21:24,686 --> 00:21:26,416
这么做 我们已经给 SwiftUI 


610
00:21:26,416 --> 00:21:27,806
描述了依赖


611
00:21:28,966 --> 00:21:30,996
现在当 currentTime 刷新时


612
00:21:30,996 --> 00:21:33,226
我们会刷新状态


613
00:21:34,016 --> 00:21:35,876
SwiftUI 就会知道


614
00:21:35,876 --> 00:21:36,666
那儿有一个依赖


615
00:21:37,136 --> 00:21:39,466
标签就会自动刷新


616
00:21:40,056 --> 00:21:42,236
就无需费力


617
00:21:42,316 --> 00:21:43,186
去做失效或管理了


618
00:21:44,516 --> 00:21:50,516
[掌声]


619
00:21:51,016 --> 00:21:52,706
我们已经简单说明了


620
00:21:52,706 --> 00:21:53,796
SwiftUI 里的外部变化


621
00:21:55,006 --> 00:21:56,386
接下来我会介绍


622
00:21:56,386 --> 00:21:57,506
外部数据


623
00:22:00,416 --> 00:22:01,856
对于外部数据


624
00:22:01,936 --> 00:22:03,196
我们有 BindableObject 协议


625
00:22:04,566 --> 00:22:06,406
BindableObject 是


626
00:22:06,406 --> 00:22:08,516
使用封装了的 测试过的 


627
00:22:08,856 --> 00:22:10,706
你已有的“true”模型的


628
00:22:10,766 --> 00:22:11,486
简便方法


629
00:22:13,106 --> 00:22:14,966
这对教 SwiftUI


630
00:22:15,456 --> 00:22:17,146
你已经架构的引用类型模型


631
00:22:17,146 --> 00:22:17,936
是非常有用的


632
00:22:19,326 --> 00:22:22,146
这是你拥有并需要管理的数据


633
00:22:23,106 --> 00:22:25,436
SwiftUI 只需要知道


634
00:22:25,436 --> 00:22:28,916
如何在这个数据中响应改变


635
00:22:29,096 --> 00:22:30,876
我们换个例子


636
00:22:32,116 --> 00:22:34,376
用户希望


637
00:22:34,376 --> 00:22:36,366
播客可以在他们


638
00:22:36,366 --> 00:22:38,016
所有的设备上同步


639
00:22:38,016 --> 00:22:39,666
我负责添加这个功能


640
00:22:39,666 --> 00:22:41,696
所以我已经开始了


641
00:22:41,846 --> 00:22:44,116
我已经建立了一个模型


642
00:22:44,116 --> 00:22:45,476
现在是时候使用 


643
00:22:45,476 --> 00:22:47,246
我在视图层级里做好的模型


644
00:22:47,246 --> 00:22:48,636
把它带到


645
00:22:48,636 --> 00:22:49,356
我们的播客播放器


646
00:22:50,306 --> 00:22:52,206
看看多么简单


647
00:22:53,066 --> 00:22:54,776
这里是我们搭建的


648
00:22:54,776 --> 00:22:57,426
模型的一个草图


649
00:22:57,616 --> 00:22:59,406
要通过 SwiftUI 用这个模型


650
00:22:59,406 --> 00:23:01,936
我要做的只是


651
00:23:01,976 --> 00:23:04,726
确认它到 BindableObject 协议


652
00:23:10,056 --> 00:23:12,556
用 BindableObject


653
00:23:12,556 --> 00:23:13,956
我们需要提供的只是一个 publisher


654
00:23:14,856 --> 00:23:17,096
这个 publisher 显示


655
00:23:17,096 --> 00:23:18,386
对数据的更改


656
00:23:19,196 --> 00:23:20,696
记住组合 publisher


657
00:23:20,696 --> 00:23:22,516
是我们为表现


658
00:23:22,516 --> 00:23:23,886
对 SwiftUI 外部更改的


659
00:23:23,886 --> 00:23:25,756
单一抽象化


660
00:23:26,716 --> 00:23:28,186
这里 我们会在 didChange property


661
00:23:28,186 --> 00:23:29,956
提供一个 publisher


662
00:23:30,516 --> 00:23:32,446
PassthroughSubject 是一个 publisher


663
00:23:33,016 --> 00:23:35,966
接着 SwiftUI 会订阅这个 publisher


664
00:23:36,226 --> 00:23:37,786
所以它知道什么时候


665
00:23:37,786 --> 00:23:39,636
更新我们的视图层级


666
00:23:40,186 --> 00:23:43,076
在高级操作中


667
00:23:44,246 --> 00:23:46,796
当我们改写模型时


668
00:23:46,796 --> 00:23:48,666
我们只是简单地发送 publisher 请求


669
00:23:50,086 --> 00:23:52,326
现在 注意 为保证正确


670
00:23:52,676 --> 00:23:54,326
不管什么时候 模型一变化


671
00:23:54,326 --> 00:23:55,766
我们就需要这样做


672
00:23:55,766 --> 00:23:56,986
这样视图层级才能保持刷新


673
00:23:57,826 --> 00:24:00,286
幸好 SwiftUI 可以帮助我们


674
00:24:00,286 --> 00:24:01,336
它优雅地应对这些数据


675
00:24:01,436 --> 00:24:03,936
帮我们很好且正确地


676
00:24:04,106 --> 00:24:05,806
实现这个效果


677
00:24:07,496 --> 00:24:09,346
现在我们已经搭建了模型


678
00:24:09,346 --> 00:24:12,146
以及它对 BindableObject 协议的确认


679
00:24:13,326 --> 00:24:14,796
接下来我将向大家展示


680
00:24:14,796 --> 00:24:16,386
如何在视图层级中用模型


681
00:24:17,466 --> 00:24:19,466
还记得之前说的两大原则吗


682
00:24:20,026 --> 00:24:21,546
每一条数据都有一个数据源


683
00:24:21,546 --> 00:24:23,916
当你访问那个数据时


684
00:24:23,956 --> 00:24:25,986
你在上面创建了一个依赖


685
00:24:26,626 --> 00:24:28,306
我们已经创建了数据源


686
00:24:28,306 --> 00:24:30,676
但是我们还没有一个依赖


687
00:24:31,636 --> 00:24:33,066
幸运的是


688
00:24:33,066 --> 00:24:35,126
在你的可绑定对象上创建依赖


689
00:24:35,126 --> 00:24:36,006
是非常简单的


690
00:24:36,576 --> 00:24:41,526
这里有一个非常基础的图解


691
00:24:41,856 --> 00:24:43,576
可以看到我们的视图层级在右侧


692
00:24:43,576 --> 00:24:45,486
是蓝色的


693
00:24:46,106 --> 00:24:47,466
我们的模型在左侧


694
00:24:47,466 --> 00:24:47,906
是绿色的


695
00:24:49,456 --> 00:24:51,076
现在我们连接二者


696
00:24:51,126 --> 00:24:53,276
用 ObjectBinding Property Wrapper


697
00:24:53,326 --> 00:24:55,236
创建一个依赖


698
00:24:56,756 --> 00:24:58,986
我们这么做时


699
00:24:58,986 --> 00:25:00,506
每一个有那个 Property Wrapper 的视图


700
00:25:00,716 --> 00:25:03,216
都取决于我们之前写的模型


701
00:25:05,296 --> 00:25:07,866
就像用 State 一样


702
00:25:07,866 --> 00:25:09,526
当你用 ObjectBinding Property Wrapper


703
00:25:09,526 --> 00:25:10,916
将它添加到视图中时


704
00:25:10,916 --> 00:25:13,296
框架会识别出


705
00:25:13,296 --> 00:25:14,546
那儿有一个依赖


706
00:25:14,916 --> 00:25:16,786
所以在主体中


707
00:25:16,786 --> 00:25:18,756
当你访问那个数据时


708
00:25:18,836 --> 00:25:21,336
我们自动明白什么时候刷新视图


709
00:25:21,896 --> 00:25:27,236
在代码里看起来就像这样


710
00:25:27,446 --> 00:25:28,936
你创建视图时


711
00:25:28,936 --> 00:25:30,486
添加 ObjectBinding Property Wrapper


712
00:25:30,486 --> 00:25:32,526
到你视图里的一个 Property


713
00:25:33,076 --> 00:25:36,006
当你实例化视图时


714
00:25:36,006 --> 00:25:38,446
你只是将引用传递给


715
00:25:38,446 --> 00:25:40,576
你已有的模型


716
00:25:41,306 --> 00:25:43,996
注意 这在视图的实例中 


717
00:25:43,996 --> 00:25:45,716
创建了一个


718
00:25:45,716 --> 00:25:47,436
清楚的依赖


719
00:25:47,436 --> 00:25:48,976
这样很棒


720
00:25:49,016 --> 00:25:50,666
因为每次我要实例化视图时


721
00:25:50,666 --> 00:25:52,246
我都知道模型上


722
00:25:52,246 --> 00:25:53,946
有个依赖


723
00:25:58,076 --> 00:25:58,936
就是这样


724
00:26:00,336 --> 00:26:02,676
我们这么做时


725
00:26:02,676 --> 00:26:04,026
每个有 Property Wrapper 的视图


726
00:26:04,146 --> 00:26:05,806
都会自动订阅


727
00:26:05,806 --> 00:26:07,596
BindableObject 的变化


728
00:26:08,566 --> 00:26:09,936
也就意味着我们实现了


729
00:26:09,936 --> 00:26:10,806
依赖自动追踪


730
00:26:11,156 --> 00:26:13,596
又不需要


731
00:26:13,596 --> 00:26:15,346
失效和同步了


732
00:26:16,516 --> 00:26:22,736
[掌声]


733
00:26:23,236 --> 00:26:24,416
这里我想停一下


734
00:26:24,456 --> 00:26:26,756
有一点需要强调 


735
00:26:26,756 --> 00:26:28,826
因为如果用 SwiftUI 


736
00:26:29,376 --> 00:26:30,536
是值类型的话


737
00:26:30,536 --> 00:26:32,026
每次你使用引用类型时


738
00:26:32,026 --> 00:26:34,066
你都应该用 ObjectBinding Property Wrapper


739
00:26:34,736 --> 00:26:36,486
这样当数据改变时 


740
00:26:36,536 --> 00:26:38,276
框架就会知道


741
00:26:38,376 --> 00:26:40,106
然后让你的视图层级随之改变


742
00:26:40,646 --> 00:26:43,166
这就是如何在 BindableObject 上


743
00:26:43,166 --> 00:26:45,176
如何使用 ObjectBinding


744
00:26:45,426 --> 00:26:46,486
创建一个依赖


745
00:26:47,446 --> 00:26:48,976
其实我们还有一个工具


746
00:26:48,976 --> 00:26:49,966
也可以创建


747
00:26:49,966 --> 00:26:51,106
这些依赖


748
00:26:52,566 --> 00:26:54,726
我们可以创建间接依赖


749
00:26:56,156 --> 00:26:57,756
所以我带了一个


750
00:26:57,756 --> 00:26:58,976
和刚才大家看到的图解


751
00:26:58,976 --> 00:27:01,266
很相似的一个图解 


752
00:27:01,266 --> 00:27:02,146
但是这次我们的视图中多了些子类


753
00:27:02,656 --> 00:27:06,946
接下来 我想要引入 Environment 


754
00:27:08,066 --> 00:27:09,586
如果你看了 SwiftUI Essentials 讲解


755
00:27:09,636 --> 00:27:11,636
你就知道


756
00:27:11,636 --> 00:27:12,936
Environment 是非常好的封装


757
00:27:12,936 --> 00:27:15,316
它可以推动数据


758
00:27:15,316 --> 00:27:17,046
一路向下流过视图层级 


759
00:27:18,196 --> 00:27:19,936
使用 Environment Object Modifier


760
00:27:19,936 --> 00:27:22,766
我们可以真正地


761
00:27:22,766 --> 00:27:28,116
把 BindableObject 写入 Environment 


762
00:27:28,116 --> 00:27:30,166
现在 我们的模型在 Environment 里


763
00:27:30,836 --> 00:27:34,276
我们可以用


764
00:27:34,276 --> 00:27:35,736
EnvironmentObject Property Wrapper


765
00:27:35,736 --> 00:27:37,396
在模型上


766
00:27:39,936 --> 00:27:40,096
创建依赖


767
00:27:40,266 --> 00:27:41,706
现在 通过使用这个 


768
00:27:41,706 --> 00:27:43,086
Property Wrapper


769
00:27:43,086 --> 00:27:44,426
我们可以在那个模型上创建依赖


770
00:27:46,976 --> 00:27:48,376
但是不止这样


771
00:27:49,156 --> 00:27:50,526
你可以在很多地方


772
00:27:50,526 --> 00:27:51,776
用到它


773
00:27:52,756 --> 00:27:55,376
所以你可以


774
00:27:55,376 --> 00:27:56,406
在整个层级的


775
00:27:56,406 --> 00:27:57,896
各种视图中使用它 


776
00:27:57,896 --> 00:27:59,506
它们都依赖于同一个模型


777
00:28:00,106 --> 00:28:03,166
当然 数据变化


778
00:28:03,166 --> 00:28:05,706
一切都会自动


779
00:28:05,706 --> 00:28:07,206
随之更新


780
00:28:08,586 --> 00:28:09,906
你获得了


781
00:28:09,906 --> 00:28:11,636
和 ObjectBinding 相同的 


782
00:28:11,636 --> 00:28:12,546
依赖追踪


783
00:28:13,066 --> 00:28:15,676
你用这些工具 


784
00:28:15,676 --> 00:28:18,186
把依赖描述给 SwiftUI


785
00:28:18,186 --> 00:28:19,516
框架会处理其他的部分


786
00:28:20,056 --> 00:28:20,596
这很棒


787
00:28:21,516 --> 00:28:27,036
[掌声]


788
00:28:27,536 --> 00:28:29,066
这个便捷的方法


789
00:28:29,066 --> 00:28:30,156
就可以更新我们的播客播放器


790
00:28:31,306 --> 00:28:33,796
就像这样


791
00:28:34,656 --> 00:28:35,766
你只需要添加


792
00:28:35,766 --> 00:28:37,086
EnvironmentObject Property Wrapper 到视图


793
00:28:37,086 --> 00:28:40,126
然后在视图


794
00:28:40,126 --> 00:28:41,486
上方的父类中 


795
00:28:41,486 --> 00:28:43,366
只用 EnvironmentObject Modifier 


796
00:28:43,366 --> 00:28:45,106
提供模型


797
00:28:46,426 --> 00:28:48,466
现在 不论什么时候


798
00:28:48,466 --> 00:28:50,426
只要我们在主体中使用播放器


799
00:28:50,526 --> 00:28:53,346
SwiftUI 就会自动替我们更新数据


800
00:28:53,976 --> 00:28:55,346
你可能会想


801
00:28:56,026 --> 00:28:56,866
什么时候用


802
00:28:56,866 --> 00:28:58,836
EnvironmentObject 


803
00:28:58,836 --> 00:28:59,566
什么时候用 ObjectBinding


804
00:29:00,556 --> 00:29:02,966
实际上你可以使用 ObjectBinding


805
00:29:02,966 --> 00:29:04,246
构建整个 App


806
00:29:04,246 --> 00:29:06,796
但是从出栈到进栈


807
00:29:06,796 --> 00:29:08,006
传递模型


808
00:29:08,006 --> 00:29:10,006
会比较冗长


809
00:29:11,286 --> 00:29:11,846
这时候就需要


810
00:29:11,846 --> 00:29:13,126
EnvironmentObject 了


811
00:29:14,136 --> 00:29:16,366
这真的很方便


812
00:29:16,696 --> 00:29:18,446
不直接在层级间 


813
00:29:18,446 --> 00:29:19,866
传输数据


814
00:29:21,316 --> 00:29:23,626
这里 你可以看到


815
00:29:23,626 --> 00:29:25,686
通过 EnvironmentObject


816
00:29:25,686 --> 00:29:27,156
我们可以间接传送模型


817
00:29:27,156 --> 00:29:29,026
通过视图层级 


818
00:29:29,026 --> 00:29:30,566
也就是说我们不需要


819
00:29:30,566 --> 00:29:32,006
用模型实例化所有的即时视图


820
00:29:32,006 --> 00:29:33,846
到视图层级


821
00:29:37,816 --> 00:29:39,616
所以 Environment 真的是一个很好的方式


822
00:29:39,616 --> 00:29:41,186
用来间接传送各种数据


823
00:29:41,186 --> 00:29:42,876
一路通过


824
00:29:42,876 --> 00:29:43,626
你的视图层级


825
00:29:44,366 --> 00:29:46,126
你可能已经看过


826
00:29:46,396 --> 00:29:48,956
它在重点色


827
00:29:48,956 --> 00:29:51,356
或布局方向等方面的应用


828
00:29:52,446 --> 00:29:55,036
正如 Luca 刚才所说 


829
00:29:55,036 --> 00:29:57,106
数据的形态结构多种多样


830
00:29:58,276 --> 00:30:00,616
值 像是重点色


831
00:30:00,726 --> 00:30:02,746
布局方向


832
00:30:02,746 --> 00:30:03,226
它们只是数据


833
00:30:04,276 --> 00:30:06,006
当你在视图中使用它们时


834
00:30:06,006 --> 00:30:07,506
你就是在它们上面


835
00:30:07,506 --> 00:30:08,406
创建依赖


836
00:30:09,726 --> 00:30:11,906
实际上 Environment 是一个


837
00:30:12,016 --> 00:30:13,416
通用集装箱 


838
00:30:13,416 --> 00:30:15,186
可以用来处理各种


839
00:30:15,256 --> 00:30:16,376
间接数据和依赖


840
00:30:16,776 --> 00:30:17,956
框架自由使用它


841
00:30:17,956 --> 00:30:20,066
为你带来各种特色功能


842
00:30:20,066 --> 00:30:22,606
比如动态类型


843
00:30:22,606 --> 00:30:23,176
和深色模式


844
00:30:24,156 --> 00:30:25,566
你还可以


845
00:30:25,686 --> 00:30:27,546
在预览中使用 Environment  


846
00:30:27,546 --> 00:30:29,066
给重点色或主题等


847
00:30:29,066 --> 00:30:31,486
赋新值


848
00:30:35,756 --> 00:30:37,406
我们已经快速过了一遍


849
00:30:37,406 --> 00:30:39,646
SwiftUI 里


850
00:30:39,646 --> 00:30:41,226
处理数据的强大工具


851
00:30:42,466 --> 00:30:43,916
现在我让大家


852
00:30:43,916 --> 00:30:46,496
对如何使用正确的工具


853
00:30:46,496 --> 00:30:48,276
和如何调配它们


854
00:30:48,276 --> 00:30:48,836
有一个概念


855
00:30:49,386 --> 00:30:53,276
这里主题之一是


856
00:30:53,526 --> 00:30:55,446
每一条数据


857
00:30:55,446 --> 00:30:57,006
都有单一数据源


858
00:30:57,646 --> 00:30:59,516
在 SwiftUI 中 


859
00:30:59,606 --> 00:31:01,746
我们有两种选择 


860
00:31:01,746 --> 00:31:03,936
去处理这些数据源


861
00:31:04,126 --> 00:31:05,586
第一种是 State


862
00:31:06,606 --> 00:31:08,236
State 适合本地视图的数据


863
00:31:08,386 --> 00:31:10,766
一个值类型


864
00:31:11,766 --> 00:31:14,506
由框架 


865
00:31:14,506 --> 00:31:15,106
处理 分配 和创建 


866
00:31:15,776 --> 00:31:19,836
BindableObject 适合


867
00:31:19,836 --> 00:31:20,916
你控制的数据


868
00:31:22,286 --> 00:31:23,396
它适用于给 SwiftUI 展现


869
00:31:23,526 --> 00:31:25,746
外部数据


870
00:31:25,746 --> 00:31:29,576
比如在 onDevice 数据库


871
00:31:29,786 --> 00:31:32,756
这里有你处理的内存


872
00:31:32,756 --> 00:31:34,306
对你已有的模型


873
00:31:34,306 --> 00:31:35,296
很有帮助


874
00:31:35,926 --> 00:31:38,756
现在我们已经了解了


875
00:31:38,756 --> 00:31:40,866
数据源 接下来


876
00:31:40,866 --> 00:31:42,306
我想介绍一下


877
00:31:42,306 --> 00:31:43,486
构建可重复使用的组件


878
00:31:44,056 --> 00:31:46,456
SwiftUI 的一个优点是


879
00:31:46,456 --> 00:31:48,866
视图是


880
00:31:48,866 --> 00:31:49,976
低成本阻塞


881
00:31:49,976 --> 00:31:52,786
这意味着


882
00:31:52,946 --> 00:31:54,466
我们不需要


883
00:31:54,756 --> 00:31:57,576
在架构和性能之间做折中


884
00:31:58,246 --> 00:31:59,566
你可以搭建


885
00:31:59,566 --> 00:32:00,996
你想搭建的架构


886
00:32:01,206 --> 00:32:03,466
同时也能获得很好的性能


887
00:32:03,626 --> 00:32:04,566
你不需要


888
00:32:04,566 --> 00:32:05,666
权衡折中


889
00:32:06,826 --> 00:32:09,316
通过 SwiftUI 你可以集中精力于


890
00:32:09,436 --> 00:32:10,786
让你的视图成为


891
00:32:10,786 --> 00:32:11,906
可重复使用的组件


892
00:32:12,446 --> 00:32:14,606
当你这么做时


893
00:32:14,816 --> 00:32:16,646
你可能会注意到


894
00:32:16,646 --> 00:32:17,966
在视图中使用数据时


895
00:32:17,966 --> 00:32:19,896
你也许不需要


896
00:32:19,896 --> 00:32:20,666
改写它


897
00:32:21,326 --> 00:32:24,106
所以当你可以不管它时


898
00:32:24,686 --> 00:32:27,106
只读路径是更好的选择


899
00:32:28,236 --> 00:32:30,336
在这一点上 我们有 Swift Property


900
00:32:30,336 --> 00:32:31,826
和 Environment 


901
00:32:32,766 --> 00:32:34,566
因为视图在 SwiftUI 中是


902
00:32:34,566 --> 00:32:36,396
值类型


903
00:32:36,566 --> 00:32:37,606
框架可以自动确定


904
00:32:37,606 --> 00:32:39,126
数据什么时候改变


905
00:32:39,126 --> 00:32:43,146
视图也会随之变化


906
00:32:43,146 --> 00:32:44,596
总的来说 你应该倾向于选择


907
00:32:44,596 --> 00:32:46,896
不可改写访问


908
00:32:46,956 --> 00:32:48,306
但是有时你确实需要改写值


909
00:32:49,626 --> 00:32:51,596
这时我们有 Binding


910
00:32:52,256 --> 00:32:55,756
正如 Luca 刚才告诉大家的


911
00:32:55,756 --> 00:32:58,186
Binding 是数据的第一类对象


912
00:32:59,126 --> 00:33:00,976
它可以让你的组件


913
00:33:00,976 --> 00:33:03,756
在不拥有的情况下


914
00:33:03,756 --> 00:33:05,276
读写数据


915
00:33:05,276 --> 00:33:07,256
这对于可重复使用来说很有利


916
00:33:08,226 --> 00:33:09,576
实际上 你可以


917
00:33:09,576 --> 00:33:10,586
绑定到很多不同的


918
00:33:10,586 --> 00:33:11,596
数据表现


919
00:33:12,566 --> 00:33:13,836
今天我们将展示如何


920
00:33:13,836 --> 00:33:15,476
绑定到 State


921
00:33:15,476 --> 00:33:16,796
和如何绑定到


922
00:33:16,796 --> 00:33:17,486
ObjectBinding


923
00:33:18,096 --> 00:33:20,616
实际上 你也可以


924
00:33:20,616 --> 00:33:21,756
绑定另一个绑定


925
00:33:22,926 --> 00:33:24,266
你只需要用


926
00:33:24,266 --> 00:33:25,846
我们之前展示的


927
00:33:25,846 --> 00:33:26,406
美元符号前缀


928
00:33:26,406 --> 00:33:28,266
它可以让你


929
00:33:28,266 --> 00:33:29,596
从其他工具之一里


930
00:33:29,596 --> 00:33:30,346
生成一个绑定


931
00:33:30,346 --> 00:33:33,716
我想停一下让大家欣赏


932
00:33:33,716 --> 00:33:35,066
这是多么有用


933
00:33:35,946 --> 00:33:37,926
刚才 Luca 展示了


934
00:33:37,926 --> 00:33:39,316
我们在 SwiftUI 里提供的组件


935
00:33:39,376 --> 00:33:41,386
它们运行在 Binding 上


936
00:33:42,436 --> 00:33:44,286
接下来以 Toggle 为例


937
00:33:45,296 --> 00:33:47,256
Toggle 把绑定给到 Boolean


938
00:33:48,456 --> 00:33:49,856
但是 SwiftUI 中数据的美观性在于


939
00:33:49,856 --> 00:33:51,906
Toggle 不需要知道


940
00:33:51,906 --> 00:33:55,036
或不需要在意


941
00:33:55,036 --> 00:33:56,736
Boolean 在哪儿或来自哪儿


942
00:33:57,476 --> 00:33:59,446
它要做的只是


943
00:33:59,446 --> 00:34:01,906
知道如何读取和改变值


944
00:34:02,916 --> 00:34:04,106
Binding 是一个工具 


945
00:34:04,106 --> 00:34:05,926
它可以封装这些操作


946
00:34:06,246 --> 00:34:08,576
而且同时


947
00:34:08,576 --> 00:34:09,856
不需要考虑 Toggle


948
00:34:10,456 --> 00:34:14,255
这是在 SwiftUI 中使用数据的


949
00:34:14,255 --> 00:34:15,466
真正魅力所在


950
00:34:16,286 --> 00:34:17,996
你可以做到非常准确


951
00:34:18,866 --> 00:34:20,835
而且不需要担心其他的


952
00:34:23,876 --> 00:34:25,346
你会发现


953
00:34:25,346 --> 00:34:26,826
在我讲解


954
00:34:26,826 --> 00:34:28,076
搭建可重复使用组件的时候


955
00:34:28,076 --> 00:34:29,036
我实际并没怎么提及 State


956
00:34:29,356 --> 00:34:32,416
State 被卡在你的


957
00:34:32,416 --> 00:34:33,706
视图以及它的子类里


958
00:34:34,696 --> 00:34:36,846
所以如果你的组件需要


959
00:34:36,846 --> 00:34:38,045
操作一个值


960
00:34:38,156 --> 00:34:40,146
一个来自外部或其他地方的值


961
00:34:40,795 --> 00:34:43,426
State 也许不合适


962
00:34:44,235 --> 00:34:46,356
对于原型开发第一步来说


963
00:34:46,356 --> 00:34:47,366
State 是一个很好的工具


964
00:34:47,366 --> 00:34:49,386
正如你今天看到的


965
00:34:49,386 --> 00:34:50,116
它在我们播客播放器上的表现一样


966
00:34:51,196 --> 00:34:53,126
但是大部分情况下


967
00:34:53,346 --> 00:34:55,036
你的数据是存在于


968
00:34:55,226 --> 00:34:55,666
SwiftUI 之外的


969
00:34:57,386 --> 00:34:59,096
比如数据可能


970
00:34:59,096 --> 00:35:00,936
在一个数据库里 


971
00:35:00,936 --> 00:35:02,266
这可能就需要其他东西来展现它


972
00:35:02,586 --> 00:35:04,036
比如 BindableObject


973
00:35:04,726 --> 00:35:07,266
所以如果你要用 State 的话


974
00:35:07,266 --> 00:35:09,376
请退一步


975
00:35:09,376 --> 00:35:12,066
考虑一下


976
00:35:12,106 --> 00:35:13,886
数据真的需要


977
00:35:13,886 --> 00:35:14,346
被视图拥有吗


978
00:35:15,526 --> 00:35:17,806
也许数据 状态


979
00:35:17,856 --> 00:35:19,166
需要被提到父类


980
00:35:19,166 --> 00:35:20,616
就像刚才 Loca 展示的那样


981
00:35:20,616 --> 00:35:23,206
或者数据可以


982
00:35:23,206 --> 00:35:24,736
被外部源


983
00:35:24,956 --> 00:35:27,486
通过 BindableObject 展现


984
00:35:27,966 --> 00:35:31,076
所以使用数据时


985
00:35:31,076 --> 00:35:33,546
需要非常小心


986
00:35:33,546 --> 00:35:34,306
但它确实有它的优点


987
00:35:35,566 --> 00:35:37,196
State 的一大用途是


988
00:35:37,436 --> 00:35:40,066
我们框架里有按钮


989
00:35:41,486 --> 00:35:43,286
按钮用 State 追踪


990
00:35:43,576 --> 00:35:44,916
用户是否按下了按钮


991
00:35:44,916 --> 00:35:46,656
然后以合适的方式高亮它


992
00:35:47,676 --> 00:35:48,796
通过 State 处理按钮的好处是


993
00:35:48,796 --> 00:35:51,286
当你创建了一个按钮


994
00:35:51,286 --> 00:35:52,626
你不需要再考虑


995
00:35:52,626 --> 00:35:54,656
高亮状态


996
00:35:55,726 --> 00:35:58,366
数据真正


997
00:35:58,606 --> 00:36:01,336
归按钮所有


998
00:36:01,506 --> 00:36:02,566
所以当你要用 State 时


999
00:36:02,566 --> 00:36:04,816
你需要考虑的是


1000
00:36:04,816 --> 00:36:05,556
情况是否和按钮一样


1001
00:36:06,256 --> 00:36:07,516
如果一样的话


1002
00:36:07,516 --> 00:36:08,036
State 或许是个很好的工具


1003
00:36:08,906 --> 00:36:10,776
如果情况不一样


1004
00:36:10,776 --> 00:36:12,066
那你就要考虑使用其他工具了


1005
00:36:12,066 --> 00:36:13,656
我们刚才也为大家展示了


1006
00:36:13,656 --> 00:36:14,236
这些 SwiftUI 中的工具


1007
00:36:17,536 --> 00:36:18,946
这就是如何用 SwiftUI 


1008
00:36:18,946 --> 00:36:20,016
构建可重复使用组件


1009
00:36:20,686 --> 00:36:23,196
我们在这里向大家展示的是


1010
00:36:23,196 --> 00:36:25,246
对所有类型的软件都适用的


1011
00:36:25,246 --> 00:36:26,386
普遍情况


1012
00:36:27,606 --> 00:36:29,156
每个软件都有数据


1013
00:36:30,076 --> 00:36:32,126
而且每个软件都有


1014
00:36:32,176 --> 00:36:33,126
数据访问


1015
00:36:34,296 --> 00:36:36,036
仔细了解你的数据


1016
00:36:36,036 --> 00:36:38,196
尽量减少


1017
00:36:38,196 --> 00:36:40,396
数据源


1018
00:36:40,396 --> 00:36:42,356
构建可重复使用组件


1019
00:36:42,356 --> 00:36:44,986
你可以消除一整级的 Bug 


1020
00:36:45,646 --> 00:36:48,426
使用 SwiftUI 时


1021
00:36:49,016 --> 00:36:50,526
应用这些观念


1022
00:36:50,526 --> 00:36:52,596
会非常简单


1023
00:36:52,676 --> 00:36:54,096
因为我们已经把它们


1024
00:36:54,146 --> 00:36:54,556
应用在框架里了


1025
00:36:57,436 --> 00:36:58,686
我们还有很多关于


1026
00:36:58,686 --> 00:37:00,766
SwiftUI 的讲解


1027
00:37:00,766 --> 00:37:04,106
我建议大家去看一下所有的相关介绍


1028
00:37:04,306 --> 00:37:07,146
这将会改变你搭建 App 的方式


1029
00:37:08,096 --> 00:37:08,746
谢谢大家


1030
00:37:09,516 --> 00:37:15,500
[掌声]

