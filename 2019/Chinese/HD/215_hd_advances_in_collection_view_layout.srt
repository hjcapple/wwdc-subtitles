1
00:00:00,506 --> 00:00:08,516
[音乐]


2
00:00:09,516 --> 00:00:13,946
[掌声]


3
00:00:14,446 --> 00:00:14,886
>> 欢迎大家


4
00:00:15,346 --> 00:00:16,346
我的名字叫 Steve Breen


5
00:00:16,346 --> 00:00:17,856
我是 UIKit 团队的工程师


6
00:00:18,446 --> 00:00:19,436
今天和我一起的


7
00:00:19,436 --> 00:00:20,966
还有我的同事们 


8
00:00:20,966 --> 00:00:22,596
来自 AppKit 团队的 Troy Stephens


9
00:00:22,596 --> 00:00:24,716
还有来自 App Store 团队的 Abolfathi


10
00:00:26,436 --> 00:00:27,436
今天我们将谈一谈


11
00:00:27,436 --> 00:00:29,006
关于 CollectionView 布局的一些


12
00:00:29,006 --> 00:00:30,646
改进与发展


13
00:00:30,846 --> 00:00:31,486
下面我们的发言


14
00:00:31,486 --> 00:00:33,536
将分成四大部分


15
00:00:33,536 --> 00:00:34,376
首先 我们将回顾目前


16
00:00:34,376 --> 00:00:35,316
这项技术的发展状况


17
00:00:35,316 --> 00:00:35,966
也就是现在我们是怎么做的


18
00:00:35,966 --> 00:00:38,076
我们如何定义 App 中的


19
00:00:38,076 --> 00:00:39,456
CollectionView 布局


20
00:00:40,436 --> 00:00:41,326
之后 我们会介绍一种


21
00:00:41,426 --> 00:00:43,216
全新的方法


22
00:00:43,216 --> 00:00:44,406
今年会将它应用到所有平台上


23
00:00:44,406 --> 00:00:46,256
包括 iOS 和 tvOS 以及 Mac


24
00:00:46,896 --> 00:00:48,326
接着 我们将进行一些


25
00:00:48,326 --> 00:00:49,956
实际操作的演示


26
00:00:49,956 --> 00:00:51,556
这样就能看到运行中的 API 了


27
00:00:52,276 --> 00:00:53,526
最后 我们将为大家展示


28
00:00:53,526 --> 00:00:55,136
更多的高级功能


29
00:00:55,136 --> 00:00:56,886
以使这个 API 发挥最大功效


30
00:01:00,236 --> 00:01:01,746
我们的内容很多


31
00:01:01,746 --> 00:01:03,346
我们开始吧


32
00:01:04,215 --> 00:01:06,306
首先我们说一说


33
00:01:06,306 --> 00:01:07,166
现在这项技术的发展状况


34
00:01:07,166 --> 00:01:07,876
我们现在是怎么做的呢


35
00:01:07,876 --> 00:01:10,056
我们是如何定义 CollectionView 布局的呢


36
00:01:11,336 --> 00:01:13,176
当 CollectionView


37
00:01:13,176 --> 00:01:15,206
被引入 iOS 6 的时候


38
00:01:15,206 --> 00:01:17,006
就有一个很新颖的概念


39
00:01:17,006 --> 00:01:18,426
它用一个单独的抽象概念


40
00:01:18,426 --> 00:01:19,256
来定义布局


41
00:01:20,156 --> 00:01:21,766
因此它其实是


42
00:01:21,766 --> 00:01:22,906
相互配合作用的两个类


43
00:01:22,906 --> 00:01:23,686
一个负责渲染


44
00:01:23,686 --> 00:01:25,626
另一个负责布局


45
00:01:25,626 --> 00:01:27,966
也就是 CollectionView 布局


46
00:01:28,856 --> 00:01:30,256
CollectionView 布局是一个


47
00:01:30,256 --> 00:01:31,166
抽象的概念


48
00:01:31,166 --> 00:01:32,676
所以我们必须将其编入子类


49
00:01:32,676 --> 00:01:33,306
去使用它


50
00:01:33,356 --> 00:01:35,416
我们之前在 iOS 6 中装载了


51
00:01:35,416 --> 00:01:37,336
一个具体的布局类


52
00:01:37,336 --> 00:01:38,576
称作 CollectionView 流式布局


53
00:01:40,136 --> 00:01:41,696
流式布局对许多不同的设计


54
00:01:41,696 --> 00:01:43,476
都十分有用


55
00:01:43,476 --> 00:01:44,926
特别是在 iOS 6 时期


56
00:01:44,926 --> 00:01:46,126
当时的情况


57
00:01:46,126 --> 00:01:47,176
可能更简单一些


58
00:01:48,066 --> 00:01:49,576
当时这么做是因为它使用的


59
00:01:49,576 --> 00:01:51,306
是一种基于行的布局系统


60
00:01:51,306 --> 00:01:53,606
去年 我们在


61
00:01:54,146 --> 00:01:55,686
UI CollectionView 中讲到了它


62
00:01:56,146 --> 00:01:57,826
但总的来说 一个基于行的系统


63
00:01:57,826 --> 00:01:59,096
使你能够在正交轴上进行布局


64
00:01:59,096 --> 00:02:00,576
设置布局轴


65
00:02:00,576 --> 00:02:02,386
直到你填满


66
00:02:02,386 --> 00:02:03,496
可用的空间数量


67
00:02:03,496 --> 00:02:05,026
然后开始下一行


68
00:02:05,726 --> 00:02:07,726
这种方法真的很不错


69
00:02:07,726 --> 00:02:09,446
它运行简单 推理容易


70
00:02:09,485 --> 00:02:10,826
你很快就可以做好布局


71
00:02:11,786 --> 00:02:15,736
但是今天的 App 呢


72
00:02:16,636 --> 00:02:18,906
随着设备的异构性增强


73
00:02:18,906 --> 00:02:20,656
和屏幕大小的改变


74
00:02:20,656 --> 00:02:21,756
在如今的 App 里


75
00:02:21,756 --> 00:02:23,326
情况变得更加复杂了


76
00:02:23,326 --> 00:02:25,186
在这里我们看到的是


77
00:02:25,326 --> 00:02:26,866
装载在 iOS 13 中的 App Store


78
00:02:27,736 --> 00:02:29,236
如果今设计师天交给你这样的设计


79
00:02:29,236 --> 00:02:31,116
你会怎么办呢


80
00:02:31,116 --> 00:02:32,216
你肯定会想


81
00:02:32,216 --> 00:02:33,986
“好吧 我得选择如何进行设计”


82
00:02:33,986 --> 00:02:35,156
因为现在我们可选的选项


83
00:02:35,156 --> 00:02:35,716
远多于从前


84
00:02:36,806 --> 00:02:38,656
然后你也许会选定 CollectionView


85
00:02:38,656 --> 00:02:40,426
而如果你选定了它


86
00:02:40,486 --> 00:02:42,196
你就会想


87
00:02:42,196 --> 00:02:43,406
“我真的能在这里实现流式布局吗”


88
00:02:44,256 --> 00:02:45,666
然后你有可能立刻放弃它


89
00:02:47,196 --> 00:02:47,976
你所面对的


90
00:02:47,976 --> 00:02:49,486
则是一个自定布局


91
00:02:49,486 --> 00:02:51,256
并且 我看到你们在 Twitter 上


92
00:02:51,256 --> 00:02:52,876
关于自定布局的讨论


93
00:02:52,876 --> 00:02:53,996
它们可能会很复杂


94
00:02:53,996 --> 00:02:55,676
去年我们在


95
00:02:55,766 --> 00:02:58,136
CollectionView 的介绍中讨论过它


96
00:02:58,716 --> 00:03:00,256
我们当时讨论了


97
00:03:00,256 --> 00:03:02,076
创建一个自定布局所需要的东西


98
00:03:03,476 --> 00:03:05,016
你需要


99
00:03:05,266 --> 00:03:06,536
在你的具体的布局类中


100
00:03:06,536 --> 00:03:08,976
提供一定数量的东西


101
00:03:09,336 --> 00:03:10,486
我们也讨论了这些东西


102
00:03:10,756 --> 00:03:12,236
同时我们也考虑到了


103
00:03:12,286 --> 00:03:13,566
一些性能注意事项


104
00:03:13,566 --> 00:03:14,776
这是你在设计一个自定布局时


105
00:03:14,776 --> 00:03:15,976
所必须要考虑的事情


106
00:03:15,976 --> 00:03:17,386
以确保当你的 CollectionView 中


107
00:03:17,386 --> 00:03:18,466
有大量的项目时


108
00:03:18,466 --> 00:03:19,046
它依然能快速运行


109
00:03:19,576 --> 00:03:20,716
但我们并没有涵盖所有的情况


110
00:03:20,716 --> 00:03:22,286
如果我们创建这些


111
00:03:22,286 --> 00:03:23,356
自定布局的话


112
00:03:23,356 --> 00:03:24,296
还会遇到其他的挑战


113
00:03:25,436 --> 00:03:26,766
有很多这样的例子


114
00:03:26,766 --> 00:03:27,876
我将在这里介绍一些


115
00:03:27,916 --> 00:03:29,286
比如 补充视图


116
00:03:29,286 --> 00:03:31,246
和装饰视图


117
00:03:31,246 --> 00:03:33,416
都是可以在 CollectionView 里


118
00:03:33,416 --> 00:03:34,816
搞得定的视图


119
00:03:34,816 --> 00:03:36,236
而它们在自定布局里就有点棘手了


120
00:03:36,236 --> 00:03:36,986
你只能靠自己了


121
00:03:37,566 --> 00:03:39,296
同时还有自定尺寸这一挑战


122
00:03:39,296 --> 00:03:40,556
你都得想办法解决


123
00:03:41,016 --> 00:03:42,336
之后我们还会谈到这个


124
00:03:42,606 --> 00:03:44,186
今年我们将一种


125
00:03:44,186 --> 00:03:46,796
全新的具体的布局类


126
00:03:46,796 --> 00:03:48,666
应用到平台中


127
00:03:48,666 --> 00:03:50,676
作为流式布局的同级


128
00:03:51,286 --> 00:03:53,886
我们称之为组合布局


129
00:03:54,986 --> 00:03:55,706
好的


130
00:03:56,091 --> 00:03:58,091
[掌声]


131
00:03:58,166 --> 00:03:59,936
我们还没看过这种布局呢


132
00:04:00,566 --> 00:04:02,686
什么是组合布局呢


133
00:04:02,686 --> 00:04:03,496
它是做什么的呢


134
00:04:04,606 --> 00:04:06,856
先讲一点原理


135
00:04:06,916 --> 00:04:08,076
这是建立在什么基础上的呢


136
00:04:08,076 --> 00:04:09,656
它有三个基本支柱


137
00:04:09,656 --> 00:04:10,976
我们在上面搭建组合布局


138
00:04:10,976 --> 00:04:12,466
首先 它是可组合的


139
00:04:12,466 --> 00:04:13,816
也就是用简单的东西


140
00:04:13,816 --> 00:04:14,696
来制作复杂的东西


141
00:04:15,636 --> 00:04:17,086
同时它也是灵活的


142
00:04:17,555 --> 00:04:19,866
你可以用组合布局


143
00:04:19,866 --> 00:04:20,606
来写任何布局


144
00:04:20,606 --> 00:04:21,776
它十分灵活


145
00:04:21,776 --> 00:04:23,496
在默认情况下它的速度也很快


146
00:04:23,496 --> 00:04:25,296
我们之前已经


147
00:04:25,296 --> 00:04:26,626
在框架中进行了


148
00:04:26,626 --> 00:04:27,966
所有的性能优化


149
00:04:27,966 --> 00:04:28,836
因此在这里不用考虑这点


150
00:04:28,836 --> 00:04:30,276
组合布局就是


151
00:04:30,276 --> 00:04:32,376
描述或定义你想做什么


152
00:04:32,376 --> 00:04:33,766
它是一种描述性的 API


153
00:04:36,346 --> 00:04:37,376
“组成”这个词


154
00:04:37,376 --> 00:04:39,016
你将会在本讲座中听到很多次


155
00:04:39,016 --> 00:04:40,776
我们该如何用组合布局


156
00:04:40,776 --> 00:04:41,776
来进行组成呢


157
00:04:41,776 --> 00:04:43,186
我们会用小块的布局


158
00:04:43,186 --> 00:04:44,636
这些小组件


159
00:04:44,636 --> 00:04:46,896
将它们缝合在一起


160
00:04:47,196 --> 00:04:48,556
这样你就用小块的布局


161
00:04:48,556 --> 00:04:50,126
组成了更大的布局


162
00:04:50,516 --> 00:04:51,766
我们已经从大量相关课程里


163
00:04:51,766 --> 00:04:52,916
学习了流式布局


164
00:04:52,916 --> 00:04:54,416
通过这些基于行的课程


165
00:04:54,416 --> 00:04:56,836
你可以学习沿着行进行布局


166
00:04:56,916 --> 00:04:57,956
我们也许知道有多少项目


167
00:04:57,956 --> 00:04:58,506
也许不知道


168
00:04:58,506 --> 00:04:59,766
但我们可以在这些小布局组中的


169
00:04:59,766 --> 00:05:01,126
一行上布局项目


170
00:05:02,626 --> 00:05:03,506
最后 正如名字所示


171
00:05:03,506 --> 00:05:05,656
你不用设置子类


172
00:05:05,656 --> 00:05:06,496
你只需要构建一个东西


173
00:05:06,496 --> 00:05:08,096
然后将一些元素组合起来


174
00:05:08,096 --> 00:05:09,706
之后就可以运行了


175
00:05:09,706 --> 00:05:13,676
说了这么多还没有看代码


176
00:05:13,676 --> 00:05:14,686
在这样的会议上


177
00:05:14,686 --> 00:05:15,696
讨论的应该全是代码


178
00:05:15,696 --> 00:05:17,586
我们来看些代码吧


179
00:05:18,056 --> 00:05:22,026
这是一个 Hello World


180
00:05:22,376 --> 00:05:23,156
组合布局


181
00:05:23,206 --> 00:05:24,676
共有五行代码


182
00:05:24,676 --> 00:05:27,036
现在 我要切换到


183
00:05:27,036 --> 00:05:28,666
我这里的设备


184
00:05:30,026 --> 00:05:33,446
这里展示的是我们的示例 App


185
00:05:33,446 --> 00:05:35,536
接着是列表示例


186
00:05:35,886 --> 00:05:36,876
哇 这个布局挺无聊的


187
00:05:36,876 --> 00:05:38,496
看起来像个表格 


188
00:05:39,296 --> 00:05:41,436
这不重要


189
00:05:41,806 --> 00:05:46,336
下面我们把重点


190
00:05:46,336 --> 00:05:47,236
放在代码上


191
00:05:47,236 --> 00:05:47,976
我们来看这个


192
00:05:48,886 --> 00:05:50,846
这里我们马上


193
00:05:50,986 --> 00:05:52,206
就会有一些发现


194
00:05:52,206 --> 00:05:53,426
那第一个发现


195
00:05:53,426 --> 00:05:54,986
因为我知道开发者们会说


196
00:05:54,986 --> 00:05:55,896
“嘿 Steve 我可以在流式布局中


197
00:05:55,936 --> 00:05:57,956
用两行代码完成这个


198
00:05:57,996 --> 00:05:59,146
你这个有什么意义呢”


199
00:05:59,856 --> 00:06:01,476
这种想法的确没错


200
00:06:01,476 --> 00:06:03,156
你也许可以那样做


201
00:06:03,156 --> 00:06:05,186
但在听完今天的整个发言后


202
00:06:05,186 --> 00:06:05,996
我希望你们


203
00:06:05,996 --> 00:06:07,416
记住和思考的是


204
00:06:07,416 --> 00:06:08,996
当这些布局变得更多更复杂的时候


205
00:06:08,996 --> 00:06:10,096
我们不会让代码量


206
00:06:10,096 --> 00:06:12,766
随着问题的大小


207
00:06:12,766 --> 00:06:14,126
呈线性增长


208
00:06:14,126 --> 00:06:14,686
而是逐渐减少


209
00:06:14,686 --> 00:06:15,286
因为我们只要将


210
00:06:15,286 --> 00:06:16,806
新的东西组到布局中去


211
00:06:16,806 --> 00:06:18,436
用一种非常简单的


212
00:06:18,676 --> 00:06:20,526
容易推出的方法


213
00:06:20,526 --> 00:06:21,966
来得到十分复杂的布局


214
00:06:22,626 --> 00:06:23,876
我非常激动能向你们展示这些成果


215
00:06:24,636 --> 00:06:26,316
第二个发现是


216
00:06:26,466 --> 00:06:27,406
我想要你们看看


217
00:06:27,406 --> 00:06:29,746
这些类型中有一个自然过渡 


218
00:06:29,746 --> 00:06:31,076
这里我们一共有五种类型


219
00:06:31,076 --> 00:06:32,226
这里什么情况


220
00:06:33,246 --> 00:06:34,926
我首先要关注的类型


221
00:06:35,136 --> 00:06:36,666
是这四种类型


222
00:06:36,666 --> 00:06:38,216
它们在逐级递进时


223
00:06:38,216 --> 00:06:40,306
自然会看到这个抽象过程


224
00:06:40,536 --> 00:06:42,596
我们从一个项目开始


225
00:06:42,596 --> 00:06:43,716
这个项目被折叠成一个组


226
00:06:43,716 --> 00:06:45,916
这个组又变成一个段


227
00:06:46,366 --> 00:06:48,606
而这个段又变为我们的布局


228
00:06:49,856 --> 00:06:51,756
现在 我们直观地看一下


229
00:06:53,386 --> 00:06:58,016
这里 这个大矩形就是布局


230
00:06:58,016 --> 00:07:01,716
这个布局是你整个的布局


231
00:07:02,426 --> 00:07:03,676
然后这些明显的白色部分


232
00:07:03,676 --> 00:07:06,456
代表我们的段


233
00:07:06,806 --> 00:07:08,256
这会直接映射到


234
00:07:08,256 --> 00:07:09,966
数据源 也就是


235
00:07:09,966 --> 00:07:10,726
那些段中的内容


236
00:07:11,606 --> 00:07:12,316
接着在这个具体的例子里


237
00:07:12,316 --> 00:07:14,126
我们展示的是一种


238
00:07:14,126 --> 00:07:15,766
传统的网格型布局


239
00:07:15,766 --> 00:07:17,666
我们可以看到这些组


240
00:07:17,666 --> 00:07:19,026
代表了我们的行


241
00:07:19,886 --> 00:07:22,016
在里面的就是项目


242
00:07:22,906 --> 00:07:24,086
这里主要是为了


243
00:07:24,086 --> 00:07:25,136
展示这个将贯穿


244
00:07:25,136 --> 00:07:26,296
整个演讲的层次结构


245
00:07:26,326 --> 00:07:27,706
也就是这种重复的模式


246
00:07:27,806 --> 00:07:31,106
项目 组 段 布局的模式


247
00:07:33,076 --> 00:07:34,256
现在我想要


248
00:07:34,256 --> 00:07:35,296
简要谈一谈


249
00:07:35,296 --> 00:07:36,486
一些概念


250
00:07:36,486 --> 00:07:38,526
在组合布局中的这些核心类型


251
00:07:38,636 --> 00:07:40,046
只要我们弄懂这些


252
00:07:40,046 --> 00:07:41,006
我们就可以直接跳到


253
00:07:41,006 --> 00:07:42,486
实际演示中来检测其适用性


254
00:07:42,526 --> 00:07:45,266
我想从设定尺寸


255
00:07:45,266 --> 00:07:46,316
开始讲起


256
00:07:47,236 --> 00:07:48,306
组合布局扩展了


257
00:07:48,306 --> 00:07:49,906
设定尺寸的功能


258
00:07:49,906 --> 00:07:51,226
让你更容易推出


259
00:07:51,226 --> 00:07:52,876
在一个组合布局里面


260
00:07:52,876 --> 00:07:53,866
如何设定尺寸


261
00:07:54,566 --> 00:07:56,226
所有东西都有一个清楚的尺寸


262
00:07:56,226 --> 00:07:57,766
每个东西的大小


263
00:07:57,766 --> 00:07:58,696
都十分明确


264
00:08:00,076 --> 00:08:01,836
现在 我们在这个欧几里得


265
00:08:01,836 --> 00:08:03,266
二维几何平面上


266
00:08:03,336 --> 00:08:03,856
用弯曲视图


267
00:08:03,856 --> 00:08:05,916
因此 一个尺寸实际上


268
00:08:05,916 --> 00:08:06,756
只是两个属性


269
00:08:06,756 --> 00:08:08,646
一个是宽度 一个是高度


270
00:08:09,466 --> 00:08:11,756
这里我们可以看到


271
00:08:11,756 --> 00:08:12,866
我们得到了该类型的


272
00:08:12,896 --> 00:08:13,696
简化版定义


273
00:08:13,696 --> 00:08:15,646
它有一个宽度和一个高度


274
00:08:15,646 --> 00:08:16,686
但要注意的是


275
00:08:16,686 --> 00:08:17,396
宽度和高度这两个维度


276
00:08:17,396 --> 00:08:18,676
它们并不是标量值


277
00:08:18,676 --> 00:08:19,506
它不只是一个浮点数或其他


278
00:08:19,506 --> 00:08:20,846
它其实是另一种类型


279
00:08:20,896 --> 00:08:22,116
也就是


280
00:08:22,166 --> 00:08:24,046
NSCollectionLayoutDimension


281
00:08:25,136 --> 00:08:26,156
那又是什么呢


282
00:08:26,956 --> 00:08:27,756
其实很简单


283
00:08:27,896 --> 00:08:29,896
这是用一种不依赖于轴的方式


284
00:08:29,896 --> 00:08:31,966
来描述一个具体的轴的大小


285
00:08:31,966 --> 00:08:32,876
我们有四个不同的方法


286
00:08:32,876 --> 00:08:35,015
来定义这个东西


287
00:08:35,775 --> 00:08:36,885
我们用一种可视的方式


288
00:08:36,885 --> 00:08:38,586
来完成这些


289
00:08:39,716 --> 00:08:41,395
你现在有一个项目


290
00:08:41,395 --> 00:08:42,296
你想要描述它


291
00:08:42,296 --> 00:08:44,166
相对于其容器的大小


292
00:08:44,926 --> 00:08:45,906
最外层的容器


293
00:08:45,906 --> 00:08:46,676
将会是你的 CollectionView


294
00:08:47,256 --> 00:08:48,376
在这里我们只说


295
00:08:48,376 --> 00:08:49,976
这个项目的宽度


296
00:08:49,976 --> 00:08:51,176
会是其容器宽度的


297
00:08:51,176 --> 00:08:53,246
一部分或 50%


298
00:08:54,656 --> 00:08:56,846
同样的 我们可以说


299
00:08:56,846 --> 00:08:58,056
某个东西的高度


300
00:08:58,056 --> 00:08:59,566
是其容器高度的一部分


301
00:08:59,566 --> 00:09:01,566
在这里是 30%


302
00:09:03,496 --> 00:09:05,266
因为我们可以用这种


303
00:09:05,266 --> 00:09:07,656
不依赖轴的方法来描述某物


304
00:09:07,656 --> 00:09:09,616
我们就可以用


305
00:09:09,616 --> 00:09:11,486
具体的长宽比来定义某物


306
00:09:11,486 --> 00:09:12,816
在这个例子里长宽比是 1


307
00:09:12,816 --> 00:09:15,516
通过将宽度和高度


308
00:09:15,666 --> 00:09:18,166
定义为一个维度


309
00:09:18,166 --> 00:09:19,876
即其容器宽度的一部分


310
00:09:20,526 --> 00:09:22,186
因此当它的宽度为


311
00:09:22,186 --> 00:09:23,496
其容器的 25% 时


312
00:09:23,676 --> 00:09:24,326
其高度也是 25%


313
00:09:25,906 --> 00:09:26,656
这些就是


314
00:09:26,876 --> 00:09:28,716
创建维度的分数变量


315
00:09:29,626 --> 00:09:31,006
基于点的值呢


316
00:09:31,736 --> 00:09:32,636
我们有两个


317
00:09:33,256 --> 00:09:34,876
第一个是最简单的 绝对值


318
00:09:35,536 --> 00:09:36,296
你把这个值设为 200 点


319
00:09:36,296 --> 00:09:37,246
因为你的设计师


320
00:09:37,246 --> 00:09:40,256
强调它必须是 200 点


321
00:09:40,256 --> 00:09:42,076
那它就是这样的 


322
00:09:42,076 --> 00:09:42,796
接着在这里


323
00:09:42,986 --> 00:09:44,336
就一个有趣的概念 估算值


324
00:09:45,376 --> 00:09:47,246
如果你不知道具体的


325
00:09:47,246 --> 00:09:48,166
项目的尺寸是多少


326
00:09:48,166 --> 00:09:49,606
我们会经常这样说


327
00:09:49,736 --> 00:09:51,056
你可以估计其大小


328
00:09:51,056 --> 00:09:52,206
假设它是 200 点


329
00:09:52,566 --> 00:09:55,226
随着时间的过去


330
00:09:55,226 --> 00:09:56,456
它会随着项目的渲染而增长


331
00:09:56,456 --> 00:09:57,566
我们对这个项目中的内容


332
00:09:57,566 --> 00:09:59,436
也会更加了解


333
00:10:00,506 --> 00:10:03,996
这就是布局的维度和尺寸


334
00:10:05,146 --> 00:10:06,666
接下来我们来谈一谈项目


335
00:10:06,666 --> 00:10:07,656
这很简单


336
00:10:07,656 --> 00:10:09,406
这是一个储存格或者补充物


337
00:10:09,406 --> 00:10:11,116
它是一个呈现在屏幕上的东西


338
00:10:12,296 --> 00:10:14,886
你会在 STK 中看到更多的东西


339
00:10:14,886 --> 00:10:16,866
但这只是那种类型定义的一小部分


340
00:10:17,586 --> 00:10:18,516
我们发现当我们构建这些东西时


341
00:10:18,516 --> 00:10:20,756
我们总要给它一个尺寸


342
00:10:20,996 --> 00:10:22,566
所有的东西都要有一个尺寸


343
00:10:23,236 --> 00:10:25,866
我们就接着说


344
00:10:25,916 --> 00:10:27,146
按照抽象层级


345
00:10:27,146 --> 00:10:28,536
已经说过了项目 下面我们来说组


346
00:10:28,856 --> 00:10:29,536
所以什么是组呢


347
00:10:29,536 --> 00:10:31,366
组是层级中的骨干


348
00:10:31,366 --> 00:10:33,206
它就是你要


349
00:10:33,206 --> 00:10:34,756
组成的布局的基本单元


350
00:10:34,756 --> 00:10:37,286
有三种形式


351
00:10:37,426 --> 00:10:38,506
水平 垂直 和自定


352
00:10:39,136 --> 00:10:39,976
你可以把这些想象成


353
00:10:39,976 --> 00:10:41,226
小型的流式布局 


354
00:10:41,226 --> 00:10:42,696
它们布局在水平轴


355
00:10:42,696 --> 00:10:44,496
和垂直轴的一条线上


356
00:10:45,426 --> 00:10:46,806
但要记住 我们之前说过


357
00:10:46,806 --> 00:10:48,556
它是十分灵活的


358
00:10:48,696 --> 00:10:50,426
如果你有一些东西


359
00:10:50,426 --> 00:10:51,446
没有沿着该线进行布局


360
00:10:51,446 --> 00:10:52,826
很多布局就都没有做到这一点


361
00:10:53,176 --> 00:10:54,316
我们可以用一个自定组


362
00:10:55,096 --> 00:10:56,166
那是什么呢


363
00:10:57,286 --> 00:10:58,726
自定组让你以一种


364
00:10:58,726 --> 00:11:00,876
自定义的方式


365
00:11:00,876 --> 00:11:02,446
描述项目的绝对大小和位置


366
00:11:02,446 --> 00:11:03,436
所以如果你有


367
00:11:03,436 --> 00:11:04,896
预定义的生成器


368
00:11:04,896 --> 00:11:06,726
来生成布局 那你就可以用自定组


369
00:11:07,286 --> 00:11:08,166
或者如果你要做一个径向的布局


370
00:11:08,166 --> 00:11:09,096
并且你想要计算它


371
00:11:09,096 --> 00:11:10,926
那你也可以用自定组来完成


372
00:11:11,526 --> 00:11:12,896
很厉害的是


373
00:11:12,896 --> 00:11:14,066
你可以直接在垂直


374
00:11:14,066 --> 00:11:15,786
和水平方向上组成自定义组


375
00:11:15,786 --> 00:11:17,596
也就是用简单


376
00:11:17,596 --> 00:11:18,016
构建复杂


377
00:11:19,696 --> 00:11:22,156
这就是组 层级中的骨干


378
00:11:23,486 --> 00:11:24,446
接下来我们要说


379
00:11:24,666 --> 00:11:26,276
NSCollectionLayoutSection


380
00:11:27,166 --> 00:11:28,666
正如它的名字所示


381
00:11:28,666 --> 00:11:29,806
这是一种基于


382
00:11:29,886 --> 00:11:31,586
CollectionView 中每个段的


383
00:11:31,586 --> 00:11:32,936
布局定义


384
00:11:33,066 --> 00:11:34,196
可以把该段中有多少项目


385
00:11:34,196 --> 00:11:37,406
直接映射到该段的数据源


386
00:11:37,406 --> 00:11:38,886
正如预期 我们看到


387
00:11:39,466 --> 00:11:40,556
对段进行初始化


388
00:11:40,556 --> 00:11:42,146
只需输入布局组
 
00:11:42,676 --> 00:11:45,106
我们已经讲过了项目 组 和段


389
00:11:45,916 --> 00:11:49,076
在这部分的最后


390
00:11:49,076 --> 00:11:51,686
我们将讲到两个


391
00:11:51,686 --> 00:11:53,486
顶级的布局类


392
00:11:53,566 --> 00:11:56,786
在 iOS 和 tvOS 中我们有


393
00:11:56,786 --> 00:11:58,296
UICollectionViewCompositionalLayout


394
00:11:59,016 --> 00:12:00,856
而在 Mac 中我们有


395
00:12:01,356 --> 00:12:02,646
NSViewCompositionalLayout


396
00:12:03,806 --> 00:12:05,026
有趣的是


397
00:12:05,116 --> 00:12:06,556
这些布局的定义都是一样的


398
00:12:06,556 --> 00:12:08,896
无论应用在哪个平台


399
00:12:09,586 --> 00:12:10,236
它们只是在顶级类上


400
00:12:10,236 --> 00:12:12,896
有一些细微的差别


401
00:12:13,516 --> 00:12:15,046
最后在这里要说的是


402
00:12:15,046 --> 00:12:15,866
一件十分有趣的事


403
00:12:15,866 --> 00:12:16,546
我们也会在之后的


404
00:12:16,546 --> 00:12:17,296
演示中看到更多


405
00:12:17,296 --> 00:12:20,956
构建一个组合布局的方法


406
00:12:21,126 --> 00:12:22,056
有两种方法


407
00:12:22,556 --> 00:12:24,486
最简单的方法是


408
00:12:24,486 --> 00:12:26,206
直接描述一个布局段的定义


409
00:12:26,416 --> 00:12:27,776
这和我们今天在流式布局中


410
00:12:27,776 --> 00:12:29,296
所用的方法差不多


411
00:12:29,296 --> 00:12:30,696
因为流式布局将每个段的量


412
00:12:30,696 --> 00:12:31,926
定义为与其他所有段一样


413
00:12:31,926 --> 00:12:33,206
因而它是均匀的


414
00:12:34,396 --> 00:12:36,946
而组合布局则扩展了这个想法


415
00:12:37,526 --> 00:12:38,646
因为现在我们有了


416
00:12:38,646 --> 00:12:39,856
这种对段的定义


417
00:12:39,856 --> 00:12:42,976
我们就可以指定一个闭包


418
00:12:43,236 --> 00:12:44,856
该闭包将被调回


419
00:12:44,856 --> 00:12:46,586
并将在每个段的基础上


420
00:12:46,586 --> 00:12:48,876
请求这些段的定义


421
00:12:49,236 --> 00:12:51,126
这样就带来了许多的可能性


422
00:12:51,126 --> 00:12:52,306
因为现在你的布局


423
00:12:52,736 --> 00:12:53,846
能够在段间


424
00:12:53,846 --> 00:12:55,876
被完全区分开


425
00:12:55,976 --> 00:12:57,886
在之后的演示中


426
00:12:57,886 --> 00:12:59,276
我们会向你们展示很多


427
00:12:59,276 --> 00:13:02,016
现在就到演示的部分了


428
00:13:02,176 --> 00:13:03,926
关于类型的讨论已经够多了


429
00:13:04,006 --> 00:13:05,626
下面我们要看看它的实际应用


430
00:13:05,626 --> 00:13:06,536
这一部分就交给


431
00:13:06,536 --> 00:13:08,896
我的同事 Troy Stephens


432
00:13:08,896 --> 00:13:09,116
Troy


433
00:13:10,321 --> 00:13:12,321
[掌声]


434
00:13:12,626 --> 00:13:13,266
>> 谢谢 Steve


435
00:13:14,776 --> 00:13:16,676
接下来 我们就来看一些代码


436
00:13:16,676 --> 00:13:17,816
我们将深入探讨


437
00:13:17,816 --> 00:13:19,716
一些实用的方法


438
00:13:19,716 --> 00:13:21,416
我们如何用 Steve 刚才描述的


439
00:13:21,516 --> 00:13:22,886
这些简单的元素


440
00:13:23,046 --> 00:13:24,366
来构建任意类型的


441
00:13:24,366 --> 00:13:25,406
你想要的布局


442
00:13:25,956 --> 00:13:27,016
因此如果你还没有下载


443
00:13:27,016 --> 00:13:28,596
本次讲座的示例项目的话


444
00:13:28,596 --> 00:13:29,496
请务必下载


445
00:13:29,986 --> 00:13:31,306
这样你就可以跟着做


446
00:13:31,486 --> 00:13:33,156
还能有空的时候研究一下


447
00:13:33,156 --> 00:13:35,506
最重要的是可以在你自己的项目中


448
00:13:35,506 --> 00:13:37,246
免费使用我们的代码


449
00:13:37,756 --> 00:13:38,736
而无论你想要完成


450
00:13:38,736 --> 00:13:39,656
哪种布局的构建


451
00:13:39,656 --> 00:13:41,236
你都能在我们今天


452
00:13:41,236 --> 00:13:42,356
所讲的例子里


453
00:13:42,356 --> 00:13:43,746
找到与之类似的案例


454
00:13:44,376 --> 00:13:45,916
用我们的代码作为基础


455
00:13:45,916 --> 00:13:46,806
进行你的布局


456
00:13:46,806 --> 00:13:48,266
你将会更快更有效地


457
00:13:48,266 --> 00:13:49,056
接近你的目标


458
00:13:49,096 --> 00:13:50,706
我们将看到这很容易


459
00:13:50,796 --> 00:13:52,696
我们利用任意现有的


460
00:13:52,696 --> 00:13:54,226
组合布局描述


461
00:13:54,566 --> 00:13:56,246
并逐步改进它


462
00:13:56,246 --> 00:13:57,666
使之成为你想要的布局


463
00:13:59,026 --> 00:13:59,996
当我们看完今天的示例


464
00:13:59,996 --> 00:14:01,566
我想让你们注意的是


465
00:14:01,566 --> 00:14:03,726
每一个例子中都有


466
00:14:03,726 --> 00:14:04,806
相同的基本模式


467
00:14:05,076 --> 00:14:07,236
这就是 Steve 向我们介绍的模式


468
00:14:07,916 --> 00:14:09,466
每一个组合布局描述


469
00:14:09,466 --> 00:14:11,346
都由四个相同的


470
00:14:11,346 --> 00:14:13,846
基础部分组成


471
00:14:13,976 --> 00:14:15,896
分别是项目 组和段的描述


472
00:14:15,896 --> 00:14:17,596
以及包含三者的


473
00:14:17,596 --> 00:14:19,146
整个布局


474
00:14:19,496 --> 00:14:20,936
在接下来我们看的


475
00:14:20,936 --> 00:14:21,606
每一个代码示例里


476
00:14:21,606 --> 00:14:22,836
我们都将会看到相同的


477
00:14:22,836 --> 00:14:24,346
四层嵌套结构


478
00:14:24,726 --> 00:14:26,036
在更高级的讨论中


479
00:14:26,036 --> 00:14:27,056
我们将看到如何


480
00:14:27,056 --> 00:14:28,776
将组嵌套进其他的组中


481
00:14:28,776 --> 00:14:30,166
利用这些简单的


482
00:14:30,206 --> 00:14:32,476
易懂的部分


483
00:14:32,506 --> 00:14:34,306
来构建或组成


484
00:14:34,476 --> 00:14:37,026
更为复杂精细的布局


485
00:14:37,676 --> 00:14:38,686
接下来我们来看代码


486
00:14:45,066 --> 00:14:46,286
这里我们会从


487
00:14:46,286 --> 00:14:47,876
我们的列表示例开始


488
00:14:48,456 --> 00:14:49,646
这是 Steve 之前展示过的那个


489
00:14:49,646 --> 00:14:51,426
在这里 这是我们


490
00:14:51,426 --> 00:14:54,396
能想到的最简单的有用的布局


491
00:14:54,576 --> 00:14:56,456
这一个单列列表


492
00:14:56,456 --> 00:14:58,226
其中项目的宽度与


493
00:14:58,226 --> 00:14:58,956
CollectionView 相当


494
00:14:59,656 --> 00:15:02,316
如果我把手机转过来


495
00:15:02,316 --> 00:15:03,646
我们能看到这些项目的确会


496
00:15:03,646 --> 00:15:05,206
进行扩展以填充可用的宽度


497
00:15:05,206 --> 00:15:06,836
但同时可以


498
00:15:06,836 --> 00:15:07,966
保持原有高度不变


499
00:15:08,376 --> 00:15:09,656
我们如何用组合布局


500
00:15:09,726 --> 00:15:11,016
来实施这个呢


501
00:15:11,566 --> 00:15:12,956
我打开了列表视图


502
00:15:12,956 --> 00:15:14,946
控制器源文件


503
00:15:14,946 --> 00:15:15,836
这就是我们


504
00:15:15,836 --> 00:15:16,656
实施布局的地方


505
00:15:16,686 --> 00:15:17,856
在今天要讲的每个例子里


506
00:15:17,856 --> 00:15:19,476
我们进行了一个


507
00:15:19,476 --> 00:15:20,986
CreatLayout 的函数


508
00:15:20,986 --> 00:15:22,346
它能够灵活地将


509
00:15:22,346 --> 00:15:23,936
组合布局的描述


510
00:15:23,936 --> 00:15:25,686
打包封装起来


511
00:15:25,686 --> 00:15:27,456
然后再返回来连接到


512
00:15:27,456 --> 00:15:28,676
我们的 CollectionView 中


513
00:15:28,676 --> 00:15:29,626
就像其他任何的


514
00:15:29,746 --> 00:15:30,906
CollectionView 布局一样


515
00:15:31,836 --> 00:15:33,056
这里要注意的第一件事


516
00:15:33,606 --> 00:15:35,606
就是我们之前说过的


517
00:15:35,606 --> 00:15:37,656
要从描述一个项目及其尺寸开始


518
00:15:38,536 --> 00:15:39,906
我们先描述一个项目


519
00:15:40,396 --> 00:15:42,036
然后用它来描述


520
00:15:42,036 --> 00:15:44,626
一个项目组


521
00:15:45,156 --> 00:15:46,906
接着我们把该组放进一个段里


522
00:15:47,636 --> 00:15:49,196
最后我们创建并回到


523
00:15:49,196 --> 00:15:51,106
我们的组合布局


524
00:15:51,856 --> 00:15:53,016
这就是项目 组


525
00:15:53,016 --> 00:15:54,256
段及布局的结构


526
00:15:54,596 --> 00:15:55,406
这里值得注意的第二件事


527
00:15:55,446 --> 00:15:56,676
也是我们在进入到


528
00:15:56,676 --> 00:15:57,746
另一个例子之前


529
00:15:57,746 --> 00:15:59,056
应该真正理解的事


530
00:15:59,356 --> 00:16:01,996
是我们定义项目尺寸的方式


531
00:16:02,766 --> 00:16:04,336
在这个例子中


532
00:16:04,336 --> 00:16:06,666
组的大小最终决定了


533
00:16:07,306 --> 00:16:08,466
项目的大小


534
00:16:08,466 --> 00:16:10,066
下面我来解释一下原理


535
00:16:10,506 --> 00:16:12,296
在这个简单的列表示例中


536
00:16:12,296 --> 00:16:14,396
组似乎有一点多余


537
00:16:14,646 --> 00:16:15,896
在一个组合布局里


538
00:16:15,896 --> 00:16:17,766
一个组代表了一些


539
00:16:17,766 --> 00:16:19,076
典型的重复结构


540
00:16:19,076 --> 00:16:20,686
即一列项目


541
00:16:20,966 --> 00:16:21,926
或一行项目


542
00:16:22,196 --> 00:16:23,656
在这个例子里是一行项目


543
00:16:23,656 --> 00:16:24,726
但的确在一些十分简单的例子里


544
00:16:24,726 --> 00:16:26,716
每一行只有一个项目


545
00:16:27,166 --> 00:16:29,896
这时每个项目都会有自己的组


546
00:16:30,266 --> 00:16:31,576
但是组通常都是


547
00:16:31,576 --> 00:16:32,906
组合布局描述中


548
00:16:32,906 --> 00:16:33,706
固定的一部分


549
00:16:33,706 --> 00:16:34,626
同时我们要用组


550
00:16:34,626 --> 00:16:36,256
来帮助我们定义


551
00:16:36,256 --> 00:16:37,326
项目的大小


552
00:16:38,046 --> 00:16:40,076
之前 Steve 已经介绍了如何


553
00:16:40,076 --> 00:16:41,466
用容器定义大小


554
00:16:42,676 --> 00:16:44,866
我们先来看组的大小的描述


555
00:16:45,856 --> 00:16:48,206
这里我们要求组


556
00:16:48,206 --> 00:16:49,836
也就是这个例子里的行


557
00:16:50,156 --> 00:16:52,946
扩展成容器宽度的 100%


558
00:16:53,256 --> 00:16:54,726
这个组的容器就是它的段


559
00:16:54,726 --> 00:16:56,406
而段会反过来扩大


560
00:16:56,406 --> 00:16:57,656
布局或 CollectionView


561
00:16:59,586 --> 00:17:01,036
同时 我们要求每一个组的高度


562
00:17:01,116 --> 00:17:03,116
都是一个绝对值


563
00:17:03,116 --> 00:17:05,215
即 44 点高


564
00:17:06,336 --> 00:17:07,185
要注意的是


565
00:17:07,185 --> 00:17:09,076
这基本上已经定义了


566
00:17:09,076 --> 00:17:10,376
这个项目方框


567
00:17:10,376 --> 00:17:11,656
就是我们想要的项目大小


568
00:17:11,656 --> 00:17:12,626
即与 CollectionView 等宽


569
00:17:12,626 --> 00:17:13,646
44 点高


570
00:17:14,215 --> 00:17:15,326
在指定项目的大小时


571
00:17:15,326 --> 00:17:17,346
我们需要做的就是


572
00:17:17,896 --> 00:17:18,986
假设我们想要每个项目的


573
00:17:18,986 --> 00:17:21,396
宽度都是其容器的 100%


574
00:17:21,396 --> 00:17:22,756
高度也是 100%


575
00:17:22,756 --> 00:17:25,896
这时该项目的容器就是组


576
00:17:26,695 --> 00:17:28,056
这就是完成一个列表


577
00:17:28,056 --> 00:17:29,076
所需要的全部信息


578
00:17:29,076 --> 00:17:30,166
但有趣的是 在此过程中


579
00:17:30,166 --> 00:17:31,186
我们会发现


580
00:17:31,186 --> 00:17:32,316
我们并不需要在编码上


581
00:17:32,316 --> 00:17:33,436
做大的改变


582
00:17:33,436 --> 00:17:35,106
就能得到十分不同的布局


583
00:17:35,996 --> 00:17:37,006
我们来看另一个例子


584
00:17:37,006 --> 00:17:40,016
这里我要


585
00:17:40,016 --> 00:17:40,976
打开我们的网格


586
00:17:41,236 --> 00:17:43,196
这是一个无边框的


587
00:17:43,196 --> 00:17:44,566
五列的网格


588
00:17:46,036 --> 00:17:47,646
我们可以看看


589
00:17:47,646 --> 00:17:51,046
如果把手机转过来


590
00:17:51,046 --> 00:17:52,466
这个布局就变成了这样


591
00:17:52,466 --> 00:17:54,376
这时我们的确仍然有五列


592
00:17:54,376 --> 00:17:56,496
项目也仍然是正方形的


593
00:17:56,496 --> 00:17:58,136
而项目大小随之改变


594
00:17:58,216 --> 00:18:00,506
以适应这五列的宽度


595
00:18:03,426 --> 00:18:04,626
在这个例子中


596
00:18:04,626 --> 00:18:06,376
组其实要更方便一些


597
00:18:06,376 --> 00:18:07,646
同时我们更容易理解


598
00:18:07,646 --> 00:18:09,496
它们的函数是什么


599
00:18:10,326 --> 00:18:11,576
打开合格网格视图


600
00:18:11,576 --> 00:18:12,706
控制源文件


601
00:18:12,706 --> 00:18:13,806
看看这里创建布局的函数


602
00:18:13,806 --> 00:18:16,056
同样的 还是这个结构


603
00:18:16,106 --> 00:18:20,676
项目 组 段和布局


604
00:18:21,496 --> 00:18:22,826
这看起来和列表布局描述


605
00:18:22,826 --> 00:18:23,456
基本上差不多


606
00:18:23,456 --> 00:18:24,516
这里唯一不同的就是


607
00:18:24,516 --> 00:18:27,376
我们所设定的项目和组的大小


608
00:18:27,406 --> 00:18:28,716
我们来看看能有什么不同


609
00:18:29,616 --> 00:18:31,876
因为一组代表一行


610
00:18:31,876 --> 00:18:33,216
我们仍然让每一组都


611
00:18:33,216 --> 00:18:34,936
扩展到整个


612
00:18:34,936 --> 00:18:35,786
CollectionView 的宽度


613
00:18:35,936 --> 00:18:38,976
这很但这次我们不想让项目


614
00:18:38,976 --> 00:18:40,406
与组的宽度保持一致


615
00:18:40,536 --> 00:18:42,306
我们想要一行有五个项目


616
00:18:42,306 --> 00:18:43,406
那在这个例子里


617
00:18:43,406 --> 00:18:45,566
我们所要做的就是


618
00:18:45,566 --> 00:18:48,396
在这里指定该项目的宽度


619
00:18:48,396 --> 00:18:50,636
为其容器的 20%


620
00:18:51,106 --> 00:18:52,216
该项目的容器是组或行


621
00:18:52,216 --> 00:18:53,916
这时我们就


622
00:18:53,916 --> 00:18:55,146
能够通过我们对


623
00:18:55,146 --> 00:18:57,076
宽度的设定


624
00:18:57,076 --> 00:18:58,946
使一行有五个项目


625
00:18:59,906 --> 00:19:01,226
现在 我们来看高度


626
00:19:01,226 --> 00:19:02,626
我们不设定一个绝对点值


627
00:19:03,606 --> 00:19:04,826
我们说过想让每组


628
00:19:04,976 --> 00:19:07,236
或每行的高度


629
00:19:07,236 --> 00:19:11,076
是其容器宽度的 20%


630
00:19:11,076 --> 00:19:12,236
注意 这里我们用这个方法


631
00:19:12,746 --> 00:19:15,096
来指定横轴的


632
00:19:15,096 --> 00:19:17,146
百分比宽度或高度


633
00:19:17,146 --> 00:19:18,756
这真的很容易


634
00:19:18,756 --> 00:19:20,706
这样我们就能让项目呈正方形


635
00:19:21,076 --> 00:19:23,286
项目的宽度和组的高度


636
00:19:23,666 --> 00:19:25,186
是一样的


637
00:19:26,436 --> 00:19:27,506
同时因为组的高度


638
00:19:27,506 --> 00:19:28,756
决定了项目的高度


639
00:19:28,756 --> 00:19:30,096
在这里我们需要做的就是


640
00:19:30,096 --> 00:19:32,616
设定项目的高度为其组高的 100%


641
00:19:33,326 --> 00:19:35,886
这样创建一个网格


642
00:19:35,886 --> 00:19:37,306
是很简单的


643
00:19:37,306 --> 00:19:38,566
而我们现在所用的代码


644
00:19:38,566 --> 00:19:39,856
与制作列表时所用的


645
00:19:39,856 --> 00:19:41,856
并没有根本上的不同


646
00:19:42,566 --> 00:19:43,726
如果设计师给你一个布局


647
00:19:43,726 --> 00:19:44,626
通常来说 你会想要


648
00:19:44,626 --> 00:19:46,446
在项目之间有一些空间


649
00:19:46,446 --> 00:19:48,046
那接下来就看看怎样加这些空间


650
00:19:48,936 --> 00:19:50,466
打开嵌入式项目网格示例


651
00:19:50,466 --> 00:19:52,136
这仍然是一个


652
00:19:52,136 --> 00:19:54,086
五列的网格


653
00:19:54,086 --> 00:19:55,866
只是在项目之间


654
00:19:55,866 --> 00:19:57,056
增加了一些空间


655
00:19:59,416 --> 00:20:01,576
接下来打开嵌入式项目视图


656
00:20:02,376 --> 00:20:04,006
InsetItemsGridViewController


657
00:20:04,006 --> 00:20:05,726
我们来看


658
00:20:06,246 --> 00:20:08,146
这里 如果把这些代码与


659
00:20:08,146 --> 00:20:09,296
之前的例子相比


660
00:20:09,296 --> 00:20:10,786
你就会发现


661
00:20:10,836 --> 00:20:12,516
只有一行代码有所变化


662
00:20:12,666 --> 00:20:15,006
这个发现很有用


663
00:20:15,006 --> 00:20:16,016
因为你完全可以


664
00:20:16,016 --> 00:20:17,966
把这个布局想成


665
00:20:17,966 --> 00:20:19,886
和之前的无边框布局


666
00:20:19,886 --> 00:20:21,616
几乎完全一样的计算


667
00:20:22,726 --> 00:20:25,016
每个项目都会分配到


668
00:20:25,016 --> 00:20:26,476
与之前给的无边框方块


669
00:20:26,476 --> 00:20:28,256
一样的方块中


670
00:20:28,716 --> 00:20:30,046
但在这个例子里


671
00:20:30,046 --> 00:20:32,406
我们决定不通过


672
00:20:32,406 --> 00:20:33,576
设定项目的大小


673
00:20:33,576 --> 00:20:34,886
使其占据所分配的整个正方形


674
00:20:34,976 --> 00:20:37,156
而是在最后 通过每个边上的


675
00:20:37,156 --> 00:20:40,096
五个点 来嵌入项目的内容


676
00:20:40,226 --> 00:20:41,706
所以这时候 项目的内容


677
00:20:41,706 --> 00:20:42,686
就很有用了


678
00:20:42,686 --> 00:20:45,136
而这个最后的步骤


679
00:20:45,136 --> 00:20:46,896
是从已计算过的布局中减去一部分


680
00:20:47,426 --> 00:20:48,066
这真的很棒


681
00:20:48,066 --> 00:20:50,196
我们看过了如何创建列表和网格


682
00:20:50,436 --> 00:20:51,896
还通过定义项目的大小


683
00:20:52,216 --> 00:20:54,726
创建了网格


684
00:20:55,096 --> 00:20:55,896
这里还有一种很好的方法


685
00:20:55,946 --> 00:20:58,306
可以用来创建


686
00:20:58,416 --> 00:21:00,596
含有行和列的网格状布局


687
00:21:01,636 --> 00:21:02,806
我在这里展示给你们


688
00:21:02,806 --> 00:21:03,746
这样就能熟悉它了


689
00:21:04,366 --> 00:21:05,126
这里我打开


690
00:21:05,126 --> 00:21:06,636
两列的网格示例


691
00:21:07,166 --> 00:21:09,956
从表面上看起来


692
00:21:09,956 --> 00:21:11,016
这和五列的网格很像


693
00:21:11,016 --> 00:21:13,366
只是这里的列更少 


694
00:21:13,366 --> 00:21:15,446
的确 如果我把它转过来


695
00:21:15,446 --> 00:21:17,056
它就变成了这样


696
00:21:17,056 --> 00:21:18,936
仍然保持两列不变


697
00:21:19,426 --> 00:21:20,606
而每个项目都扩展到了适当宽度


698
00:21:21,696 --> 00:21:22,886
但是这与之前的做法


699
00:21:22,886 --> 00:21:24,426
还是有所不同的


700
00:21:24,426 --> 00:21:25,376
所以我们有必要讲讲


701
00:21:25,926 --> 00:21:27,016
这里


702
00:21:27,016 --> 00:21:28,876
在 TwoColumnViewController 中


703
00:21:29,206 --> 00:21:30,506
我们要看的是


704
00:21:30,506 --> 00:21:31,556
createLayout 函数


705
00:21:33,056 --> 00:21:34,546
我们注意到 有趣的是


706
00:21:34,546 --> 00:21:36,146
这里又一次出现了


707
00:21:36,146 --> 00:21:39,096
项目 组 段和布局结构


708
00:21:39,096 --> 00:21:39,946
但我们首先要注意的


709
00:21:39,946 --> 00:21:42,006
这也许不会


710
00:21:42,006 --> 00:21:43,776
立刻表现出来


711
00:21:43,776 --> 00:21:45,406
即我们在创建代表着


712
00:21:45,406 --> 00:21:47,246
每一行的水平组时


713
00:21:47,246 --> 00:21:48,436
用了一种不太一样的方法


714
00:21:49,106 --> 00:21:50,516
我们用一种不同形式的


715
00:21:50,516 --> 00:21:52,276
初始化程序


716
00:21:52,276 --> 00:21:53,926
该程序有明确的计数参数


717
00:21:54,236 --> 00:21:56,066
这里我们就明确地设定


718
00:21:56,606 --> 00:21:58,676
每一组需要有两个项目


719
00:21:58,676 --> 00:22:01,236
即每行两个项目


720
00:22:01,816 --> 00:22:02,466
如此一来


721
00:22:02,466 --> 00:22:03,576
组合布局就会


722
00:22:03,656 --> 00:22:05,356
自动计算出


723
00:22:05,356 --> 00:22:06,546
项目的宽度


724
00:22:06,546 --> 00:22:07,446
以满足这一设定


725
00:22:08,406 --> 00:22:10,226
我们在这里像往常一样


726
00:22:10,226 --> 00:22:11,396
设定一个项目的宽度


727
00:22:11,616 --> 00:22:13,506
我们假设它是容器的 100%


728
00:22:14,036 --> 00:22:15,366
但是顶部的值


729
00:22:15,366 --> 00:22:17,006
最终会被覆盖


730
00:22:17,006 --> 00:22:18,106
当你要求每一组都有


731
00:22:18,106 --> 00:22:19,586
一定数量的项目时


732
00:22:19,976 --> 00:22:21,336
组合布局


733
00:22:21,626 --> 00:22:22,616
该组合布局就会


734
00:22:22,616 --> 00:22:24,026
将其视为一种覆盖


735
00:22:24,326 --> 00:22:25,136
然后就会计算出


736
00:22:25,136 --> 00:22:26,246
真正能够满足


737
00:22:26,246 --> 00:22:28,316
我们要求的宽度


738
00:22:28,476 --> 00:22:29,936
我们也用一种不同的方法


739
00:22:29,936 --> 00:22:31,216
增加项目与项目


740
00:22:31,216 --> 00:22:32,286
之间的空间


741
00:22:32,286 --> 00:22:33,446
组合布局提供了


742
00:22:33,446 --> 00:22:34,906
很多方法来完成这一步


743
00:22:34,906 --> 00:22:36,486
这让 API 变得十分灵活


744
00:22:37,706 --> 00:22:39,666
在这个例子里


745
00:22:39,666 --> 00:22:42,216
我们不指定 itemInsets


746
00:22:42,826 --> 00:22:44,446
而是在段上指定 contentInsets


747
00:22:45,066 --> 00:22:46,306
这里 我想在左右两边


748
00:22:46,306 --> 00:22:47,616
都加上一点空白


749
00:22:47,616 --> 00:22:48,956
我们只有一个段


750
00:22:48,956 --> 00:22:50,856
所以这基本上就是我们整个的布局


751
00:22:51,336 --> 00:22:53,236
我们想要 10 个点的前导间隔


752
00:22:53,236 --> 00:22:55,776
和 10 个点的尾随间隔


753
00:22:56,846 --> 00:22:58,266
注意当我们在这行代码上时


754
00:22:58,266 --> 00:23:00,836
组合布局的设计会促使你


755
00:23:00,836 --> 00:23:02,626
用不确定布局方向的方式


756
00:23:02,626 --> 00:23:05,556
来表达你的布局


757
00:23:05,556 --> 00:23:07,776
所以不用明确指出左右


758
00:23:07,776 --> 00:23:09,526
我们只用指定


759
00:23:09,526 --> 00:23:10,676
前导和尾随


760
00:23:10,856 --> 00:23:12,316
这样真的很棒


761
00:23:12,316 --> 00:23:13,726
因为当你用一种从右到左的语言


762
00:23:13,726 --> 00:23:15,156
运行 App 的时候


763
00:23:15,156 --> 00:23:17,146
你会自动得到


764
00:23:17,146 --> 00:23:18,206
正确的布局


765
00:23:19,156 --> 00:23:23,106
这里我们也用到一个组的属性


766
00:23:23,106 --> 00:23:24,896
叫做 interItemSpacing


767
00:23:24,896 --> 00:23:26,416
我们请求一个组


768
00:23:26,416 --> 00:23:27,666
在其项目之间增加一定量的空间


769
00:23:27,696 --> 00:23:29,256
在这个例子中


770
00:23:29,316 --> 00:23:31,516
我们将其设为 10 个点


771
00:23:31,806 --> 00:23:34,246
其他的都与前面的例子


772
00:23:34,246 --> 00:23:35,506
非常相似


773
00:23:35,506 --> 00:23:36,776
我们只用那个方法


774
00:23:36,776 --> 00:23:39,206
来明确指定每一组的项目数


775
00:23:40,566 --> 00:23:41,586
这样就相当不错


776
00:23:42,356 --> 00:23:43,606
但 Steve 之前提到了


777
00:23:43,696 --> 00:23:44,916
另一种很棒的功能


778
00:23:44,916 --> 00:23:45,876
我想深入讲讲


779
00:23:46,916 --> 00:23:48,326
他提到每个段


780
00:23:48,326 --> 00:23:50,476
都可以有不同的布局


781
00:23:50,476 --> 00:23:51,816
目前为止我们只看了


782
00:23:51,816 --> 00:23:53,586
一个段的布局


783
00:23:53,586 --> 00:23:54,546
但要是我们想要有多个段呢


784
00:23:54,546 --> 00:23:56,456
而且每个段还要有


785
00:23:56,456 --> 00:23:57,856
不同的布局呢


786
00:23:58,746 --> 00:23:59,926
下面打开不同的


787
00:23:59,926 --> 00:24:00,866
段的示例


788
00:24:02,106 --> 00:24:03,616
现在这个布局


789
00:24:03,616 --> 00:24:04,876
有点像我们之前讲过的


790
00:24:04,876 --> 00:24:05,686
示例的合成


791
00:24:05,936 --> 00:24:07,726
在这个布局中有三个段


792
00:24:08,726 --> 00:24:11,446
第一段是一个简单的


793
00:24:11,446 --> 00:24:13,326
类似于之前的单列列表


794
00:24:14,126 --> 00:24:16,006
第二段是一个正方形项目的


795
00:24:16,006 --> 00:24:16,806
五列网格


796
00:24:16,806 --> 00:24:18,876
第三段则是一个长方形项目的


797
00:24:18,876 --> 00:24:20,266
三列网格


798
00:24:21,176 --> 00:24:22,976
那我们该怎么做呢


799
00:24:24,346 --> 00:24:25,076
首先打开


800
00:24:25,076 --> 00:24:26,616
DistinctSectionsViewController


801
00:24:26,616 --> 00:24:28,586
看 createLayout 函数


802
00:24:30,126 --> 00:24:31,456
第一眼看上去


803
00:24:31,456 --> 00:24:32,406
它好像和之前完全不同


804
00:24:32,406 --> 00:24:33,946
但实际上只是


805
00:24:33,946 --> 00:24:35,206
最外层的组件不同


806
00:24:35,206 --> 00:24:36,386
相比我们先前例示的布局


807
00:24:36,386 --> 00:24:37,486
它不是在结尾


808
00:24:37,486 --> 00:24:38,666
而是在开头


809
00:24:39,306 --> 00:24:40,166
原因是这样


810
00:24:40,766 --> 00:24:42,336
当我们例示组合布局时


811
00:24:42,336 --> 00:24:43,596
用的是一个初始化程序


812
00:24:43,596 --> 00:24:45,356
该程序将提供段的闭包


813
00:24:45,356 --> 00:24:47,066
视为其参数


814
00:24:47,066 --> 00:24:48,526
这是 Steve 提到过的


815
00:24:49,286 --> 00:24:50,656
提供段的闭包


816
00:24:50,656 --> 00:24:52,406
是一个任意代码块


817
00:24:52,406 --> 00:24:54,596
因此你们可以想象


818
00:24:54,596 --> 00:24:56,756
你可以通过返回任何类型的


819
00:24:56,756 --> 00:24:58,396
你想要的段的布局


820
00:24:58,396 --> 00:25:00,296
来对这个被调用做出响应


821
00:25:01,096 --> 00:25:02,516
传两个指明具体段的参数


822
00:25:03,206 --> 00:25:04,376
即两个段指数参数


823
00:25:04,376 --> 00:25:05,186
在这个例子里


824
00:25:05,186 --> 00:25:06,606
将会是 0 1 或 2


825
00:25:07,596 --> 00:25:08,976
一个布局环境


826
00:25:08,976 --> 00:25:10,106
包含了各种


827
00:25:10,106 --> 00:25:11,326
你可以查到的有用属性


828
00:25:11,326 --> 00:25:13,076
那个我们待会再看


829
00:25:14,536 --> 00:25:16,676
这个闭包里的


830
00:25:16,676 --> 00:25:17,796
其他东西都只是


831
00:25:17,796 --> 00:25:18,956
和之前一样的代码


832
00:25:19,026 --> 00:25:21,446
我们指定一个项目的描述


833
00:25:22,066 --> 00:25:24,576
然后将其嵌入一个组的描述


834
00:25:25,056 --> 00:25:27,026
最后 我们指定


835
00:25:27,026 --> 00:25:28,256
一个段的描述


836
00:25:28,256 --> 00:25:29,166
这就是提供段的闭包


837
00:25:29,166 --> 00:25:30,386
所返回的内容


838
00:25:30,996 --> 00:25:32,966
组合布局会


839
00:25:32,966 --> 00:25:34,156
在需要重新查询


840
00:25:34,156 --> 00:25:35,866
一个对特定段的


841
00:25:35,866 --> 00:25:38,666
新的描述时


842
00:25:38,666 --> 00:25:39,676
自动调用这个闭包


843
00:25:40,346 --> 00:25:42,126
这里的内容就与


844
00:25:42,126 --> 00:25:43,266
之前的十分相似


845
00:25:44,126 --> 00:25:45,466
有趣的是


846
00:25:45,466 --> 00:25:46,516
使各种布局有所区分的


847
00:25:46,516 --> 00:25:47,886
主要是每个布局中


848
00:25:47,886 --> 00:25:49,116
列的数量不同


849
00:25:49,846 --> 00:25:50,746
我们已经有


850
00:25:50,746 --> 00:25:52,966
这个 SectionLayoutKind 类型


851
00:25:52,966 --> 00:25:54,376
它在源文件的顶端


852
00:25:54,376 --> 00:25:55,416
我们来看一下


853
00:25:55,416 --> 00:25:56,846
当我们将它初始化


854
00:25:56,886 --> 00:25:58,506
我们就进入到段指数中


855
00:25:58,506 --> 00:25:59,816
该指数为 0 1 或 2


856
00:26:00,626 --> 00:26:02,666
它要做的就是将其映射到


857
00:26:02,666 --> 00:26:04,476
一个告诉我们


858
00:26:04,476 --> 00:26:05,606
SectionLayoutKind 要么是一个列表


859
00:26:05,606 --> 00:26:08,306
要么是网格 5 或网格 3


860
00:26:08,306 --> 00:26:08,906
的枚举类型中


861
00:26:09,126 --> 00:26:11,696
我们还添加了 columnCount


862
00:26:11,896 --> 00:26:13,436
这个方便易得的属性


863
00:26:13,436 --> 00:26:14,636
这里我们可以直接请求


864
00:26:14,636 --> 00:26:16,636
该 SectionLayoutKind 值


865
00:26:16,636 --> 00:26:18,136
即在该布局中应有多少列


866
00:26:18,646 --> 00:26:21,056
回到我们的 createLayout 函数


867
00:26:21,056 --> 00:26:22,376
我们能看到在我们请求


868
00:26:22,376 --> 00:26:24,356
该 columnCount 的地方


869
00:26:24,356 --> 00:26:25,556
有两处不同应用


870
00:26:25,866 --> 00:26:29,436
在两列网格的示例里


871
00:26:29,436 --> 00:26:31,256
当我们将水平的组


872
00:26:31,256 --> 00:26:32,796
初始化时


873
00:26:32,796 --> 00:26:34,836
我们明确指定了


874
00:26:34,836 --> 00:26:35,826
想要的列的数量


875
00:26:36,616 --> 00:26:38,866
因此我们就交给复合布局


876
00:26:38,956 --> 00:26:40,506
来自动算出


877
00:26:40,506 --> 00:26:42,006
所含的是哪种项目宽度


878
00:26:42,276 --> 00:26:43,676
我们还用列的数量


879
00:26:43,676 --> 00:26:45,716
来决定布局中的


880
00:26:45,716 --> 00:26:46,936
组或行的高度


881
00:26:46,936 --> 00:26:48,416
来区分布局


882
00:26:48,416 --> 00:26:50,516
你可以选择你想用的方法


883
00:26:50,806 --> 00:26:52,816
真的很不错


884
00:26:52,816 --> 00:26:53,856
但如果我们想要


885
00:26:53,856 --> 00:26:56,066
调整这个布局呢


886
00:26:56,066 --> 00:26:58,596
如果我们将手机转过来


887
00:26:59,306 --> 00:27:00,726
可能空间就没有被


888
00:27:00,726 --> 00:27:01,776
充分利用了


889
00:27:02,526 --> 00:27:03,906
或许我们可以放更多的项目


890
00:27:04,866 --> 00:27:06,836
那我们就来看看自适应段布局


891
00:27:07,856 --> 00:27:09,276
第一眼看上去


892
00:27:09,276 --> 00:27:10,926
这和上一个例子一模一样


893
00:27:11,336 --> 00:27:13,896
但旋转过来之后


894
00:27:13,896 --> 00:27:15,216
我们发现第一段


895
00:27:15,216 --> 00:27:16,846
调整显示为两列


896
00:27:16,846 --> 00:27:18,806
第二段调整为十列


897
00:27:18,806 --> 00:27:21,766
第三段调整为六列


898
00:27:22,486 --> 00:27:24,176
这个代码应该怎么写呢


899
00:27:24,616 --> 00:27:26,976
其实和前一个例子很像


900
00:27:28,586 --> 00:27:29,196
下面打开


901
00:27:29,356 --> 00:27:31,096
AdaptiveSectionsViewController


902
00:27:31,156 --> 00:27:33,076
看 createLayout 函数


903
00:27:33,076 --> 00:27:36,676
这和前一个例子很像


904
00:27:36,786 --> 00:27:37,576
我们最先注意到的不同


905
00:27:37,576 --> 00:27:39,366
就是我们改变了


906
00:27:39,366 --> 00:27:41,376
SectionLayoutKind 的类型


907
00:27:42,026 --> 00:27:42,696
这里仍然有


908
00:27:42,696 --> 00:27:43,866
SectionLayoutKind


909
00:27:44,286 --> 00:27:45,786
但 columnCount 不再只是


910
00:27:45,786 --> 00:27:47,326
一个可获取的属性


911
00:27:47,406 --> 00:27:48,796
而是有一个参数的函数


912
00:27:48,796 --> 00:27:52,396
这里我们给它传一个


913
00:27:52,556 --> 00:27:55,286
从 layoutEnvironment 里获得的宽度


914
00:27:55,286 --> 00:27:56,746
该 layoutEnvironment 类型里


915
00:27:57,056 --> 00:27:58,366
就包含了一些信息


916
00:27:58,406 --> 00:27:59,806
比如你的布局所要处理的


917
00:28:00,056 --> 00:28:01,386
总的容器宽度


918
00:28:01,896 --> 00:28:04,046
在 iOS 上它还包含


919
00:28:04,046 --> 00:28:05,666
特征集合信息


920
00:28:05,846 --> 00:28:07,076
因此你可以用这些信息


921
00:28:07,076 --> 00:28:08,906
来计算出


922
00:28:08,906 --> 00:28:10,116
什么样的布局


923
00:28:10,116 --> 00:28:11,336
适合现在的环境


924
00:28:11,826 --> 00:28:13,276
这里我们只使用宽度


925
00:28:13,276 --> 00:28:16,476
如果我们看看顶部


926
00:28:16,476 --> 00:28:18,026
我们在这里用了 SectionLayoutKind


927
00:28:18,806 --> 00:28:19,946
我们可以发现该 columnCount 函数


928
00:28:19,946 --> 00:28:21,416
现在是一个函数


929
00:28:21,796 --> 00:28:24,096
它接受我们传入的宽度参数


930
00:28:24,096 --> 00:28:25,106
在这个例子里


931
00:28:25,106 --> 00:28:26,616
这是 CollectionView 的宽度


932
00:28:26,986 --> 00:28:28,236
我们基本上实现了


933
00:28:28,236 --> 00:28:28,926
一个布局改变


934
00:28:29,326 --> 00:28:30,906
我们决定如果在我们的设备上


935
00:28:30,906 --> 00:28:32,696
需要处理大于


936
00:28:32,696 --> 00:28:34,106
800 个点的宽度


937
00:28:34,106 --> 00:28:36,126
我们会用 wideMode


938
00:28:36,566 --> 00:28:38,896
在 wideMode 里我们只要


939
00:28:38,896 --> 00:28:40,946
在每个段中返回大量的列


940
00:28:41,646 --> 00:28:43,266
就可以完成


941
00:28:43,436 --> 00:28:44,566
如果我们返回 creatLayout 函数


942
00:28:44,566 --> 00:28:45,766
我们就会发现


943
00:28:45,766 --> 00:28:47,336
当我们得到列的数量后


944
00:28:47,336 --> 00:28:49,646
我们所用的方法


945
00:28:49,646 --> 00:28:51,936
可能还是和以前差不多


946
00:28:51,936 --> 00:28:53,506
所以我们不用改变太多代码


947
00:28:53,716 --> 00:28:55,266
就可以得到一个自适应


948
00:28:55,266 --> 00:28:57,426
旋转的布局


949
00:28:57,956 --> 00:29:00,396
这样就很不错


950
00:29:00,506 --> 00:29:02,006
但目前为止


951
00:29:02,006 --> 00:29:03,306
我们只讨论了项目


952
00:29:03,306 --> 00:29:05,136
我们甚至还没有深入探讨


953
00:29:05,136 --> 00:29:07,516
我们可以用补充视图


954
00:29:07,516 --> 00:29:08,836
和装饰视图做什么


955
00:29:09,056 --> 00:29:09,916
我最喜欢组合布局的


956
00:29:09,916 --> 00:29:10,866
一点是


957
00:29:10,866 --> 00:29:12,776
它使事情变得


958
00:29:12,776 --> 00:29:14,926
前所未有地简单


959
00:29:14,926 --> 00:29:17,046
我们能够超出页眉和页脚


960
00:29:17,046 --> 00:29:18,136
使用你自己设计的


961
00:29:18,246 --> 00:29:21,276
任意的补充视图


962
00:29:21,856 --> 00:29:24,336
接下来的部分


963
00:29:24,336 --> 00:29:25,646
我们将进入


964
00:29:25,646 --> 00:29:26,976
一些更高级的话题


965
00:29:26,976 --> 00:29:28,556
一些你可以用组合布局


966
00:29:28,556 --> 00:29:29,896
完成的很棒的事情


967
00:29:29,896 --> 00:29:31,866
下面就继续交给我的同事 Steve


968
00:29:32,016 --> 00:29:32,496
谢谢


969
00:29:33,516 --> 00:29:37,876
[掌声]


970
00:29:38,376 --> 00:29:39,336
>> 既然我们已经


971
00:29:39,336 --> 00:29:40,856
看过基本的工作原理


972
00:29:41,026 --> 00:29:41,896
知道如何创建


973
00:29:41,896 --> 00:29:42,806
和运行组合布局


974
00:29:42,806 --> 00:29:44,736
接下来我就要带大家进入


975
00:29:44,856 --> 00:29:46,106
更高级的话题了


976
00:29:46,106 --> 00:29:47,326
因为我们有很多种方法


977
00:29:47,326 --> 00:29:48,936
可以用组合布局


978
00:29:48,936 --> 00:29:50,046
来创建自定布局


979
00:29:50,806 --> 00:29:53,926
首先我要接着


980
00:29:53,926 --> 00:29:55,476
谈一谈补充项目


981
00:29:56,616 --> 00:29:58,126
CollectionView 可以做三个基本的


982
00:29:58,126 --> 00:30:00,086
视图类类型


983
00:30:00,086 --> 00:30:01,486
包括储存格 即用来表示


984
00:30:01,486 --> 00:30:02,906
模型对象的交互对象


985
00:30:02,906 --> 00:30:04,966
同时它也代表着


986
00:30:05,136 --> 00:30:07,736
补充项目和装饰项目


987
00:30:08,446 --> 00:30:10,236
它们是为了装饰


988
00:30:10,236 --> 00:30:11,296
布局的其他部分 


989
00:30:11,296 --> 00:30:12,786
来给你一些关于内容信息的


990
00:30:12,926 --> 00:30:14,436
视觉提示 比如


991
00:30:14,436 --> 00:30:16,106
一个储存格上的标记会说


992
00:30:16,106 --> 00:30:17,076
“嘿 你有一条推特评论”


993
00:30:17,076 --> 00:30:17,816
或其他什么


994
00:30:18,946 --> 00:30:20,906
今天我们会看到一些


995
00:30:20,946 --> 00:30:22,886
这三个例子的常见用法


996
00:30:22,966 --> 00:30:24,776
即标记 页眉和页脚


997
00:30:25,186 --> 00:30:26,766
现在我们有流支持


998
00:30:26,766 --> 00:30:28,406
以及粘性的页眉和页脚


999
00:30:28,406 --> 00:30:29,876
它们在内容上方浮动


1000
00:30:30,176 --> 00:30:32,086
但我们可以在


1001
00:30:32,086 --> 00:30:32,946
组合布局里进行扩展


1002
00:30:32,946 --> 00:30:34,166
使其变得更容易


1003
00:30:34,616 --> 00:30:36,776
我们可以用这个概念简化它


1004
00:30:36,776 --> 00:30:37,836
将内容锚定在


1005
00:30:37,836 --> 00:30:42,036
你布局的一个项目或组上


1006
00:30:42,036 --> 00:30:43,276
这样可以简化视觉关系


1007
00:30:43,276 --> 00:30:44,536
这是怎么做到的呢


1008
00:30:44,536 --> 00:30:47,496
我们来直观地看一下


1009
00:30:47,496 --> 00:30:50,406
这里 我们能看到


1010
00:30:50,576 --> 00:30:51,416
有一个新的类型


1011
00:30:51,646 --> 00:30:52,876
NSCollectionLayoutAnchor


1012
00:30:53,586 --> 00:30:54,986
我们在这里设定


1013
00:30:55,186 --> 00:30:56,896
这两种类型的关系


1014
00:30:56,896 --> 00:30:58,066
我们的补充物就会


1015
00:30:58,066 --> 00:31:00,216
通过与一个主空间


1016
00:31:00,216 --> 00:31:02,016
一个项目或组的几何形状


1017
00:31:02,016 --> 00:31:04,326
相对应的方式被锚定


1018
00:31:04,986 --> 00:31:06,956
这非常容易推出


1019
00:31:09,466 --> 00:31:11,766
那这里我们马上看到


1020
00:31:11,766 --> 00:31:14,276
我们创建的 NSCollectionLayoutAnchor


1021
00:31:14,276 --> 00:31:15,376
我们指定边缘


1022
00:31:15,376 --> 00:31:16,716
我们想要把这个项目固定在


1023
00:31:16,716 --> 00:31:20,156
该储存格顶端的尾随边


1024
00:31:20,836 --> 00:31:22,656
我们想让它稍微


1025
00:31:23,076 --> 00:31:24,106
超出几何图形


1026
00:31:24,106 --> 00:31:25,276
我们可以用分数高度


1027
00:31:27,106 --> 00:31:29,416
这里我们能看到这个设备


1028
00:31:29,416 --> 00:31:31,066
我们已经放上了这些标记


1029
00:31:31,606 --> 00:31:33,096
得益于我精湛的设计技巧


1030
00:31:33,096 --> 00:31:34,396
这里有一个四个项目的网格


1031
00:31:34,846 --> 00:31:36,696
由浅蓝色的储存格组成


1032
00:31:37,296 --> 00:31:38,476
这里我们能看到


1033
00:31:38,476 --> 00:31:39,436
在一些项目上


1034
00:31:39,436 --> 00:31:40,246
有小的通知标记 


1035
00:31:40,246 --> 00:31:41,146
它们是在说


1036
00:31:41,146 --> 00:31:42,396
“嘿 你需要注意这里”


1037
00:31:43,576 --> 00:31:45,626
而这里的这些标记


1038
00:31:45,626 --> 00:31:47,456
就稍稍超出了几何图形


1039
00:31:47,676 --> 00:31:48,486
它们不完全在


1040
00:31:48,486 --> 00:31:49,676
储存格的几何图形里面


1041
00:31:50,376 --> 00:31:51,486
我们回到幻灯片上


1042
00:31:51,486 --> 00:31:52,686
快速浏览一下


1043
00:31:53,076 --> 00:31:56,156
就是 fractionalOffset


1044
00:31:56,156 --> 00:31:58,306
使它们能稍稍超出几何图形


1045
00:31:58,306 --> 00:31:59,096
现在我们将


1046
00:31:59,096 --> 00:32:01,406
在正 X 上移动 30% 


1047
00:32:01,406 --> 00:32:04,436
然后在负 Y 上也移动30%


1048
00:32:04,916 --> 00:32:06,646
然后我们用


1049
00:32:06,646 --> 00:32:07,956
badgeSize 和 elementKind 定义


1050
00:32:07,956 --> 00:32:11,156
CollectionLayoutSupplementaryItem


1051
00:32:11,156 --> 00:32:12,046
我们要用


1052
00:32:12,046 --> 00:32:12,766
已注册的补充类型 


1053
00:32:12,766 --> 00:32:13,606
重新回到


1054
00:32:13,666 --> 00:32:14,846
CollectionView 的视图类


1055
00:32:15,486 --> 00:32:17,426
然后我们指定容器的锚


1056
00:32:17,426 --> 00:32:19,796
指定它如何进行关联


1057
00:32:19,796 --> 00:32:21,456
既然我们有了


1058
00:32:21,496 --> 00:32:22,856
这个补充物的定义


1059
00:32:22,856 --> 00:32:24,516
就要把它和一些东西关联起来


1060
00:32:24,786 --> 00:32:26,086
我们要把它与一个项目


1061
00:32:26,416 --> 00:32:28,476
一个储存格相关联


1062
00:32:29,026 --> 00:32:30,226
在这个例子中


1063
00:32:30,226 --> 00:32:31,686
我们要用一个带有


1064
00:32:31,686 --> 00:32:33,346
一系列补充物的初始化程序


1065
00:32:33,346 --> 00:32:34,456
的扩展变体


1066
00:32:34,456 --> 00:32:35,566
来进行初始化


1067
00:32:35,566 --> 00:32:39,476
就是这样


1068
00:32:39,476 --> 00:32:41,146
页眉和页脚呢


1069
00:32:41,486 --> 00:32:43,166
页眉和页脚


1070
00:32:43,166 --> 00:32:44,696
与这些项目的补充物


1071
00:32:44,696 --> 00:32:45,886
只有一点点不同


1072
00:32:45,886 --> 00:32:47,326
当你想到


1073
00:32:47,326 --> 00:32:48,776
用一个补充页眉和页脚


1074
00:32:48,776 --> 00:32:50,566
来装饰的内容时


1075
00:32:51,276 --> 00:32:52,226
你并不想让


1076
00:32:52,226 --> 00:32:53,106
补充页眉或页脚


1077
00:32:53,106 --> 00:32:54,726
遮挡住真正的内容


1078
00:32:54,726 --> 00:32:56,596
需要扩展内容的区域


1079
00:32:56,596 --> 00:32:58,096
以便看到内容本身


1080
00:32:59,186 --> 00:33:00,466
在这个例子里


1081
00:33:00,466 --> 00:33:01,666
我们有很多不同的补充物


1082
00:33:01,666 --> 00:33:03,886
叫做边界补充物


1083
00:33:03,946 --> 00:33:04,936
我们要把它放在


1084
00:33:04,936 --> 00:33:06,346
主几何图形的补充物


1085
00:33:06,346 --> 00:33:07,426
的边界上


1086
00:33:08,636 --> 00:33:09,706
我们可以为段或整个布局


1087
00:33:09,706 --> 00:33:11,136
制作这些边界补充物


1088
00:33:11,136 --> 00:33:13,316
我们可以将它们


1089
00:33:13,316 --> 00:33:14,716
固定在这整个平衡中


1090
00:33:14,716 --> 00:33:16,056
完成一些很棒的布局


1091
00:33:16,726 --> 00:33:18,196
下面我将切换到


1092
00:33:18,196 --> 00:33:19,226
设备上的例子


1093
00:33:20,726 --> 00:33:21,856
就是这样


1094
00:33:22,106 --> 00:33:24,586
我们看看这个例子


1095
00:33:25,146 --> 00:33:27,206
很简单易懂的例子


1096
00:33:27,206 --> 00:33:29,146
这里有一个固定在段上


1097
00:33:29,146 --> 00:33:30,136
的页眉和页脚


1098
00:33:30,616 --> 00:33:31,676
上下滑动


1099
00:33:31,676 --> 00:33:33,926
发现这就是我们想要的


1100
00:33:34,186 --> 00:33:34,786
下面来看代码


1101
00:33:38,716 --> 00:33:40,296
这个和几分钟前说到的


1102
00:33:40,296 --> 00:33:42,326
BoundarySupplementaryItems 代码很像


1103
00:33:42,786 --> 00:33:44,016
现在除了这个容器锚


1104
00:33:44,086 --> 00:33:45,636
这里还有


1105
00:33:45,636 --> 00:33:46,726
对齐属性


1106
00:33:47,706 --> 00:33:49,896
这里为页眉指定了顶部


1107
00:33:49,896 --> 00:33:51,116
为页脚指定了底部


1108
00:33:51,116 --> 00:33:52,316
因为想到达几何图形的


1109
00:33:52,316 --> 00:33:53,786
段的顶部和底部


1110
00:33:54,456 --> 00:33:55,806
为了确保页眉浮动


1111
00:33:55,806 --> 00:33:57,566
并固定在段中


1112
00:33:57,616 --> 00:33:58,876
它所在的内容区域


1113
00:33:58,876 --> 00:34:00,616
我们只需指定


1114
00:34:00,616 --> 00:34:02,046
PinToVisibleBounds


1115
00:34:02,306 --> 00:34:04,526
接着我们需要将页眉和页脚


1116
00:34:04,526 --> 00:34:05,516
与它们要进入的


1117
00:34:05,516 --> 00:34:06,466
几何图形关联起来


1118
00:34:06,466 --> 00:34:07,256
也就是段


1119
00:34:07,446 --> 00:34:08,315
这里我们就用


1120
00:34:08,315 --> 00:34:10,016
BoundarySupplementaryItems 阵列


1121
00:34:11,016 --> 00:34:11,735
很简单吧


1122
00:34:12,886 --> 00:34:15,196
目前为止我们展示时


1123
00:34:15,196 --> 00:34:17,255
都用的是全新的 iOS 13 卡片


1124
00:34:17,255 --> 00:34:18,766
这种卡片设计语言


1125
00:34:19,156 --> 00:34:20,976
贯穿整个系统


1126
00:34:21,936 --> 00:34:23,666
我们在滚动 UI 中也能看到 


1127
00:34:23,826 --> 00:34:26,156
各种各样的内容


1128
00:34:26,156 --> 00:34:27,306
都用卡片


1129
00:34:27,366 --> 00:34:28,815
以逻辑方式组合在一起


1130
00:34:29,136 --> 00:34:30,556
这自然很适合 CollectionView


1131
00:34:30,556 --> 00:34:31,426
因为我们一直


1132
00:34:31,426 --> 00:34:33,536
支持装饰视图的概念


1133
00:34:33,536 --> 00:34:36,446
在过去你需要自己进行运算


1134
00:34:36,446 --> 00:34:37,156
但在组合布局里


1135
00:34:37,156 --> 00:34:39,056
这就变得很简单


1136
00:34:39,666 --> 00:34:41,166
我们用一个


1137
00:34:41,196 --> 00:34:42,706
CollectionLayoutDecorationItem 进行支持


1138
00:34:43,025 --> 00:34:43,696
你只要用一个 elementKind


1139
00:34:43,696 --> 00:34:44,976
来创建它就可以了


1140
00:34:45,746 --> 00:34:47,436
这么做是为了


1141
00:34:47,436 --> 00:34:49,045
在段的内容之后


1142
00:34:49,045 --> 00:34:50,485
产生一个视图


1143
00:34:50,485 --> 00:34:51,866
以提供良好的视觉分组


1144
00:34:52,646 --> 00:34:54,315
想要创建它


1145
00:34:54,315 --> 00:34:55,206
只需要一行代码


1146
00:34:55,206 --> 00:34:55,996
想要将它加到段里


1147
00:34:55,996 --> 00:34:57,896
你只要指定项目


1148
00:34:58,116 --> 00:35:00,116
这样就可以了


1149
00:35:01,076 --> 00:35:01,696
就是这样


1150
00:35:02,256 --> 00:35:03,816
那我们来快速浏览一下


1151
00:35:03,816 --> 00:35:04,446
这组代码的结果


1152
00:35:04,876 --> 00:35:08,586
非常简单也非常直观


1153
00:35:08,976 --> 00:35:09,906
这是包含多个段的列表


1154
00:35:09,906 --> 00:35:11,196
我们增加了装饰视图


1155
00:35:11,196 --> 00:35:14,096
只用了一行代码


1156
00:35:14,226 --> 00:35:14,946
很简单


1157
00:35:17,756 --> 00:35:20,306
下面是一个我


1158
00:35:20,306 --> 00:35:21,356
非常关心的话题


1159
00:35:21,356 --> 00:35:22,176
估算自定尺寸


1160
00:35:23,466 --> 00:35:25,436
在 iOS 13 中我们花了


1161
00:35:25,436 --> 00:35:27,836
很多时间来确保其速度快 准确性高


1162
00:35:29,436 --> 00:35:30,806
组合布局以非常具体的方式


1163
00:35:30,806 --> 00:35:31,766
扩展了估算自定尺寸


1164
00:35:31,766 --> 00:35:34,406
这一概念


1165
00:35:34,406 --> 00:35:36,616
它允许你按每个轴来确定尺寸


1166
00:35:36,616 --> 00:35:37,816
这非常重要


1167
00:35:38,496 --> 00:35:39,486
因为通常你想要


1168
00:35:39,486 --> 00:35:40,366
在你呈现内容时


1169
00:35:40,366 --> 00:35:41,606
得到良好的视图层次


1170
00:35:41,606 --> 00:35:43,086
你并不想要完全


1171
00:35:43,086 --> 00:35:44,736
被限制在轴线上


1172
00:35:44,866 --> 00:35:47,086
不想只能在 X 轴上


1173
00:35:47,086 --> 00:35:48,546
和 Y 轴上增长


1174
00:35:49,066 --> 00:35:50,286
比如你可能知道


1175
00:35:50,286 --> 00:35:51,296
这个东西的宽度


1176
00:35:52,216 --> 00:35:53,716
举一个页眉和页脚的例子


1177
00:35:53,716 --> 00:35:55,336
我们希望它的宽度


1178
00:35:55,336 --> 00:35:58,106
恰好是 CollectionView 的宽度


1179
00:35:58,266 --> 00:35:59,546
但是 我们希望它的高度


1180
00:35:59,546 --> 00:36:00,756
有一点变化


1181
00:36:01,386 --> 00:36:03,466
快速看一下这个例子


1182
00:36:03,466 --> 00:36:04,996
我们之前已经看过这个代码了


1183
00:36:05,636 --> 00:36:07,796
所以这里 我们看到非常熟悉的


1184
00:36:07,796 --> 00:36:10,206
段 页眉和页脚


1185
00:36:10,206 --> 00:36:11,216
然后我从这里下拉


1186
00:36:11,216 --> 00:36:14,566
打开文本大小部件 把它放大


1187
00:36:15,896 --> 00:36:18,326
这里所有的东西都变大了


1188
00:36:18,456 --> 00:36:19,746
这就对了 是吧


1189
00:36:20,096 --> 00:36:21,336
这是怎么做到的呢


1190
00:36:21,406 --> 00:36:23,756
这里我们能看到


1191
00:36:23,756 --> 00:36:25,306
heightDimension 是估算的


1192
00:36:25,656 --> 00:36:26,936
这就是唯一的不同


1193
00:36:26,936 --> 00:36:28,226
我们指定了


1194
00:36:28,226 --> 00:36:29,606
我们知道的确定宽度


1195
00:36:29,606 --> 00:36:31,676
但我们不知道具体高度


1196
00:36:31,676 --> 00:36:33,426
我们只是将其估算为 44 个点


1197
00:36:34,046 --> 00:36:35,316
随着内容的呈现


1198
00:36:35,686 --> 00:36:36,436
我们有了更好的想法


1199
00:36:36,436 --> 00:36:38,096
我们可以使布局自动作废


1200
00:36:38,096 --> 00:36:39,026
这些都是自动的


1201
00:36:39,396 --> 00:36:40,466
这使得你的 App


1202
00:36:40,466 --> 00:36:42,046
更容易支持动态类型


1203
00:36:42,046 --> 00:36:43,356
即使其中包含


1204
00:36:43,356 --> 00:36:44,776
补充物 页眉和页脚


1205
00:36:44,776 --> 00:36:46,536
所以 这是很不错的


1206
00:36:48,906 --> 00:36:49,926
现在我们来说一些


1207
00:36:49,926 --> 00:36:50,636
很有趣的东西


1208
00:36:50,636 --> 00:36:52,076
怎样嵌套呢


1209
00:36:52,186 --> 00:36:54,606
我们之前说过组成这个概念


1210
00:36:54,606 --> 00:36:56,646
我们来看看要怎么做


1211
00:36:57,436 --> 00:37:00,856
组合布局的


1212
00:37:00,856 --> 00:37:02,226
核心布局是布局组


1213
00:37:02,766 --> 00:37:04,416
布局组其实是


1214
00:37:04,416 --> 00:37:06,766
NSCollectionLayoutItem 的一个子类型 


1215
00:37:07,506 --> 00:37:09,006
因为有了这样的关系


1216
00:37:09,086 --> 00:37:11,186
当你指定一个


1217
00:37:11,186 --> 00:37:12,966
布局组中的项目时


1218
00:37:12,966 --> 00:37:14,826
你还可以有其他的组


1219
00:37:14,826 --> 00:37:15,736
你可以将它们嵌套


1220
00:37:15,736 --> 00:37:17,186
这个嵌套是没有限制的


1221
00:37:17,226 --> 00:37:18,636
它是任意的


1222
00:37:18,786 --> 00:37:21,086
因为这一点


1223
00:37:21,086 --> 00:37:24,146
我们解锁了很多有趣的新设计


1224
00:37:25,456 --> 00:37:27,076
那在这个例子里


1225
00:37:27,326 --> 00:37:29,456
我们看到一个组里有三个项目


1226
00:37:30,156 --> 00:37:32,006
我们看到在前导侧


1227
00:37:32,006 --> 00:37:33,716
有个大方块


1228
00:37:33,716 --> 00:37:37,246
在尾随侧有个垂直的组


1229
00:37:37,646 --> 00:37:39,436
那这个怎么在代码里推出呢


1230
00:37:43,906 --> 00:37:45,366
这个很简单


1231
00:37:45,366 --> 00:37:46,646
底部有一个


1232
00:37:46,646 --> 00:37:47,686
水平的组


1233
00:37:47,776 --> 00:37:49,546
其子项分别是


1234
00:37:49,546 --> 00:37:52,966
leadingItem 和一个 trailingGroup


1235
00:37:52,966 --> 00:37:54,236
我们很容易


1236
00:37:54,236 --> 00:37:55,186
推出这样的东西


1237
00:37:55,186 --> 00:37:56,786
我们现在就看看要怎么做


1238
00:37:56,786 --> 00:37:57,856
只需添加一些额外的东西


1239
00:37:57,856 --> 00:38:01,126
就可以得到这些很棒的布局


1240
00:38:02,056 --> 00:38:05,406
嵌套组是很有用的


1241
00:38:05,406 --> 00:38:08,446
嵌套 CollectionView 呢


1242
00:38:08,916 --> 00:38:10,266
好的


1243
00:38:10,266 --> 00:38:14,296
这里我们看到的是 App Store


1244
00:38:14,656 --> 00:38:16,756
是 iOS 13 的更新


1245
00:38:17,516 --> 00:38:18,396
我不知道你怎么看


1246
00:38:18,396 --> 00:38:19,146
但如果我是一个


1247
00:38:19,146 --> 00:38:20,116
第三方开发者时


1248
00:38:20,606 --> 00:38:21,826
要是交给我这样的设计


1249
00:38:21,826 --> 00:38:22,776
我会心脏病发作的


1250
00:38:22,846 --> 00:38:24,116
这真的很复杂


1251
00:38:24,116 --> 00:38:25,916
很有挑战性


1252
00:38:25,916 --> 00:38:27,496
因为有很多簿记工作要做


1253
00:38:27,596 --> 00:38:28,776
但这是一种常见的模式


1254
00:38:28,776 --> 00:38:30,376
在今天的 App 中


1255
00:38:30,526 --> 00:38:32,236
我们也经常看到它


1256
00:38:32,656 --> 00:38:34,686
要使其外观好性能棒


1257
00:38:34,686 --> 00:38:36,656
这一点就颇具挑战性


1258
00:38:36,656 --> 00:38:37,696
组合布局能用


1259
00:38:37,696 --> 00:38:39,456
一行代码来解决这个问题


1260
00:38:40,366 --> 00:38:41,836
下面我就给你们展示一个示例


1261
00:38:42,516 --> 00:38:47,500
[鼓掌]


1262
00:38:52,306 --> 00:38:54,246
这里的组


1263
00:38:54,246 --> 00:38:55,366
和之前的一样


1264
00:38:55,366 --> 00:38:56,146
但我们注意到这个组


1265
00:38:56,146 --> 00:38:57,126
铺得更平了


1266
00:38:57,126 --> 00:38:59,586
它大概占了容器宽度的 80%


1267
00:38:59,586 --> 00:39:02,376
这是一个垂直滚动的 CollectionView


1268
00:39:02,376 --> 00:39:03,706
里面有五个段


1269
00:39:04,576 --> 00:39:05,946
但每个段都可以


1270
00:39:05,946 --> 00:39:07,876
用这一行代码垂直滚动


1271
00:39:08,516 --> 00:39:15,396
[掌声]


1272
00:39:15,896 --> 00:39:18,086
这里有很多不同的变化


1273
00:39:18,086 --> 00:39:18,646
请容许我


1274
00:39:18,646 --> 00:39:19,536
切换到这里


1275
00:39:19,596 --> 00:39:21,846
我们有五种不同的方法


1276
00:39:21,846 --> 00:39:22,886
对 这里还有


1277
00:39:22,886 --> 00:39:24,416
我不想看到的无的情况


1278
00:39:24,996 --> 00:39:26,626
有两个连续函数的例子


1279
00:39:26,876 --> 00:39:29,176
然后是三个分页函数的例子


1280
00:39:29,626 --> 00:39:31,166
我将用可视的方式


1281
00:39:31,166 --> 00:39:34,666
来讲每个例子


1282
00:39:36,256 --> 00:39:38,396
先向大家演示我们


1283
00:39:39,136 --> 00:39:40,756
垂直滚动段的行为


1284
00:39:41,396 --> 00:39:42,956
正如你所期待的那样


1285
00:39:42,956 --> 00:39:44,696
这是一个十分简单的


1286
00:39:44,696 --> 00:39:46,896
滚动视图的行为 


1287
00:39:46,896 --> 00:39:48,376
这里有一个弹回 


1288
00:39:48,376 --> 00:39:51,446
这个很棒


1289
00:39:51,446 --> 00:39:52,506
我这么滑几个小时都不会烦


1290
00:39:52,986 --> 00:39:54,226
好了


1291
00:39:54,226 --> 00:39:56,006
这只是正常滚动视图的行为


1292
00:39:56,006 --> 00:39:57,186
但在连续函数里


1293
00:39:57,186 --> 00:39:58,846
我们还有一个另外的


1294
00:39:58,846 --> 00:40:00,516
流体滚动视图行为


1295
00:40:00,516 --> 00:40:02,316
我们称为 continuousGroupLeadingBoundary


1296
00:40:02,316 --> 00:40:03,356
这有点拗口


1297
00:40:03,356 --> 00:40:04,066
但描述得很到位


1298
00:40:04,476 --> 00:40:05,696
当我们滚动然后松手时


1299
00:40:05,696 --> 00:40:07,836
我们自然会停留在


1300
00:40:07,836 --> 00:40:09,426
该组语义前导


1301
00:40:09,426 --> 00:40:10,976
的边界上


1302
00:40:11,516 --> 00:40:15,286
[掌声]


1303
00:40:15,786 --> 00:40:16,966
鼓掌的人以前一定做过


1304
00:40:17,006 --> 00:40:18,496
定向内容偏移或提议过偏移


1305
00:40:18,496 --> 00:40:20,356
所以你们知道有多痛苦


1306
00:40:20,566 --> 00:40:21,696
好了


1307
00:40:21,696 --> 00:40:24,926
说完这个连续行为


1308
00:40:24,926 --> 00:40:26,216
我们来说说分页行为


1309
00:40:26,216 --> 00:40:27,276
这个也很酷


1310
00:40:27,276 --> 00:40:29,316
这就像是普通的


1311
00:40:29,316 --> 00:40:30,856
滚动视图分页行为


1312
00:40:30,856 --> 00:40:32,216
我们称之为分页


1313
00:40:33,266 --> 00:40:33,696
很有创意


1314
00:40:34,386 --> 00:40:35,526
在这里 我们能看到


1315
00:40:35,526 --> 00:40:36,866
无论用户用怎样的速度进行滚动


1316
00:40:36,866 --> 00:40:39,216
得到的都只是一页的内容


1317
00:40:39,216 --> 00:40:40,826
这个页面被定义为


1318
00:40:40,826 --> 00:40:42,596
默认滚动视图行为


1319
00:40:42,596 --> 00:40:44,796
它的宽度是 CollectionView 的宽度


1320
00:40:46,776 --> 00:40:48,866
这里还可以有两种变化 


1321
00:40:48,866 --> 00:40:50,596
你可能已经猜到了


1322
00:40:50,596 --> 00:40:52,636
接下来我们要说组分页的概念


1323
00:40:53,316 --> 00:40:54,526
现在我们有关于


1324
00:40:54,526 --> 00:40:55,906
一个组的语义概念


1325
00:40:55,906 --> 00:40:57,786
我们就就可以将组的大小


1326
00:40:57,786 --> 00:40:58,606
设置为页面的大小


1327
00:40:59,646 --> 00:41:01,696
这样真的很棒


1328
00:41:03,121 --> 00:41:05,121
[掌声]


1329
00:41:05,226 --> 00:41:06,276
这样你可以自动得到


1330
00:41:06,306 --> 00:41:07,996
没有遮挡的内容


1331
00:41:07,996 --> 00:41:08,976
你的内容总是


1332
00:41:08,976 --> 00:41:10,116
呈现在前面和中间


1333
00:41:10,356 --> 00:41:13,226
最后要说的是组分页居中


1334
00:41:13,226 --> 00:41:14,626
这个和组分页很像


1335
00:41:15,426 --> 00:41:16,976
但现在我们会自动把该组居中


1336
00:41:17,516 --> 00:41:20,546
[掌声]


1337
00:41:21,046 --> 00:41:21,836
对 看上去很棒


1338
00:41:22,636 --> 00:41:23,756
这样就是一种很好的


1339
00:41:23,756 --> 00:41:24,716
显示部分内容的效果 


1340
00:41:24,716 --> 00:41:25,846
你可以看到前导


1341
00:41:25,846 --> 00:41:26,666
和尾随两端的内容


1342
00:41:26,666 --> 00:41:29,666
你就会很清楚你所在的位置


1343
00:41:31,056 --> 00:41:32,576
这就是一些


1344
00:41:32,576 --> 00:41:33,766
应用在组合 App 中的


1345
00:41:33,766 --> 00:41:36,156
高级的附加特性


1346
00:41:36,156 --> 00:41:36,536
诸如此类的还有很多


1347
00:41:36,536 --> 00:41:38,946
你可以打开 SDK 来查看


1348
00:41:40,296 --> 00:41:44,606
在 Apple


1349
00:41:44,606 --> 00:41:46,746
协作的概念


1350
00:41:46,746 --> 00:41:48,026
是非常重要的


1351
00:41:48,026 --> 00:41:49,496
我们要与全公司的团队


1352
00:41:49,496 --> 00:41:51,816
进行合作以解决问题


1353
00:41:53,036 --> 00:41:56,526
作为一名框架工程师


1354
00:41:56,526 --> 00:41:57,846
对我们来说


1355
00:41:57,916 --> 00:41:59,836
与公司中不同的团队合作


1356
00:41:59,836 --> 00:42:00,776
确保我们知道他们


1357
00:42:00,776 --> 00:42:01,986
对新框架特性的需求


1358
00:42:01,986 --> 00:42:04,196
是非常重要的


1359
00:42:05,256 --> 00:42:07,616
其中一个团队


1360
00:42:07,616 --> 00:42:09,196
App Store 团队就在


1361
00:42:09,196 --> 00:42:10,526
iOS 13 中做了重新设计


1362
00:42:10,526 --> 00:42:11,466
他们真的很想


1363
00:42:11,466 --> 00:42:12,566
简化一下代码库


1364
00:42:12,566 --> 00:42:14,616
所以在沟通的过程中


1365
00:42:15,256 --> 00:42:16,836
我们讨论了组合布局


1366
00:42:16,836 --> 00:42:18,926
他们对此非常兴奋


1367
00:42:18,926 --> 00:42:20,846
用它写了很多代码


1368
00:42:20,846 --> 00:42:22,086
下面我们就有请


1369
00:42:22,086 --> 00:42:23,816
来自 App Store 团队的同事


1370
00:42:23,816 --> 00:42:25,906
Dersu Abolfathi 为大家介绍


1371
00:42:26,276 --> 00:42:26,646
Dersu


1372
00:42:27,516 --> 00:42:32,766
[掌声]


1373
00:42:33,266 --> 00:42:34,086
>> 谢谢 Steve


1374
00:42:35,266 --> 00:42:36,806
有数百万的用户


1375
00:42:36,906 --> 00:42:38,386
在 App Store 中


1376
00:42:38,486 --> 00:42:39,746
寻找合适的 App


1377
00:42:39,746 --> 00:42:41,506
以使其设备充分发挥效用


1378
00:42:42,896 --> 00:42:44,076
在座有很多人每天


1379
00:42:44,076 --> 00:42:45,976
都会访问 App Store


1380
00:42:45,976 --> 00:42:47,236
里面的内容就要丰富


1381
00:42:48,046 --> 00:42:50,176
吸引人而且有活力


1382
00:42:51,666 --> 00:42:53,486
CollectionView 在这其中


1383
00:42:53,486 --> 00:42:55,646
发挥着关键作用


1384
00:42:57,876 --> 00:42:59,606
这是 App Store


1385
00:43:00,536 --> 00:43:02,586
如果你今天想要只用


1386
00:43:02,646 --> 00:43:05,276
流式布局来构建这样的 UI


1387
00:43:05,276 --> 00:43:07,396
你可能会从


1388
00:43:07,396 --> 00:43:08,556
一个竖直方向滚动的


1389
00:43:08,556 --> 00:43:09,816
CollectionView 开始


1390
00:43:11,656 --> 00:43:14,046
而对于每一个


1391
00:43:14,236 --> 00:43:15,586
在水平轴上滚动的段


1392
00:43:15,586 --> 00:43:17,466
你都需要一个附加的 CollectionView


1393
00:43:17,466 --> 00:43:19,846
这意味着你需要有


1394
00:43:19,846 --> 00:43:21,526
更多的支持代码


1395
00:43:21,526 --> 00:43:24,406
来连接每个集合的演示和行为


1396
00:43:27,536 --> 00:43:29,576
而在组合布局中


1397
00:43:29,576 --> 00:43:32,226
只需要一个 CollectionView 就可以完成


1398
00:43:32,226 --> 00:43:35,816
事实上 我们已经这么做了


1399
00:43:37,086 --> 00:43:39,386
在 iOS 13 中我们用组合布局


1400
00:43:39,386 --> 00:43:41,736
重新设计了 App Store


1401
00:43:42,286 --> 00:43:45,436
你在此页上看到的


1402
00:43:45,436 --> 00:43:47,526
每种内容类型都能进行


1403
00:43:47,526 --> 00:43:49,646
它们自己的布局描述


1404
00:43:50,146 --> 00:43:52,016
所有的这些布局段


1405
00:43:52,016 --> 00:43:54,906
一起组成一个整体的


1406
00:43:54,906 --> 00:43:56,076
CollectionViewLayout


1407
00:43:59,646 --> 00:44:01,996
我们只用一个布局项目


1408
00:44:01,996 --> 00:44:03,996
就能描述这个段


1409
00:44:03,996 --> 00:44:05,756
该项目有一个已知的高度


1410
00:44:05,756 --> 00:44:08,076
而宽度则为容器的 100%


1411
00:44:10,616 --> 00:44:12,266
布局项目位于一个布局组里


1412
00:44:12,266 --> 00:44:14,566
而布局组本身


1413
00:44:14,566 --> 00:44:16,556
占据容器宽度的一半


1414
00:44:17,056 --> 00:44:19,796
这些都是


1415
00:44:19,796 --> 00:44:22,136
让 UI 运行的基本构件


1416
00:44:22,696 --> 00:44:26,466
我们拿出该布局组


1417
00:44:26,466 --> 00:44:28,556
将其贴在一个布局段中


1418
00:44:28,556 --> 00:44:29,746
然后为了得到想要的分页行为


1419
00:44:29,746 --> 00:44:31,266
我们将垂直滚动行为


1420
00:44:31,266 --> 00:44:33,426
设置为组分页


1421
00:44:34,156 --> 00:44:34,976
然后好戏就开场了


1422
00:44:39,446 --> 00:44:41,676
在 iOS 13 的 App Store 里


1423
00:44:41,676 --> 00:44:43,636
UI 也支持


1424
00:44:43,636 --> 00:44:45,976
从右向左阅读的语言


1425
00:44:45,976 --> 00:44:48,436
组合布局帮助实现了这一功能


1426
00:44:49,016 --> 00:44:52,456
我们用所有


1427
00:44:52,566 --> 00:44:53,656
今天能看到的


1428
00:44:53,656 --> 00:44:55,376
相同的原语来构建布局


1429
00:44:55,376 --> 00:44:57,556
组合布局只负责剩下的部分


1430
00:44:58,056 --> 00:45:00,236
它确保我们的补充物


1431
00:45:00,236 --> 00:45:01,626
和储存格的位置


1432
00:45:01,626 --> 00:45:04,526
适合从右到左的环境


1433
00:45:05,186 --> 00:45:07,456
此外 我们不再需要 


1434
00:45:07,496 --> 00:45:09,326
单独写一行代码


1435
00:45:09,486 --> 00:45:10,976
来确保我们的分页行为


1436
00:45:10,976 --> 00:45:14,496
也适用于从右到左的布局方向


1437
00:45:17,496 --> 00:45:20,216
所以这个新的 API


1438
00:45:20,216 --> 00:45:21,946
使我们能够获取所有那些


1439
00:45:21,946 --> 00:45:23,466
我们之前从头管到脚的可滚动区域


1440
00:45:23,466 --> 00:45:25,746
并将它们平铺到


1441
00:45:25,936 --> 00:45:28,576
顶层的一个 CollectionView 中


1442
00:45:28,576 --> 00:45:31,336
这样一来我们的代码


1443
00:45:31,336 --> 00:45:34,086
变得更加简洁


1444
00:45:34,086 --> 00:45:36,286
更易于推出


1445
00:45:36,286 --> 00:45:37,736
同时也更易于日后维护


1446
00:45:40,016 --> 00:45:41,466
组合布局重新定义了


1447
00:45:41,526 --> 00:45:42,966
我们在自己的 App 中


1448
00:45:42,966 --> 00:45:44,686
思考 CollectionViews 的方式


1449
00:45:44,686 --> 00:45:46,546
我们迫不及待地想看看


1450
00:45:46,546 --> 00:45:47,756
它是如何提升


1451
00:45:47,756 --> 00:45:49,436
你们在 App Store 中


1452
00:45:49,436 --> 00:45:50,756
所得到的 App 的体验呢


1453
00:45:50,756 --> 00:45:51,936
下面交给你 Troy


1454
00:45:52,516 --> 00:45:57,546
[掌声]


1455
00:45:58,046 --> 00:45:59,206
>> 非常感谢 Dersu


1456
00:45:59,206 --> 00:46:00,996
这个设计真不错


1457
00:46:01,376 --> 00:46:02,996
我们非常高兴地看到


1458
00:46:03,116 --> 00:46:04,406
我们已经用组合布局


1459
00:46:04,436 --> 00:46:07,346
简化了一个知名的 


1460
00:46:07,346 --> 00:46:10,446
面向用户的 App 的开发过程


1461
00:46:10,446 --> 00:46:13,046
我很高兴在我们的平台上


1462
00:46:13,046 --> 00:46:14,556
开发人员能


1463
00:46:14,556 --> 00:46:16,756
使用同样的API


1464
00:46:17,186 --> 00:46:18,516
说到这儿 我想给你们


1465
00:46:18,516 --> 00:46:19,986
快速地展示一下


1466
00:46:19,986 --> 00:46:21,396
组合布局用 NSCollectionView


1467
00:46:21,396 --> 00:46:23,866
在 macOS 上的运行


1468
00:46:29,596 --> 00:46:31,086
当你打开你在 Xcode 上


1469
00:46:31,086 --> 00:46:32,316
下载的示例项目时


1470
00:46:32,316 --> 00:46:34,196
注意会有一个


1471
00:46:34,196 --> 00:46:35,866
Mac 的构建方案和目标


1472
00:46:36,196 --> 00:46:37,976
我们要在这里构建且运行它


1473
00:46:42,126 --> 00:46:43,656
我们打开


1474
00:46:43,656 --> 00:46:45,206
我们在本次讲座中看过的


1475
00:46:45,206 --> 00:46:47,016
所有布局示例


1476
00:46:47,016 --> 00:46:47,816
然后把它们分散开


1477
00:46:51,276 --> 00:46:53,096
就是这样 这就是我们的


1478
00:46:53,096 --> 00:46:54,376
各种组合布局的例子


1479
00:46:54,696 --> 00:46:55,876
而我们用的代码


1480
00:46:55,876 --> 00:46:57,326
本质上都是一样的


1481
00:46:57,326 --> 00:46:59,356
我们也将得到相同的 API


1482
00:46:59,686 --> 00:47:00,536
你真正看到的


1483
00:47:00,536 --> 00:47:01,636
唯一的调整就是


1484
00:47:01,636 --> 00:47:03,816
我们想要在其中应用


1485
00:47:03,816 --> 00:47:05,896
更多适合 macOS 的指标


1486
00:47:05,896 --> 00:47:08,666
这里可以水平滚动


1487
00:47:10,176 --> 00:47:12,786
当然 在 Mac 上我们想要


1488
00:47:12,786 --> 00:47:14,636
它们以 Mac 的方式运行


1489
00:47:14,636 --> 00:47:15,396
我们在 Mac 上


1490
00:47:15,396 --> 00:47:16,396
使用 CollectionViews 时


1491
00:47:16,396 --> 00:47:19,066
它们是可以不断调整大小的 


1492
00:47:19,446 --> 00:47:21,546
我们已经确保 Mac


1493
00:47:21,546 --> 00:47:23,286
能又快又好地进行


1494
00:47:24,176 --> 00:47:25,296
超轻量的大小调整


1495
00:47:25,506 --> 00:47:27,286
布局也调整得非常快


1496
00:47:27,286 --> 00:47:29,156
我们的自适应段布局


1497
00:47:29,246 --> 00:47:31,076
和之前一样有一个布局改变


1498
00:47:31,076 --> 00:47:32,606
既然你知道了运行原理


1499
00:47:32,606 --> 00:47:33,886
你就可以随意地增加


1500
00:47:33,886 --> 00:47:35,126
额外的布局改变


1501
00:47:35,126 --> 00:47:37,546
给更大的窗口宽度和屏幕宽度


1502
00:47:38,226 --> 00:47:40,386
当然 我们还有一些特性


1503
00:47:40,386 --> 00:47:42,116
比如点击项目就能选中它们


1504
00:47:42,626 --> 00:47:45,656
用箭头键就可以进行导航


1505
00:47:46,446 --> 00:47:47,756
按住 Shift 键


1506
00:47:47,756 --> 00:47:48,736
同时按箭头键


1507
00:47:48,736 --> 00:47:49,926
就可以选中多个项目


1508
00:47:50,516 --> 00:47:53,546
[掌声]


1509
00:47:54,046 --> 00:47:56,026
当然 也可以拖动选择任意区域


1510
00:47:56,026 --> 00:47:57,266
可以大批量选择项目


1511
00:47:57,266 --> 00:47:58,986
这个在任何的


1512
00:47:58,986 --> 00:48:00,536
组合布局里都可以完成


1513
00:48:00,536 --> 00:48:01,976
包括像这样更高级的布局


1514
00:48:02,016 --> 00:48:03,076
[掌声]


1515
00:48:03,076 --> 00:48:05,906
所有用户期待


1516
00:48:05,906 --> 00:48:07,386
在 Mac 上实现的东西都可以做到


1517
00:48:07,386 --> 00:48:09,606
我们已经运行所有这些布局


1518
00:48:09,896 --> 00:48:11,976
下面这些代码已经说得够多了


1519
00:48:11,976 --> 00:48:13,346
项目 段和组的描述


1520
00:48:13,346 --> 00:48:15,836
在所使用的 API 中


1521
00:48:15,836 --> 00:48:17,426
是相同的


1522
00:48:17,426 --> 00:48:18,586
你甚至可以提取代码


1523
00:48:18,586 --> 00:48:19,816
并在不同的平台项目之间


1524
00:48:19,816 --> 00:48:22,336
分享这些代码


1525
00:48:23,396 --> 00:48:24,846
所以我们可以看到


1526
00:48:24,846 --> 00:48:26,796
这里的组合布局我们


1527
00:48:26,796 --> 00:48:29,686
在不同的平台上的操作


1528
00:48:29,686 --> 00:48:30,896
变得更加容易


1529
00:48:31,026 --> 00:48:33,766
它确实有很多值得推荐的地方


1530
00:48:34,406 --> 00:48:35,806
从今天开始你就可以


1531
00:48:35,806 --> 00:48:39,856
在 iOS tvOS 和 macOS 上使用它


1532
00:48:39,856 --> 00:48:41,566
我们只要简单地描述它


1533
00:48:41,836 --> 00:48:43,966
就可以轻易地为 CollectionView


1534
00:48:43,966 --> 00:48:46,816
创建新的自定布局


1535
00:48:46,816 --> 00:48:48,546
我们认为这是一个打破格局的创新


1536
00:48:49,436 --> 00:48:50,386
反过来 这使得


1537
00:48:50,386 --> 00:48:51,766
CollectionView 成为一个


1538
00:48:51,846 --> 00:48:53,636
比以前更全能的工具


1539
00:48:53,636 --> 00:48:55,816
你可以随心所欲地


1540
00:48:55,816 --> 00:48:58,236
展示你的内容


1541
00:48:58,926 --> 00:49:00,176
你可以更容易地


1542
00:49:00,176 --> 00:49:02,116
描述新的布局


1543
00:49:02,116 --> 00:49:03,066
调整和改变布局


1544
00:49:03,066 --> 00:49:04,216
尝试不同的东西


1545
00:49:04,216 --> 00:49:05,556
并进行迭代


1546
00:49:05,606 --> 00:49:08,396
这些都将使设计人员


1547
00:49:08,526 --> 00:49:10,266
能够更快地进行迭代


1548
00:49:10,606 --> 00:49:12,786
这的确是个改变游戏规则的创新


1549
00:49:14,256 --> 00:49:15,606
所以等你们回去


1550
00:49:15,606 --> 00:49:17,806
打开示例项目进行试验


1551
00:49:17,846 --> 00:49:19,946
尝试改变不同的事物


1552
00:49:19,946 --> 00:49:21,746
以我们的代码作为基础


1553
00:49:21,746 --> 00:49:23,606
为 App 的下个版本


1554
00:49:23,606 --> 00:49:25,686
创建自定布局吧


1555
00:49:25,956 --> 00:49:27,026
我们迫不及待地想看到


1556
00:49:27,026 --> 00:49:28,696
组合布局能够使你


1557
00:49:28,696 --> 00:49:29,986
在很短的时间内


1558
00:49:29,986 --> 00:49:32,326
创建出更好的用户体验


1559
00:49:33,356 --> 00:49:34,426
如果你本次讲座很感兴趣


1560
00:49:34,426 --> 00:49:35,766
我们还有一个话题


1561
00:49:35,766 --> 00:49:36,616
我想你也会非常喜欢


1562
00:49:36,616 --> 00:49:37,696
特别是使用 CollectionViews 


1563
00:49:37,696 --> 00:49:40,046
甚至是 UI 表视图的朋友


1564
00:49:40,286 --> 00:49:42,486
在UI数据源方面的发展中


1565
00:49:42,806 --> 00:49:44,816
我们引入了一个全新的


1566
00:49:45,006 --> 00:49:47,126
非常简单的 API


1567
00:49:47,126 --> 00:49:48,806
用于向 CollectionViews


1568
00:49:48,806 --> 00:49:50,446
和 UI 表视图提供模型数据


1569
00:49:50,446 --> 00:49:52,016
同时免费获得


1570
00:49:52,016 --> 00:49:53,266
对差异的自动计算


1571
00:49:53,266 --> 00:49:55,596
和自动动画


1572
00:49:55,596 --> 00:49:56,666
它将创造令人愉快的


1573
00:49:56,666 --> 00:49:57,666
用户体验


1574
00:49:57,666 --> 00:49:59,876
所以一定要观看这个讲座


1575
00:50:01,046 --> 00:50:02,546
感谢各位的聆听


1576
00:50:03,508 --> 00:50:05,508
[掌声]

