1
00:00:06,640 --> 00:00:07,741 line:0
（LLDB：不止“PO”）


2
00:00:07,808 --> 00:00:09,810 line:0
大家好 我是Davide


3
00:00:09,877 --> 00:00:10,811 line:0
我是一名工程师


4
00:00:10,878 --> 00:00:13,480 line:0
来自Apple调试技术团队


5
00:00:13,914 --> 00:00:16,015 line:0
今天我将与我的同事
Jonas共同进行本次演讲


6
00:00:16,350 --> 00:00:21,054 line:0
你们可能很熟悉po了 它是一种
在LLDB中打印变量的方式


7
00:00:21,421 --> 00:00:24,491 line:0
今天我们就来谈谈po及其运行方式


8
00:00:25,125 --> 00:00:29,329 line:0
我们也会介绍其他方法
来查看源代码中的变量


9
00:00:29,396 --> 00:00:33,033 line:0
以及进行格式化输出的机制


10
00:00:34,134 --> 00:00:38,505 line:-2
LLDB是为Xcode中的
变量视图提供支持的调试工具


11
00:00:39,473 --> 00:00:42,876 line:-1
你可以看到定义的变量及其类型


12
00:00:43,243 --> 00:00:44,912 line:-1
在Xcode进行调试时


13
00:00:44,978 --> 00:00:47,047 line:-1
你可以在窗口右下方


14
00:00:47,114 --> 00:00:49,850 line:-1
直接发送命令


15
00:00:49,917 --> 00:00:52,052 line:-1
并通过控制台与LLDB进行交互


16
00:00:52,519 --> 00:00:55,622 line:-1
它可以你检查app中的错误时


17
00:00:55,689 --> 00:00:57,624 line:-1
同时打印出定义


18
00:00:57,691 --> 00:01:00,260 line:-1
源代码的变量值


19
00:01:00,594 --> 00:01:04,397 line:-2
LLDB可以有多种方式
来完成这一任务


20
00:01:04,464 --> 00:01:07,568 line:-1
而每种方式都有不同的权衡取舍


21
00:01:07,634 --> 00:01:08,869 line:-1
我们来看


22
00:01:09,436 --> 00:01:10,604 line:-1
在这个例子中


23
00:01:10,671 --> 00:01:13,574 line:-1
假设我们有一个代表Trip的结构


24
00:01:13,774 --> 00:01:16,844 line:-1
由名和目的站组成


25
00:01:17,177 --> 00:01:19,746 line:-1
接下来让我们仔细看看


26
00:01:20,948 --> 00:01:24,751 line:-1
我们要探究的第一个命令是po


27
00:01:24,818 --> 00:01:28,455 line:-1
你可以把它看作是打印对象描述


28
00:01:28,522 --> 00:01:30,023 line:-1
当我们运用这个命令时


29
00:01:30,090 --> 00:01:33,427 line:-1
我们得到的返回就是对象描述


30
00:01:33,493 --> 00:01:36,997 line:-1
也就是你打印实例的文本表达


31
00:01:37,531 --> 00:01:40,367 line:-1
系统运行时会提供一个默认值


32
00:01:40,434 --> 00:01:42,536 line:-1
但也是可以自定义的


33
00:01:43,170 --> 00:01:45,839 line:-1
我们可以将一致性


34
00:01:45,906 --> 00:01:49,109 line:-2
加入至CustomDebugStringConvertible
协议中


35
00:01:49,743 --> 00:01:54,114 line:-2
这需要一种叫
debugDescription的属性


36
00:01:55,048 --> 00:01:58,919 line:-2
现在如果我们在调试工具中
打印对象描述


37
00:01:59,152 --> 00:02:03,123 line:-2
我们就可以看到我们规定的描述
而不是默认描述了


38
00:02:03,557 --> 00:02:06,493 line:-1
此项更改仅影响顶级描述


39
00:02:07,928 --> 00:02:10,163 line:-1
如果你需要修改子结构


40
00:02:10,229 --> 00:02:14,168 line:-2
就查看CustomerReflectable
协议的文档


41
00:02:14,434 --> 00:02:17,304 line:-2
也可以通过
Objective-C对象完成


42
00:02:17,371 --> 00:02:19,740 line:-1
实现描述方法


43
00:02:21,175 --> 00:02:24,344 line:-1
但是po能做的不仅仅是打印变量


44
00:02:24,411 --> 00:02:25,579 line:-1
比如


45
00:02:25,646 --> 00:02:27,581 line:-1
你可以得到漫游名称


46
00:02:27,648 --> 00:02:30,150 line:-1
并计算出它的大写版本


47
00:02:30,484 --> 00:02:34,488 line:-1
或者是按字母排序的漫游目的站


48
00:02:35,289 --> 00:02:39,426 line:-1
一般来说 它可以评估任何表达方式


49
00:02:39,493 --> 00:02:43,263 line:-2
所以 任意给定命令提示符中
可以编译的东西


50
00:02:43,330 --> 00:02:45,799 line:-1
都可以作为参数传递给注释


51
00:02:46,867 --> 00:02:47,734 line:-1
实际上


52
00:02:47,801 --> 00:02:51,638 line:-1
po是一个名为表达的命令的别名


53
00:02:51,705 --> 00:02:54,575 line:-1
含有能够打印对象描述的参数


54
00:02:55,209 --> 00:02:59,179 line:-2
LECC和LLDB都是让你
不用敲那么多下键盘的简便方式


55
00:03:00,047 --> 00:03:03,617 line:-1
比如说 你想自己实现po


56
00:03:03,684 --> 00:03:05,285 line:-1
你就可以用alias命令


57
00:03:05,352 --> 00:03:08,589 line:-1
将你的命令名称指定为第一个参数


58
00:03:08,655 --> 00:03:11,091 line:-2
再按照你想进行
alias的命令进行操作


59
00:03:11,391 --> 00:03:12,960 line:-1
确定好之后


60
00:03:13,026 --> 00:03:15,963 line:-2
你就可以像LLDB中其他命令一样
使用自己的命令了


61
00:03:17,231 --> 00:03:19,199 line:-1
现在我们了解了po可以做什么


62
00:03:19,266 --> 00:03:21,568 line:-1
我们再来深入看看它是怎么运行的


63
00:03:22,302 --> 00:03:26,306 line:-2
让我们来看看po要传输一个值时
所要经历的步骤


64
00:03:26,607 --> 00:03:30,043 line:-2
为了让你现在使用的语言
能够完整表达


65
00:03:30,110 --> 00:03:33,814 line:-1
LLDB不会解析和评估表达本身


66
00:03:34,214 --> 00:03:37,718 line:-1
相反 它一开始会生成一串源代码


67
00:03:37,784 --> 00:03:40,721 line:-1
这些代码是由你所给定的表达编译的


68
00:03:40,988 --> 00:03:43,423 line:-1
跟这里展示的片段很像


69
00:03:43,490 --> 00:03:46,760 line:-2
之后它会运用嵌入式Swift
并声明编译器


70
00:03:46,827 --> 00:03:48,095 line:-1
来编译代码


71
00:03:48,161 --> 00:03:52,266 line:-2
之后会在你
调试程序的context中执行


72
00:03:52,866 --> 00:03:55,035 line:-1
一旦执行完成


73
00:03:55,102 --> 00:03:57,971 line:-1
LLDB就要访问结果值


74
00:04:00,140 --> 00:04:02,609 line:-1
从结果值 你要得到对象描述


75
00:04:02,676 --> 00:04:07,781 line:-2
为此 LLDB将前一结果
写入另一段源代码中


76
00:04:08,115 --> 00:04:12,953 line:-2
这也会被编译并在
调试过程的context里执行


77
00:04:13,387 --> 00:04:17,624 line:-2
执行结果是LLDB
作为po命令的结果


78
00:04:17,690 --> 00:04:19,860 line:-1
显示的字符串


79
00:04:19,927 --> 00:04:22,029 line:-1
po只是三种方式中的一种


80
00:04:22,095 --> 00:04:24,865 line:-2
我们要介绍
如何在LLDB中打印变量


81
00:04:24,932 --> 00:04:26,633 line:-1
我们再来看看其他方式


82
00:04:26,700 --> 00:04:29,703 line:-1
第二种在LLDB中打印变量的方式


83
00:04:29,770 --> 00:04:31,004 line:-1
叫p命令


84
00:04:31,371 --> 00:04:35,042 line:-2
可以把它想象成是一种
不用对象描述就能够打印的方法


85
00:04:35,409 --> 00:04:36,910 line:-1
让我们来看看它的输出


86
00:04:37,611 --> 00:04:38,879 line:-1
要注意的第一点是


87
00:04:38,946 --> 00:04:41,315 line:-1
它与在po中的表达


88
00:04:41,381 --> 00:04:43,550 line:-1
略有不同之处


89
00:04:43,617 --> 00:04:47,321 line:-1
但它们包含的是同样的信息


90
00:04:47,821 --> 00:04:49,089 line:-1
需要注意的第二点


91
00:04:49,156 --> 00:04:53,293 line:-1
是结果值已被命名为$R0


92
00:04:53,894 --> 00:04:56,430 line:-1
这是LLDB中的特殊约定


93
00:04:56,730 --> 00:05:00,067 line:-1
每个表达的结果都要被赋予增值名称


94
00:05:00,133 --> 00:05:03,704 line:-1
比如$R1和$R2


95
00:05:03,770 --> 00:05:07,307 line:-2
这些名称在LLDB
之后的表达中要用到


96
00:05:07,574 --> 00:05:10,143 line:-1
你可以参考$R0


97
00:05:10,210 --> 00:05:13,180 line:-1
与你的项目中其他变量西欧昂通


98
00:05:13,580 --> 00:05:16,717 line:-1
比如说 你可以打印损坏字段


99
00:05:17,184 --> 00:05:18,652 line:-1
与po类似


100
00:05:18,719 --> 00:05:21,588 line:-1
P在LLDB中也并不是顶级命令


101
00:05:21,655 --> 00:05:24,558 line:-1
它只是表达命令的别名


102
00:05:24,625 --> 00:05:28,095 line:-1
但是后面不用加--对象描述


103
00:05:28,762 --> 00:05:30,697 line:-1
就像刚刚的po一样


104
00:05:30,764 --> 00:05:33,500 line:-1
我们具体来看p是如何运作的


105
00:05:35,235 --> 00:05:37,571 line:-1
因为p不需要获取表述


106
00:05:37,638 --> 00:05:39,840 line:-1
它也就没有那么复杂


107
00:05:39,907 --> 00:05:43,744 line:-2
你可以从之前我对po的介绍中
回忆起这个图


108
00:05:44,011 --> 00:05:46,046 line:-1
实际上 第一部分


109
00:05:46,113 --> 00:05:48,549 line:-1
编译和评估表达


110
00:05:48,615 --> 00:05:50,918 line:-1
对于这两种命令是完全一样的


111
00:05:51,285 --> 00:05:53,253 line:-1
但当它得到结果后


112
00:05:53,320 --> 00:05:57,024 line:-2
LLDB会执行一项
叫动态类型解析的步骤


113
00:05:57,558 --> 00:05:59,793 line:-1
说得更具体一些


114
00:06:00,160 --> 00:06:01,461 line:-1
为了做到这一点


115
00:06:01,528 --> 00:06:04,198 line:-1
我们要对例子进行一些修改


116
00:06:04,498 --> 00:06:05,599 line:-1
我们来看看是怎么做的


117
00:06:06,400 --> 00:06:08,268 line:-1
我们更改Trip结构


118
00:06:08,335 --> 00:06:10,971 line:-1
以符合协议名称活动


119
00:06:11,705 --> 00:06:15,275 line:-2
在Swift中
源代码中的静态表达


120
00:06:15,342 --> 00:06:17,377 line:-1
和运行时的动态类型


121
00:06:17,444 --> 00:06:19,379 line:-1
不一定是相同的


122
00:06:19,813 --> 00:06:20,747 line:-1
例如


123
00:06:20,814 --> 00:06:24,418 line:-1
变量可声明使用该种类型协议


124
00:06:25,018 --> 00:06:26,453 line:-1
在该例中


125
00:06:26,520 --> 00:06:28,722 line:-1
变量是静态的漫游活动


126
00:06:29,189 --> 00:06:30,557 line:-1
但在运行时


127
00:06:30,624 --> 00:06:33,560 line:-1
该变量又会具有Trip类型实例


128
00:06:33,994 --> 00:06:35,462 line:-1
既动态


129
00:06:36,530 --> 00:06:38,165 line:-1
如果我们打印漫游值


130
00:06:38,232 --> 00:06:40,601 line:-1
我们会得到Trip类型对象


131
00:06:40,667 --> 00:06:43,237 line:-1
因为LLDB重新生成了结果元数据


132
00:06:43,303 --> 00:06:44,872 line:-1
在给定的程序点显示


133
00:06:44,938 --> 00:06:47,774 line:-1
给定变量的最准确类型


134
00:06:48,208 --> 00:06:50,944 line:-1
这也就是我们所说的动态类型解析


135
00:06:51,144 --> 00:06:52,679 line:-1
在p命令里


136
00:06:52,746 --> 00:06:57,484 line:-1
动态类型解析仅会对表达结果执行


137
00:06:57,818 --> 00:07:00,754 line:-1
假设我们要访问一个漫游字段


138
00:07:01,054 --> 00:07:04,558 line:-2
当LLDB想通过p
对该表达进行评估时


139
00:07:04,625 --> 00:07:07,494 line:-1
我们看到漫游是一个活动类型对象


140
00:07:07,861 --> 00:07:09,830 line:-1
也没有叫name的成员


141
00:07:10,197 --> 00:07:12,266 line:-1
出现错误 评估失败


142
00:07:12,599 --> 00:07:15,302 line:-1
原因是 如果你还记得的话


143
00:07:15,669 --> 00:07:18,205 line:-1
LLDB在p命令运行位置编译代码


144
00:07:18,272 --> 00:07:21,475 line:-2
且唯一可识别的代码类型
就是你源代码中的类型


145
00:07:21,542 --> 00:07:22,776 line:-1
也就是静态类型


146
00:07:23,243 --> 00:07:25,345 line:-1
如果你在源代码中打出


147
00:07:25,412 --> 00:07:27,814 line:-2
cruise.name的
命令也是一样


148
00:07:27,881 --> 00:07:30,817 line:-1
静态编译器会报错并拒绝执行


149
00:07:31,785 --> 00:07:34,688 line:-1
如果你想评估表达且不被报错


150
00:07:34,755 --> 00:07:39,059 line:-1
首先你需要将对象转化为其动态类型


151
00:07:39,126 --> 00:07:41,361 line:-1
然后再访问结果字段


152
00:07:41,662 --> 00:07:44,998 line:-1
这在调试工具和你的源代码中都一样


153
00:07:46,567 --> 00:07:48,836 line:-1
到这里p命令还没有结束


154
00:07:49,102 --> 00:07:52,840 line:-1
在结果中执行动态解析后


155
00:07:52,906 --> 00:07:57,044 line:-2
LLDB将生成的对象传递给
格式化程序子系统


156
00:07:57,110 --> 00:07:58,412 line:-1
这也是LLDB要做的事


157
00:07:58,478 --> 00:08:02,916 line:-1
打印出人能够看懂的对象描述


158
00:08:02,983 --> 00:08:04,017 line:-1
让我们来细看


159
00:08:05,452 --> 00:08:07,321 line:-1
为了展示格式化是如何进行的


160
00:08:07,387 --> 00:08:09,990 line:-1
我将展示它的输入和输出


161
00:08:10,757 --> 00:08:12,526 line:-1
如果没有格式化


162
00:08:12,593 --> 00:08:14,928 line:-1
字符串就会是这样的


163
00:08:15,629 --> 00:08:17,197 line:-1
如果你想自己尝试


164
00:08:17,264 --> 00:08:19,900 line:-1
你可以给p命令传递--原始选项


165
00:08:20,367 --> 00:08:22,069 line:-1
标准库类型


166
00:08:22,135 --> 00:08:24,538 line:-2
即使是像字符串和整数
这样简单的类型


167
00:08:24,605 --> 00:08:26,707 line:-1
都有复杂的表达


168
00:08:26,773 --> 00:08:29,443 line:-2
因为它们针对速度和大小
进行了高度优化


169
00:08:30,477 --> 00:08:32,645 line:-1
在进行格式化操作之后


170
00:08:32,712 --> 00:08:34,982 line:-1
字符串看起来就如你所想


171
00:08:35,048 --> 00:08:36,817 line:-1
一串字母


172
00:08:37,518 --> 00:08:41,255 line:-1
LLDB了解许多常用类型


173
00:08:41,321 --> 00:08:43,524 line:-1
也可以将它们格式化


174
00:08:43,823 --> 00:08:46,660 line:-1
你还可以自己编写自定义格式化程序


175
00:08:46,727 --> 00:08:48,529 line:-1
我们简单说说


176
00:08:49,363 --> 00:08:51,798 line:-1
我们刚刚介绍了po和p


177
00:08:52,332 --> 00:08:56,703 line:-2
现在来介绍LLDB中
打印变量的第三种方式


178
00:08:56,770 --> 00:08:57,838 line:-1
v命令


179
00:08:59,206 --> 00:09:00,607 line:-1
v命令的输出


180
00:09:00,674 --> 00:09:02,676 line:-1
和p是完全一样的


181
00:09:02,743 --> 00:09:05,746 line:-2
因为它靠的也是
我们刚才说过的格式化程序


182
00:09:06,914 --> 00:09:08,615 line:-1
像其他两个命令一样


183
00:09:08,682 --> 00:09:12,619 line:-2
v也是我们在Xcode 10.2
介绍过的


184
00:09:12,686 --> 00:09:14,888 line:-1
帧变量命令的一个别名


185
00:09:14,955 --> 00:09:16,957 line:-1
但他不像刚刚两个命令


186
00:09:17,024 --> 00:09:20,194 line:-1
v命令并不编译和执行代码


187
00:09:20,260 --> 00:09:22,029 line:-1
所以它非常快


188
00:09:22,930 --> 00:09:24,865 line:-1
由于v命令不编译代码


189
00:09:24,932 --> 00:09:26,567 line:-1
它有自己的语法


190
00:09:26,633 --> 00:09:30,437 line:-2
它的语法可能和你在调试中
所使用的语言并不相同


191
00:09:30,704 --> 00:09:34,708 line:-1
例如 它用点和下标符


192
00:09:34,775 --> 00:09:36,610 line:-1
来访问字段


193
00:09:36,677 --> 00:09:39,213 line:-1
但他在解析时并不会过载运行


194
00:09:39,279 --> 00:09:42,216 line:-1
也无法评估计算属性


195
00:09:42,549 --> 00:09:45,586 line:-1
由于它要执行代码


196
00:09:46,086 --> 00:09:49,423 line:-1
你可以用p或po


197
00:09:49,723 --> 00:09:50,924 line:-1
你可能也想到了


198
00:09:51,158 --> 00:09:54,328 line:-1
v命令与其他两种打印变量的


199
00:09:54,394 --> 00:09:55,929 line:-1
运行方式大相径庭


200
00:09:56,230 --> 00:09:59,099 line:-1
我们详细来看


201
00:09:59,166 --> 00:10:03,103 line:-1
在图中 这是v命令


202
00:10:03,504 --> 00:10:05,339 line:-1
我们要打印变量


203
00:10:05,405 --> 00:10:06,440 line:-1
为此


204
00:10:06,507 --> 00:10:10,811 line:-2
v命令会首先查询程序状态
以在内存中定位变量


205
00:10:10,878 --> 00:10:14,348 line:-1
之后 它在内存中读取变量值


206
00:10:14,414 --> 00:10:17,484 line:-1
然后对其进行动态类型解析


207
00:10:17,551 --> 00:10:20,320 line:-1
如果用户要求访问子字段


208
00:10:20,387 --> 00:10:23,390 line:-1
它会在子字段中重复上述步骤


209
00:10:23,457 --> 00:10:26,627 line:-1
每次都会进行动态变量解析


210
00:10:26,960 --> 00:10:28,362 line:-1
完成之后


211
00:10:28,428 --> 00:10:31,932 line:-1
它就会传递数据格式化子系统的结果


212
00:10:32,399 --> 00:10:35,369 line:-1
v命令可能多次进行


213
00:10:35,435 --> 00:10:37,337 line:-1
动态类型解析


214
00:10:37,404 --> 00:10:39,606 line:-1
这是我们需要记住的一点


215
00:10:39,673 --> 00:10:43,210 line:-2
也是p命令和v命令运行中
非常不同的一点


216
00:10:43,277 --> 00:10:47,247 line:-1
格式化程序只执行一次动态类型解析


217
00:10:47,314 --> 00:10:50,050 line:-1
我们来看这些情况


218
00:10:51,185 --> 00:10:52,886 line:-1
回到我们的例子


219
00:10:52,953 --> 00:10:55,956 line:-1
p命令无法访问漫游成员的地方


220
00:10:56,323 --> 00:11:00,861 line:-2
通过在解释的每个步骤中
执行动态类型解析


221
00:11:00,928 --> 00:11:04,665 line:-2
v命令知道漫游是
Trip类型的一个对象


222
00:11:04,965 --> 00:11:06,900 line:-1
能够从内存中访问它的字段


223
00:11:07,901 --> 00:11:11,538 line:-1
这是它比P命令要好的一点


224
00:11:11,605 --> 00:11:13,407 line:-1
它可以让你查看


225
00:11:13,473 --> 00:11:16,210 line:-1
p命令没有转化的类型


226
00:11:17,177 --> 00:11:19,413 line:-1
我们说完了这三种


227
00:11:19,479 --> 00:11:21,982 line:-1
在LLDB中打印变量的方式


228
00:11:23,383 --> 00:11:24,651 line:-1
我们来回顾一下


229
00:11:24,718 --> 00:11:29,890 line:-1
以及对比po、p和v命令的不同


230
00:11:30,524 --> 00:11:32,059 line:-1
要说的第一点是


231
00:11:32,125 --> 00:11:34,561 line:-1
对象是如何呈现的


232
00:11:35,362 --> 00:11:38,298 line:-1
po命令运用的是对象描述


233
00:11:38,365 --> 00:11:40,701 line:-1
而p和v命令


234
00:11:40,767 --> 00:11:43,437 line:-1
运用的是格式化程序来呈现对象


235
00:11:44,037 --> 00:11:47,074 line:-1
我们也要记住计算结果的方式


236
00:11:47,441 --> 00:11:49,810 line:-1
po和p都会编译表达


237
00:11:49,877 --> 00:11:51,812 line:-1
并且可以访问完整的语言


238
00:11:52,179 --> 00:11:54,381 line:-1
而v命令有自己的语法


239
00:11:54,448 --> 00:11:56,216 line:-1
解释和表达


240
00:11:56,283 --> 00:12:00,721 line:-2
并在解释的每步中
都会进行动态类型解析


241
00:12:02,322 --> 00:12:06,693 line:-2
我们刚才也提过
LLDB格式化是可以自定义的


242
00:12:06,760 --> 00:12:08,262 line:-1
接下来我们也会详细讲到


243
00:12:08,328 --> 00:12:10,297 line:-1
有请我的同事Jonas


244
00:12:10,364 --> 00:12:12,199 line:-1
大家好 我是Jonas


245
00:12:12,566 --> 00:12:15,736 line:-1
我也是调试技术团队的一名工程师


246
00:12:16,069 --> 00:12:17,304 line:-1
在LLDB中


247
00:12:17,371 --> 00:12:20,140 line:-1
在调试工具中的数据格式化程序


248
00:12:20,207 --> 00:12:21,275 line:-1
定义了变量的显示方式


249
00:12:22,776 --> 00:12:25,546 line:-1
建立格式化程序有几种常见的类型


250
00:12:25,612 --> 00:12:26,880 line:-1
在实例中


251
00:12:26,947 --> 00:12:28,348 line:-1
当我们运用v命令时


252
00:12:28,415 --> 00:12:30,651 line:-1
我们可以打印漫游的目的地


253
00:12:30,717 --> 00:12:33,854 line:-1
以及以可读形式显示的数组元素


254
00:12:34,421 --> 00:12:38,992 line:-2
通常 默认的格式化程序在
用户定义类型


255
00:12:39,059 --> 00:12:41,261 line:-1
和标准库中的类型里都能运行


256
00:12:41,728 --> 00:12:44,765 line:-2
但有时 你可能要调整
现有的格式化程序


257
00:12:45,065 --> 00:12:46,266 line:-1
或者自己找一个


258
00:12:48,001 --> 00:12:49,069 line:-1
你也可以做到


259
00:12:49,136 --> 00:12:52,973 line:-2
因为LLDB中的数据格式化程序
是完全可扩展的


260
00:12:53,273 --> 00:12:55,776 line:-1
每种类型都有自己的表达


261
00:12:56,143 --> 00:12:58,478 line:-1
为了帮助你自定义这些表达


262
00:12:58,545 --> 00:13:02,816 line:-2
LLDB会提供过滤器
摘要和合成子项


263
00:13:04,418 --> 00:13:08,121 line:-2
过滤器用于限制
现有格式化程序的输出


264
00:13:08,188 --> 00:13:11,124 line:-1
现在我们的Trip只有几个目的地


265
00:13:11,191 --> 00:13:14,795 line:-2
但随着数量的增加
输出可能变得很乱


266
00:13:15,662 --> 00:13:16,964 line:-1
通过过滤器


267
00:13:17,030 --> 00:13:20,167 line:-1
我们就能指定只显示Trip名称


268
00:13:20,934 --> 00:13:23,871 line:-2
这不仅只影响控制台
格式化程序的输出


269
00:13:23,937 --> 00:13:25,906 line:-1
同时也影响Xcode中的变量


270
00:13:26,573 --> 00:13:29,309 line:-1
在我们继续之前先把过滤器去掉


271
00:13:30,644 --> 00:13:33,680 line:-1
摘要能够提供一种类型的字符串表达


272
00:13:33,747 --> 00:13:36,450 line:-2
为了一目了然地显示
有关该类型的信息


273
00:13:36,517 --> 00:13:39,319 line:-1
他们的数据格式化程序


274
00:13:39,386 --> 00:13:41,455 line:-1
和你在用po的时候是一样的


275
00:13:41,955 --> 00:13:43,223 line:-1
加上过滤器之后


276
00:13:43,290 --> 00:13:45,459 line:-2
它也可以影响Xcode中
显示的变量


277
00:13:46,193 --> 00:13:48,562 line:-1
Trip种的所有成员都是有摘要的


278
00:13:48,629 --> 00:13:49,930 line:-1
但Trip本身是没有的


279
00:13:50,197 --> 00:13:51,298 line:-1
我们改一下


280
00:13:52,566 --> 00:13:55,836 line:-2
一个好的摘要应该是
最初和最终的目的地


281
00:13:56,236 --> 00:13:58,805 line:-1
摘要字符串包括常规文本


282
00:13:58,872 --> 00:13:59,840 line:-1
和特殊变量


283
00:13:59,907 --> 00:14:02,709 line:-1
这些内容能够访问正在打印的字段


284
00:14:03,143 --> 00:14:05,112 line:-1
该变量以美元标志开始


285
00:14:05,179 --> 00:14:06,980 line:-1
用花括号括起来


286
00:14:07,314 --> 00:14:09,783 line:-1
它们的语法和v命令一致


287
00:14:10,217 --> 00:14:12,953 line:-1
摘要定义的当前类型


288
00:14:13,020 --> 00:14:14,588 line:-1
以var形式进行访问


289
00:14:14,988 --> 00:14:18,525 line:-2
该摘要以var.name
来访问Trip名称


290
00:14:18,592 --> 00:14:21,862 line:-2
以var.destinations
来访问目的地


291
00:14:22,563 --> 00:14:24,531 line:-1
但这样的摘要有一个问题


292
00:14:24,598 --> 00:14:28,302 line:-2
它只有在包含这三种特定目的地的
Trip中才能运行


293
00:14:28,669 --> 00:14:31,071 line:-1
因为格式化程序无法访问计算变量


294
00:14:31,138 --> 00:14:32,472 line:-1
比如一个数组


295
00:14:32,539 --> 00:14:35,108 line:-2
我们必须对最后一个元素的
索引进行硬编码


296
00:14:36,543 --> 00:14:39,880 line:-1
幸运的是 我们还有其他有用的工具


297
00:14:40,113 --> 00:14:42,482 line:-1
我们可以在Python里定义摘要


298
00:14:43,083 --> 00:14:46,086 line:-2
Python的格式化程序
可以进行任意计算


299
00:14:46,153 --> 00:14:49,890 line:-2
而且它可以完全访问
LLDB的脚本桥API


300
00:14:50,224 --> 00:14:51,792 line:-1
还可以提供用于


301
00:14:51,859 --> 00:14:54,895 line:-1
访问当前调试会话状态的对象


302
00:14:56,463 --> 00:14:59,666 line:-1
目标是当前正在调试的程序


303
00:14:59,733 --> 00:15:02,402 line:-1
进程 线程和框架


304
00:15:02,469 --> 00:15:05,506 line:-1
都为对应运行时信息提供访问


305
00:15:06,507 --> 00:15:10,377 line:-1
变量 寄存器和表达的值


306
00:15:10,444 --> 00:15:13,347 line:-1
都由SB值类进行表示


307
00:15:13,413 --> 00:15:16,617 line:-1
这对数据格式化程序来说十分有趣


308
00:15:16,683 --> 00:15:19,920 line:-2
因为其可以用来定位
各种类型及对应的值


309
00:15:20,354 --> 00:15:23,357 line:-1
更多详细信息请查看在线文档


310
00:15:25,158 --> 00:15:26,760 line:-1
从Xcode 11开始


311
00:15:26,827 --> 00:15:28,529 line:-1
脚本使用的是Python 3


312
00:15:28,962 --> 00:15:30,931 line:-2
如果你用的是
现有Python 2脚本


313
00:15:30,998 --> 00:15:32,666 line:-1
请查看Xcode的发行说明


314
00:15:32,733 --> 00:15:35,402 line:-2
上面有如何转换到
Python 3的详细信息


315
00:15:38,038 --> 00:15:40,140 line:-1
让我们来探究LDB API


316
00:15:40,841 --> 00:15:42,442 line:-1
执行脚本命令


317
00:15:42,509 --> 00:15:45,445 line:-2
将其放入交互式
Python解释器中


318
00:15:46,046 --> 00:15:49,850 line:-2
lldb.frame变量
可以访问当前框架


319
00:15:50,217 --> 00:15:52,352 line:-1
返回为一个SBFrame实例


320
00:15:52,819 --> 00:15:55,822 line:-2
我们知道当前框架
包含一个叫漫游的变量


321
00:15:56,089 --> 00:16:00,394 line:-2
因此我们可以用
FindVariable来获取其SB值


322
00:16:01,161 --> 00:16:04,298 line:-2
由于这些对象为
数据格式化程序提供支持


323
00:16:04,364 --> 00:16:06,133 line:-1
所以将它们打印出来


324
00:16:06,200 --> 00:16:09,503 line:-2
看起来与其对应的
数据格式化程序相同也就不足为奇了


325
00:16:11,438 --> 00:16:14,942 line:-2
我们也知道该漫游有一个叫
目的地的成员


326
00:16:15,008 --> 00:16:18,145 line:-2
我们可以通过调用
GetChildMemberWithName来访问它


327
00:16:18,779 --> 00:16:23,083 line:-1
结果是另一个表示目标数组的SB值


328
00:16:24,618 --> 00:16:27,888 line:-2
让我们用Python
来模拟之前的格式化程序


329
00:16:27,955 --> 00:16:30,991 line:-2
这一次最后一个元素的索引
不需要进行硬编码


330
00:16:31,425 --> 00:16:34,828 line:-2
我们可以在SB值目的地
使用GetNumChildren


331
00:16:34,895 --> 00:16:36,530 line:-1
来获取元素数量


332
00:16:36,964 --> 00:16:38,332 line:-1
通过GetChildAtIndex


333
00:16:38,398 --> 00:16:41,735 line:-1
我们可以访问第一和最后一个元素


334
00:16:42,369 --> 00:16:45,339 line:-2
请注意 打印值
是context相关的


335
00:16:45,405 --> 00:16:47,407 line:-1
它们包含了数组中的索引


336
00:16:47,808 --> 00:16:51,545 line:-2
SB值实例维持着
其父关系的context


337
00:16:52,579 --> 00:16:55,649 line:-2
现在 我们可以将所有东西
都一起放进一个字符串中


338
00:16:55,949 --> 00:16:58,852 line:-1
然而结果并不是我们想要的


339
00:16:59,152 --> 00:17:01,288 line:-1
通过打印开始和结束


340
00:17:01,355 --> 00:17:03,957 line:-1
我们获取到了SB值对象的描述


341
00:17:04,223 --> 00:17:06,760 line:-1
但是我们想要的是它们的摘要


342
00:17:07,294 --> 00:17:10,531 line:-2
我们可以使用GetSummary
来检索格式化之后的值


343
00:17:10,597 --> 00:17:11,765 line:-1
并使用它们


344
00:17:12,165 --> 00:17:13,233 line:-1
现在的结果


345
00:17:13,300 --> 00:17:15,836 line:-1
只有目标字符串本身


346
00:17:17,104 --> 00:17:18,739 line:-1
现在我们把所有都综合到一起


347
00:17:18,805 --> 00:17:22,075 line:-2
格式化程序可以在
调试器控制台中直接定义


348
00:17:22,142 --> 00:17:25,012 line:-2
或者你可以创建一个文件
并将其加载进LLDB内


349
00:17:25,279 --> 00:17:28,415 line:-2
我们创建一个
叫Trip.py的文件


350
00:17:28,949 --> 00:17:30,884 line:-1
当在文件中定义提供程序时


351
00:17:30,951 --> 00:17:34,354 line:-2
无需使用当前框架
来访问我们想要显示的变量


352
00:17:34,421 --> 00:17:38,058 line:-1
SB值会作为输入参数传递给函数


353
00:17:38,659 --> 00:17:40,060 line:-1
接下来的步骤


354
00:17:40,127 --> 00:17:43,063 line:-1
就和之前的类似


355
00:17:43,630 --> 00:17:46,800 line:-2
用Python来定义
格式化程序的另一个优点是


356
00:17:46,867 --> 00:17:48,302 line:-1
我们有控制流程


357
00:17:48,735 --> 00:17:50,537 line:-1
如果该Trip没有目的地


358
00:17:50,604 --> 00:17:52,773 line:-1
我们就可以打印为空Trip


359
00:17:53,307 --> 00:17:55,976 line:-1
我们可以获取第一和最后一个目的地


360
00:17:56,043 --> 00:17:57,644 line:-1
并返回为摘要字符串


361
00:17:58,912 --> 00:18:02,449 line:-2
现在 我们要将新的摘要提供程序
加载到LLDB中


362
00:18:02,749 --> 00:18:05,853 line:-1
可以使用脚本导入命令完成


363
00:18:06,320 --> 00:18:09,089 line:-2
接下来
我们要指定新的格式化程序为


364
00:18:09,156 --> 00:18:11,558 line:-1
之前用于Trip类型的那个


365
00:18:11,625 --> 00:18:13,227 line:-1
使用类型摘要添加


366
00:18:13,293 --> 00:18:15,295 line:-1
并提供要格式化的类型


367
00:18:15,362 --> 00:18:17,197 line:-1
及要使用的提供程序函数


368
00:18:17,698 --> 00:18:20,400 line:-1
在这里 使用完全限定类型非常重要


369
00:18:20,801 --> 00:18:22,169 line:-1
一切都搞定之后


370
00:18:22,236 --> 00:18:25,806 line:-2
v命令会用Python
摘要提供程序来打印漫游对象


371
00:18:27,274 --> 00:18:29,443 line:-1
该摘要不仅会在控制台显示


372
00:18:29,510 --> 00:18:32,045 line:-1
也会也显示在Xcode变量视图中


373
00:18:33,180 --> 00:18:35,215 line:-1
我们讲到了过滤器和摘要


374
00:18:35,282 --> 00:18:37,718 line:-1
最后一种自定义类型显示的方法


375
00:18:37,784 --> 00:18:39,453 line:-1
就是将合成子项


376
00:18:39,820 --> 00:18:44,191 line:-1
这可以使你自定义类型的子项


377
00:18:44,258 --> 00:18:47,661 line:-2
例如当你在Xcode中
输入变量视图时


378
00:18:48,195 --> 00:18:52,633 line:-2
在Python中 各子项都有一个
SB值 并且都有自己的摘要


379
00:18:54,434 --> 00:18:56,637 line:-1
定义自己的合成子项提供程序


380
00:18:56,703 --> 00:18:59,006 line:-1
与定义摘要提供程序类似


381
00:18:59,072 --> 00:19:00,340 line:-1
但是我们不定义函数


382
00:19:00,407 --> 00:19:03,143 line:-1
而是定义特定实现方法的类


383
00:19:03,477 --> 00:19:04,778 line:-1
除了init之外


384
00:19:04,845 --> 00:19:07,681 line:-1
你还提供了获取子项总数的方法


385
00:19:07,748 --> 00:19:09,449 line:-1
合成子项本身


386
00:19:09,516 --> 00:19:11,151 line:-1
及给定名称的索引


387
00:19:11,652 --> 00:19:15,556 line:-1
此期的资源链接中有完整示例


388
00:19:18,025 --> 00:19:19,026 line:-1
和刚才一样


389
00:19:19,092 --> 00:19:23,030 line:-2
使用脚本导入命令将Python
源代码加载到LLDB中


390
00:19:23,363 --> 00:19:24,198 line:-1
在这个例子中


391
00:19:24,264 --> 00:19:26,166 line:-1
我们在刚刚已经加载了过滤器


392
00:19:26,233 --> 00:19:28,635 line:-1
再次运行该命令会重新加载文件


393
00:19:29,970 --> 00:19:33,006 line:-1
指定用于合成子项的格式化程序


394
00:19:33,073 --> 00:19:34,842 line:-1
运用类型合成添加


395
00:19:34,908 --> 00:19:37,811 line:-1
并提供要格式化的类型和要使用的类


396
00:19:39,513 --> 00:19:42,983 line:-1
在定义好我们自定义的提供程序后


397
00:19:43,050 --> 00:19:45,719 line:-2
我们不希望在
调试会话结束时丢失它们


398
00:19:46,253 --> 00:19:48,088 line:-1
你在控制台的所有命令


399
00:19:48,155 --> 00:19:52,259 line:-2
可以永久保存在主目录中的
.lldbinit文件中


400
00:19:52,759 --> 00:19:56,396 line:-2
在调试会话开始时
该文件会自动加载


401
00:19:58,665 --> 00:20:00,734 line:-1
LLDB具有多种功能


402
00:20:00,801 --> 00:20:03,737 line:-1
可助你在调试时查看程序的状态


403
00:20:03,971 --> 00:20:07,541 line:-1
运用v、p还是po命令来打印变量


404
00:20:07,608 --> 00:20:10,143 line:-1
取决于你是否需要只显示其值


405
00:20:10,210 --> 00:20:13,213 line:-1
要执行命令还是获取对象描是


406
00:20:13,580 --> 00:20:15,949 line:-2
自定义或定义
你自己的数据格式化程序


407
00:20:16,016 --> 00:20:19,620 line:-1
可以使用过滤器 摘要和合成子项


408
00:20:20,087 --> 00:20:23,156 line:-2
最后 如果你用的是
Python 2写的脚本


409
00:20:23,223 --> 00:20:25,659 line:-2
请更新
以便与Python 3兼容


410
00:20:25,726 --> 00:20:29,229 line:-2
LLDB使用的版本
是从Xcode 11开始的


411
00:20:30,864 --> 00:20:32,065 line:-1
欲知更多信息


412
00:20:32,132 --> 00:20:35,602 line:-2
请登录developer.apple.com
查看本次演讲

