1
00:00:06,640 --> 00:00:09,743 line:0
（自定义工具建模
建立更智能的工具）


2
00:00:12,813 --> 00:00:13,680 line:-1
谢谢


3
00:00:16,149 --> 00:00:18,252 line:-2
大家下午好
我是Chad Woolf


4
00:00:18,318 --> 00:00:20,220 line:-1
Apple的性能工具工程师


5
00:00:20,287 --> 00:00:24,291 line:-1
演讲421的主题是自定义工具建模


6
00:00:24,925 --> 00:00:26,894 line:-1
在自定义工具架构中


7
00:00:27,227 --> 00:00:30,030 line:-1
负责建模的是中间这个 建模模块


8
00:00:30,097 --> 00:00:32,266 line:-1
它是要推出


9
00:00:32,799 --> 00:00:35,035 line:-1
操作系统记录的原始事件


10
00:00:35,102 --> 00:00:37,905 line:-1
完成转换 创建可显示的事件


11
00:00:37,971 --> 00:00:42,543 line:-2
或导入另一个建模模块
给Air Instruments UI的工具


12
00:00:42,910 --> 00:00:46,046 line:-1
这个架构的完整介绍收录在


13
00:00:46,113 --> 00:00:48,549 line:-1
2018年“创建自定义工具”演讲


14
00:00:49,082 --> 00:00:50,450 line:-1
本场演讲的内容


15
00:00:50,517 --> 00:00:52,719 line:-1
重点关注的是


16
00:00:52,786 --> 00:00:54,488 line:-1
中间的这个 建模模块


17
00:00:55,222 --> 00:00:57,224 line:-1
建模模块对所有工具都很重要


18
00:00:57,291 --> 00:00:59,993 line:-2
包括这里的
Time Profiler


19
00:01:00,594 --> 00:01:04,164 line:-2
在Time Profiler
UI中显示的数据


20
00:01:04,230 --> 00:01:07,034 line:-1
与内核记录的数据形式不一样


21
00:01:07,534 --> 00:01:09,636 line:-1
我们用建模模块进行转换


22
00:01:10,137 --> 00:01:12,806 line:-1
内核读取线程内容的样本时


23
00:01:12,873 --> 00:01:16,543 line:-1
会创建或捕捉一个叫原始回溯的东西


24
00:01:17,010 --> 00:01:19,112 line:-1
并添加到时间样本表格


25
00:01:19,613 --> 00:01:22,049 line:-2
之后由Time Profiler
的建模模块读取


26
00:01:22,649 --> 00:01:25,919 line:-1
再转换成可显示的回溯


27
00:01:25,986 --> 00:01:27,821 line:-2
放入
Time Profiler表格


28
00:01:28,422 --> 00:01:30,824 line:-2
最终由Time Profiler
工具显示


29
00:01:31,225 --> 00:01:32,693 line:-1
这样做是为了


30
00:01:32,759 --> 00:01:36,830 line:-1
更简单有效地捕捉原始回溯


31
00:01:36,997 --> 00:01:39,933 line:-1
以便之后在模块的用户空间中修复


32
00:01:40,133 --> 00:01:42,970 line:-1
从而有效地在内核留下记录


33
00:01:43,637 --> 00:01:46,874 line:-1
内核做的另一种优化是


34
00:01:47,341 --> 00:01:52,346 line:-2
如果内核对之前抽样过
但没有移动的线程 再次抽样


35
00:01:52,546 --> 00:01:54,248 line:-1
它不需要全部回溯


36
00:01:54,648 --> 00:01:58,085 line:-2
只要在样本表格中
放入一个占位符回溯


37
00:01:58,585 --> 00:02:00,821 line:-2
然后
Time Profiler模块会


38
00:02:01,388 --> 00:02:03,423 line:-1
提取最后一次回溯


39
00:02:03,924 --> 00:02:06,393 line:-2
复制到
Time Profiler表


40
00:02:06,460 --> 00:02:07,895 line:-1
然后由工具审阅


41
00:02:08,294 --> 00:02:09,562 line:-1
它做了两件事


42
00:02:09,729 --> 00:02:12,566 line:-1
它大量节省了内核的记录缓冲


43
00:02:12,633 --> 00:02:14,168 line:-1
特别是当线程为闲置状态


44
00:02:14,768 --> 00:02:17,070 line:-1
还能保持UI的效率


45
00:02:17,237 --> 00:02:19,940 line:-1
因为UI不知道这个占位符转换


46
00:02:20,274 --> 00:02:23,177 line:-1
因为是由建模模块转换的


47
00:02:23,844 --> 00:02:25,913 line:-1
下面这些主题会不断重复出现


48
00:02:26,380 --> 00:02:29,716 line:-1
基本上将自定义工具的复杂性


49
00:02:30,050 --> 00:02:31,919 line:-1
吸收到建模层面


50
00:02:32,152 --> 00:02:34,788 line:-1
这可以简化其他部分 特别是


51
00:02:35,155 --> 00:02:38,091 line:-1
对内嵌在逻辑里的追踪代码


52
00:02:38,158 --> 00:02:40,027 line:-1
和工具使用UI


53
00:02:40,994 --> 00:02:42,196 line:-1
这就今天的内容


54
00:02:42,262 --> 00:02:43,997 line:-1
我们会回顾建模基础


55
00:02:44,064 --> 00:02:47,234 line:-1
然后了解创建自定义工具的流程


56
00:02:47,701 --> 00:02:49,803 line:-1
在创建自定义模块时


57
00:02:50,604 --> 00:02:52,539 line:-1
用Scratch很难操作


58
00:02:53,006 --> 00:02:56,944 line:-1
因此今年的演讲中会展示样本代码


59
00:02:57,010 --> 00:02:58,512 line:-1
你可以模仿样本


60
00:02:58,745 --> 00:03:00,581 line:-1
或将其用作创建基础


61
00:03:01,081 --> 00:03:02,683 line:-1
现在我们要讲的是


62
00:03:02,850 --> 00:03:06,019 line:-1
执行和Cliff规则引擎


63
00:03:06,320 --> 00:03:08,522 line:-1
还有关键内容 推断


64
00:03:09,056 --> 00:03:12,226 line:-1
首先来重温一些建模基础


65
00:03:13,994 --> 00:03:15,863 line:-1
在创建模块时


66
00:03:16,096 --> 00:03:17,331 line:-1
你需要定义


67
00:03:17,397 --> 00:03:19,600 line:-1
其他架构部分


68
00:03:19,800 --> 00:03:21,702 line:-1
比如定义schema


69
00:03:21,768 --> 00:03:24,004 line:-1
整合查看器的所有内容


70
00:03:24,404 --> 00:03:28,108 line:-1
并最后审阅查看器的输出


71
00:03:28,609 --> 00:03:31,612 line:-1
所有这些都建在工具分布包中


72
00:03:31,678 --> 00:03:34,915 line:-1
可以在工具内安装并测试


73
00:03:35,482 --> 00:03:36,984 line:-1
这里我们假设


74
00:03:37,050 --> 00:03:39,853 line:-1
Xcode中已经有一个项目


75
00:03:39,920 --> 00:03:42,623 line:-1
你要做的是添加自定义模块


76
00:03:42,856 --> 00:03:44,791 line:-1
或使用样本代码


77
00:03:44,992 --> 00:03:46,560 line:-1
今年的演讲中有展示


78
00:03:46,927 --> 00:03:49,062 line:-1
获得设置好的项目


79
00:03:50,197 --> 00:03:52,699 line:-1
何时需要创建自定义模块呢


80
00:03:53,433 --> 00:03:56,170 line:-1
Xcode的确可以生成模块


81
00:03:56,236 --> 00:04:00,040 line:-2
特别是OS Signpost
作为输入时


82
00:04:00,607 --> 00:04:02,409 line:-1
但这些建模模块只是让你


83
00:04:02,476 --> 00:04:03,944 line:-1
快速运行工具


84
00:04:04,011 --> 00:04:07,314 line:-1
而不是开放所有功能


85
00:04:07,381 --> 00:04:08,749 line:-1
让你自定义建块


86
00:04:09,416 --> 00:04:12,319 line:-1
比如融合多个输入表的数据


87
00:04:12,386 --> 00:04:14,288 line:-1
自定义模块可以做到


88
00:04:14,354 --> 00:04:15,822 line:-1
已生成的案例就不行


89
00:04:16,790 --> 00:04:18,759 line:-1
更重要的是维护工作记忆


90
00:04:18,825 --> 00:04:22,029 line:-1
让模块记录运行总计


91
00:04:22,095 --> 00:04:23,397 line:-1
追踪开区间


92
00:04:23,730 --> 00:04:25,732 line:-1
运行更多计算


93
00:04:25,799 --> 00:04:27,968 line:-1
使用模块的工作记忆


94
00:04:29,536 --> 00:04:31,538 line:-1
另外能做的是创建自定义图表


95
00:04:31,605 --> 00:04:32,906 line:-1
如果想要创建图表


96
00:04:32,973 --> 00:04:34,341 line:-1
但工具不能在本地完成


97
00:04:34,675 --> 00:04:37,177 line:-1
你可以在建模模块中合成


98
00:04:37,244 --> 00:04:40,681 line:-1
比如 你可以计算移动平均值


99
00:04:40,747 --> 00:04:42,649 line:-1
或更复杂的卡尔曼滤波


100
00:04:42,716 --> 00:04:43,817 line:-1
这都取决于你


101
00:04:43,884 --> 00:04:46,353 line:-1
所有这些都能在自定义建模中完成


102
00:04:46,920 --> 00:04:49,990 line:-1
最终目标是建立更为智能的工具


103
00:04:50,691 --> 00:04:53,560 line:-1
让工具知道代码在做什么


104
00:04:53,794 --> 00:04:56,029 line:-1
甚至能够达到


105
00:04:56,330 --> 00:04:59,132 line:-1
让使用代码的人会先查找工具


106
00:04:59,199 --> 00:05:00,901 line:-1
然后再找你解决问题


107
00:05:01,235 --> 00:05:03,971 line:-1
这就解放了你 让你能投入下个项目


108
00:05:05,506 --> 00:05:07,407 line:-1
模块基本等于规则引擎


109
00:05:07,608 --> 00:05:11,778 line:-1
捆绑一套输入表和一套输出表


110
00:05:12,546 --> 00:05:16,683 line:-2
工具的分析内核
负责对输入表按时间排列


111
00:05:16,750 --> 00:05:19,186 line:-1
然后注入模块的工作记忆


112
00:05:19,586 --> 00:05:21,688 line:-1
工作记忆中的对象叫做事实


113
00:05:21,922 --> 00:05:23,156 line:-1
用来推断


114
00:05:23,223 --> 00:05:25,125 line:-1
工作记忆和事实的变化


115
00:05:25,559 --> 00:05:28,529 line:-1
是CLIPS语言的规则系统


116
00:05:28,595 --> 00:05:29,963 line:-1
CLIPS是开源语言


117
00:05:30,030 --> 00:05:32,466 line:-1
八十年代出现 并有很多优秀的案例


118
00:05:32,766 --> 00:05:34,401 line:-1
和文献供你参考


119
00:05:34,635 --> 00:05:36,503 line:-1
我们的样本代码里也有很多例子


120
00:05:36,570 --> 00:05:38,005 line:-1
还有幻灯片中


121
00:05:39,173 --> 00:05:40,807 line:-1
当建模模块发现


122
00:05:40,874 --> 00:05:42,476 line:-1
它想输出的东西


123
00:05:42,543 --> 00:05:45,979 line:-1
模块的函数可以编写绑定的输出表


124
00:05:46,947 --> 00:05:48,815 line:-1
要从Scratch编写模块


125
00:05:48,882 --> 00:05:51,151 line:-1
可以分三步 首先是


126
00:05:51,518 --> 00:05:52,753 line:-1
决定模块内容


127
00:05:53,120 --> 00:05:55,122 line:-1
意思是了解技术


128
00:05:55,189 --> 00:05:56,590 line:-1
创建自定义工具


129
00:05:57,124 --> 00:05:58,258 line:-1
也就是说


130
00:05:58,325 --> 00:06:00,594 line:-1
了解自定义工具的结构


131
00:06:00,661 --> 00:06:02,129 line:-1
和如何发挥最多用处


132
00:06:02,896 --> 00:06:05,766 line:-2
2019年“开发优秀的剖析体验”
演讲中


133
00:06:05,832 --> 00:06:07,601 line:-1
我们团队会带你了解


134
00:06:08,001 --> 00:06:10,704 line:-1
代码的变化如何讲故事


135
00:06:10,771 --> 00:06:11,738 line:-1
通过自定义工具


136
00:06:11,805 --> 00:06:15,142 line:-1
它可以作为了解建模内容的起点


137
00:06:16,343 --> 00:06:19,913 line:-1
给建模模块定义了输出后


138
00:06:20,247 --> 00:06:21,648 line:-1
需要一些输入


139
00:06:22,049 --> 00:06:24,618 line:-1
从代码输入工具的最好方法是


140
00:06:24,685 --> 00:06:26,420 line:-2
通过
OS Signpost API


141
00:06:26,920 --> 00:06:29,122 line:-1
这个API可以穿插在代码中


142
00:06:29,189 --> 00:06:30,757 line:-1
追踪代码变化


143
00:06:30,824 --> 00:06:32,593 line:-1
传递实参数据


144
00:06:32,659 --> 00:06:35,896 line:-1
让模块在输入流中完成推断


145
00:06:36,496 --> 00:06:38,599 line:-1
有了输入和输出之后


146
00:06:38,665 --> 00:06:40,667 line:-1
要开始定义规则系统


147
00:06:40,734 --> 00:06:41,768 line:-1
并编写规则


148
00:06:42,169 --> 00:06:44,371 line:-1
第二步和第三步都是迭代的


149
00:06:44,438 --> 00:06:46,540 line:-1
因此在写规则时


150
00:06:46,607 --> 00:06:49,343 line:-2
可能需要回溯
添加更多Signpost


151
00:06:49,409 --> 00:06:51,545 line:-2
或修改Signpost
都没问题


152
00:06:51,612 --> 00:06:52,446 line:-1
可以这样做


153
00:06:52,779 --> 00:06:55,916 line:-2
但要记住
Signpost是设立界限


154
00:06:55,983 --> 00:06:58,385 line:-1
隔离代码和工具的内容


155
00:06:58,452 --> 00:07:00,554 line:-1
所以 你要保证


156
00:07:00,988 --> 00:07:03,423 line:-1
给Signpost调用添加评论


157
00:07:03,490 --> 00:07:05,692 line:-1
让人们知道这实际是个合约


158
00:07:05,759 --> 00:07:08,462 line:-1
如果修改就会破坏工具


159
00:07:09,463 --> 00:07:12,099 line:-1
要了解这个过程 可能最好是要


160
00:07:12,165 --> 00:07:13,233 line:-1
通过实际例子


161
00:07:13,300 --> 00:07:16,637 line:-1
所以我要请上我们的建模专家


162
00:07:16,937 --> 00:07:19,006 line:-2
Alejandro Lucena
来讲解


163
00:07:24,211 --> 00:07:26,446 line:-1
大家下午好 感谢Chad


164
00:07:27,681 --> 00:07:29,316 line:-1
我要做的就是


165
00:07:29,383 --> 00:07:31,218 line:-1
演示Chad说的思维过程


166
00:07:31,418 --> 00:07:34,588 line:-2
并用一个例子演示
如何将所有组件融为一体


167
00:07:35,389 --> 00:07:38,258 line:-1
首先 从这个演示app开始


168
00:07:38,458 --> 00:07:42,029 line:-1
坦白说 这可能是我做过的最酷的事


169
00:07:42,496 --> 00:07:44,231 line:-1
它是列出了各种山羊


170
00:07:44,831 --> 00:07:48,969 line:-1
这些山羊不仅是显示在app中


171
00:07:49,036 --> 00:07:50,637 line:-1
app还能让我排序


172
00:07:51,138 --> 00:07:53,006 line:-1
排序的实现是通过


173
00:07:53,073 --> 00:07:54,441 line:-1
“移动主体模式”


174
00:07:54,975 --> 00:07:58,412 line:-1
它有很多并列的不同模式可供使用


175
00:07:58,478 --> 00:08:01,014 line:-2
比如future和promise
或执行序列


176
00:08:01,448 --> 00:08:03,483 line:-1
所以如果“移动主体”这个词


177
00:08:03,550 --> 00:08:04,484 line:-1
你听到我们说


178
00:08:04,718 --> 00:08:08,322 line:-1
你可以想象成你使用的任何模式


179
00:08:08,689 --> 00:08:11,491 line:-1
但本场还是称之为“移动主体”


180
00:08:12,559 --> 00:08:13,794 line:-1
如字面意思


181
00:08:13,861 --> 00:08:16,463 line:-1
移动主体模式传递的重要概念


182
00:08:16,530 --> 00:08:17,664 line:-1
就是移动主体


183
00:08:18,198 --> 00:08:21,435 line:-1
可视化为左上角的圆圈


184
00:08:22,202 --> 00:08:25,372 line:-1
这个主体是要完成任务 比如排序


185
00:08:25,439 --> 00:08:27,741 line:-1
并分成几个子任务


186
00:08:27,975 --> 00:08:29,743 line:-1
比如获取初始表


187
00:08:29,810 --> 00:08:31,578 line:-1
排序 然后确认结果


188
00:08:32,145 --> 00:08:35,616 line:-1
每个子任务会在“站点”执行


189
00:08:36,183 --> 00:08:37,784 line:-1
站点告诉主体


190
00:08:37,851 --> 00:08:40,419 line:-1
依赖关系或执行上下文


191
00:08:40,486 --> 00:08:41,688 line:-1
帮它完成子目标


192
00:08:43,023 --> 00:08:45,792 line:-1
下面看看如何执行任务 比如排序


193
00:08:45,859 --> 00:08:47,294 line:-1
通过移动主体模式


194
00:08:47,895 --> 00:08:51,031 line:-1
我们要做的是点击左上角的“排序”


195
00:08:51,732 --> 00:08:54,401 line:-1
主体会移动到第一个站点


196
00:08:54,568 --> 00:08:56,503 line:-1
这里的站点由UI控制


197
00:08:57,037 --> 00:09:00,107 line:-1
它会执行第一个子任务 获取列表


198
00:09:00,908 --> 00:09:02,309 line:-1
获取列表后


199
00:09:02,509 --> 00:09:06,513 line:-2
它可以移动到另一个站点
比如分发队列


200
00:09:07,281 --> 00:09:10,417 line:-1
在分发队列站点 它可以运行排序


201
00:09:11,585 --> 00:09:13,086 line:-1
排序完成后


202
00:09:13,487 --> 00:09:14,721 line:-1
它会回到UI


203
00:09:15,489 --> 00:09:18,091 line:-1
最后将列表按序整理排列


204
00:09:19,226 --> 00:09:21,895 line:-1
最后停泊到“排序”键 供以后使用


205
00:09:23,230 --> 00:09:25,766 line:-1
刚才演示的就是移动主体模式


206
00:09:25,832 --> 00:09:28,268 line:-1
主体可以是两个初始阶段中的一个


207
00:09:28,569 --> 00:09:32,105 line:-2
可以在一个站点执行
也可以移动到另一个站点


208
00:09:32,539 --> 00:09:34,007 line:-1
这就是建模有趣的地方


209
00:09:34,074 --> 00:09:36,610 line:-1
具体来说 有趣的是看到它们


210
00:09:36,677 --> 00:09:38,645 line:-1
交互的时间


211
00:09:39,446 --> 00:09:40,547 line:-1
为了更好的可视化


212
00:09:40,614 --> 00:09:42,182 line:-1
我再演示一遍这个排序的例子


213
00:09:42,249 --> 00:09:44,251 line:-1
带上区间


214
00:09:44,318 --> 00:09:45,185 line:-1
我要做的是


215
00:09:45,252 --> 00:09:47,387 line:-1
将设备移动到左边


216
00:09:47,888 --> 00:09:49,189 line:-1
因为需要一些空间


217
00:09:50,090 --> 00:09:53,760 line:-2
然后点击“排序”按钮
这个主体会移动到UI站点


218
00:09:54,494 --> 00:09:57,064 line:-1
移动发生时 看到一个区间


219
00:09:57,130 --> 00:09:59,867 line:-2
带描述性字符串
或告诉我们发生了什么


220
00:10:01,001 --> 00:10:02,102 line:-1
然后在站点


221
00:10:02,169 --> 00:10:04,371 line:-1
主体会执行第一个子任务


222
00:10:04,438 --> 00:10:05,973 line:-1
获取列表


223
00:10:07,040 --> 00:10:08,809 line:-1
这里有个不同的区间


224
00:10:10,410 --> 00:10:13,013 line:-1
然后主体会移动到分发队列


225
00:10:13,714 --> 00:10:15,516 line:-1
由它自己的区间显示


226
00:10:17,618 --> 00:10:20,087 line:-1
在分发队列 主体会执行排序


227
00:10:21,221 --> 00:10:23,190 line:-1
如所见 它在执行排序模式


228
00:10:24,691 --> 00:10:26,860 line:-1
然后回到UI站点


229
00:10:26,927 --> 00:10:29,763 line:-1
这是最后一个移动区间 移回UI


230
00:10:30,931 --> 00:10:34,067 line:-2
这个站点上
它会执行下一个也是最后一个


231
00:10:34,134 --> 00:10:36,436 line:-1
更新排序的子任务


232
00:10:37,738 --> 00:10:40,107 line:-2
有了这些区间
就可以设想区间的开始


233
00:10:40,174 --> 00:10:41,975 line:-1
就是活动的起始时间


234
00:10:42,042 --> 00:10:43,377 line:-1
无论是执行还是移动


235
00:10:43,744 --> 00:10:46,313 line:-1
区间的结束就是活动的终止时间


236
00:10:47,047 --> 00:10:48,282 line:-1
记住这些区间


237
00:10:48,348 --> 00:10:51,585 line:-1
就可以拥有或设计想要的工具


238
00:10:51,785 --> 00:10:53,587 line:-1
就是屏幕上展示的这样


239
00:10:54,421 --> 00:10:55,422 line:-1
最上面的轨道


240
00:10:55,489 --> 00:10:57,124 line:-1
显示了所有的区间


241
00:10:57,191 --> 00:10:59,259 line:-1
可以看到不同的移动和执行


242
00:10:59,793 --> 00:11:01,562 line:-1
它的下面


243
00:11:01,628 --> 00:11:03,764 line:-1
是轨道上不同的活动站点


244
00:11:04,998 --> 00:11:07,234 line:-1
除了工具的直观样式


245
00:11:07,301 --> 00:11:08,802 line:-1
还要看看细节视图


246
00:11:09,169 --> 00:11:10,871 line:-1
细节视图提供更多信息


247
00:11:10,938 --> 00:11:12,372 line:-1
关于每个站点的活动


248
00:11:12,439 --> 00:11:15,309 line:-1
比如起始时间 时长


249
00:11:15,642 --> 00:11:17,244 line:-1
主体是什么 等等


250
00:11:18,378 --> 00:11:21,849 line:-1
这里要注意最上面这一列


251
00:11:22,249 --> 00:11:25,419 line:-1
它定义了建模的关键兴趣点


252
00:11:25,953 --> 00:11:27,287 line:-1
这几列告诉了我们


253
00:11:27,354 --> 00:11:29,289 line:-1
起始时间 时长和主体类型


254
00:11:29,590 --> 00:11:31,625 line:-1
通常这几列中的定义


255
00:11:31,692 --> 00:11:34,027 line:-1
在工具的XML文件包中


256
00:11:34,528 --> 00:11:37,030 line:-1
它们共同组成输出表


257
00:11:37,598 --> 00:11:39,199 line:-1
这也是我们的第一个检查点


258
00:11:39,600 --> 00:11:40,834 line:-1
通过这些列


259
00:11:40,901 --> 00:11:43,337 line:-1
定义要存储的数据


260
00:11:43,670 --> 00:11:45,172 line:-1
这就完成了第一个目标


261
00:11:45,239 --> 00:11:47,007 line:-1
决定模块的内容


262
00:11:47,841 --> 00:11:48,742 line:-1
这就好了


263
00:11:49,576 --> 00:11:52,980 line:-2
下一步就是获取数据
从app到工具


264
00:11:53,380 --> 00:11:55,249 line:-1
通过OS Signpost实现


265
00:11:56,683 --> 00:11:58,118 line:-1
再回到之前的区间


266
00:11:58,652 --> 00:11:59,486 line:-1
就是它们


267
00:12:00,087 --> 00:12:03,056 line:-2
我们有个API
使用OS Signpost


268
00:12:03,123 --> 00:12:04,992 line:-1
是本地为区间而创建的


269
00:12:05,759 --> 00:12:07,494 line:-1
但我们想更进一步


270
00:12:07,728 --> 00:12:10,864 line:-1
使用Event Signpost


271
00:12:11,331 --> 00:12:13,400 line:-2
每个event Signpost
会出现在


272
00:12:13,467 --> 00:12:15,469 line:-1
活动区间之间的界限上


273
00:12:15,836 --> 00:12:17,871 line:-1
这样做不仅是为了


274
00:12:17,938 --> 00:12:21,642 line:-1
节省大约50%的Signpost


275
00:12:21,975 --> 00:12:23,944 line:-1
更是为了更准确的显示


276
00:12:24,011 --> 00:12:25,145 line:-1
移动主体模式


277
00:12:25,812 --> 00:12:28,348 line:-1
就是主体结束当前活动后


278
00:12:28,415 --> 00:12:29,783 line:-1
会立即开始另一个


279
00:12:29,850 --> 00:12:32,152 line:-2
所以只能发射一个Signpost
告诉我们


280
00:12:32,319 --> 00:12:33,520 line:-1
主体开始下一个活动了


281
00:12:35,422 --> 00:12:36,623 line:-1
为实现它


282
00:12:36,857 --> 00:12:40,260 line:-2
需要executeStop函数
是移动主体的一部分


283
00:12:40,694 --> 00:12:42,996 line:-1
在运行内部逻辑


284
00:12:43,063 --> 00:12:45,232 line:-1
执行该站点活动之前


285
00:12:45,666 --> 00:12:47,401 line:-2
要有一个Signpost
带有名称


286
00:12:47,668 --> 00:12:50,838 line:-2
具体的Signpost ID
和内嵌消息


287
00:12:52,306 --> 00:12:53,140 line:-1
除此之外


288
00:12:53,674 --> 00:12:57,578 line:-2
visitNextStop函数中
配置相同的OS Signpost


289
00:12:57,644 --> 00:13:00,814 line:-1
执行主体在站点间移动的逻辑


290
00:13:01,315 --> 00:13:03,016 line:-1
同样 执行移动之前


291
00:13:03,317 --> 00:13:05,586 line:-2
命名
Mobile Agent Moved


292
00:13:05,652 --> 00:13:08,021 line:-2
再给一个Signpost ID
和一条消息


293
00:13:11,825 --> 00:13:14,294 line:-1
现在注意看中间的模块


294
00:13:14,361 --> 00:13:16,430 line:-1
它会转换Signpost


295
00:13:16,496 --> 00:13:17,698 line:-1
把刚输入app的


296
00:13:18,065 --> 00:13:20,567 line:-1
变成可用的区间 写入输出表


297
00:13:22,035 --> 00:13:23,170 line:-1
举个例子


298
00:13:23,237 --> 00:13:24,238 line:-1
这个模块


299
00:13:24,304 --> 00:13:26,640 line:-1
一开始 工作记忆是空的


300
00:13:26,707 --> 00:13:29,276 line:-1
因为它不知道app的状态


301
00:13:30,244 --> 00:13:31,778 line:-1
但我们知道


302
00:13:32,145 --> 00:13:35,315 line:-2
模块与OS Signpost表
交互频繁


303
00:13:35,649 --> 00:13:37,918 line:-2
OS Signpost表
由app生成


304
00:13:38,785 --> 00:13:41,488 line:-1
假设模块想要侦测


305
00:13:41,688 --> 00:13:43,490 line:-1
Signpost上的移动主体


306
00:13:44,591 --> 00:13:46,827 line:-1
点击演示app上的排序按钮后


307
00:13:47,094 --> 00:13:49,263 line:-2
模块会接收一个
OS Signpost


308
00:13:49,563 --> 00:13:51,999 line:-1
然后将它表述为一个事实


309
00:13:52,266 --> 00:13:53,901 line:-1
这个事实带有信息栏


310
00:13:53,967 --> 00:13:56,069 line:-2
根据调用
OS Signpost的方法


311
00:13:57,271 --> 00:13:59,106 line:-1
现在 建模模块看到


312
00:13:59,173 --> 00:14:01,241 line:-2
OS Signpost事实
实际上是


313
00:14:01,308 --> 00:14:02,809 line:-1
移动主体的各种信息


314
00:14:03,310 --> 00:14:07,080 line:-2
模块就能通过
OS Signpost事实推断主体


315
00:14:07,247 --> 00:14:09,983 line:-1
通过确定事实 注入工作记忆


316
00:14:10,284 --> 00:14:12,920 line:-1
确定知道有一个排序主体


317
00:14:12,986 --> 00:14:14,054 line:-1
移动到后台


318
00:14:16,223 --> 00:14:19,193 line:-1
然后 模块要决定主体的活动


319
00:14:19,259 --> 00:14:22,729 line:-1
比如实际在做什么 以及时间


320
00:14:23,363 --> 00:14:25,799 line:-1
然后模块会查看已知事实 然后说


321
00:14:25,866 --> 00:14:28,101 line:-1
我知道主体正在移动


322
00:14:28,468 --> 00:14:31,538 line:-2
而Signpost事实的
起始时间是42


323
00:14:32,005 --> 00:14:33,607 line:-1
建模模块会记住它


324
00:14:33,674 --> 00:14:35,943 line:-1
在工作记忆中再输入一个事实


325
00:14:36,443 --> 00:14:38,445 line:-1
表明起始时间为42


326
00:14:39,980 --> 00:14:42,216 line:-1
这时Signpost事实消失了


327
00:14:43,183 --> 00:14:45,686 line:-1
没问题 因为我们把所有相关信息


328
00:14:45,752 --> 00:14:48,021 line:-1
确定的事实 都存入了工作记忆


329
00:14:49,156 --> 00:14:51,658 line:-1
我把它们往上挪一点 留些空间


330
00:14:52,759 --> 00:14:54,494 line:-1
最后建模模块要做的


331
00:14:54,795 --> 00:14:57,264 line:-1
是决定活动的完整区间


332
00:14:57,564 --> 00:15:00,434 line:-1
现在只有起始时间 没有完整区间


333
00:15:01,134 --> 00:15:02,469 line:-1
但我们知道某个点上


334
00:15:02,870 --> 00:15:05,072 line:-2
演示app会发出
另一个Signpost


335
00:15:05,305 --> 00:15:06,640 line:-1
同样的 建模模块接收后


336
00:15:06,840 --> 00:15:08,475 line:-1
会表述为相应事实


337
00:15:09,309 --> 00:15:10,878 line:-1
因为Signpost经过架构


338
00:15:10,944 --> 00:15:13,313 line:-1
会在区间间隙发出


339
00:15:13,780 --> 00:15:16,850 line:-2
模块知道何时接收
下一个Signpost


340
00:15:16,917 --> 00:15:20,087 line:-1
它可以查看任何之前打开的区间事实


341
00:15:20,587 --> 00:15:21,421 line:-1
并关闭


342
00:15:22,155 --> 00:15:25,359 line:-1
这里 它会查看事实的值


343
00:15:25,592 --> 00:15:28,729 line:-1
用足够的值决定完整区间


344
00:15:29,129 --> 00:15:31,031 line:-1
为此 它要调出输出表


345
00:15:32,432 --> 00:15:34,668 line:-1
删除已有的开区间事实


346
00:15:35,335 --> 00:15:36,837 line:-1
用完整区间替代


347
00:15:36,904 --> 00:15:38,071 line:-1
这里是移动到后台


348
00:15:38,872 --> 00:15:40,874 line:-1
并使用这个区间填写输出表


349
00:15:43,210 --> 00:15:44,077 line:-1
好了


350
00:15:44,645 --> 00:15:47,614 line:-1
在研究实际的CLIPS代码之前


351
00:15:47,681 --> 00:15:51,752 line:-2
还是要了解app代码
调用的API如何


352
00:15:51,818 --> 00:15:53,620 line:-1
能翻译成CLIPS事实


353
00:15:54,688 --> 00:15:58,659 line:-2
特别是当调用特殊名称的
OS Signpost


354
00:15:58,725 --> 00:16:02,696 line:-2
这个名称会成为
OS Signpost事实中的名称


355
00:16:04,698 --> 00:16:07,668 line:-2
另外 这个事件里的
Signpost类型


356
00:16:07,734 --> 00:16:10,704 line:-2
会成为OS Signpost
事件中的事件类型栏


357
00:16:12,105 --> 00:16:14,174 line:-1
最后 Signpost ID


358
00:16:14,575 --> 00:16:17,744 line:-2
会成为OS Signpost
事件内的标识符值


359
00:16:18,445 --> 00:16:20,080 line:-1
还有消息 内嵌的消息


360
00:16:20,147 --> 00:16:23,650 line:-2
也是OS Signpost
事实的信息值


361
00:16:26,787 --> 00:16:27,721 line:-1
现在我们知道


362
00:16:27,788 --> 00:16:30,057 line:-1
可以通过查找规则来侦测移动主体


363
00:16:30,123 --> 00:16:31,525 line:-1
这是一个CLIPS规则


364
00:16:31,758 --> 00:16:32,926 line:-1
首先要做的是


365
00:16:32,993 --> 00:16:35,062 line:-1
侦测OS Signpost


366
00:16:35,996 --> 00:16:38,532 line:-2
通过名称
比如Mobile Agent Moved


367
00:16:39,900 --> 00:16:41,935 line:-1
我们要捕捉这个值


368
00:16:42,002 --> 00:16:45,138 line:-2
位于标识符栏
在instance变量中


369
00:16:47,007 --> 00:16:49,376 line:-1
另外 我们可以对消息进行解析


370
00:16:49,443 --> 00:16:51,411 line:-1
提取有用信息 如图


371
00:16:54,014 --> 00:16:54,948 line:-1
第二部分


372
00:16:55,015 --> 00:16:56,884 line:-1
我们要表述一个条件


373
00:16:57,050 --> 00:17:00,921 line:-1
就是要匹配缺失的移动主体


374
00:17:00,988 --> 00:17:02,923 line:-1
Signpost标识过的


375
00:17:03,223 --> 00:17:05,826 line:-2
我们会用Signpost
去找到移动主体


376
00:17:05,893 --> 00:17:07,661 line:-1
但是不想增加任何重复


377
00:17:07,994 --> 00:17:10,263 line:-1
因此关键词not就是告诉模块


378
00:17:10,430 --> 00:17:12,598 line:-1
前提是没有移动主体


379
00:17:12,665 --> 00:17:14,835 line:-2
在这个instance变量中
被识别


380
00:17:16,069 --> 00:17:17,003 line:-1
如果是这样


381
00:17:17,069 --> 00:17:19,839 line:-2
模块可以确认这个移动主体
并注入工作记忆


382
00:17:22,776 --> 00:17:25,679 line:-1
同样的 在侦测移动主体活动时


383
00:17:26,280 --> 00:17:27,981 line:-2
会再次匹配
OS Signpost事实


384
00:17:28,048 --> 00:17:30,117 line:-1
因为需要确定某些属性


385
00:17:30,984 --> 00:17:31,852 line:-1
但这里


386
00:17:32,252 --> 00:17:34,021 line:-1
省略了关键词not


387
00:17:34,087 --> 00:17:36,623 line:-1
因为要将这个主体事实显示到


388
00:17:36,690 --> 00:17:37,824 line:-1
工作记忆中


389
00:17:37,891 --> 00:17:39,893 line:-1
现在已经解析了主体


390
00:17:40,160 --> 00:17:41,295 line:-1
并可以用它做更多事情


391
00:17:42,462 --> 00:17:45,465 line:-1
具体来说 一旦有了这两个事实


392
00:17:45,966 --> 00:17:48,368 line:-1
就能确定或添加移动事实


393
00:17:48,669 --> 00:17:51,271 line:-1
让建模模块可以追踪主体的实际活动


394
00:17:53,674 --> 00:17:56,577 line:-1
以上是CLIPS代码的例子


395
00:17:56,777 --> 00:17:59,746 line:-1
用来侦测主体和主体的活动


396
00:17:59,947 --> 00:18:02,716 line:-1
但我们还需要更多底层执行的知识


397
00:18:03,217 --> 00:18:05,485 line:-1
以便更好地架构建模模块


398
00:18:06,119 --> 00:18:08,488 line:-1
我要请Chad回到舞台


399
00:18:08,555 --> 00:18:09,790 line:-1
讲解规则执行


400
00:18:14,161 --> 00:18:16,530 line:-1
好的 下面来讲规则执行


401
00:18:16,597 --> 00:18:19,032 line:-1
CLIPS语言下的规则引擎


402
00:18:20,667 --> 00:18:22,269 line:-1
当我们在CLIPS中定义规则时


403
00:18:22,336 --> 00:18:24,771 line:-2
分为左边(LHS)
和右边(RHS)


404
00:18:24,838 --> 00:18:26,974 line:-1
用=>隔开


405
00:18:27,374 --> 00:18:30,511 line:-1
左边是描述性语言


406
00:18:30,577 --> 00:18:32,145 line:-1
定义了一个模式


407
00:18:32,212 --> 00:18:35,549 line:-1
让规则引擎在工作记忆中查找事实


408
00:18:36,283 --> 00:18:38,919 line:-1
当规则引擎找到了事实


409
00:18:38,986 --> 00:18:41,488 line:-1
满足左边的模式


410
00:18:41,788 --> 00:18:43,156 line:-1
会创建一个 激活


411
00:18:43,557 --> 00:18:46,960 line:-1
每次激活会触发规则的右边


412
00:18:47,561 --> 00:18:48,729 line:-1
规则的右边


413
00:18:48,795 --> 00:18:50,330 line:-1
是命令式语言


414
00:18:50,397 --> 00:18:52,733 line:-1
让你控制函数 比如“取消”


415
00:18:52,799 --> 00:18:55,035 line:-1
就是从工作记忆中删除事实


416
00:18:55,636 --> 00:18:59,106 line:-2
或“确认” 就是
在工作记忆中添加事实


417
00:18:59,706 --> 00:19:01,341 line:-1
还有特殊函数


418
00:19:01,408 --> 00:19:04,411 line:-1
让你写入模块的输出表


419
00:19:04,811 --> 00:19:06,013 line:-1
就能编写输出了


420
00:19:07,614 --> 00:19:08,982 line:-1
先讲讲事实


421
00:19:09,383 --> 00:19:11,451 line:-1
在工作记忆中确认事实


422
00:19:11,718 --> 00:19:13,053 line:-1
要用assert函数


423
00:19:13,520 --> 00:19:16,857 line:-1
每个新事实分配一个事实地址


424
00:19:16,924 --> 00:19:20,093 line:-1
标识为f-加一些数字


425
00:19:20,894 --> 00:19:24,531 line:-1
如果要在工作记忆中修改事实


426
00:19:24,698 --> 00:19:26,700 line:-1
我们还要有modify函数


427
00:19:27,367 --> 00:19:29,870 line:-1
它将修改的事实地址和栏


428
00:19:29,937 --> 00:19:31,238 line:-1
替换进工作记忆


429
00:19:31,905 --> 00:19:34,575 line:-1
这实际上结合了


430
00:19:34,641 --> 00:19:36,243 line:-1
一个撤回和一个确认


431
00:19:36,310 --> 00:19:39,513 line:-1
也就是先从工作记忆中撤回一个事实


432
00:19:39,780 --> 00:19:42,783 line:-1
修改后重新在工作记忆中确认


433
00:19:42,850 --> 00:19:44,818 line:-1
更新后的字段或栏


434
00:19:45,552 --> 00:19:47,421 line:-1
这很重要 因为


435
00:19:47,487 --> 00:19:49,389 line:-1
工作记忆中重新确认内容


436
00:19:49,456 --> 00:19:52,259 line:-1
会再次触发或激活某些规则


437
00:19:52,526 --> 00:19:54,494 line:-1
大部分情况下是好的


438
00:19:54,561 --> 00:19:56,797 line:-1
因为这就是规则系统反应


439
00:19:56,864 --> 00:19:59,666 line:-1
工作记忆事实变化的过程


440
00:20:00,400 --> 00:20:03,237 line:-1
但是在某些情况下会有麻烦


441
00:20:03,303 --> 00:20:05,339 line:-1
我说的是逻辑回路


442
00:20:05,873 --> 00:20:07,608 line:-1
我们可能一不小心


443
00:20:07,674 --> 00:20:09,543 line:-1
在代码中包括了逻辑回路


444
00:20:10,277 --> 00:20:11,812 line:-1
所以这里有个小规则


445
00:20:11,879 --> 00:20:15,449 line:-1
是为了给移动主体计数


446
00:20:15,782 --> 00:20:18,051 line:-1
工作记忆中的移动主体


447
00:20:18,652 --> 00:20:21,889 line:-2
它首先是带计数器的事实
初始值为0


448
00:20:22,489 --> 00:20:25,559 line:-1
每个进入工作记忆的移动主体


449
00:20:25,626 --> 00:20:27,394 line:-1
会触发规则的右边


450
00:20:27,895 --> 00:20:32,666 line:-1
只要修改计数器的数字栏 +1


451
00:20:32,833 --> 00:20:34,234 line:-1
这就很直白了


452
00:20:34,801 --> 00:20:37,471 line:-1
来看看实际执行的样子


453
00:20:38,138 --> 00:20:39,072 line:-1
首先


454
00:20:39,139 --> 00:20:40,674 line:-1
工作记忆中的计数器


455
00:20:40,741 --> 00:20:42,276 line:-1
初始值为0


456
00:20:43,810 --> 00:20:45,646 line:-1
之后的某个时点


457
00:20:45,712 --> 00:20:47,848 line:-1
一个移动主体在工作记忆中确认


458
00:20:47,915 --> 00:20:50,984 line:-1
现在左边足以触发右边


459
00:20:51,818 --> 00:20:54,021 line:-1
调用modify函数


460
00:20:54,087 --> 00:20:57,257 line:-1
它先是撤回这个事实


461
00:20:57,891 --> 00:21:00,627 line:-1
增加计数的值


462
00:21:01,094 --> 00:21:03,397 line:-1
然后回到工作记忆中重新确认


463
00:21:03,697 --> 00:21:04,698 line:-1
这样做时


464
00:21:04,898 --> 00:21:06,967 line:-1
注意它重新触发了同一个规则


465
00:21:07,467 --> 00:21:09,436 line:-1
现在对同一个移动主体实体


466
00:21:09,503 --> 00:21:12,206 line:-1
它会计数2 3 4 5 6 7


467
00:21:12,272 --> 00:21:13,774 line:-1
一直数下去


468
00:21:14,208 --> 00:21:15,676 line:-1
直到追踪停止


469
00:21:15,742 --> 00:21:17,811 line:-1
工具会警告有严重错误


470
00:21:18,178 --> 00:21:20,113 line:-1
规则引擎卡住了


471
00:21:20,747 --> 00:21:23,650 line:-1
模块界面的工具查看器中


472
00:21:24,084 --> 00:21:25,552 line:-1
你看到的追踪


473
00:21:25,619 --> 00:21:27,654 line:-1
显示了所有事件和激活


474
00:21:27,721 --> 00:21:29,656 line:-1
在回路中发生的


475
00:21:29,723 --> 00:21:32,793 line:-2
这就给你一个好的开始
让你知道怎么调试和消除


476
00:21:33,594 --> 00:21:35,329 line:-1
在我来看 最简单的方法


477
00:21:35,395 --> 00:21:36,663 line:-1
消除逻辑回路


478
00:21:36,730 --> 00:21:38,398 line:-1
就是目的引导式编程


479
00:21:38,966 --> 00:21:40,901 line:-1
不是直接修改计数器事实


480
00:21:40,968 --> 00:21:45,506 line:-1
而是创建目标事件 帮我们计数


481
00:21:46,240 --> 00:21:48,575 line:-1
现在要侦测移动主体时


482
00:21:48,775 --> 00:21:51,245 line:-1
就要确认目标事实 来对实体计数


483
00:21:51,945 --> 00:21:53,247 line:-1
计数规则中


484
00:21:53,614 --> 00:21:56,350 line:-1
要捕捉计数器和目标


485
00:21:56,783 --> 00:21:59,553 line:-1
然后撤回目标 因为已经满足


486
00:21:59,920 --> 00:22:00,954 line:-1
计数器计数的规则


487
00:22:01,021 --> 00:22:02,990 line:-1
这样规则就会不断回来


488
00:22:03,056 --> 00:22:04,992 line:-1
从而打破逻辑回路


489
00:22:06,660 --> 00:22:09,663 line:-1
现在来看规则的触发顺序


490
00:22:09,730 --> 00:22:12,165 line:-1
及其对模块结果的影响


491
00:22:13,367 --> 00:22:15,068 line:-2
现在回到
executeStop函数


492
00:22:15,135 --> 00:22:17,371 line:-1
它先被调用 然后移动主体才会


493
00:22:17,437 --> 00:22:18,906 line:-1
进入执行阶段


494
00:22:19,740 --> 00:22:21,909 line:-2
现在你看到
OS Signpost中


495
00:22:21,975 --> 00:22:24,444 line:-1
第一版代码的第一个实参


496
00:22:24,611 --> 00:22:27,281 line:-1
实际上是主体的类型字符串


497
00:22:27,781 --> 00:22:29,183 line:-1
这里就是排序主体


498
00:22:29,249 --> 00:22:32,853 line:-2
或者是记入追踪缓冲的
14个字节的数据


499
00:22:33,187 --> 00:22:34,655 line:-1
我想还可以改善


500
00:22:35,155 --> 00:22:38,659 line:-1
将它从字符串变成类型代码


501
00:22:39,059 --> 00:22:41,228 line:-1
就是一个四字节整数


502
00:22:41,295 --> 00:22:43,463 line:-1
每个事件可节省10个字节


503
00:22:43,764 --> 00:22:46,066 line:-1
如果数据成千上百的进来


504
00:22:46,466 --> 00:22:49,436 line:-1
就可以节省几万字节的追踪缓冲


505
00:22:50,370 --> 00:22:51,238 line:-1
为实现它


506
00:22:51,305 --> 00:22:53,540 line:-1
就要在模块里创建映射


507
00:22:53,707 --> 00:22:55,976 line:-1
将代码转化为字符串


508
00:22:56,043 --> 00:22:57,711 line:-1
通过使用事实


509
00:22:58,512 --> 00:23:01,448 line:-1
在侦测规则中


510
00:23:01,615 --> 00:23:04,284 line:-1
捕捉主体的类型代码


511
00:23:04,918 --> 00:23:06,687 line:-1
在确认移动主体时


512
00:23:06,753 --> 00:23:09,857 line:-1
类型那一栏标记为sentinel


513
00:23:09,923 --> 00:23:11,859 line:-1
表示还没有完整的字符串


514
00:23:12,693 --> 00:23:14,161 line:-1
因为在第二个规则


515
00:23:14,228 --> 00:23:16,430 line:-1
我们要找到所有移动主体


516
00:23:16,597 --> 00:23:17,965 line:-1
类型为sentinel的


517
00:23:18,799 --> 00:23:22,469 line:-1
然后找到对应的类型代码


518
00:23:22,636 --> 00:23:25,405 line:-1
就是上一张图里的类型字符串映射


519
00:23:26,106 --> 00:23:27,674 line:-1
找到它们后


520
00:23:27,741 --> 00:23:29,643 line:-1
修改类型栏


521
00:23:29,877 --> 00:23:32,813 line:-2
从sentinel
改为真实的字符串


522
00:23:33,614 --> 00:23:37,985 line:-1
这一切都基于第二个查找规则


523
00:23:38,051 --> 00:23:40,320 line:-1
在运行确认后立即触发


524
00:23:41,121 --> 00:23:42,823 line:-1
但如果系统中有其他规则


525
00:23:42,890 --> 00:23:44,658 line:-1
比如主体停靠规则


526
00:23:44,725 --> 00:23:46,493 line:-1
也是引用移动主体


527
00:23:47,194 --> 00:23:49,162 line:-1
捕捉和使用类型栏的


528
00:23:49,229 --> 00:23:52,900 line:-2
如果它出现在确认
和查找规则之间会怎样


529
00:23:52,966 --> 00:23:54,401 line:-1
这会有一个sentinel


530
00:23:54,835 --> 00:23:56,703 line:-1
鉴于这是对规则系统的修改


531
00:23:56,770 --> 00:23:57,704 line:-1
你要准备好


532
00:23:57,771 --> 00:23:59,072 line:-1
面对很多新的缺陷


533
00:23:59,673 --> 00:24:01,008 line:-1
为了解决问题


534
00:24:01,074 --> 00:24:05,045 line:-1
要添加规则限制 就是


535
00:24:05,412 --> 00:24:07,614 line:-1
只要类型不是sentinel


536
00:24:07,681 --> 00:24:09,550 line:-1
这有效的延迟了规则触发


537
00:24:09,616 --> 00:24:13,453 line:-1
直到查找规则实际改变了主体的类型


538
00:24:14,121 --> 00:24:15,822 line:-1
从sentinel变为实际内容


539
00:24:16,557 --> 00:24:17,558 line:-1
这完全可行


540
00:24:17,624 --> 00:24:19,226 line:-1
但要用于所有规则


541
00:24:19,293 --> 00:24:20,961 line:-1
否则就会有维护问题


542
00:24:21,028 --> 00:24:25,532 line:-2
特别是当现有的规则集
设为永不为sentinel时


543
00:24:26,466 --> 00:24:28,802 line:-1
再来看另一种方法


544
00:24:29,036 --> 00:24:31,471 line:-1
我们实际是让查找规则


545
00:24:31,538 --> 00:24:33,807 line:-1
在确认后立即触发


546
00:24:34,007 --> 00:24:35,375 line:-1
其中一种方法是


547
00:24:35,976 --> 00:24:39,980 line:-1
告诉CLIPS那个规则更重要


548
00:24:40,047 --> 00:24:43,817 line:-1
或比默认的0突出值更突出


549
00:24:44,518 --> 00:24:48,488 line:-1
只要这个规则是系统中最突出的


550
00:24:48,789 --> 00:24:50,691 line:-1
那么第一个规则结束时


551
00:24:50,757 --> 00:24:52,459 line:-1
第二个就会被触发


552
00:24:52,793 --> 00:24:54,461 line:-1
如果在其他位置使用突出性


553
00:24:54,528 --> 00:24:56,230 line:-1
就要过一遍代码 确保


554
00:24:56,630 --> 00:24:58,966 line:-1
100仍是最高突出值


555
00:24:59,032 --> 00:25:00,634 line:-1
但这是后话了


556
00:25:01,034 --> 00:25:03,537 line:-1
这里还有一个更直接的方法


557
00:25:03,604 --> 00:25:05,806 line:-1
控制规则的排序和触发


558
00:25:06,206 --> 00:25:09,476 line:-1
这就要了解激活


559
00:25:10,444 --> 00:25:12,846 line:-1
提示一下 激活实际上是


560
00:25:12,913 --> 00:25:14,948 line:-1
工作记忆中的事实集合


561
00:25:15,015 --> 00:25:16,917 line:-1
满足规则的左边


562
00:25:17,217 --> 00:25:19,486 line:-1
每次激活都会触发规则的右边


563
00:25:20,354 --> 00:25:23,257 line:-1
现在不要直接触发规则的左边


564
00:25:23,557 --> 00:25:24,691 line:-1
而是要将


565
00:25:24,892 --> 00:25:27,628 line:-1
激活记入数据结构


566
00:25:27,995 --> 00:25:30,497 line:-1
叫做agenda


567
00:25:32,032 --> 00:25:35,602 line:-1
agenda实际是激活列表


568
00:25:35,669 --> 00:25:37,471 line:-1
是工作记忆更新的结果


569
00:25:37,638 --> 00:25:39,006 line:-1
因此所有规则引擎都要


570
00:25:39,072 --> 00:25:41,008 line:-1
从上而下过一遍这个列表


571
00:25:41,074 --> 00:25:43,343 line:-1
以特定的模式触发规则


572
00:25:44,244 --> 00:25:46,813 line:-2
这里先触发第一个规则
然后是第二个


573
00:25:47,047 --> 00:25:48,515 line:-1
这个数据结构是动态的


574
00:25:48,582 --> 00:25:51,718 line:-1
如果规则99是要撤回事实17


575
00:25:52,419 --> 00:25:55,822 line:-1
而事实17由其他两个激活引用


576
00:25:55,889 --> 00:26:00,127 line:-2
CLIPS会先撤回激活
然后往下走


577
00:26:00,194 --> 00:26:02,729 line:-1
此时agenda会是这样


578
00:26:02,796 --> 00:26:04,498 line:-1
在执行继续时


579
00:26:05,966 --> 00:26:09,837 line:-2
agenda根据突出性排序
那么salience就很重要


580
00:26:09,903 --> 00:26:11,738 line:-2
突出值越高 agenda上的
位置就越高


581
00:26:12,472 --> 00:26:13,941 line:-1
但更重要的是


582
00:26:14,007 --> 00:26:17,010 line:-1
模块中没有单独的agenda


583
00:26:17,077 --> 00:26:19,379 line:-1
定义中一个模块只有一个


584
00:26:19,713 --> 00:26:21,648 line:-1
在分析内核中可以用它


585
00:26:21,715 --> 00:26:24,017 line:-1
定义部分标准模块


586
00:26:24,651 --> 00:26:26,553 line:-1
第一个是建模模块


587
00:26:26,620 --> 00:26:29,790 line:-1
这里要放入纯推理逻辑


588
00:26:29,857 --> 00:26:32,125 line:-1
和推理规则


589
00:26:32,192 --> 00:26:34,928 line:-1
将规则名设为modeler::


590
00:26:35,896 --> 00:26:39,433 line:-1
第二个模块是recorder


591
00:26:39,499 --> 00:26:41,502 line:-1
放入的是输出规则


592
00:26:41,568 --> 00:26:43,704 line:-1
前缀为recorder::


593
00:26:44,304 --> 00:26:45,506 line:-1
这么做的原因是


594
00:26:46,006 --> 00:26:48,275 line:-1
在执行这些规则时


595
00:26:48,642 --> 00:26:51,879 line:-2
首先执行所有模块
agenda上的内容


596
00:26:52,212 --> 00:26:53,380 line:-1
直到清空


597
00:26:53,447 --> 00:26:55,582 line:-1
然后再到recorder模块


598
00:26:56,016 --> 00:26:58,418 line:-1
它会让你拥有自信


599
00:26:58,719 --> 00:27:00,354 line:-1
在写输出规则时


600
00:27:00,521 --> 00:27:02,122 line:-1
不用查看工作记忆中


601
00:27:02,189 --> 00:27:04,825 line:-1
modeler模块推出的过程


602
00:27:05,759 --> 00:27:07,127 line:-1
现在你可以利用这个


603
00:27:07,194 --> 00:27:09,763 line:-1
自定义CLIPS模块


604
00:27:09,830 --> 00:27:11,698 line:-1
现在看看如何实现


605
00:27:11,965 --> 00:27:16,103 line:-1
更好的调整查找规则的执行


606
00:27:16,904 --> 00:27:20,207 line:-2
首先是定义查找规则模块
lookup


607
00:27:21,008 --> 00:27:23,210 line:-1
将查找规则放到


608
00:27:23,277 --> 00:27:26,079 line:-1
模块里 命名为lookup::


609
00:27:27,247 --> 00:27:30,284 line:-1
确认移动主体事实后


610
00:27:30,684 --> 00:27:35,155 line:-2
要立刻告诉CLIPS
关注查找agenda


611
00:27:35,355 --> 00:27:38,058 line:-2
就是运行查找agenda里的
所有激活进程


612
00:27:38,525 --> 00:27:41,395 line:-2
然后返回
modeler agenda


613
00:27:41,628 --> 00:27:43,397 line:-1
执行下一套建模规则


614
00:27:43,463 --> 00:27:45,232 line:-1
这是防止规则插入


615
00:27:45,299 --> 00:27:48,202 line:-1
执行顺序的好方法


616
00:27:49,069 --> 00:27:50,771 line:-1
以上内容已经很充足


617
00:27:51,071 --> 00:27:55,075 line:-1
现在可以看看调试和剖析了


618
00:27:55,142 --> 00:27:58,045 line:-2
现在有请Alejandro
回到舞台


619
00:27:58,345 --> 00:27:59,246 line:-1
讲解这一部分


620
00:28:05,085 --> 00:28:06,053 line:-1
谢谢Chad


621
00:28:06,653 --> 00:28:09,556 line:-1
我要讲的是调试和剖析基元


622
00:28:09,623 --> 00:28:11,792 line:-1
用于搭建这些模块


623
00:28:12,492 --> 00:28:13,727 line:-1
首先是日志


624
00:28:14,294 --> 00:28:16,730 line:-1
我们可用的日志基元


625
00:28:16,897 --> 00:28:20,100 line:-2
很像printf
用来定义格式化字符串


626
00:28:20,400 --> 00:28:24,671 line:-1
格式化标记和代表这些类别的变量


627
00:28:25,506 --> 00:28:28,175 line:-2
与printf或其常用方法
不同的是


628
00:28:28,642 --> 00:28:29,776 line:-1
在工具查看器


629
00:28:29,843 --> 00:28:31,578 line:-1
实际上可以动态的


630
00:28:31,645 --> 00:28:33,180 line:-1
开关日志声明


631
00:28:33,247 --> 00:28:34,715 line:-1
之后会举例说明


632
00:28:35,716 --> 00:28:38,418 line:-1
怎么把这些日志声明放入规则？


633
00:28:39,319 --> 00:28:41,522 line:-2
CLIPS里有个函数
log-narrative


634
00:28:41,922 --> 00:28:43,657 line:-1
它的运行 如我之前所讲


635
00:28:43,724 --> 00:28:46,226 line:-1
很像printf 定义字符串


636
00:28:46,293 --> 00:28:48,028 line:-1
比如Resolved Agent Kind Code


637
00:28:48,462 --> 00:28:50,864 line:-1
然后用%定义格式类别


638
00:28:51,164 --> 00:28:52,366 line:-1
实际的工程类别


639
00:28:52,533 --> 00:28:56,403 line:-2
这里是UN 64
后跟% to string


640
00:28:56,770 --> 00:28:59,206 line:-1
然后是表示数据类别的变量


641
00:29:01,909 --> 00:29:04,878 line:-1
同样也可以使用不同的基元类别


642
00:29:04,945 --> 00:29:06,914 line:-1
就是剖析 通过工具查看器


643
00:29:07,514 --> 00:29:10,551 line:-1
剖析基元提供的是规则激活计数


644
00:29:10,617 --> 00:29:12,853 line:-1
让我们知道规则触发的次数


645
00:29:13,420 --> 00:29:14,988 line:-1
以及时间分布


646
00:29:15,055 --> 00:29:17,357 line:-1
我们能知道用了多少秒


647
00:29:17,424 --> 00:29:20,127 line:-1
去激活规则 按百分比计算


648
00:29:20,794 --> 00:29:22,196 line:-1
为了整体理解


649
00:29:22,462 --> 00:29:23,730 line:-1
我要做一个演示


650
00:29:23,797 --> 00:29:25,532 line:-1
看看它们怎样放到一起


651
00:29:29,636 --> 00:29:32,472 line:-1
这里是样本代码 也是可以下载的


652
00:29:32,739 --> 00:29:33,674 line:-1
样本代码中


653
00:29:33,740 --> 00:29:35,409 line:-1
有很多可用的不同目标


654
00:29:35,909 --> 00:29:37,377 line:-1
我首先要讲的


655
00:29:37,444 --> 00:29:40,347 line:-1
是这里的绘制模板建模对象


656
00:29:41,381 --> 00:29:44,451 line:-1
它会在创建和运行工具的时候打开


657
00:29:47,020 --> 00:29:48,188 line:-1
好像已经搭建成功了


658
00:29:50,891 --> 00:29:52,693 line:-1
然后打开工具


659
00:29:54,027 --> 00:29:58,031 line:-1
这里那个羊的app已经打开


660
00:29:58,365 --> 00:29:59,499 line:-1
我不会最大化窗口


661
00:29:59,566 --> 00:30:02,102 line:-1
因为我们要记在脑子里


662
00:30:02,836 --> 00:30:04,838 line:-1
我要做的是回到空白模板


663
00:30:05,639 --> 00:30:06,974 line:-1
在右上角


664
00:30:07,040 --> 00:30:08,742 line:-1
选择要添加的工具


665
00:30:08,809 --> 00:30:11,245 line:-1
为此 打开这里


666
00:30:11,778 --> 00:30:15,582 line:-1
查找移动主体 就是刚建的目标


667
00:30:17,184 --> 00:30:18,685 line:-1
这里 如我所说


668
00:30:18,752 --> 00:30:21,255 line:-1
日志叙述可动态开关


669
00:30:21,321 --> 00:30:22,589 line:-1
通过工具查看器


670
00:30:22,656 --> 00:30:23,857 line:-1
按下command I


671
00:30:24,191 --> 00:30:25,792 line:-1
打开工具查看器


672
00:30:26,059 --> 00:30:28,629 line:-1
这有个日志标签 默认为无


673
00:30:28,829 --> 00:30:30,397 line:-1
但可以改成narrative


674
00:30:30,464 --> 00:30:32,266 line:-1
这样就开启了日志叙述声明


675
00:30:33,133 --> 00:30:34,268 line:-1
关闭它 继续


676
00:30:34,434 --> 00:30:36,036 line:-1
代替所有进程


677
00:30:36,103 --> 00:30:37,804 line:-1
现在切换到山羊的列表app


678
00:30:39,606 --> 00:30:40,641 line:-1
现在开始记录


679
00:30:40,974 --> 00:30:42,809 line:-1
在这个列表里可以进行一些操作


680
00:30:42,876 --> 00:30:44,811 line:-1
比如给不同的列表排序


681
00:30:45,312 --> 00:30:47,414 line:-1
你看到查看器里弹出一些活动


682
00:30:48,515 --> 00:30:50,884 line:-1
再点一次 会有更多活动弹出


683
00:30:51,385 --> 00:30:53,220 line:-1
我想这个点已经足够清楚了


684
00:30:54,655 --> 00:30:56,023 line:-1
首先我们看这里


685
00:30:56,790 --> 00:30:59,293 line:-1
显示不同的区间 我们之前讲过


686
00:30:59,359 --> 00:31:02,329 line:-1
比如激活和移动等等


687
00:31:03,063 --> 00:31:04,698 line:-1
但在实际的叙述声明


688
00:31:04,765 --> 00:31:07,167 line:-1
还是command I打开查看器


689
00:31:08,001 --> 00:31:10,737 line:-1
有新的东西 这个模块日志表


690
00:31:11,004 --> 00:31:12,406 line:-1
在这个表里


691
00:31:12,472 --> 00:31:14,308 line:-1
存着所有日志叙述声明


692
00:31:14,675 --> 00:31:16,977 line:-1
比如这个解析代理类型代码


693
00:31:17,044 --> 00:31:19,179 line:-1
使用日志叙述的例子里看到过


694
00:31:19,646 --> 00:31:21,682 line:-1
还有规则里的许多其他声明


695
00:31:23,550 --> 00:31:26,320 line:-1
那如何从日志叙述切换到剖析呢


696
00:31:26,653 --> 00:31:28,956 line:-1
还是在这个日志标签


697
00:31:29,022 --> 00:31:30,858 line:-1
切换到profile 1


698
00:31:31,725 --> 00:31:33,260 line:-1
关闭查看器


699
00:31:33,694 --> 00:31:35,128 line:-1
再次运行工具


700
00:31:35,295 --> 00:31:36,363 line:-1
再次记录轨迹


701
00:31:37,030 --> 00:31:39,233 line:-1
这时看到列表已经排序过了


702
00:31:39,299 --> 00:31:41,969 line:-1
但移动主体还是发生了一些活动


703
00:31:42,903 --> 00:31:44,905 line:-1
这也足够说明问题了


704
00:31:45,873 --> 00:31:49,009 line:-1
所以停止 再次打开查看器


705
00:31:49,943 --> 00:31:53,380 line:-2
这里就不再有模块日志表
因为没有可显示的日志叙述了


706
00:31:54,014 --> 00:31:56,450 line:-1
但是如果打开这里的模块标签


707
00:31:57,017 --> 00:31:59,353 line:-1
会看到整洁的描述性界面


708
00:31:59,419 --> 00:32:01,255 line:-1
列出不同的剖析值


709
00:32:01,555 --> 00:32:04,758 line:-1
比如这个“查看未知执行站点”规则


710
00:32:05,092 --> 00:32:09,029 line:-2
有7条记录
还显示了用时和时间占比


711
00:32:09,596 --> 00:32:12,232 line:-1
还有其他建模过程中定义的规则


712
00:32:13,867 --> 00:32:15,035 line:-1
在关闭这个界面之前


713
00:32:15,302 --> 00:32:17,404 line:-1
我发现一些有趣的点


714
00:32:17,471 --> 00:32:18,705 line:-1
我要再运行一次追踪


715
00:32:18,772 --> 00:32:21,108 line:-1
因为我想再捕捉一次


716
00:32:22,109 --> 00:32:24,611 line:-1
开启排序后 我看到不同的活动出现


717
00:32:25,245 --> 00:32:26,580 line:-1
但如果我再次排序


718
00:32:26,647 --> 00:32:28,582 line:-1
我注意到这些黄色的长区间


719
00:32:28,649 --> 00:32:29,716 line:-1
出现在事实后面


720
00:32:29,783 --> 00:32:34,721 line:-2
它们对实时描述或实时解读的跟踪
不同于


721
00:32:34,788 --> 00:32:36,023 line:-1
我的预判


722
00:32:36,823 --> 00:32:38,525 line:-1
为了找到原因


723
00:32:38,592 --> 00:32:41,562 line:-1
搞清楚状况 并找到解决办法


724
00:32:41,828 --> 00:32:43,964 line:-1
我要请回Chad 讲解推断


725
00:32:51,772 --> 00:32:53,106 line:-1
谢谢Alejandro


726
00:32:54,208 --> 00:32:57,611 line:-2
为了描述Alejandro
刚才看到的现象


727
00:32:57,678 --> 00:32:58,579 line:-1
并解决它


728
00:32:58,645 --> 00:33:00,814 line:-1
就要引入一个概念 叫做推断


729
00:33:01,849 --> 00:33:03,383 line:-1
这些区间怎么了？


730
00:33:03,650 --> 00:33:05,953 line:-1
它们的特点 第一是长区间


731
00:33:06,019 --> 00:33:09,056 line:-2
它们出现的时间
或持续的时间有好几秒


732
00:33:09,122 --> 00:33:10,524 line:-1
这显而易见


733
00:33:11,124 --> 00:33:13,794 line:-1
第二 真正的问题是


734
00:33:13,861 --> 00:33:15,796 line:-1
对这些区间的记录


735
00:33:15,863 --> 00:33:17,764 line:-1
只在模块的工作记忆中


736
00:33:17,998 --> 00:33:21,001 line:-1
UI只看模块的输出表


737
00:33:21,068 --> 00:33:22,436 line:-1
不会看这些


738
00:33:22,936 --> 00:33:26,807 line:-2
所以不能把这些区间写入输出表
直到明确了


739
00:33:26,874 --> 00:33:28,108 line:-1
它们关闭的时间


740
00:33:28,175 --> 00:33:30,878 line:-1
这个例子就是这样


741
00:33:31,578 --> 00:33:33,113 line:-1
现在要做的是


742
00:33:33,180 --> 00:33:35,782 line:-1
写入临时或占位符行


743
00:33:35,849 --> 00:33:37,784 line:-1
给模块的输出表


744
00:33:37,985 --> 00:33:40,721 line:-1
为此就要介绍推断模式


745
00:33:41,922 --> 00:33:44,391 line:-1
模块中的推断模式表示


746
00:33:44,458 --> 00:33:47,661 line:-1
如果这是最后写入输入表的机会


747
00:33:48,028 --> 00:33:49,463 line:-1
你要写什么？


748
00:33:49,897 --> 00:33:51,164 line:-1
来看个例子


749
00:33:51,732 --> 00:33:55,102 line:-2
假设模块处理了
这条白线之前的所有数据


750
00:33:55,169 --> 00:33:57,137 line:-1
我们叫做视界


751
00:33:57,638 --> 00:34:01,308 line:-2
视界是一个时间点
此后模块看不到任何东西


752
00:34:01,475 --> 00:34:04,144 line:-1
原因可能是追踪停止了


753
00:34:04,478 --> 00:34:06,113 line:-1
或者分析内核


754
00:34:06,180 --> 00:34:08,882 line:-1
还没填入追踪部分


755
00:34:09,349 --> 00:34:11,552 line:-1
没人知道线的另一边有什么


756
00:34:11,985 --> 00:34:14,288 line:-1
如你所见 我们创建的区间写着


757
00:34:14,353 --> 00:34:15,489 line:-1
移动到后台


758
00:34:15,688 --> 00:34:17,123 line:-1
这样做是因为它夹在


759
00:34:17,190 --> 00:34:19,760 line:-2
一对移动和执行
Signpost之间


760
00:34:20,260 --> 00:34:23,797 line:-2
但我们不知道
这个追踪执行区间什么时候结束


761
00:34:23,864 --> 00:34:26,132 line:-1
因为它的结束事件在视界的另一边


762
00:34:26,699 --> 00:34:29,503 line:-1
因此我们要进入推断模式


763
00:34:29,670 --> 00:34:32,706 line:-1
只要在表中写入临时占位符事件


764
00:34:33,005 --> 00:34:34,842 line:-1
UI就能看到些什么


765
00:34:35,475 --> 00:34:39,545 line:-1
然运行区间从执行Signpost


766
00:34:39,780 --> 00:34:42,081 line:-1
直到视界的当前值


767
00:34:43,283 --> 00:34:45,518 line:-1
推断模式里的模块


768
00:34:45,585 --> 00:34:47,154 line:-1
因为推断事实


769
00:34:47,221 --> 00:34:50,389 line:-1
会被注入到工作记忆


770
00:34:51,123 --> 00:34:52,559 line:-1
在记录规则中


771
00:34:52,626 --> 00:34:55,728 line:-2
可以将推断事实
与任何开区间事实结合


772
00:34:55,795 --> 00:34:59,466 line:-1
把这些开区间写入表


773
00:34:59,533 --> 00:35:01,401 line:-1
用捕捉到的视界时间戳


774
00:35:02,503 --> 00:35:04,905 line:-1
这里就是写入开区间的机会


775
00:35:05,873 --> 00:35:08,442 line:-1
下面来看一个示例规则


776
00:35:08,976 --> 00:35:11,144 line:-1
首先 将推断式的


777
00:35:11,512 --> 00:35:13,480 line:-1
输出编写规则放入记录模块


778
00:35:13,547 --> 00:35:15,516 line:-1
前缀为RECORDER::


779
00:35:16,750 --> 00:35:19,052 line:-1
然后匹配推断事件


780
00:35:19,119 --> 00:35:21,121 line:-1
捕捉视界的值


781
00:35:21,188 --> 00:35:24,625 line:-1
这就有了区间的结束时间 理论上


782
00:35:25,459 --> 00:35:28,762 line:-1
对工作记忆中的每个区间事实


783
00:35:28,829 --> 00:35:30,898 line:-1
触发规则的右边


784
00:35:31,398 --> 00:35:32,633 line:-1
我们这里要做的


785
00:35:32,699 --> 00:35:36,203 line:-2
是基于结束时间
也就是视界值计算时长


786
00:35:36,270 --> 00:35:38,605 line:-1
和区间开始的时间


787
00:35:39,273 --> 00:35:42,376 line:-1
然后写新的行 填写栏内容


788
00:35:42,442 --> 00:35:44,244 line:-1
和正常的输出编写规则一样


789
00:35:44,311 --> 00:35:45,379 line:-1
唯一区分


790
00:35:45,445 --> 00:35:48,415 line:-1
正常的和推断式的输出编写规则


791
00:35:48,916 --> 00:35:53,020 line:-1
在于当你测试或预测推断事实的规则


792
00:35:53,453 --> 00:35:56,657 line:-1
你要查看开区间 而不是闭区间


793
00:35:56,723 --> 00:35:59,359 line:-1
像往常编写输出表那样


794
00:36:00,661 --> 00:36:03,030 line:-1
如果是即时模式


795
00:36:03,263 --> 00:36:06,300 line:-1
在记录前进的过程中


796
00:36:06,867 --> 00:36:09,670 line:-1
旧的推断性数据会被清洗


797
00:36:09,736 --> 00:36:11,872 line:-1
模块会再次进入推断模式


798
00:36:11,939 --> 00:36:13,874 line:-1
以新的视界值


799
00:36:14,174 --> 00:36:16,376 line:-1
放回推断事件


800
00:36:16,643 --> 00:36:19,346 line:-1
UI会跟往常一样更新


801
00:36:19,980 --> 00:36:24,751 line:-2
追踪停止时
模块会再次进入推断模式


802
00:36:25,085 --> 00:36:26,386 line:-1
但无论你写什么


803
00:36:26,453 --> 00:36:29,690 line:-1
实际都记录在追踪数据中


804
00:36:29,857 --> 00:36:32,860 line:-1
对下行模块可用 不仅是UI


805
00:36:33,827 --> 00:36:37,297 line:-1
如果修改现有的工具


806
00:36:37,898 --> 00:36:39,433 line:-1
它就会变成这样


807
00:36:39,766 --> 00:36:42,202 line:-1
这是移动主体轨迹 你看到


808
00:36:42,269 --> 00:36:45,873 line:-1
这个parking区间持续延长


809
00:36:46,440 --> 00:36:47,474 line:-1
它会实时更新


810
00:36:47,541 --> 00:36:49,076 line:-1
如果查看底部的细节表


811
00:36:49,142 --> 00:36:51,578 line:-1
你会看到 时长也在增加


812
00:36:52,279 --> 00:36:55,115 line:-1
现在如果按下停止键 终止记录


813
00:36:55,182 --> 00:36:56,950 line:-1
你会看到区间停住了


814
00:36:57,017 --> 00:36:59,853 line:-1
它实际上被记录为轨迹的一部分


815
00:37:01,321 --> 00:37:03,490 line:-1
总结来说 编写自定义模块


816
00:37:03,557 --> 00:37:05,392 line:-1
代表巨大的投入


817
00:37:05,459 --> 00:37:07,394 line:-1
要投入时间学习新的技术


818
00:37:07,761 --> 00:37:10,831 line:-1
但这是使用自定义工具的最好方式


819
00:37:10,898 --> 00:37:13,433 line:-1
并智能化自定义工具


820
00:37:13,800 --> 00:37:15,969 line:-1
我们看到 智能化工具


821
00:37:16,036 --> 00:37:18,572 line:-1
意味着更高效的记录机制


822
00:37:18,639 --> 00:37:20,274 line:-1
和更好的用户体验


823
00:37:21,975 --> 00:37:24,211 line:-1
更多信息 请参见随附的样本代码


824
00:37:24,278 --> 00:37:27,981 line:-1
以及本场演讲网站中的相关演讲


825
00:37:28,982 --> 00:37:30,884 line:-1
以上就是今天的内容 谢谢大家


826
00:37:30,951 --> 00:37:31,852 line:-1
请享受其余的讲演

