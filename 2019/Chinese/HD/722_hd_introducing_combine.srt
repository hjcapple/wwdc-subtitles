1
00:00:06,939 --> 00:00:11,178 line:0
（Combine介绍）


2
00:00:15,148 --> 00:00:15,983 line:-1
大家好


3
00:00:16,583 --> 00:00:17,451 line:-1
谢谢


4
00:00:17,518 --> 00:00:18,552 line:-1
我是Tony Parker


5
00:00:18,619 --> 00:00:20,787 line:-2
是Apple的
Foundation团队的经理


6
00:00:20,854 --> 00:00:22,656 line:-1
今天很开心


7
00:00:22,723 --> 00:00:24,591 line:-1
向大家介绍最新的框架


8
00:00:24,658 --> 00:00:25,926 line:-1
叫做Combine


9
00:00:26,527 --> 00:00:28,495 line:-1
我们先来谈谈异步编程


10
00:00:29,796 --> 00:00:31,298 line:-1
这里正在运行一款app


11
00:00:31,365 --> 00:00:35,235 line:-2
可以让学生注册成为我的
最新巫师学校的学生


12
00:00:35,302 --> 00:00:37,604 line:-2
你可以看到
它有几项非常简单的要求


13
00:00:38,272 --> 00:00:40,107 line:-1
首先要一个有效用户名


14
00:00:40,174 --> 00:00:43,243 line:-2
我们将通过向服务器
发出网络请求来检查是否有效


15
00:00:43,510 --> 00:00:45,445 line:-1
当然还要密码


16
00:00:45,512 --> 00:00:47,781 line:-1
这我们在app本地就可以检查


17
00:00:48,448 --> 00:00:49,650 line:-1
在我们做这些事的同时


18
00:00:49,716 --> 00:00:52,519 line:-1
我们还要维护响应式用户界面


19
00:00:52,586 --> 00:00:53,987 line:-1
不会阻塞主线程


20
00:00:54,054 --> 00:00:55,289 line:-1
（app的要求）


21
00:00:55,355 --> 00:00:57,191 line:-1
我们来试试这是怎么运行的


22
00:00:57,758 --> 00:01:01,461 line:-1
首先我们输入用户名


23
00:01:01,528 --> 00:01:02,663 line:-1
就Merlin吧


24
00:01:03,397 --> 00:01:04,798 line:-1
听起来是个不错的巫师名字


25
00:01:04,864 --> 00:01:08,235 line:-1
其实这已经有许多异步行为了


26
00:01:08,302 --> 00:01:12,239 line:-2
我使用Target/Action
来获取有关用户输入的通知


27
00:01:12,706 --> 00:01:16,577 line:-1
我运用计时器来等待用户暂定输入


28
00:01:16,643 --> 00:01:20,447 line:-2
这样网络请求就不会
使我的服务器过载


29
00:01:20,814 --> 00:01:23,951 line:-1
最后我使用诸如KVO之类的东西来


30
00:01:24,017 --> 00:01:25,786 line:-1
接收有关异步操作的进度更新


31
00:01:26,620 --> 00:01:27,754 line:-1
如果我继续下去的话


32
00:01:28,155 --> 00:01:30,424 line:-1
我就会收到关于该请求的响应


33
00:01:30,490 --> 00:01:31,925 line:-1
我们就要更新UI了


34
00:01:31,992 --> 00:01:33,193 line:-1
所以 我选择一个新的用户名


35
00:01:33,493 --> 00:01:37,297 line:-1
再填入我超级安全的密码12345


36
00:01:37,631 --> 00:01:39,733 line:-2
请不要真的用这种密码
这只是例子


37
00:01:41,001 --> 00:01:43,804 line:-1
到这里 我们又完成了许多异步工作


38
00:01:43,871 --> 00:01:47,140 line:-1
我们等待了URL会话请求的响应


39
00:01:47,207 --> 00:01:49,042 line:-1
我们将该结果与


40
00:01:49,109 --> 00:01:51,278 line:-1
同步检查结果合并


41
00:01:51,345 --> 00:01:53,146 line:-1
最后做完这些事情


42
00:01:53,480 --> 00:01:56,350 line:-2
做完这些事情之后
我要再次更新UI


43
00:01:56,416 --> 00:01:57,985 line:-1
使用KVC之类的东西


44
00:01:59,486 --> 00:02:00,387 line:-1
（异步界面）


45
00:02:00,454 --> 00:02:01,889 line:-1
在Cocoa SDK里


46
00:02:01,955 --> 00:02:05,125 line:-1
你可以看到很多异步界面


47
00:02:05,192 --> 00:02:07,995 line:-2
如这里Target/Action
但其实还有更多


48
00:02:08,061 --> 00:02:11,064 line:-2
包括Notification Center
还有许多临时回调


49
00:02:11,131 --> 00:02:14,201 line:-1
这些都是采用闭合或完成块的API


50
00:02:14,268 --> 00:02:17,204 line:-1
这些都有重要和不同的用途


51
00:02:17,504 --> 00:02:19,640 line:-1
但如果你要将它们结合起来的话


52
00:02:19,706 --> 00:02:21,175 line:-1
就有点挑战了


53
00:02:21,808 --> 00:02:25,179 line:-2
对于Combine
我们不是要替换它们


54
00:02:25,245 --> 00:02:27,781 line:-1
而是找到它们的共同点


55
00:02:28,315 --> 00:02:29,650 line:-1
这就是Combine


56
00:02:29,950 --> 00:02:34,087 line:-2
会根据时间处理这些值的
统一声明式API


57
00:02:35,389 --> 00:02:38,192 line:-2
Combine是Swift中写的
也是为了Swift而写


58
00:02:38,258 --> 00:02:41,595 line:-2
也就意味着我们可以利用
像泛型这样的Swift功能


59
00:02:41,962 --> 00:02:44,431 line:-2
泛型可以减少
我们需要写的


60
00:02:44,498 --> 00:02:45,599 line:-1
样板代码的数量


61
00:02:45,899 --> 00:02:48,302 line:-2
也就是说我们只需
写一次关于异步行为的


62
00:02:48,368 --> 00:02:51,171 line:-2
泛型算法
就可以将它应用于


63
00:02:51,238 --> 00:02:53,740 line:-1
所有类型的异步界面


64
00:02:54,908 --> 00:02:56,543 line:-1
Combine也是类型安全的


65
00:02:56,610 --> 00:03:00,247 line:-2
它让我们在编译时就能捕获错误
而不是运行时


66
00:03:00,314 --> 00:03:01,281 line:-1
（Combine功能）


67
00:03:01,348 --> 00:03:04,785 line:-2
Combine的主要设计点是
组成优先


68
00:03:05,118 --> 00:03:09,389 line:-1
这意味着核心概念是简单易懂的


69
00:03:09,456 --> 00:03:10,657 line:-1
但是一旦你将它们组合起来


70
00:03:10,724 --> 00:03:13,393 line:-2
创造出的总价值
可以超过各自的简单叠加


71
00:03:14,261 --> 00:03:16,496 line:-1
最后Combine是请求驱动的


72
00:03:16,763 --> 00:03:20,200 line:-2
它让你能够更加仔细地管理
app的内存使用情况


73
00:03:20,267 --> 00:03:21,935 line:-1
以及app的性能


74
00:03:22,736 --> 00:03:24,905 line:-2
所以 现在我们就来谈谈
这些核心概念


75
00:03:24,972 --> 00:03:28,375 line:-2
核心概念只有三个
发布程序 订阅程序和操作程序


76
00:03:28,442 --> 00:03:30,143 line:-1
我们每一个都会详细讲到


77
00:03:30,210 --> 00:03:31,845 line:-1
首先是发布程序


78
00:03:33,280 --> 00:03:36,016 line:-2
发布程序是
Combine API的声明部分


79
00:03:36,450 --> 00:03:39,553 line:-1
它描述了值和错误是如何产生的


80
00:03:39,620 --> 00:03:42,422 line:-1
但不一定是产生这些东西的源头


81
00:03:42,990 --> 00:03:45,659 line:-2
这意味着作为描述
发布程序是值类型


82
00:03:45,926 --> 00:03:48,295 line:-2
在Swift里的意思就是
我们使用的是结构


83
00:03:49,329 --> 00:03:53,667 line:-1
发布程序允许注册订阅程序


84
00:03:53,734 --> 00:03:56,170 line:-1
该程序会随着时间来接收这些值


85
00:03:57,337 --> 00:03:58,338 line:-1
这是协议


86
00:03:58,705 --> 00:03:59,873 line:-1
这就是发布程序


87
00:03:59,940 --> 00:04:01,608 line:-1
它有两种相关类型


88
00:04:01,675 --> 00:04:04,444 line:-1
输出 这就是它会生成的值


89
00:04:04,511 --> 00:04:05,546 line:-1
还有故障


90
00:04:05,612 --> 00:04:07,614 line:-1
是它生成的错误


91
00:04:07,881 --> 00:04:10,450 line:-1
如果发布程序不能生成错误


92
00:04:10,517 --> 00:04:13,820 line:-2
你就可以将从不类型
设为相关类型


93
00:04:14,955 --> 00:04:18,325 line:-2
发布程序有一个核心功能
叫订阅程序


94
00:04:18,659 --> 00:04:20,327 line:-1
从这个函数的泛型约束


95
00:04:20,394 --> 00:04:21,595 line:-1
可以看出


96
00:04:21,661 --> 00:04:25,199 line:-2
订阅要求用订阅程序的输入
来匹配发布程序的输出


97
00:04:25,265 --> 00:04:27,801 line:-2
用订阅程序的故障来匹配
发布程序的故障


98
00:04:27,868 --> 00:04:29,603 line:-1
（发布程序）


99
00:04:29,670 --> 00:04:31,271 line:-1
这是一个发布程序的例子


100
00:04:31,338 --> 00:04:33,473 line:-2
这是我们Notification Center
的新发布程序


101
00:04:34,107 --> 00:04:39,513 line:-2
你可以看到 它是一个结构
输出类型是通知


102
00:04:39,813 --> 00:04:41,281 line:-1
故障类型是从不


103
00:04:41,882 --> 00:04:44,484 line:-1
它初始化了三样东西 中心


104
00:04:44,551 --> 00:04:46,286 line:-1
名称 还有对象


105
00:04:46,620 --> 00:04:49,356 line:-2
如果你了解我们现在的
Notification Center API


106
00:04:49,423 --> 00:04:50,724 line:-1
你应该很熟悉这些代码


107
00:04:50,791 --> 00:04:52,893 line:-2
再次强调 我们并没有替换
Notification Center


108
00:04:52,960 --> 00:04:54,061 line:-1
只是做了适当改写


109
00:04:55,329 --> 00:04:56,697 line:-1
接下来说说订阅程序


110
00:04:57,231 --> 00:04:59,700 line:-1
订阅程序与发布程序对应


111
00:05:00,267 --> 00:05:01,435 line:-1
它用于接收值


112
00:05:01,502 --> 00:05:04,271 line:-2
如果发布程序有限的话
它的功能还包括完成


113
00:05:05,038 --> 00:05:09,142 line:-2
因为订阅程序在接收到值后
通常会执行并改变现有状况


114
00:05:09,209 --> 00:05:12,446 line:-2
我们在Swift中用的是引用类型
这也就意味着它们是类


115
00:05:13,247 --> 00:05:14,815 line:-1
这是订阅程序协议


116
00:05:15,115 --> 00:05:17,384 line:-2
你可以看到
它有一样的两种相关类型


117
00:05:17,451 --> 00:05:18,519 line:-1
输入和故障


118
00:05:18,585 --> 00:05:21,522 line:-1
同样 如果订阅程序无法接收故障


119
00:05:21,588 --> 00:05:23,090 line:-1
那么你就可以使用永不类型


120
00:05:23,590 --> 00:05:25,192 line:-1
订阅程序有三种主要功能


121
00:05:25,792 --> 00:05:27,227 line:-1
它会接收订阅


122
00:05:27,628 --> 00:05:30,597 line:-1
订阅是订阅程序控制从发布服务器


123
00:05:30,664 --> 00:05:32,432 line:-1
到订阅服务器的数据流的方法


124
00:05:32,966 --> 00:05:34,735 line:-1
它也可以接收输入


125
00:05:35,002 --> 00:05:37,971 line:-2
最后 如果它所连接的
发布程序是有限的


126
00:05:38,038 --> 00:05:41,875 line:-2
那么它也可以接受
来自完成或故障的完成程序


127
00:05:41,942 --> 00:05:43,577 line:-1
（订阅程序）


128
00:05:43,644 --> 00:05:45,179 line:-1
这是订阅程序的例子


129
00:05:45,812 --> 00:05:47,214 line:-1
叫做分配


130
00:05:47,714 --> 00:05:52,719 line:-1
分配是一个类 它用类的实例


131
00:05:52,786 --> 00:05:56,957 line:-2
对象的实例 以及进入该对象的
安全键路径类型进行初始化


132
00:05:57,457 --> 00:05:59,693 line:-1
当它接受到输入


133
00:05:59,760 --> 00:06:02,229 line:-1
它就会将其写入该对象的属性


134
00:06:02,529 --> 00:06:04,631 line:-2
因为在Swift中
如果你只写入属性值


135
00:06:04,698 --> 00:06:06,333 line:-1
它是没有办法处理错误的


136
00:06:06,600 --> 00:06:09,102 line:-1
我们将分配的故障类型设为永不


137
00:06:10,404 --> 00:06:11,705 line:-2
我们接下来谈谈
怎么将它们结合在一起


138
00:06:11,772 --> 00:06:12,973 line:-1
（模式）


139
00:06:13,040 --> 00:06:14,908 line:-1
你可能会用某些控制器对象


140
00:06:14,975 --> 00:06:18,011 line:-1
或是其他类型来保存你的订阅程序


141
00:06:18,078 --> 00:06:20,781 line:-1
它负责用订阅程序来


142
00:06:20,848 --> 00:06:21,982 line:-1
调用订阅


143
00:06:22,449 --> 00:06:24,751 line:-1
将其作为附加发送给发布程序


144
00:06:25,652 --> 00:06:28,288 line:-1
这时 发布程序就会将订阅


145
00:06:28,655 --> 00:06:29,890 line:-1
发送给订阅程序


146
00:06:29,957 --> 00:06:33,961 line:-2
订阅程序会将其用于
向发布程序发出


147
00:06:34,027 --> 00:06:36,463 line:-1
一定数量或无数值的请求


148
00:06:37,231 --> 00:06:38,799 line:-1
这时 发布程序


149
00:06:38,866 --> 00:06:42,369 line:-2
就可以将该数量或者更少的值
发送给订阅程序


150
00:06:42,436 --> 00:06:44,338 line:-1
再次强调 如果发布程序是有限的


151
00:06:44,404 --> 00:06:47,341 line:-1
那么它只会发送完成或者是错误


152
00:06:48,308 --> 00:06:50,043 line:-1
所以 一个订阅会发送


153
00:06:50,444 --> 00:06:53,480 line:-1
0个或更多的值 或者是一个完成


154
00:06:55,449 --> 00:06:56,984 line:-1
回到我们的例子


155
00:06:57,050 --> 00:07:00,187 line:-1
假设我有一个模型对象叫巫师


156
00:07:00,254 --> 00:07:03,457 line:-1
我现在关注的是巫师的年级


157
00:07:03,790 --> 00:07:06,026 line:-1
我们先从五年级的Merlin开始


158
00:07:07,594 --> 00:07:09,963 line:-1
我想做的是接收关于


159
00:07:10,030 --> 00:07:11,932 line:-1
毕业学生的通知


160
00:07:11,999 --> 00:07:16,103 line:-2
当他们毕业 我就要更新
我的模型对象值


161
00:07:16,470 --> 00:07:18,972 line:-1
所以 我从默认中心


162
00:07:19,439 --> 00:07:20,574 line:-1
Merlin毕业情况的


163
00:07:21,375 --> 00:07:22,943 line:-2
Notification Center
发布程序开始


164
00:07:24,244 --> 00:07:26,713 line:-1
接下来 我要创建分配订阅程序


165
00:07:26,780 --> 00:07:30,817 line:-2
让它将新年级写入
Merlin的年级属性


166
00:07:32,686 --> 00:07:35,222 line:-1
我再用订阅进行附加


167
00:07:35,289 --> 00:07:38,025 line:-1
但是可能如你所料 它没有进行编译


168
00:07:38,392 --> 00:07:40,661 line:-1
原因是类型不匹配


169
00:07:41,395 --> 00:07:43,330 line:-2
Notification Center
会生成通知


170
00:07:43,730 --> 00:07:48,235 line:-2
但是分配被配置需要整数
来写入整数属性


171
00:07:48,902 --> 00:07:51,038 line:-1
所以我们要在通知


172
00:07:51,104 --> 00:07:53,774 line:-1
和整数之间折中


173
00:07:54,241 --> 00:07:55,108 line:-1
那就是


174
00:07:55,876 --> 00:07:56,710 line:-1
操作程序


175
00:07:57,411 --> 00:08:00,314 line:-2
操作程序在采用发布程序协议前
一直是发布程序


176
00:08:00,647 --> 00:08:03,317 line:-1
它也是声明性的 所以它也是值类型


177
00:08:03,717 --> 00:08:07,387 line:-1
它会描述改变值 增加值


178
00:08:07,454 --> 00:08:08,288 line:-1
或删除值的行为


179
00:08:08,355 --> 00:08:11,058 line:-1
或者是其他行为


180
00:08:11,792 --> 00:08:15,229 line:-2
并订阅我们称之为上游的
另一个发布程序


181
00:08:15,963 --> 00:08:18,999 line:-2
并将结果发送至
我们称为下游的订阅程序


182
00:08:19,066 --> 00:08:20,234 line:-1
（操作程序）


183
00:08:20,300 --> 00:08:21,935 line:-1
这是操作程序的例子


184
00:08:22,236 --> 00:08:24,071 line:-1
当你运用Combine的时候


185
00:08:24,137 --> 00:08:25,005 line:-1
你就会了解该例


186
00:08:25,072 --> 00:08:26,240 line:-1
它叫做Map


187
00:08:26,640 --> 00:08:31,378 line:-1
Map是上游连接的初始化结构


188
00:08:31,445 --> 00:08:34,748 line:-1
它会将下游的输出转化为自己的输出


189
00:08:35,482 --> 00:08:37,484 line:-1
因为Map无法自己生成故障


190
00:08:37,551 --> 00:08:39,686 line:-1
它只会反映上游的故障类型


191
00:08:39,753 --> 00:08:41,054 line:-1
并且传递


192
00:08:41,621 --> 00:08:43,390 line:-1
所以有了Map 我们就有了


193
00:08:43,457 --> 00:08:45,826 line:-1
在通知和整数之间转化的工具


194
00:08:46,460 --> 00:08:47,294 line:-1
我们来看


195
00:08:48,128 --> 00:08:50,597 line:-2
我们用的是之前的
发布程序和订阅程序


196
00:08:50,664 --> 00:08:51,899 line:-1
我添加转换器


197
00:08:52,165 --> 00:08:55,802 line:-2
你可以看到它被配置为
连接到毕业发布程序


198
00:08:55,869 --> 00:08:57,004 line:-1
还有一个闭合包


199
00:08:57,070 --> 00:08:59,206 line:-1
该闭合包会接收通知


200
00:08:59,473 --> 00:09:02,109 line:-1
并查找名为新年级的用户信息密钥


201
00:09:02,676 --> 00:09:03,677 line:-1
如果有该密钥


202
00:09:03,744 --> 00:09:06,313 line:-2
且该密钥为整数
那么我们就将其从闭合包中返回


203
00:09:06,780 --> 00:09:09,216 line:-1
如果无密钥或密钥不为整数


204
00:09:09,283 --> 00:09:11,084 line:-1
就将新默认值设为0


205
00:09:11,485 --> 00:09:15,122 line:-2
也就是说不管如何
闭合包的结果都是整数


206
00:09:15,189 --> 00:09:18,792 line:-1
这样我们就可以将其连接至订阅程序


207
00:09:19,159 --> 00:09:22,396 line:-2
这样所有东西就可以连接
编译并工作了


208
00:09:23,297 --> 00:09:26,033 line:-1
现在所有这些构造语法都有点冗长


209
00:09:26,099 --> 00:09:28,435 line:-1
所以我们需要更为流畅的语法


210
00:09:28,702 --> 00:09:29,770 line:-1
让我们来看看


211
00:09:31,405 --> 00:09:35,843 line:-2
作为发布程序协议的扩展
也就是说它对所有发布程序都可用


212
00:09:36,310 --> 00:09:40,080 line:-2
我们添加了一系列
以操作程序命名的函数


213
00:09:40,347 --> 00:09:41,582 line:-1
这是Map的函数


214
00:09:42,015 --> 00:09:42,916 line:-1
如你所见


215
00:09:42,983 --> 00:09:46,420 line:-1
它的参数是初始化Map所需的一切


216
00:09:46,486 --> 00:09:47,988 line:-1
除了上游


217
00:09:48,055 --> 00:09:50,824 line:-1
原因是作为发布程序的扩展


218
00:09:50,891 --> 00:09:52,292 line:-1
我们使用self就可以了


219
00:09:53,427 --> 00:09:55,696 line:-1
这看起来是一个简便的方法


220
00:09:55,762 --> 00:09:58,465 line:-1
但事实上这会改变


221
00:09:58,532 --> 00:10:01,034 line:-1
你对app的异步编程的看法


222
00:10:01,535 --> 00:10:04,538 line:-1
回到我们的例子 但这次用新的语法


223
00:10:06,006 --> 00:10:08,709 line:-1
我从Merlin毕业情况的


224
00:10:08,775 --> 00:10:10,310 line:-2
Notification Center
发布程序开始


225
00:10:11,378 --> 00:10:14,147 line:-1
当我接受到通知 我就对其使用地图


226
00:10:15,148 --> 00:10:17,217 line:-1
闭合包与我们刚才所用一致


227
00:10:17,985 --> 00:10:21,588 line:-2
之后我将其分配至
Merlin年级属性


228
00:10:22,122 --> 00:10:24,558 line:-1
你可以看到现在的语法是线性的


229
00:10:24,625 --> 00:10:27,561 line:-1
每一步发生了什么都可以轻松看懂


230
00:10:28,395 --> 00:10:31,398 line:-1
分配之后会返回一个叫可取消的东西


231
00:10:31,465 --> 00:10:33,700 line:-1
取消也是Combine中的一部分


232
00:10:34,067 --> 00:10:36,870 line:-1
取消能够让你尽早拆除发布程序和


233
00:10:36,937 --> 00:10:38,939 line:-1
订阅程序间的序列 如果有该需要


234
00:10:40,474 --> 00:10:43,110 line:-1
所以该逐步语法是


235
00:10:43,177 --> 00:10:44,611 line:-1
使用Combine的核心


236
00:10:44,978 --> 00:10:48,048 line:-1
每个步骤都描述了链中的下一组指令


237
00:10:48,415 --> 00:10:50,517 line:-1
并传输从第一个发布程序开始


238
00:10:50,584 --> 00:10:53,220 line:-1
逐一向操作程序传送的值


239
00:10:53,287 --> 00:10:55,088 line:-1
到订阅程序为止


240
00:10:55,856 --> 00:10:57,457 line:-1
我们有许多像这样的操作程序


241
00:10:57,758 --> 00:11:00,060 line:-1
我们叫它声明性操作程序API


242
00:11:00,527 --> 00:11:02,563 line:-1
它们包括像Map这样的转换功能


243
00:11:02,629 --> 00:11:04,431 line:-1
我们也有筛选和减少


244
00:11:04,498 --> 00:11:09,002 line:-2
列出操作 例如获取发布程序的
第一个 第二个或是第五个元素


245
00:11:09,403 --> 00:11:13,740 line:-2
错误处理 例如将错误转换为
默认值或放置值


246
00:11:14,107 --> 00:11:17,744 line:-2
线程或Q移动
例如将繁重的处理工作移动到


247
00:11:17,811 --> 00:11:20,781 line:-1
后台线程或UI工作到主线程


248
00:11:21,114 --> 00:11:23,917 line:-1
还有调度和时间 包括循环集成


249
00:11:24,384 --> 00:11:27,921 line:-1
调度队列 计时器支持 超时等


250
00:11:28,789 --> 00:11:30,657 line:-1
有这么多许多可用的操作程序


251
00:11:30,724 --> 00:11:32,326 line:-1
到底要用哪一个


252
00:11:32,392 --> 00:11:35,696 line:-1
你可能会有点选择困难症


253
00:11:36,029 --> 00:11:37,164 line:-1
所以我建议你


254
00:11:37,231 --> 00:11:40,267 line:-2
回到关于Combine的
核心设计原则


255
00:11:40,334 --> 00:11:42,503 line:-1
那就是组成


256
00:11:42,569 --> 00:11:44,004 line:-1
（首先尝试组成）


257
00:11:44,071 --> 00:11:47,708 line:-2
我们并不是只提供少数的操作程序
然后让它们做许多的工作


258
00:11:47,774 --> 00:11:50,544 line:-2
而是提供许多操作程序
让个程序的工作量降下来


259
00:11:50,611 --> 00:11:52,112 line:-1
这样会让它们更便于理解


260
00:11:52,913 --> 00:11:55,816 line:-2
所以为了帮助你在
这些操作系统中做出选择


261
00:11:55,883 --> 00:12:00,153 line:-2
我们从现有的Swift collection
API中获取了命名灵感


262
00:12:01,255 --> 00:12:02,089 line:-1
让我们来看看


263
00:12:02,789 --> 00:12:04,291 line:-1
我们想象这样一个象限图


264
00:12:04,791 --> 00:12:08,996 line:-2
一边是同步的API
另一边是异步的


265
00:12:09,363 --> 00:12:13,367 line:-1
顶部是单个值 底部是多个


266
00:12:14,401 --> 00:12:17,638 line:-2
在Swift中
如果要同步表示一个整数


267
00:12:17,704 --> 00:12:19,473 line:-1
你就要用到int之类的功能


268
00:12:19,873 --> 00:12:22,242 line:-1
如果你想同步表示许多整数


269
00:12:22,309 --> 00:12:24,478 line:-1
就要用整数数组之类的东西


270
00:12:25,012 --> 00:12:26,613 line:-2
在Combine中
我们采用了这些概念


271
00:12:26,680 --> 00:12:29,116 line:-1
并将它们映射到异步中


272
00:12:29,449 --> 00:12:32,119 line:-1
所以 如果你想要异步表示一个值


273
00:12:32,186 --> 00:12:34,321 line:-1
那么之后会有future值


274
00:12:34,388 --> 00:12:37,291 line:-1
如果你要异步表示许多值


275
00:12:37,357 --> 00:12:38,325 line:-1
那么这就是一个发布程序


276
00:12:38,992 --> 00:12:39,860 line:-1
意思就是


277
00:12:39,927 --> 00:12:42,095 line:-1
如果你在寻找一种你已经知道


278
00:12:42,162 --> 00:12:44,831 line:-1
如何处理数组的特定操作


279
00:12:44,898 --> 00:12:47,134 line:-1
试试使用发布程序的名称


280
00:12:47,668 --> 00:12:48,936 line:-1
看看下面这个例子


281
00:12:50,637 --> 00:12:54,408 line:-1
这个例子中 如果密钥不存在


282
00:12:54,474 --> 00:12:57,144 line:-2
或者不为整数的话
我就用默认值0来表示


283
00:12:57,544 --> 00:13:01,215 line:-1
如果不让这个坏值进入我们的程序


284
00:13:01,281 --> 00:13:03,851 line:-1
并最终写入我的模型对象中就更好了


285
00:13:04,318 --> 00:13:07,988 line:-1
所以我可以允许让这个闭合包返回无


286
00:13:08,055 --> 00:13:10,190 line:-1
再筛选掉无值


287
00:13:10,691 --> 00:13:14,661 line:-2
在Swift 4.1 标准库
引入了该操作的名称


288
00:13:14,728 --> 00:13:16,129 line:-1
叫compactMap


289
00:13:16,196 --> 00:13:20,033 line:-2
发布程序也有一个相似的名称
功能也差不多


290
00:13:20,100 --> 00:13:23,804 line:-2
如果闭合包返回无值
就会被compactMap筛选掉


291
00:13:23,871 --> 00:13:25,973 line:-1
防止它继续在流程中继续


292
00:13:27,107 --> 00:13:28,909 line:-1
让我们使用一些更熟悉的名称


293
00:13:28,976 --> 00:13:31,144 line:-1
来构建我们的分步说明


294
00:13:33,380 --> 00:13:35,983 line:-1
假如只有五年级以上的学生


295
00:13:36,049 --> 00:13:37,518 line:-1
可以继续留下来


296
00:13:37,818 --> 00:13:39,686 line:-1
我就可以用过滤器来做到


297
00:13:40,153 --> 00:13:41,321 line:-1
过滤器会接受一个谓词


298
00:13:41,388 --> 00:13:44,691 line:-1
并只允许传递该谓词的元素继续下去


299
00:13:44,758 --> 00:13:47,561 line:-1
这与数组过滤器完全一致


300
00:13:48,262 --> 00:13:50,464 line:-1
让我们进一步假设你最多只能


301
00:13:50,531 --> 00:13:52,099 line:-1
毕业三次


302
00:13:52,866 --> 00:13:54,334 line:-1
那么在数组中


303
00:13:54,401 --> 00:13:55,869 line:-1
如果你想要获取前三项元素


304
00:13:55,936 --> 00:13:57,437 line:-1
你可以使用前缀3


305
00:13:57,704 --> 00:13:58,539 line:-1
在发布程序中


306
00:13:58,605 --> 00:14:00,307 line:-1
如果你只想接受前三项元素


307
00:14:00,374 --> 00:14:02,376 line:-1
你可以使用3的前缀


308
00:14:02,776 --> 00:14:05,179 line:-1
它在接收到这三个值后


309
00:14:05,245 --> 00:14:06,713 line:-1
它将取消上游


310
00:14:06,780 --> 00:14:08,582 line:-1
并向下游发送完成


311
00:14:10,250 --> 00:14:12,519 line:-1
所以后退一步 看看这里有什么


312
00:14:12,819 --> 00:14:16,757 line:-2
Notification Center发布程序接收到
Merlin毕业情况的通知


313
00:14:17,724 --> 00:14:20,627 line:-1
当他毕业后 我们就会从该属性中


314
00:14:20,694 --> 00:14:23,197 line:-1
获取新年级 从该通知中获取


315
00:14:23,664 --> 00:14:26,600 line:-1
我们要确保该值大于五年级


316
00:14:26,667 --> 00:14:29,236 line:-1
并且最多只发生三次


317
00:14:29,303 --> 00:14:32,906 line:-2
最后再将它分配给
Merlin的年级属性


318
00:14:34,575 --> 00:14:35,676 line:-1
（结合发布程序）


319
00:14:35,742 --> 00:14:37,778 line:-1
Map和过滤器都是很好的API


320
00:14:37,845 --> 00:14:40,013 line:-1
但它们主要是同步行为


321
00:14:40,514 --> 00:14:43,684 line:-2
Combine在进行异步行为时
尤为大放异彩


322
00:14:44,184 --> 00:14:46,486 line:-2
所以接下来我们就会讲到
两种操作程序


323
00:14:46,553 --> 00:14:48,121 line:-1
对异步行为十分有用


324
00:14:48,188 --> 00:14:49,256 line:-1
首先是Zip


325
00:14:50,190 --> 00:14:54,194 line:-2
所以在我们的app中
用户要等待魔杖被创造出来


326
00:14:54,261 --> 00:14:56,063 line:-1
才能继续操作


327
00:14:56,129 --> 00:14:59,299 line:-1
这是三个长时间运行的异步操作


328
00:15:00,434 --> 00:15:01,268 line:-1
所以


329
00:15:01,535 --> 00:15:04,905 line:-2
等这三件事完成之后
继续按钮才会被启用


330
00:15:05,272 --> 00:15:06,773 line:-1
这就是Zip的工作


331
00:15:07,474 --> 00:15:11,278 line:-2
Zip将几个上游输入
转换为单个元组


332
00:15:12,279 --> 00:15:14,815 line:-1
因为它需要所有来自上游的输入


333
00:15:14,882 --> 00:15:16,083 line:-1
才能继续进行


334
00:15:16,149 --> 00:15:19,119 line:-1
它会在一件事情完成


335
00:15:19,186 --> 00:15:22,689 line:-2
开始进行下一件事的时候
进行when/and操作


336
00:15:23,790 --> 00:15:26,660 line:-1
比如第一个发布程序生成A


337
00:15:27,127 --> 00:15:29,496 line:-1
然后第二个发布程序生成1


338
00:15:29,563 --> 00:15:31,999 line:-1
我就有足够的信息来创造一个元组了


339
00:15:32,366 --> 00:15:35,435 line:-1
并将该值下游发送给订阅程序


340
00:15:37,371 --> 00:15:40,374 line:-1
我的app用的是这个版本的Zip


341
00:15:40,440 --> 00:15:44,444 line:-2
它让三个上游等待
三个异步操作的结果


342
00:15:44,511 --> 00:15:46,446 line:-2
每个操作都会
给我一个布尔结果


343
00:15:46,513 --> 00:15:48,582 line:-1
所以我将该元组映射到布尔


344
00:15:48,649 --> 00:15:50,851 line:-2
这时我就会将它写入
按钮中的isEnabled属性


345
00:15:50,918 --> 00:15:52,753 line:-1
来将它启动


346
00:15:55,022 --> 00:15:57,958 line:-1
所以 在等待魔杖生成后


347
00:15:58,025 --> 00:15:59,026 line:-1
像其他人一样


348
00:15:59,092 --> 00:16:01,662 line:-2
我的学生必须要
同意一系列条款和条件


349
00:16:01,728 --> 00:16:04,698 line:-1
才能被允许继续玩他们的魔杖


350
00:16:05,332 --> 00:16:07,534 line:-1
这也就是说在启用开始按钮之前


351
00:16:07,601 --> 00:16:10,337 line:-1
必须启用这三个开关


352
00:16:10,404 --> 00:16:13,140 line:-1
但是如果其中一个开关之后被禁用了


353
00:16:13,207 --> 00:16:15,242 line:-1
那么这个开关也要被禁用


354
00:16:15,843 --> 00:16:17,911 line:-2
这就是
Combine Latest的工作


355
00:16:18,545 --> 00:16:21,882 line:-2
与Zip一样 它将几个上游输入
转换为单个值


356
00:16:22,282 --> 00:16:23,383 line:-1
但又不完全像Zip


357
00:16:23,450 --> 00:16:26,653 line:-1
它需要来自任何上游的输入


358
00:16:26,720 --> 00:16:29,156 line:-1
才能使其成为when/or操作


359
00:16:29,623 --> 00:16:30,624 line:-1
为了支持这一点


360
00:16:30,691 --> 00:16:34,027 line:-2
它会存储从每个上游
接收的最后一个值


361
00:16:34,094 --> 00:16:35,729 line:-1
同时配置闭合包


362
00:16:35,796 --> 00:16:38,632 line:-2
这样你就可以将其
转化为单个下游值了


363
00:16:39,900 --> 00:16:42,536 line:-1
比如我的第一个发布程序生成了A


364
00:16:42,936 --> 00:16:45,506 line:-1
第二个生成A1


365
00:16:45,772 --> 00:16:48,408 line:-1
之后我运行闭合包将其串联


366
00:16:48,475 --> 00:16:49,776 line:-1
发送至下游


367
00:16:50,244 --> 00:16:53,080 line:-1
之后如果第二个发布程序再生成新值


368
00:16:53,146 --> 00:16:56,183 line:-1
我就可以将它与前面


369
00:16:56,250 --> 00:16:59,052 line:-2
第一个发布程序生成的值结合
再将新值传输下去


370
00:16:59,620 --> 00:17:03,056 line:-2
也就是说每当上游发生变化时
我都能获取新事件


371
00:17:04,090 --> 00:17:05,925 line:-1
所以在我的app中


372
00:17:05,992 --> 00:17:08,829 line:-2
我用的是这种Combine Latest
它有三个上游


373
00:17:09,496 --> 00:17:10,430 line:-1
每当三个开关的


374
00:17:10,497 --> 00:17:13,032 line:-1
布尔状态变化时


375
00:17:13,300 --> 00:17:15,536 line:-2
就再次将其转化
为单个布尔值


376
00:17:15,602 --> 00:17:18,539 line:-2
再将其写入开始按钮的
isEnabled属性中


377
00:17:19,205 --> 00:17:22,276 line:-2
也就是说 只要其中任何一个
开关为假 结果也就为假


378
00:17:22,342 --> 00:17:25,045 line:-1
如果全为真 结果也为真


379
00:17:25,112 --> 00:17:26,445 line:-1
这样我们就能启用按钮了


380
00:17:28,448 --> 00:17:31,752 line:-2
我们设计Combine的里面是
让你在app中逐步采用


381
00:17:31,818 --> 00:17:34,321 line:-1
你不用转化所有内容来使用它


382
00:17:34,588 --> 00:17:37,057 line:-1
所以开始我有一些建议


383
00:17:37,124 --> 00:17:40,827 line:-2
可能会对你在app中
使用Combine有一些用处


384
00:17:41,261 --> 00:17:43,997 line:-2
比如你要使用
Notification Center


385
00:17:44,064 --> 00:17:46,767 line:-1
你就会收到通知 之后你会查看


386
00:17:46,834 --> 00:17:50,070 line:-1
来决定是否执行 那么试试过滤器


387
00:17:51,371 --> 00:17:54,575 line:-2
如果你要对几个
异步操作的结果进行加权


388
00:17:54,842 --> 00:17:58,645 line:-2
那么你可以用Zip
包括网络操作


389
00:17:59,479 --> 00:18:04,017 line:-2
最后 如果你用的是
URL会话来接收数据


390
00:18:04,084 --> 00:18:07,588 line:-2
然后使用JSON Decoder
将该数据转换为自己的对象


391
00:18:07,855 --> 00:18:09,790 line:-2
我们同样也有一款
操作程序能够帮到你


392
00:18:09,857 --> 00:18:11,291 line:-1
那就是Decode


393
00:18:11,358 --> 00:18:12,860 line:-1
（试试看）


394
00:18:12,926 --> 00:18:13,861 line:-1
（关于Combine的更多信息）


395
00:18:13,927 --> 00:18:18,065 line:-2
今天我们讲到了基础的东西
发布程序 订阅程序和操作程序


396
00:18:18,131 --> 00:18:20,133 line:-1
但是Combine还有更多的东西


397
00:18:20,934 --> 00:18:23,504 line:-1
包括错误处理和取消


398
00:18:23,937 --> 00:18:27,541 line:-2
调度程序和时间
以及一些很棒的设计模式


399
00:18:27,608 --> 00:18:30,377 line:-1
包括在app中的不同模块或


400
00:18:30,444 --> 00:18:34,481 line:-2
不同区域之间使用Combine
当然还有与SwiftUI的集成


401
00:18:34,548 --> 00:18:37,851 line:-2
或许更多详情
请观看Combine实务


402
00:18:39,119 --> 00:18:41,188 line:-1
今天就说这么多 谢谢大家


403
00:18:41,255 --> 00:18:44,057 line:-1
（更多信息）

