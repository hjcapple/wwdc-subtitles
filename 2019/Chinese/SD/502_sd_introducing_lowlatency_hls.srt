1
00:00:06,273 --> 00:00:10,711 line:0
（低延迟HTTP现场直播）


2
00:00:12,679 --> 00:00:13,680 line:-1
嘿！


3
00:00:14,882 --> 00:00:16,049 line:-1
下午好


4
00:00:16,917 --> 00:00:18,118 line:-1
大家下午好


5
00:00:19,319 --> 00:00:20,787 line:-1
我是Roger Pantos


6
00:00:20,954 --> 00:00:26,793 line:-2
今天关于HLS的演讲我们主要讲
低延迟


7
00:00:27,494 --> 00:00:29,863 line:-1
首先


8
00:00:30,531 --> 00:00:35,035 line:-1
当我们提到低延迟时什么是延迟呢？


9
00:00:36,570 --> 00:00:38,672 line:-1
嗯 在这个情境中


10
00:00:39,106 --> 00:00:40,941 line:-1
它指的是时间量


11
00:00:41,175 --> 00:00:43,677 line:-1
从摄像头开始记录视频时


12
00:00:43,744 --> 00:00:45,646 line:-1
或击中你的产品后台时


13
00:00:46,013 --> 00:00:47,347 line:-1
以及当用户


14
00:00:47,548 --> 00:00:52,186 line:-2
在家里在iPad或
Apple TV上观看视频时


15
00:00:53,353 --> 00:00:56,456 line:-1
缩短延迟的持续时间


16
00:00:56,523 --> 00:01:01,228 line:-2
保持简短的持续时间
对于某些类型的内容来说至关重要


17
00:01:02,596 --> 00:01:07,134 line:-2
其中我们很可能最熟悉的一种类型是
体育赛事现场直播


18
00:01:07,901 --> 00:01:11,171 line:-1
但对于最新消息来说也很重要


19
00:01:11,405 --> 00:01:15,375 line:-1
比如游戏直播


20
00:01:16,009 --> 00:01:18,812 line:-1
甚至比如奥斯卡颁奖这样的新闻


21
00:01:19,079 --> 00:01:22,149 line:-1
实际上 这对于任何有大量人群


22
00:01:22,216 --> 00:01:25,352 line:-2
同时观看同一个视频时的情况
都很重要


23
00:01:25,686 --> 00:01:28,088 line:-1
通常它存在社交因素


24
00:01:28,789 --> 00:01:35,028 line:-2
那么延迟需要有多低才能提供
良好的用户体验呢？


25
00:01:36,496 --> 00:01:42,970 line:-1
嗯 如今的金标准大约是二到八秒


26
00:01:43,403 --> 00:01:46,673 line:-1
这是由当前设备情况决定的


27
00:01:46,740 --> 00:01:49,743 line:-1
电视广播装置、电缆、卫星电视


28
00:01:50,644 --> 00:01:53,413 line:-1
因此 当我们设计低延迟HLS时


29
00:01:53,780 --> 00:01:55,349 line:-1
我们就给我们设置了一个目标


30
00:01:56,083 --> 00:01:59,086 line:-1
在任何合理的往返时间内


31
00:01:59,520 --> 00:02:01,288 line:-1
比公共互联网上的大规模直播


32
00:02:01,588 --> 00:02:03,590 line:-1
延迟一到两秒


33
00:02:04,691 --> 00:02:08,262 line:-2
现在我们不需要牺牲任何东西
就能实现


34
00:02:09,329 --> 00:02:12,966 line:-2
不需要牺牲任何功能就能让HLS
具备竞争力


35
00:02:13,534 --> 00:02:18,205 line:-2
因此我们仍采用品质来匹配
用户的网络速度


36
00:02:18,639 --> 00:02:20,774 line:-1
我们仍允许你保护你的内容


37
00:02:21,008 --> 00:02:23,143 line:-1
我们仍允许你插入广告


38
00:02:23,477 --> 00:02:26,914 line:-1
并提供程序边界和其它元数据


39
00:02:28,282 --> 00:02:32,753 line:-1
我们仍可以让你以经济有效的方式


40
00:02:32,953 --> 00:02:39,493 line:-2
把你的广播推广给数十万
使用CDN的用户


41
00:02:40,594 --> 00:02:45,065 line:-1
我们确保这些数据流向后兼容


42
00:02:45,699 --> 00:02:50,304 line:-2
因此你仍可以看到数据流在较老的
客户端上保持常规的延迟


43
00:02:51,471 --> 00:02:53,607 line:-1
我们是如何实现这些的？


44
00:02:54,908 --> 00:02:57,477 line:-1
嗯 要了解这个问题


45
00:02:58,111 --> 00:03:03,717 line:-2
我们首先要返回到常规的HLS
并了解我们是从哪里开始的


46
00:03:05,919 --> 00:03:08,522 line:-1
首先


47
00:03:08,956 --> 00:03:14,061 line:-2
从起初开始 HLS就被设计成一个
简单、强健的协议


48
00:03:14,428 --> 00:03:15,729 line:-1
那非常棒


49
00:03:16,430 --> 00:03:22,202 line:-2
事实上 如果你的内容
不在那些范围内


50
00:03:22,936 --> 00:03:24,605 line:-2
你知道的
我们刚才提到过的内容类型


51
00:03:24,771 --> 00:03:27,875 line:-2
你应该继续使用常规的HLS
并且那会很适合你


52
00:03:28,809 --> 00:03:32,012 line:-1
但那种简单是有代价的


53
00:03:32,212 --> 00:03:34,214 line:-1
当你观看体育赛事时 比如说


54
00:03:34,715 --> 00:03:37,117 line:-1
那种代价的表现通常是


55
00:03:37,284 --> 00:03:40,287 line:-2
你在Apple TV上
看到得分之前


56
00:03:40,454 --> 00:03:42,356 line:-1
你会先通过公寓的墙面听到得分


57
00:03:43,924 --> 00:03:45,025 line:-1
这是为什么呢？


58
00:03:45,859 --> 00:03:47,127 line:-1
嗯 要理解这个问题


59
00:03:47,628 --> 00:03:51,665 line:-1
让我们看一下常规HLS如何


60
00:03:52,099 --> 00:03:54,668 line:-1
从产品后台获取特定帧


61
00:03:55,068 --> 00:03:58,038 line:-1
并发送给在家里的用户


62
00:03:58,872 --> 00:04:00,040 line:-1
我们先看一下帧


63
00:04:00,274 --> 00:04:04,311 line:-2
我们要做的第一件事就是编码帧
并把它放到一个视频段中


64
00:04:04,711 --> 00:04:06,780 line:-1
现在我们推荐六秒钟为一段


65
00:04:07,114 --> 00:04:10,717 line:-2
但那确实意味着
因为我们是实时编码


66
00:04:10,984 --> 00:04:14,655 line:-2
因此甚至在你有能放在CDN上的
任何内容之前有六秒钟的空白


67
00:04:15,756 --> 00:04:19,959 line:-2
在我们得到那个视频段之后
客户端必须要发现它的存在


68
00:04:20,928 --> 00:04:24,164 line:-1
现今HLS使用查询机制


69
00:04:24,231 --> 00:04:27,434 line:-1
意思是客户端时常检查服务器端


70
00:04:27,501 --> 00:04:30,103 line:-2
看是否有最新的播放列表
从而了解是否有新内容


71
00:04:31,071 --> 00:04:33,874 line:-1
在最佳情况下 客户端可能会说


72
00:04:34,141 --> 00:04:39,313 line:-2
服务器端一向播放列表中
放入最新视频段就开始检查


73
00:04:39,379 --> 00:04:42,482 line:-2
这很棒 但通常我们不能实现那种
最佳情况


74
00:04:42,549 --> 00:04:44,451 line:-1
事实上 在某些情况下


75
00:04:44,518 --> 00:04:46,486 line:-1
甚至在客户端发现有新视频段之前


76
00:04:46,787 --> 00:04:50,090 line:-1
差不多还存在另一个六秒钟


77
00:04:51,525 --> 00:04:54,962 line:-1
在客户端发现之后 取回新播放列表


78
00:04:55,362 --> 00:04:57,564 line:-2
然后客户端必须转向反方向
并做另一个请求


79
00:04:57,865 --> 00:04:59,533 line:-1
才能实际上获得视频段


80
00:05:00,167 --> 00:05:04,304 line:-2
请记住 每个请求在网络上
都需要一段往返时间


81
00:05:05,005 --> 00:05:07,241 line:-1
在某些网络中 特别是蜂窝


82
00:05:07,574 --> 00:05:09,243 line:-1
这段时间可能在数百毫秒内


83
00:05:09,309 --> 00:05:11,378 line:-1
并不是无关紧要的


84
00:05:12,646 --> 00:05:14,248 line:-2
因此无论怎样
在客户端执行所有操作之后


85
00:05:14,648 --> 00:05:17,017 line:-1
视频段才开始流入客户端


86
00:05:17,751 --> 00:05:20,854 line:-2
然后一旦客户端获得足够多的视频段
它就开始呈现视频


87
00:05:21,355 --> 00:05:24,892 line:-2
在这个例子中
我们已经进入12秒区域了


88
00:05:25,459 --> 00:05:29,229 line:-1
但如果你通过CDN提交内容


89
00:05:29,630 --> 00:05:34,668 line:-2
我们绝大多数人都是通过CDN
提交内容的 可能延迟的时间更长


90
00:05:35,702 --> 00:05:36,870 line:-1
原因是


91
00:05:37,171 --> 00:05:42,976 line:-2
由于常规HLS与
CDN相交互的方式


92
00:05:43,043 --> 00:05:44,111 line:-1
让我们看一下


93
00:05:45,279 --> 00:05:49,383 line:-1
想象一下你获得了你的HLS视频流


94
00:05:49,449 --> 00:05:51,585 line:-1
你将其发布到右侧的视频源中


95
00:05:51,785 --> 00:05:53,086 line:-1
在特定时间内


96
00:05:53,453 --> 00:05:56,190 line:-1
它的播放列表有三个视频段


97
00:05:56,857 --> 00:06:00,661 line:-2
现在第一个客户端想查找最新、
最棒的媒体内容


98
00:06:01,495 --> 00:06:04,364 line:-2
如果客户端所通讯的
CDN边缘服务器


99
00:06:04,598 --> 00:06:06,867 line:-1
尚未缓存任何那种媒体内容


100
00:06:07,167 --> 00:06:10,370 line:-2
它实际上状况良好
因为它会请求播放列表


101
00:06:10,671 --> 00:06:12,339 line:-1
CDN将从源获取播放列表


102
00:06:12,573 --> 00:06:14,575 line:-1
获取最新版本并直接发送给客户端


103
00:06:14,641 --> 00:06:15,776 line:-1
客户端1状况良好


104
00:06:16,410 --> 00:06:19,680 line:-1
问题出现在一秒或两秒钟之后


105
00:06:20,113 --> 00:06:21,415 line:-1
当在源上


106
00:06:21,882 --> 00:06:25,219 line:-2
我们从众多视频段中得到了一个
新视频段并且播放列表也更新了


107
00:06:25,586 --> 00:06:28,355 line:-1
现在播放列表包含视频段1到4


108
00:06:29,323 --> 00:06:30,691 line:-1
那之后会发生什么？


109
00:06:30,991 --> 00:06:33,493 line:-1
当客户端2进入并再次查找时


110
00:06:33,560 --> 00:06:35,262 line:-1
“好的 有哪些最新内容？”


111
00:06:35,963 --> 00:06:38,565 line:-1
嗯 客户端2将取回的播放列表


112
00:06:38,799 --> 00:06:42,703 line:-2
是仅包含视频段1到3的
缓存播放列表


113
00:06:42,769 --> 00:06:45,739 line:-1
它甚至都不能发现有视频段4


114
00:06:46,006 --> 00:06:50,277 line:-2
因为CDN为它提供了播放列表的
缓存版本


115
00:06:51,545 --> 00:06:54,414 line:-1
为什么CDN会这样做呢？


116
00:06:55,816 --> 00:06:58,218 line:-1
嗯 它就不能给它提供最新版本吗？


117
00:06:58,986 --> 00:07:03,090 line:-1
嗯 问题是CDN没有办法了解


118
00:07:03,323 --> 00:07:05,726 line:-1
源上已经更新了播放列表


119
00:07:06,460 --> 00:07:09,329 line:-1
如果有每次有随机客户端进入


120
00:07:09,596 --> 00:07:12,266 line:-1
并说“嘿 最新播放列表是什么？”


121
00:07:12,332 --> 00:07:13,901 line:-1
它就进入并检查源


122
00:07:14,134 --> 00:07:15,702 line:-1
那会让源变得一团糟


123
00:07:16,537 --> 00:07:19,673 line:-1
因此CDN需要缓存一段时间


124
00:07:19,740 --> 00:07:21,008 line:-1
这叫做生存时间


125
00:07:21,909 --> 00:07:24,878 line:-1
生存时间越长


126
00:07:25,479 --> 00:07:27,414 line:-1
客户端查看


127
00:07:27,481 --> 00:07:29,550 line:-2
并看到过时的播放列表版本的
时间越长


128
00:07:29,783 --> 00:07:33,053 line:-1
并又把现场延迟时间拉长了那么多


129
00:07:34,721 --> 00:07:39,393 line:-1
所有问题都可以被修复


130
00:07:40,727 --> 00:07:44,464 line:-1
但在决定如何修复时


131
00:07:44,831 --> 00:07:48,435 line:-1
我们需要考虑更多因素


132
00:07:49,803 --> 00:07:54,608 line:-1
第一个是HTTP仍然是


133
00:07:54,875 --> 00:07:56,543 line:-1
通过因特网向数十万人


134
00:07:57,177 --> 00:08:01,949 line:-1
同时提交同一媒体内容的最佳方式


135
00:08:02,416 --> 00:08:04,151 line:-1
因此我们应该坚持用HTTP


136
00:08:04,751 --> 00:08:10,924 line:-2
但那样做意味着
我们坚持使用HTTP提交模型


137
00:08:11,191 --> 00:08:15,262 line:-1
那会给客户端分配不连续的视频段


138
00:08:15,329 --> 00:08:18,765 line:-1
不连续的资源块


139
00:08:19,199 --> 00:08:23,237 line:-2
如果它需要六秒钟才能产生那个
资源块


140
00:08:23,804 --> 00:08:25,739 line:-1
那么我们已经错过了我们的最终目标


141
00:08:26,273 --> 00:08:30,010 line:-2
如果我们能实现比现场
仅延迟一秒钟的最终目标


142
00:08:30,611 --> 00:08:34,214 line:-2
那么我们通过HTTP所分配的内容
就要缩水


143
00:08:34,914 --> 00:08:37,284 line:-1
在某些情况下会变得更短


144
00:08:38,684 --> 00:08:40,787 line:-1
我们要努力克服的下一件事


145
00:08:41,154 --> 00:08:43,823 line:-1
是现在对于可预见的未来


146
00:08:44,091 --> 00:08:49,763 line:-2
CDN对于帮助我们扩展到
全球规模的观众来说至关重要


147
00:08:50,864 --> 00:08:53,500 line:-1
但CDN最终


148
00:08:53,834 --> 00:08:58,238 line:-2
从本质上来说是HTTP代理缓存
它们会实现缓存要实现的功能


149
00:08:58,705 --> 00:09:01,575 line:-2
我们必须面对这个问题
而不是逃避它


150
00:09:02,876 --> 00:09:05,078 line:-1
最后一件事是


151
00:09:05,546 --> 00:09:08,415 line:-1
当我们延迟的时间非常接近现场时


152
00:09:08,615 --> 00:09:10,751 line:-1
我们只能提前缓冲非常少量的内容


153
00:09:10,817 --> 00:09:11,785 line:-1
因为那就是我们所得到的全部内容


154
00:09:12,686 --> 00:09:17,558 line:-2
因此 如果我们要执行比如切换到
一个不同的比特率


155
00:09:18,225 --> 00:09:19,459 line:-1
那么我们只能得到比如


156
00:09:19,826 --> 00:09:22,329 line:-2
在我们失速之前我们没有
十秒钟的时间来执行那个操作


157
00:09:22,696 --> 00:09:25,299 line:-1
我们可能只有不到一秒钟


158
00:09:25,666 --> 00:09:27,134 line:-1
因此我们要确保


159
00:09:27,367 --> 00:09:30,804 line:-1
切换机制要尽可能得高效


160
00:09:31,171 --> 00:09:32,706 line:-1
因为我们的执行时间很短


161
00:09:33,807 --> 00:09:34,641 line:-1
因此


162
00:09:35,909 --> 00:09:42,482 line:-2
我们查看了整个HLS提交模型
彻底查看


163
00:09:43,016 --> 00:09:47,154 line:-1
并且我们发现了需要做出


164
00:09:47,521 --> 00:09:49,056 line:-1
五处大的修改


165
00:09:49,389 --> 00:09:54,127 line:-2
从而实现这个比现场延迟
一到两秒的目标


166
00:09:55,028 --> 00:09:56,730 line:-1
我们要讲的第一件事


167
00:09:57,397 --> 00:10:03,203 line:-2
就是我们需要一种能把那个媒体内容
获取到服务器上的方式


168
00:10:04,605 --> 00:10:06,240 line:-1
时间要小于六秒


169
00:10:06,440 --> 00:10:08,542 line:-1
我们把它叫做减少发布延迟


170
00:10:10,143 --> 00:10:11,311 line:-1
我们的实现方式是


171
00:10:11,378 --> 00:10:13,614 line:-1
我们允许服务器


172
00:10:13,814 --> 00:10:18,385 line:-2
在主视频段准备好之前
先发布少量主视频段的部分内容


173
00:10:18,919 --> 00:10:21,221 line:-2
因此我们可以提前提交这些
少量的部分内容


174
00:10:22,055 --> 00:10:23,624 line:-1
我们要做的第二件事是


175
00:10:24,024 --> 00:10:28,028 line:-1
优化客户端发现视频段的方式


176
00:10:28,462 --> 00:10:29,897 line:-1
从而客户端可以迅速发现视频段


177
00:10:30,063 --> 00:10:31,298 line:-1
我们的实现方式是


178
00:10:31,765 --> 00:10:36,436 line:-1
修改客户端更新它的播放列表的方式


179
00:10:37,171 --> 00:10:40,240 line:-2
我们允许客户端在播放列表实际上
存在于服务器上之前


180
00:10:40,674 --> 00:10:43,277 line:-1
提前请求特定的播放列表更新


181
00:10:43,911 --> 00:10:46,680 line:-1
然后服务器端将保有那个请求


182
00:10:46,747 --> 00:10:50,651 line:-2
并关注播放列表
直到它更新了下一个视频段


183
00:10:50,884 --> 00:10:55,889 line:-2
那时你将立刻把播放列表发送回
客户端


184
00:10:57,224 --> 00:11:01,028 line:-2
客户端将在小于往返时间的时间内
发现播放列表


185
00:11:01,695 --> 00:11:03,230 line:-1
在这个模型中


186
00:11:03,730 --> 00:11:07,534 line:-2
每个单一播放列表更新
实际上都有一个不同的URL


187
00:11:08,335 --> 00:11:10,637 line:-1
这提供了一秒钟的优势


188
00:11:11,305 --> 00:11:12,840 line:-1
也就是


189
00:11:13,273 --> 00:11:16,910 line:-2
它让这些播放列表更新的缓存
变得更有效率了


190
00:11:17,544 --> 00:11:20,214 line:-1
因为每次更新都有不同的URL


191
00:11:20,614 --> 00:11:23,550 line:-2
每个更新看起来都像是一个独立的
可缓存的实体


192
00:11:24,384 --> 00:11:25,686 line:-1
现在发生的是


193
00:11:26,086 --> 00:11:28,789 line:-1
当客户端1想获得特定更新时


194
00:11:29,156 --> 00:11:30,057 line:-1
它会发出请求


195
00:11:30,257 --> 00:11:31,892 line:-1
CDN说“我从没听说过


196
00:11:31,959 --> 00:11:33,393 line:-1
我要直接去源那儿”


197
00:11:33,760 --> 00:11:35,796 line:-2
然后源会说“嗯
那是因为我还没有创建它”


198
00:11:36,063 --> 00:11:37,297 line:-1
因此现在它就离开了


199
00:11:37,531 --> 00:11:38,699 line:-1
一旦它获得那个更新


200
00:11:39,066 --> 00:11:41,401 line:-2
它就把更新传给CDN
CDN直接传给客户端


201
00:11:42,269 --> 00:11:45,105 line:-2
下一个客户端进入时
它会说“我想要最新更新”


202
00:11:45,639 --> 00:11:49,810 line:-2
CDN通过使用URL对其进行了
积极的识别 并说“给你吧”


203
00:11:49,877 --> 00:11:52,779 line:-1
后续的每个请求更新的客户端


204
00:11:53,180 --> 00:11:56,316 line:-1
都将立即获得CDN缓存


205
00:11:56,884 --> 00:11:59,286 line:-1
但下一次


206
00:11:59,586 --> 00:12:02,723 line:-2
此后第一个客户端或任何其它客户端
请求更新时


207
00:12:03,790 --> 00:12:07,160 line:-2
发送CDN的URL
将是不同的URL


208
00:12:07,561 --> 00:12:10,764 line:-2
因此CDN立即就知道它的缓存里
没有这个URL


209
00:12:10,831 --> 00:12:12,366 line:-1
它将不会传输过时的内容


210
00:12:12,666 --> 00:12:14,268 line:-1
相反它会立即返回到源


211
00:12:14,334 --> 00:12:15,736 line:-1
源说“嗯 我还没有创建”


212
00:12:16,103 --> 00:12:18,605 line:-1
然后一旦它创建好


213
00:12:18,939 --> 00:12:23,644 line:-2
它就把它传回给CDN
然后CDN传给客户端


214
00:12:25,646 --> 00:12:26,480 line:-1
因此


215
00:12:27,814 --> 00:12:33,287 line:-2
这些新播放列表更新请求是
固有的缓存破坏


216
00:12:33,720 --> 00:12:37,558 line:-1
那会让缓存在CDN上更好地运作


217
00:12:38,859 --> 00:12:40,961 line:-1
我们要做的第三件事是


218
00:12:41,662 --> 00:12:45,232 line:-1
消除额外的往返


219
00:12:45,532 --> 00:12:48,669 line:-2
在你发现一个视频段离开
并得到视频段自身之后


220
00:12:49,503 --> 00:12:51,572 line:-1
我们的实现方式是使用“推送”


221
00:12:52,372 --> 00:12:55,509 line:-1
当客户端请求下一个播放列表更新时


222
00:12:56,343 --> 00:12:57,644 line:-1
它会告诉服务器端


223
00:12:57,845 --> 00:12:58,946 line:-1
“顺便提一下


224
00:12:59,546 --> 00:13:02,916 line:-2
当你得到我所不知道的
下一个视频段的播放列表更新时


225
00:13:03,450 --> 00:13:05,118 line:-1
我希望你…


226
00:13:05,285 --> 00:13:06,954 line:-1
当你给我返回那个播放列表时


227
00:13:07,020 --> 00:13:09,122 line:-1
我希望你立即把那个视频段推送给我


228
00:13:09,523 --> 00:13:12,893 line:-2
那样我就不需要转向反方向
并做第二次往返了”


229
00:13:15,262 --> 00:13:16,930 line:-1
我们要做的第四件事是


230
00:13:17,164 --> 00:13:21,468 line:-1
我们要一遍又一遍地


231
00:13:21,535 --> 00:13:22,603 line:-1
设法处理转移播放列表的成本


232
00:13:22,970 --> 00:13:26,373 line:-2
我们所采用的基本方式是
使用Delta更新


233
00:13:26,940 --> 00:13:28,642 line:-1
它的运作方式是


234
00:13:28,976 --> 00:13:32,145 line:-1
客户端首次请求特定媒体播放列表时


235
00:13:32,446 --> 00:13:33,614 line:-1
它会取回完整的播放列表


236
00:13:34,248 --> 00:13:37,985 line:-2
然而在此之后
它拥有播放列表的绝大部分


237
00:13:38,252 --> 00:13:43,357 line:-2
它只对了解末端发生变更的部分
感兴趣


238
00:13:43,790 --> 00:13:46,026 line:-1
因此 在此之后


239
00:13:46,827 --> 00:13:48,395 line:-1
下一次它请求播放列表时 它会说


240
00:13:48,695 --> 00:13:50,764 line:-2
“我想要播放列表更新
这是一次Delta更新”


241
00:13:51,198 --> 00:13:52,466 line:-1
它所返回的是


242
00:13:53,100 --> 00:13:56,937 line:-1
非常少的数据块 只包含


243
00:13:57,237 --> 00:13:59,673 line:-2
在实际数字播放列表中
最新变更的内容


244
00:13:59,740 --> 00:14:02,709 line:-1
这些更新通常会放在一个数据包中


245
00:14:03,043 --> 00:14:04,278 line:-1
单一MTU数据


246
00:14:04,578 --> 00:14:07,814 line:-2
因此这对于后续的每次更新来说
有效率得多得多


247
00:14:09,583 --> 00:14:11,552 line:-1
现在第五个变更是


248
00:14:11,852 --> 00:14:15,989 line:-2
因为我们现在知道
这些播放列表更新是最新数据


249
00:14:16,557 --> 00:14:19,326 line:-1
我们可以用它们携带一些信息


250
00:14:19,526 --> 00:14:22,429 line:-2
那可以帮助我们把切换到其它
比特率层的速度变得更快一些


251
00:14:23,697 --> 00:14:27,000 line:-2
换句话说
假如我们在CDN上有两种比特率


252
00:14:27,568 --> 00:14:29,102 line:-1
客户端正在以第一种比特率播放


253
00:14:30,204 --> 00:14:35,108 line:-2
当它请求更新时
它会收到1MB播放列表的最新版本


254
00:14:35,342 --> 00:14:39,046 line:-1
它可以携带其它信息


255
00:14:39,580 --> 00:14:42,883 line:-2
比如如果它决定它需要切换到
2MB的比特率


256
00:14:43,150 --> 00:14:45,719 line:-1
它可以直接获取


257
00:14:45,986 --> 00:14:47,254 line:-1
2MB播放列表的最新版本


258
00:14:47,454 --> 00:14:50,390 line:-1
这就使切换比特率变得更有效率了


259
00:14:51,525 --> 00:14:54,061 line:-1
因此这五个变更是


260
00:14:55,429 --> 00:14:58,599 line:-2
我们减少发布延迟
把我们的媒体内容放在CDN上


261
00:14:58,999 --> 00:15:00,667 line:-1
优化视频段的发觉


262
00:15:01,268 --> 00:15:02,803 line:-1
我们消除往返


263
00:15:03,303 --> 00:15:05,973 line:-1
我们减少转移播放列表的消耗


264
00:15:06,240 --> 00:15:08,909 line:-1
并且我们使切换层的速度尽可能地快


265
00:15:09,576 --> 00:15:11,979 line:-1
现在让我们具体看一下


266
00:15:14,748 --> 00:15:17,484 line:-1
为了让这些新功能运作起来


267
00:15:19,686 --> 00:15:22,089 line:-1
客户端需要一种方式来告诉服务器端


268
00:15:22,356 --> 00:15:25,192 line:-1
它想确保这些新功能


269
00:15:25,259 --> 00:15:28,362 line:-2
比如播放列表Delta更新
或阻止播放列表重新加载


270
00:15:30,731 --> 00:15:36,003 line:-2
它的实现方式是
使用HLS Origin API


271
00:15:38,005 --> 00:15:40,374 line:-1
它的运作方式是服务自身


272
00:15:40,440 --> 00:15:41,975 line:-1
是由服务器端使用一个新标签公布的


273
00:15:42,176 --> 00:15:44,378 line:-1
即服务器控制标签


274
00:15:45,579 --> 00:15:47,614 line:-1
当客户端发现服务可用时


275
00:15:47,881 --> 00:15:49,016 line:-1
它通过给服务器端发送少量指令


276
00:15:49,283 --> 00:15:52,052 line:-1
来使用它们


277
00:15:52,352 --> 00:15:57,291 line:-2
这些指令作为查询参数
放在对播放列表的get请求中


278
00:15:58,225 --> 00:15:59,626 line:-1
看起来是类似这样的东西


279
00:16:00,827 --> 00:16:01,662 line:-1
现在


280
00:16:03,564 --> 00:16:04,765 line:-1
这是首次


281
00:16:05,032 --> 00:16:08,168 line:-2
我们把查询参数
指定为HLS的一部分


282
00:16:08,936 --> 00:16:09,803 line:-1
因此


283
00:16:10,170 --> 00:16:14,007 line:-1
我们会继续储备所有查询参数


284
00:16:14,074 --> 00:16:17,611 line:-2
从播放列表URL上的
核心HLS开始


285
00:16:17,978 --> 00:16:19,346 line:-1
它用于协议的使用


286
00:16:20,214 --> 00:16:21,515 line:-1
我们要做的另一件事就是


287
00:16:21,748 --> 00:16:24,484 line:-1
确保在所有客户端


288
00:16:24,751 --> 00:16:29,289 line:-2
那些查询参数都以确定性顺序
出现在URL中


289
00:16:29,723 --> 00:16:33,260 line:-1
从而不会导致CDN缓存


290
00:16:33,460 --> 00:16:35,929 line:-1
同一请求的多个有效附本


291
00:16:36,864 --> 00:16:41,902 line:-2
现在让我们更具体地看一下
这五个变更


292
00:16:44,371 --> 00:16:46,673 line:-1
第一个是处理这个概念…


293
00:16:46,740 --> 00:16:49,376 line:-1
是减少发布延迟


294
00:16:49,443 --> 00:16:54,381 line:-2
因此我们向HLS引入了
部分视频段的概念


295
00:16:54,915 --> 00:16:56,650 line:-1
我们把这些简称为“部分”


296
00:16:57,851 --> 00:17:02,122 line:-2
因此部分视频段实际上就是
常规视频段的一个子集


297
00:17:02,422 --> 00:17:06,660 line:-2
包含那个父视频段内
所含媒体内容的一个子集


298
00:17:07,794 --> 00:17:12,665 line:-2
并且CMAF已经给这种内容
赋予了一个名字


299
00:17:12,733 --> 00:17:15,636 line:-1
叫作CAMF数据块或FMP4内容


300
00:17:16,036 --> 00:17:20,406 line:-2
因此在HLS中你可以使用
CMAF数据块作为部分代码段


301
00:17:20,741 --> 00:17:23,577 line:-1
你还可以使用少量传输流


302
00:17:23,644 --> 00:17:27,013 line:-2
或任何其它已定义的
HLS视频段格式


303
00:17:27,247 --> 00:17:28,515 line:-1
作为部分视频段


304
00:17:30,551 --> 00:17:32,519 line:-1
它们的主要问题在于它们很短


305
00:17:33,053 --> 00:17:35,022 line:-1
比如它们可以不到一个完整的GOP


306
00:17:35,088 --> 00:17:36,290 line:-1
那意味着你可以有


307
00:17:36,523 --> 00:17:40,294 line:-2
半秒钟的部分视频段并仍保持
两秒钟的GOP


308
00:17:42,763 --> 00:17:45,132 line:-1
每次你创建新的部分视频段时


309
00:17:45,332 --> 00:17:46,867 line:-1
它都被添加到播放列表中


310
00:17:47,234 --> 00:17:51,205 line:-2
那意味着如果你已经得到了半秒钟的
部分视频段 比如说


311
00:17:51,638 --> 00:17:55,576 line:-2
然后你可以在它击中你的产品后台
半秒钟后


312
00:17:56,143 --> 00:17:58,979 line:-1
把内容发布到你的CDN


313
00:17:59,246 --> 00:18:01,682 line:-1
它只能减少这么短时间的发布延迟


314
00:18:03,750 --> 00:18:05,819 line:-2
部分视频段与常规视频段流
同时被添加到播放列表中


315
00:18:06,153 --> 00:18:12,025 line:-1
但部分视频段不会保留太长时间


316
00:18:13,861 --> 00:18:18,465 line:-1
那是因为部分视频段主要


317
00:18:18,999 --> 00:18:20,667 line:-1
当播放非常接近现场时有用


318
00:18:20,734 --> 00:18:24,838 line:-1
它们可以让客户端尽快发现媒体内容


319
00:18:25,372 --> 00:18:30,377 line:-2
并且那些部分视频段的详细的
可处理性


320
00:18:30,644 --> 00:18:32,913 line:-1
允许加入那些视频流的客户端的


321
00:18:33,213 --> 00:18:37,017 line:-2
延迟时间更短
也许是最大的视频段范围


322
00:18:37,818 --> 00:18:42,923 line:-1
但在部分视频段偏离现场边界更远


323
00:18:42,990 --> 00:18:45,559 line:-2
并且它们的父视频段
已经在播放列表中创建好了


324
00:18:45,859 --> 00:18:47,227 line:-1
客户端实际上


325
00:18:47,294 --> 00:18:49,963 line:-2
加载父视频段
比加载部分视频段更明智


326
00:18:50,030 --> 00:18:53,033 line:-2
因此部分视频段
就从播放列表中移除了


327
00:18:53,767 --> 00:18:56,036 line:-1
这会帮助保持播放列表的紧凑性


328
00:18:56,970 --> 00:19:00,807 line:-1
它的运作方式是当你生产视频段时


329
00:19:00,974 --> 00:19:03,043 line:-1
你同时会生产部分视频段


330
00:19:03,677 --> 00:19:04,511 line:-1
不久之后


331
00:19:04,578 --> 00:19:08,415 line:-2
随着那些部分视频段距离现场边界
越来越远或足够远


332
00:19:08,615 --> 00:19:12,920 line:-2
它们就被移除并且替换为
处于现场边界的新的部分视频段


333
00:19:13,520 --> 00:19:16,290 line:-2
让我们在实际的HLS播放列表中
看一下这是如何运作的


334
00:19:17,891 --> 00:19:20,027 line:-1
我这里有一些东西


335
00:19:20,427 --> 00:19:23,330 line:-1
我希望你注意的第一件事是


336
00:19:23,630 --> 00:19:26,600 line:-1
就像常规播放列表有目标持续时间


337
00:19:26,800 --> 00:19:28,802 line:-1
表明视频段有多长一样


338
00:19:29,570 --> 00:19:32,539 line:-2
部分视频段也有同样的东西
叫做部分目标持续时间


339
00:19:32,773 --> 00:19:35,609 line:-2
它表明了这个播放列表中的
部分视频段


340
00:19:35,676 --> 00:19:39,346 line:-2
部分视频段最多有十分之一秒的
持续时间


341
00:19:39,413 --> 00:19:41,782 line:-2
要注意的下一件事是
我们这里有常规视频段


342
00:19:41,849 --> 00:19:43,617 line:-1
是一个6秒的视频段43


343
00:19:44,785 --> 00:19:48,422 line:-2
当我们把视频段43
放到播放列表中的半秒后


344
00:19:48,622 --> 00:19:52,926 line:-2
我们可以放…
我们可以添加视频段44的第一部分


345
00:19:53,227 --> 00:19:56,430 line:-2
我们使用一个新标签实现
叫做部分标签


346
00:19:57,030 --> 00:20:01,401 line:-2
因此你可以看到每个部分标签
都有一个URI


347
00:20:01,468 --> 00:20:04,371 line:-2
因此视频段获得…
部分视频段有自己的URI


348
00:20:04,605 --> 00:20:08,242 line:-1
视频段44.1是半秒钟


349
00:20:08,408 --> 00:20:11,178 line:-2
并且它是独立的
那意味着它有自己的URI


350
00:20:12,379 --> 00:20:13,580 line:-1
在此之后半秒钟


351
00:20:14,114 --> 00:20:17,618 line:-2
我们可以向播放列表中添加
视频段44的下一部分视频段


352
00:20:18,018 --> 00:20:19,086 line:-1
如此反复


353
00:20:19,152 --> 00:20:21,722 line:-2
这是一个6秒的播放列表
因此它将有12个部分视频段


354
00:20:22,422 --> 00:20:26,193 line:-2
一旦我们到达视频段44的
最后一部分


355
00:20:26,593 --> 00:20:29,730 line:-1
我们实际上已经拥有整个父视频段了


356
00:20:29,963 --> 00:20:33,567 line:-2
因此我们可以同时发布
视频段44的最后一部分


357
00:20:33,934 --> 00:20:35,969 line:-1
和父视频段


358
00:20:36,270 --> 00:20:39,006 line:-1
然后半秒钟之后 再次重复这种循环


359
00:20:39,306 --> 00:20:41,175 line:-1
我们就得到了视频段45


360
00:20:41,775 --> 00:20:44,211 line:-1
然后不久之后


361
00:20:44,511 --> 00:20:46,346 line:-1
中间的那些部分视频段


362
00:20:46,547 --> 00:20:49,149 line:-1
就距离播放列表的最前方足够远了


363
00:20:49,416 --> 00:20:50,684 line:-1
它们就可以被移除了


364
00:20:50,984 --> 00:20:54,655 line:-2
现在我们已经有了视频段43、
视频段44


365
00:20:54,922 --> 00:20:57,758 line:-1
以及视频段45的一部分及其以后


366
00:20:58,792 --> 00:21:02,196 line:-2
这就是我们如何使用部分视频段
来减少发布延迟的


367
00:21:02,863 --> 00:21:06,400 line:-2
现在让我们看一下
优化发现视频段的方式


368
00:21:07,968 --> 00:21:11,972 line:-2
我们通过叫做
阻止播放列表重加载的方式来实现


369
00:21:12,372 --> 00:21:13,340 line:-1
它的运作方式是


370
00:21:13,574 --> 00:21:16,276 line:-1
服务器端公布它可以


371
00:21:16,343 --> 00:21:18,345 line:-1
处理阻止播放列表重加载


372
00:21:18,745 --> 00:21:23,317 line:-2
通过在服务器控制标签中放一个
可以阻止重加载参数来实现


373
00:21:24,251 --> 00:21:25,519 line:-1
当客户端看到这个参数之后


374
00:21:25,786 --> 00:21:28,388 line:-2
它就知道它可以
在下一个播放列表更新之前


375
00:21:28,755 --> 00:21:30,557 line:-1
提前请求下一个播放列表更新


376
00:21:30,624 --> 00:21:32,860 line:-2
因此我们通过这种方式
来分担请求的消耗


377
00:21:34,361 --> 00:21:36,797 line:-1
那时服务器端收到请求


378
00:21:36,864 --> 00:21:39,166 line:-1
意识到还没有客户端请求


379
00:21:39,333 --> 00:21:40,501 line:-1
播放列表更新


380
00:21:40,701 --> 00:21:42,603 line:-1
那它就会保有它直到有请求为止


381
00:21:44,371 --> 00:21:47,708 line:-1
客户端是如何向服务器端指明


382
00:21:48,342 --> 00:21:50,143 line:-1
它想要哪个更新的呢


383
00:21:51,144 --> 00:21:54,214 line:-2
它想要一个包含部分视频段的
特定的播放列表更新


384
00:21:54,915 --> 00:21:58,352 line:-2
嗯 它使用HLS的一个功能
叫做媒体序列号


385
00:21:58,919 --> 00:22:04,424 line:-2
现在HLS播放列表中的每个视频段
都有唯一序列号


386
00:22:05,158 --> 00:22:07,728 line:-1
播放列表中第一个视频段的序列号


387
00:22:07,995 --> 00:22:10,163 line:-1
是你在顶部看到的


388
00:22:10,230 --> 00:22:11,231 line:-1
那个媒体序列标签的值


389
00:22:11,798 --> 00:22:13,433 line:-1
在这个例子中是1800


390
00:22:14,368 --> 00:22:18,038 line:-2
下一个视频段的媒体序列号就是
在它基础上加一


391
00:22:18,739 --> 00:22:19,606 line:-1
媒体序列号仍遵守上述规则


392
00:22:19,840 --> 00:22:24,211 line:-1
即使下一个视频段由不连续标签


393
00:22:24,478 --> 00:22:26,446 line:-2
或键旋转或其它任何东西
被从其它视频段中分离开


394
00:22:26,613 --> 00:22:28,649 line:-1
序列号会继续向前计数


395
00:22:30,250 --> 00:22:33,387 line:-1
那意味着如果我们有这个播放列表


396
00:22:33,820 --> 00:22:38,091 line:-1
然后我们知道下一次它更新时


397
00:22:38,425 --> 00:22:41,728 line:-1
下一个视频段的序列号是什么


398
00:22:42,763 --> 00:22:47,534 line:-2
因此为了获得
下一个包含视频段的更新


399
00:22:47,601 --> 00:22:49,169 line:-1
你知道的 下一个感兴趣的视频段


400
00:22:49,570 --> 00:22:52,072 line:-1
我们可以告诉服务器端 “嘿


401
00:22:52,272 --> 00:22:55,409 line:-2
请为我提供播放列表更新
我想要包含


402
00:22:55,609 --> 00:22:58,145 line:-1
媒体序列号为1803的媒体内容”


403
00:22:58,779 --> 00:23:00,147 line:-1
看起来就是这样的


404
00:23:00,781 --> 00:23:04,551 line:-2
因此我们在这里得到了
播放列表的请求


405
00:23:04,618 --> 00:23:06,820 line:-2
你可以看到它正在请求m3u8
格式的媒体内容


406
00:23:07,187 --> 00:23:12,893 line:-2
我们有个查询参数
HLS msn=1803


407
00:23:12,960 --> 00:23:14,595 line:-1
这是客户端告诉服务器端


408
00:23:14,962 --> 00:23:16,864 line:-1
我想要这个特定播放列表更新的方式


409
00:23:16,930 --> 00:23:19,032 line:-2
就是那个包含这个媒体序列号的
播放列表更新


410
00:23:19,867 --> 00:23:22,035 line:-2
在客户端收到播放列表更新之后
一收到播放列表更新


411
00:23:22,369 --> 00:23:25,606 line:-2
就立即发送下一个1804的
更新请求


412
00:23:26,406 --> 00:23:29,877 line:-2
那些对于CDN来说看起来是
完全不同的URL


413
00:23:29,943 --> 00:23:33,013 line:-1
即使只有一个查询参数的一个值不同


414
00:23:33,347 --> 00:23:36,450 line:-2
对于CDN来说
它是一个完全不同的可缓存的实体


415
00:23:36,817 --> 00:23:38,519 line:-1
因此那就为我们提供了缓存破坏


416
00:23:39,987 --> 00:23:42,756 line:-1
这对于部分视频段来说也能起作用


417
00:23:43,290 --> 00:23:45,392 line:-1
在这个例子中看起来是这样的


418
00:23:45,726 --> 00:23:47,261 line:-1
我们有第二个例子


419
00:23:47,628 --> 00:23:49,863 line:-1
第二个例子说


420
00:23:50,097 --> 00:23:53,834 line:-2
“我想要包含媒体序列号
为1803的视频段的


421
00:23:54,301 --> 00:23:57,538 line:-1
第一部分的播放列表更新”


422
00:23:59,540 --> 00:24:03,977 line:-2
现在这里还会执行另一个操作
即这个推送查询参数


423
00:24:04,044 --> 00:24:04,945 line:-1
那是什么？


424
00:24:05,846 --> 00:24:09,616 line:-1
嗯 还记得我们想要做的另一件事是


425
00:24:09,917 --> 00:24:14,321 line:-2
消除获取视频段的这些额外的
往返时间吧


426
00:24:14,788 --> 00:24:17,558 line:-1
为此我们使用了“推送”


427
00:24:18,292 --> 00:24:20,928 line:-1
为此我们要使用HTTP/2


428
00:24:22,729 --> 00:24:26,934 line:-2
因为有些人可能
不怎么熟悉HTTP/2


429
00:24:27,000 --> 00:24:28,569 line:-1
所以让我快速介绍一下


430
00:24:29,937 --> 00:24:33,540 line:-2
HTTP/2是我们的老伙伴
HTTP/1的继任者


431
00:24:34,374 --> 00:24:37,678 line:-2
大概在四年前IATF
对它进行了标准化


432
00:24:38,612 --> 00:24:43,250 line:-2
自那时起 它就被网络服务器、
客户端和CDN广泛采用


433
00:24:44,685 --> 00:24:47,821 line:-1
必须采用低延迟HLS


434
00:24:48,155 --> 00:24:50,257 line:-1
因为它为我们提供一些功能


435
00:24:50,557 --> 00:24:54,795 line:-1
可以让我们提高协议交换的效率


436
00:24:55,262 --> 00:24:57,231 line:-1
其中最值得注意的是“推送”


437
00:24:57,898 --> 00:24:58,932 line:-1
那么推送是如何运作的呢？


438
00:24:59,967 --> 00:25:00,801 line:-1
嗯


439
00:25:01,368 --> 00:25:04,338 line:-2
从客户端来说 HTTP/2的
运作方式与HTTP/1相同


440
00:25:04,404 --> 00:25:07,007 line:-1
当客户端想获得资源时


441
00:25:07,074 --> 00:25:08,709 line:-1
它会向服务器端发送get请求


442
00:25:09,209 --> 00:25:11,612 line:-1
HTTP/2中的新功能是


443
00:25:11,812 --> 00:25:14,548 line:-2
当服务器端看到请求后
它可以对自己说


444
00:25:14,982 --> 00:25:18,485 line:-2
“哦 我看到你想要这个资源了
我打赌你也想要这个其它资源”


445
00:25:19,019 --> 00:25:22,122 line:-1
当它给你发送你所请求的资源时


446
00:25:22,389 --> 00:25:24,658 line:-1
同时它还可以单方面地


447
00:25:24,858 --> 00:25:28,762 line:-2
开始给你发送那个你并不知道
你是否需要的二级资源


448
00:25:29,396 --> 00:25:31,365 line:-1
那样如果它猜对了


449
00:25:31,765 --> 00:25:34,401 line:-1
你就不必再次发出第二次请求了


450
00:25:34,468 --> 00:25:35,936 line:-1
因为它已经发送给你的路上了


451
00:25:37,171 --> 00:25:42,109 line:-2
因此我们在延迟HLS中
通过视频段推送利用了这个功能


452
00:25:43,243 --> 00:25:47,648 line:-1
当客户端请求包含下一个视频段x的


453
00:25:48,215 --> 00:25:50,517 line:-1
特定播放列表更新时


454
00:25:50,884 --> 00:25:53,487 line:-2
它可以告诉服务器端
“哦 顺便提一下


455
00:25:53,720 --> 00:25:57,057 line:-2
当你给我发送播放列表更新时
也开始给我推送视频段x吧”


456
00:25:58,091 --> 00:26:01,028 line:-1
那就允许我们剔除


457
00:26:01,361 --> 00:26:04,731 line:-1
请求视频段的额外的往返


458
00:26:06,266 --> 00:26:07,100 line:-1
那么


459
00:26:07,901 --> 00:26:11,939 line:-1
让我们看一下这前三种优化


460
00:26:12,372 --> 00:26:17,744 line:-2
看看相对于常规的HLS
它们是如何影响流程的


461
00:26:17,811 --> 00:26:18,912 line:-1
让我们把那个放在那儿


462
00:26:19,246 --> 00:26:22,316 line:-1
让我们看一下新流程


463
00:26:22,382 --> 00:26:25,118 line:-1
低延迟客户端与低延迟服务器端通讯


464
00:26:25,752 --> 00:26:29,523 line:-1
首先客户端会提前请求播放列表


465
00:26:29,590 --> 00:26:30,791 line:-1
请求会在那儿排队


466
00:26:31,091 --> 00:26:32,159 line:-1
服务器端保留它


467
00:26:32,459 --> 00:26:36,697 line:-2
同时服务器端也生产第一个
部分视频段


468
00:26:37,564 --> 00:26:41,268 line:-2
假如在这个例子中
部分视频段时长一秒钟


469
00:26:41,335 --> 00:26:43,403 line:-1
在它执行编码操作一秒钟后


470
00:26:43,904 --> 00:26:46,907 line:-2
那时它可以把部分视频段添加到
播放列表中


471
00:26:47,307 --> 00:26:49,209 line:-1
并解禁那个播放列表请求


472
00:26:49,910 --> 00:26:54,081 line:-1
同时向客户端推送第一个部分视频段


473
00:26:54,748 --> 00:26:58,151 line:-2
然后客户端会在收到足够多的视频段
之后尽快开始显示


474
00:26:58,652 --> 00:27:00,320 line:-1
与此同时


475
00:27:00,521 --> 00:27:02,422 line:-2
在服务器端上排列起下一个
播放列表请求


476
00:27:02,489 --> 00:27:06,927 line:-2
从而可以尽快发现
下一个出现的视频段


477
00:27:08,028 --> 00:27:11,431 line:-1
即使部分视频段的时长有一秒钟


478
00:27:11,798 --> 00:27:17,437 line:-1
你也可以看到这极大地减少了


479
00:27:17,704 --> 00:27:19,573 line:-1
指定媒体帧


480
00:27:19,640 --> 00:27:22,876 line:-1
从服务器端传输到客户端的时间


481
00:27:24,778 --> 00:27:27,281 line:-1
最后两个修改实际上是


482
00:27:27,614 --> 00:27:30,050 line:-1
对这个基本流程的优化


483
00:27:31,952 --> 00:27:34,288 line:-1
第一个是关于一遍一遍地减少


484
00:27:34,555 --> 00:27:37,224 line:-1
传输播放列表的消耗


485
00:27:37,858 --> 00:27:39,193 line:-1
减少传输消耗为什么重要呢？


486
00:27:40,093 --> 00:27:43,163 line:-1
嗯 如果你正在传输的播放列表


487
00:27:43,230 --> 00:27:47,267 line:-1
包含三小时或甚至是五小时的视频段


488
00:27:47,768 --> 00:27:51,672 line:-2
并且你正在以每秒传输三到四次的
速度传输它


489
00:27:52,206 --> 00:27:54,575 line:-2
传输速度就变得非常重要了
即使对于gzip也一样


490
00:27:55,943 --> 00:28:00,280 line:-2
所以我们添加了
Delta播放列表更新


491
00:28:01,548 --> 00:28:04,284 line:-1
它的运作方式是


492
00:28:04,651 --> 00:28:07,120 line:-1
再一次 服务器端宣布客户端可以…


493
00:28:07,187 --> 00:28:09,523 line:-1
可以提供Delta更新


494
00:28:09,590 --> 00:28:12,392 line:-2
它通过CAN…SKIP…UNTIL
属性实现


495
00:28:12,726 --> 00:28:15,796 line:-2
那会告诉客户端
如果你请求Delta更新


496
00:28:15,863 --> 00:28:17,164 line:-1
它将跳过所有的视频段


497
00:28:17,231 --> 00:28:19,967 line:-1
直到距离现场边界一定的秒数


498
00:28:20,567 --> 00:28:21,902 line:-1
如果客户端看到了


499
00:28:22,269 --> 00:28:24,605 line:-1
它知道它上次更新播放列表的时间


500
00:28:24,671 --> 00:28:25,639 line:-1
因此它算出


501
00:28:25,839 --> 00:28:29,109 line:-2
它可以执行Delta更新
而不会错过任何信息


502
00:28:29,643 --> 00:28:31,678 line:-2
然后它可以当它下一次更新
播放列表时


503
00:28:31,879 --> 00:28:34,348 line:-1
发起明确请求 请求Delta更新


504
00:28:35,983 --> 00:28:36,917 line:-1
那个更新


505
00:28:37,618 --> 00:28:43,323 line:-1
只包含播放列表中的最后几个视频段


506
00:28:43,390 --> 00:28:45,225 line:-1
就是距离现场边界最近的几个视频段


507
00:28:46,059 --> 00:28:48,095 line:-1
并且它跳过了较早的播放列表部分


508
00:28:48,161 --> 00:28:49,363 line:-1
因为客户端已经有了


509
00:28:52,699 --> 00:28:54,134 line:-1
这里有个例子


510
00:28:55,035 --> 00:29:00,374 line:-2
在这个例子中 你可以看到客户端
正在请求Delta更新


511
00:29:00,741 --> 00:29:05,412 line:-2
通过指定underscore HLS
underscore skip=YES查询参数实现


512
00:29:05,679 --> 00:29:08,549 line:-2
当它发起它的…
播放列表get请求时


513
00:29:10,050 --> 00:29:11,585 line:-1
在返回来的播放列表中


514
00:29:12,419 --> 00:29:14,254 line:-2
你会看到有一个
CAN-SKIP-UNTIL


515
00:29:14,655 --> 00:29:17,925 line:-2
它告诉客户端
当客户端请求Delta更新时


516
00:29:18,258 --> 00:29:20,127 line:-1
Delta更新将跳过一切


517
00:29:20,194 --> 00:29:22,896 line:-1
一直到距离现场边界前的36秒钟


518
00:29:23,997 --> 00:29:27,467 line:-2
然后这里的最后一个新标签是
这个跳过标签


519
00:29:28,001 --> 00:29:29,903 line:-1
你可以把跳过标签看作是


520
00:29:30,237 --> 00:29:35,209 line:-1
代替1700 xm视频段


521
00:29:35,275 --> 00:29:38,879 line:-2
可能存在于完整播放列表更新中的
xm视频段标签


522
00:29:40,747 --> 00:29:43,517 line:-1
那么这就是Delta更新


523
00:29:43,817 --> 00:29:47,754 line:-1
可以让我们真正最小化


524
00:29:47,821 --> 00:29:49,389 line:-1
用于不断地刷新播放列表的网络流量


525
00:29:49,456 --> 00:29:51,792 line:-1
而不会失去HLS播放列表


526
00:29:51,859 --> 00:29:53,360 line:-1
提供给你的任何普遍性和能力


527
00:29:54,461 --> 00:29:56,029 line:-1
现在让我们看一下最后一个修改


528
00:29:56,096 --> 00:30:01,235 line:-2
正是这个修改帮助我们更快地切换
比特率层


529
00:30:01,902 --> 00:30:03,570 line:-1
它们叫做“演奏报告”


530
00:30:04,037 --> 00:30:05,706 line:-1
我们的想法是


531
00:30:06,006 --> 00:30:09,476 line:-1
当你的客户端以特定比特率


532
00:30:09,543 --> 00:30:12,112 line:-1
加载特定播放列表的最新版本时


533
00:30:12,613 --> 00:30:18,185 line:-1
那个更新可以深入了解


534
00:30:18,452 --> 00:30:21,889 line:-2
客户端可能在下一秒或下两秒决定
或有兴趣切换到的其它视频段


535
00:30:23,590 --> 00:30:24,625 line:-1
特别是


536
00:30:25,225 --> 00:30:27,995 line:-2
“演奏报告”在它的最后一个
部分视频段序列号中


537
00:30:28,262 --> 00:30:31,565 line:-2
包含那个纯播放列表中的最后一个
媒体内容的序列号


538
00:30:31,899 --> 00:30:34,601 line:-1
那就为客户端提供了用于构成URL


539
00:30:34,835 --> 00:30:36,270 line:-1
以获取最新播放列表所需要的东西


540
00:30:36,970 --> 00:30:38,138 line:-1
它看起来是这样的


541
00:30:39,740 --> 00:30:40,774 line:-1
在这个例子中


542
00:30:41,275 --> 00:30:45,779 line:-2
我们让客户端请求
1MB播放列表的更新


543
00:30:46,346 --> 00:30:47,381 line:-1
当它请求时


544
00:30:47,447 --> 00:30:50,317 line:-1
它使用了HLS报告查询参数


545
00:30:50,784 --> 00:30:53,187 line:-1
请求深入查看


546
00:30:53,253 --> 00:30:54,454 line:-2
位于同一台服务器上的
2MB播放列表


547
00:30:55,889 --> 00:30:57,457 line:-1
当它得到播放列表时


548
00:30:57,891 --> 00:31:00,494 line:-2
播放列表也包含一个
“演奏报告”标签


549
00:31:00,994 --> 00:31:05,098 line:-1
里面包含关于其他视频段的各种信息


550
00:31:07,100 --> 00:31:10,437 line:-1
因此如果我们把这些都放在一起


551
00:31:12,072 --> 00:31:14,474 line:-1
问题是它们可以一起发挥作用吗？


552
00:31:15,876 --> 00:31:17,010 line:-1
你们想看一个演示吗？


553
00:31:21,014 --> 00:31:21,849 line:-1
让我们做个演示吧


554
00:31:22,683 --> 00:31:27,387 line:-2
你知道的
当我们把这些会话放在一起时


555
00:31:27,855 --> 00:31:29,556 line:-2
我们像是“是的
我们可以做个现场演示


556
00:31:29,623 --> 00:31:31,558 line:-2
或我们可以做一个
库比蒂诺的现场直播”


557
00:31:32,025 --> 00:31:35,362 line:-2
但如果我们从距离我们更远的地方
做现场演示


558
00:31:35,429 --> 00:31:38,265 line:-1
不是更有说明力吗？


559
00:31:38,899 --> 00:31:42,970 line:-1
也许距离我们7000英里


560
00:31:43,036 --> 00:31:45,506 line:-1
也许是12000英里


561
00:31:45,739 --> 00:31:47,007 line:-1
比如澳大利亚悉尼？


562
00:31:51,211 --> 00:31:54,047 line:-1
但等一下 我们认识悉尼的人吗？


563
00:31:55,382 --> 00:31:56,783 line:-1
Matt 我们认识Matt


564
00:31:57,351 --> 00:31:58,285 line:-1
让我们呼叫Matt


565
00:32:02,222 --> 00:32:03,290 line:-1
好的 让我们看一下


566
00:32:03,657 --> 00:32:04,825 line:-1
天啊 我希望Matt已经醒了


567
00:32:13,934 --> 00:32:14,935 line:-1
日安Roger


568
00:32:15,302 --> 00:32:16,637 line:-1
嘿Matt 你好吗？


569
00:32:17,404 --> 00:32:18,272 line:-1
我很好 谢谢


570
00:32:18,739 --> 00:32:22,743 line:-2
太棒了 嘿 告诉你
我现在正在参加WWDC


571
00:32:23,010 --> 00:32:26,046 line:-1
我想给大家演示一下低延迟HLS


572
00:32:26,513 --> 00:32:28,148 line:-1
你那个视频流还在运行吗？


573
00:32:28,882 --> 00:32:29,783 line:-1
当然了


574
00:32:29,850 --> 00:32:31,084 line:-1
哦 太好了


575
00:32:31,818 --> 00:32:34,922 line:-1
好的 让我们…让我们打开它


576
00:32:34,988 --> 00:32:36,023 line:-1
看看我们有什么


577
00:32:36,456 --> 00:32:38,358 line:-1
我有Apple TV


578
00:32:38,525 --> 00:32:39,626 line:-1
好的 这就好


579
00:32:40,294 --> 00:32:42,763 line:-2
好的 嘿 太神奇了
我在Apple TV里


580
00:32:43,564 --> 00:32:45,165 line:-1
好吧 让我们打开我们的app


581
00:32:45,232 --> 00:32:48,535 line:-2
这里有悉尼视频流 让我们打开它
看看我们得到了什么


582
00:32:53,774 --> 00:32:55,609 line:-1
并没有开始播放悉尼视频流


583
00:32:56,476 --> 00:32:58,178 line:-1
让我们再尝试一下


584
00:33:04,484 --> 00:33:07,254 line:-1
好的 让我试试库比蒂诺视频流


585
00:33:07,321 --> 00:33:09,790 line:-2
只是为了看看是否有人…
哦 有Simon


586
00:33:09,857 --> 00:33:10,924 line:-1
Simon在库比蒂诺


587
00:33:11,325 --> 00:33:15,495 line:-2
所以那是…
我们把Simon关掉


588
00:33:17,364 --> 00:33:20,334 line:-1
好吧 让我们再试一下这个


589
00:33:20,400 --> 00:33:21,368 line:-1
我们…


590
00:33:22,836 --> 00:33:27,074 line:-1
哎呦 来吧 我该怎么搞定这个呢？


591
00:33:28,775 --> 00:33:30,677 line:-2
Matt 你还在啊
好的 呀 你还在


592
00:33:30,744 --> 00:33:32,746 line:-2
-是的 我还在这里 你好
-好的 太棒了


593
00:33:35,349 --> 00:33:37,985 line:-2
但是 嘿 你知道的
你后面是悉尼邮政总局吗？


594
00:33:38,952 --> 00:33:39,820 line:-1
当然是


595
00:33:40,287 --> 00:33:41,655 line:-1
哦 伙计 来吧


596
00:33:42,389 --> 00:33:44,458 line:-1
我们没有…抱歉…我要再试一次


597
00:33:52,533 --> 00:33:56,603 line:-2
今天我的视频流
并没有像我预期的那样


598
00:33:58,272 --> 00:33:59,740 line:-1
是的 Simon还在


599
00:34:01,642 --> 00:34:02,476 line:-1
哦 伙计


600
00:34:04,378 --> 00:34:06,813 line:-2
然后那是…好的那是…
是的 那是Matt


601
00:34:08,215 --> 00:34:10,050 line:-1
我要点击播放吗 还是暂停？


602
00:34:12,786 --> 00:34:14,353 line:-1
嗯 你知道吗


603
00:34:15,054 --> 00:34:18,257 line:-1
也许我们最后要呼叫Simon


604
00:34:18,458 --> 00:34:19,560 line:-1
那让我有点失望


605
00:34:19,626 --> 00:34:21,527 line:-1
因为我其实想给你们演示视频流


606
00:34:23,864 --> 00:34:24,697 line:-1
让我们看一下


607
00:34:25,264 --> 00:34:26,567 line:-1
屏住呼吸 好了吗？


608
00:34:27,400 --> 00:34:28,768 line:-1
你们需要重启视频流吗？


609
00:34:29,803 --> 00:34:31,103 line:-1
刚才网络断开了


610
00:34:31,170 --> 00:34:32,239 line:-1
网络断开了？


611
00:34:32,806 --> 00:34:33,639 line:-1
太棒了


612
00:34:40,280 --> 00:34:41,748 line:-1
好的 我们有…


613
00:34:42,014 --> 00:34:45,485 line:-2
让我看一下是否也许
我们是否没插好？


614
00:34:48,155 --> 00:34:49,723 line:-1
这些现场演示真的要搞死我了


615
00:35:01,268 --> 00:35:02,936 line:-1
双击这个会…


616
00:35:05,839 --> 00:35:06,974 line:-1
试着不用这个了


617
00:35:07,241 --> 00:35:09,676 line:-2
是的 我不知道这是否会帮助我
但让我们抛弃它吧


618
00:35:16,083 --> 00:35:17,150 line:-1
哦 伙计


619
00:35:18,018 --> 00:35:21,388 line:-2
好的 我认为我们要
再试一次 然后…


620
00:35:21,889 --> 00:35:24,324 line:-1
我们就要寻求备选方案了


621
00:35:24,892 --> 00:35:25,726 line:-1
好吧


622
00:35:26,360 --> 00:35:29,162 line:-2
抱歉Matt
我们的视频流出问题了


623
00:35:29,229 --> 00:35:30,264 line:-1
因此让我…


624
00:35:31,431 --> 00:35:35,102 line:-2
感谢你的出现
我们只能见你这么一小会儿


625
00:35:35,169 --> 00:35:37,104 line:-1
但我现在要连线库比蒂诺了


626
00:35:37,171 --> 00:35:38,038 line:-1
好吧 没问题


627
00:35:38,472 --> 00:35:39,339 line:-1
好的


628
00:35:39,740 --> 00:35:42,109 line:-2
嗯 这真的令人失望 但无论怎样
让我呼叫Simon吧


629
00:35:42,876 --> 00:35:44,411 line:-1
我猜这就是为什么需要备份的原因


630
00:35:49,883 --> 00:35:50,918 line:-1
嘿 Simon 你在吗？


631
00:35:51,552 --> 00:35:53,387 line:-1
是的 我在Roger 你好吗？


632
00:35:53,620 --> 00:35:55,422 line:-1
很好 Simon也是澳大利亚人


633
00:35:55,489 --> 00:35:57,991 line:-2
我意识到那不是…这是一种
于事无补的安慰 但他在那儿


634
00:35:58,058 --> 00:35:59,293 line:-1
澳大利亚人随处可见


635
00:36:01,228 --> 00:36:06,133 line:-2
Simon 我想给这里的
家伙们演示低延迟HLS视频流


636
00:36:06,600 --> 00:36:07,467 line:-1
哦 当然


637
00:36:08,035 --> 00:36:09,236 line:-1
那么我们为什么不这样做呢


638
00:36:09,303 --> 00:36:11,205 line:-1
我要让你举起手来


639
00:36:11,471 --> 00:36:12,940 line:-1
然后人们会听到你说…


640
00:36:13,006 --> 00:36:16,043 line:-2
如果你在举手的时候说了
他们会通过音频听到你的声音


641
00:36:16,109 --> 00:36:17,311 line:-1
然后他们才会在视频流上看到你


642
00:36:17,377 --> 00:36:20,180 line:-2
那会给你…给他们一种关于
视频延迟的概念


643
00:36:20,247 --> 00:36:21,748 line:-2
-那么为什么不举起你的手呢…
-哦 当然


644
00:36:23,817 --> 00:36:24,818 line:-1
好的 举起你的手


645
00:36:26,053 --> 00:36:27,020 line:-1
嘿 大家好


646
00:36:27,821 --> 00:36:29,423 line:-2
-我举起我的手了
-好的


647
00:36:29,857 --> 00:36:31,091 line:-1
很好 一直举着


648
00:36:31,758 --> 00:36:33,327 line:-1
并且…哦 你放下了


649
00:36:34,494 --> 00:36:37,331 line:-1
好的 现在 举起三根手指


650
00:36:38,232 --> 00:36:39,132 line:-1
三根手指


651
00:36:40,067 --> 00:36:40,934 line:-1
我们看到了


652
00:36:41,168 --> 00:36:44,071 line:-1
所以那是个…它们要 你知道的…


653
00:36:44,872 --> 00:36:47,407 line:-1
HLS视频流有不到两秒钟的延迟


654
00:36:48,175 --> 00:36:50,244 line:-2
Simon非常感谢你
今天对我们的帮助


655
00:36:50,777 --> 00:36:53,647 line:-2
当然 我希望你们能度过一个
愉快的WWDC


656
00:36:54,081 --> 00:36:54,915 line:-1
谢谢


657
00:36:56,049 --> 00:37:00,621 line:-1
好的 那么这就是低延迟HLS


658
00:37:01,021 --> 00:37:03,490 line:-1
在这点上 有些人很可能在想


659
00:37:03,824 --> 00:37:06,627 line:-2
我该如何为我提供那些HLS低延迟
媒体内容呢？


660
00:37:07,694 --> 00:37:08,529 line:-1
那么


661
00:37:09,162 --> 00:37:12,032 line:-1
首先许多人都是app开发人员


662
00:37:12,099 --> 00:37:13,700 line:-1
因此让我先讲一下app


663
00:37:15,836 --> 00:37:17,237 line:-1
好消息是 默认情况下


664
00:37:17,304 --> 00:37:20,574 line:-2
你们不需要做任何操作 如果你正
使用AV Player播放视频流


665
00:37:20,641 --> 00:37:22,976 line:-2
并且你支持低延迟视频流的话
你将默认得到低延迟媒体内容


666
00:37:24,311 --> 00:37:26,513 line:-1
然而我们确实有一些新API


667
00:37:27,514 --> 00:37:30,884 line:-2
其中一个会告诉你 你当前设置的
时间点距离现场边界有多远


668
00:37:31,084 --> 00:37:33,086 line:-1
另一个是一个推荐


669
00:37:33,253 --> 00:37:36,023 line:-2
根据我们所观察到的东西进行推荐
比如往返时间


670
00:37:36,256 --> 00:37:38,525 line:-2
因此你可以结合使用两个API
来进行配置


671
00:37:38,759 --> 00:37:40,794 line:-1
比如 如果你看到延迟风险太大了


672
00:37:40,861 --> 00:37:42,863 line:-1
你可以把它降低一点


673
00:37:42,930 --> 00:37:43,997 line:-1
也许我们应该在这里实现


674
00:37:44,932 --> 00:37:49,036 line:-1
第二个是一种让你维持播放头


675
00:37:49,203 --> 00:37:50,404 line:-1
相对于现场边界的位置的方式


676
00:37:50,470 --> 00:37:52,639 line:-1
它之所以有意思是因为


677
00:37:52,940 --> 00:37:54,908 line:-1
今天如果你正在播放现场直播


678
00:37:54,975 --> 00:37:57,411 line:-2
然后你穿过隧道或其它什么东西
并缓冲10秒钟


679
00:37:57,477 --> 00:38:00,047 line:-2
当你恢复时
将从你停止的那一时刻开始恢复


680
00:38:00,380 --> 00:38:01,782 line:-1
意思就是你不会错过任何东西


681
00:38:01,849 --> 00:38:04,384 line:-2
但每一次你缓冲时
你都落后一小点


682
00:38:04,885 --> 00:38:08,889 line:-2
因此如果你把距离现场边界的
保留时间偏移自动设置为“是”


683
00:38:09,189 --> 00:38:12,926 line:-2
然后每一次我们缓冲之后
我们将不能自动向前跳动到


684
00:38:13,193 --> 00:38:14,494 line:-1
距离现场边界的同一个位置


685
00:38:14,561 --> 00:38:15,929 line:-1
因此 那会让你保持现场直播


686
00:38:16,663 --> 00:38:19,299 line:-1
要考虑的下一件事是配置你的CDN


687
00:38:21,001 --> 00:38:22,870 line:-1
我们真的很想避免


688
00:38:24,204 --> 00:38:27,875 line:-2
在CDN上放置外来的
针对视频的要求


689
00:38:27,941 --> 00:38:31,078 line:-2
因为我们希望CDN的重点主要是
成为很棒的CDN


690
00:38:31,512 --> 00:38:33,180 line:-1
因此我们做到直截了当


691
00:38:33,947 --> 00:38:36,483 line:-2
你需要使用符合行业标准的
HTTP/2


692
00:38:36,550 --> 00:38:38,552 line:-1
来提交你的HSL视频段和播放列表


693
00:38:38,619 --> 00:38:41,788 line:-2
那包含支持“推送”
和标准的优先级控制


694
00:38:42,956 --> 00:38:46,226 line:-2
你应该在每台服务器上都放一个
完整的层阶梯


695
00:38:46,293 --> 00:38:48,295 line:-1
你仍然可以有多台冗余的服务器


696
00:38:48,362 --> 00:38:52,199 line:-2
但每一台应该有完整的阶梯
以便我们可以最小化连接设置时间


697
00:38:53,166 --> 00:38:57,137 line:-2
并且你需要设置你的CDN
从而聚合重复请求


698
00:38:57,204 --> 00:38:59,373 line:-1
如果Fred请求特定播放列表


699
00:38:59,540 --> 00:39:01,108 line:-1
它会进入源并获取它


700
00:39:01,275 --> 00:39:03,110 line:-1
然后如果Bob请求同样的内容


701
00:39:03,177 --> 00:39:05,379 line:-1
你不要通过CDN发送同样的请求


702
00:39:05,445 --> 00:39:06,947 line:-1
你应该把它放在Fred的请求旁边


703
00:39:07,147 --> 00:39:09,082 line:-1
等待返回来的第一个响应


704
00:39:09,283 --> 00:39:10,484 line:-1
然后再同时提交给他们


705
00:39:11,051 --> 00:39:12,953 line:-2
不同的CDN对这个过程
有不同的命名


706
00:39:13,020 --> 00:39:15,289 line:-2
Apache Traffic Server
把它叫做读写器


707
00:39:15,589 --> 00:39:19,293 line:-2
其它可能把它叫做提早发布
或类似的名字


708
00:39:19,359 --> 00:39:21,261 line:-1
重点是找到它并设置好它


709
00:39:23,197 --> 00:39:25,899 line:-1
这里的主要工作是实施你的源


710
00:39:25,966 --> 00:39:28,335 line:-1
修改用于发出部分视频段的程序包


711
00:39:28,602 --> 00:39:30,404 line:-1
并实施源API


712
00:39:30,904 --> 00:39:34,575 line:-2
为了帮助你们实现这个操作 我们
针对低延迟HLS发布了一个规范


713
00:39:34,641 --> 00:39:35,909 line:-1
你可以从网站上找到它


714
00:39:35,976 --> 00:39:39,847 line:-1
在我们的演讲页面也有一个链接


715
00:39:40,581 --> 00:39:42,683 line:-1
它当前是一个单独的草案


716
00:39:42,749 --> 00:39:45,786 line:-2
我们计划在今年下半年把规则
放到课程包里


717
00:39:46,420 --> 00:39:49,590 line:-1
它包含一些新东西即服务器配置分析


718
00:39:49,790 --> 00:39:53,060 line:-1
那包含服务器提交链的一组属性


719
00:39:53,126 --> 00:39:55,762 line:-1
需要在客户端采用低延迟模式


720
00:39:56,129 --> 00:39:58,832 line:-2
客户端会检查这些属性
如果它看到不能满足所有属性的话


721
00:39:59,066 --> 00:40:00,834 line:-1
它会退回到常规延迟


722
00:40:02,069 --> 00:40:05,873 line:-1
同时我们还提供了一个引用实施


723
00:40:05,939 --> 00:40:10,177 line:-1
用于生产和串流低延迟HLS视频流


724
00:40:10,911 --> 00:40:13,847 line:-2
它叫做低延迟
HLS Beta工具包


725
00:40:14,581 --> 00:40:17,217 line:-2
它包含一些工具
可以生成一个播放列表


726
00:40:17,284 --> 00:40:20,254 line:-2
是程序化Bitbop
或从摄像头生成


727
00:40:20,487 --> 00:40:22,756 line:-1
并把它打包到低延迟视频流中


728
00:40:23,423 --> 00:40:25,692 line:-1
它包含Apache的一个前端


729
00:40:26,026 --> 00:40:27,995 line:-1
实施源API


730
00:40:28,061 --> 00:40:31,565 line:-2
包括阻止播放列表重加载、
Delta更新、演奏报告


731
00:40:31,932 --> 00:40:35,235 line:-2
你可以使用它在你的app中
试验低延迟


732
00:40:35,302 --> 00:40:36,336 line:-1
或当你创建它时


733
00:40:36,603 --> 00:40:39,072 line:-1
把它与后台实施进行对比


734
00:40:40,307 --> 00:40:44,444 line:-2
那么这就是你作为开发人员
需要了解和实施的操作


735
00:40:44,511 --> 00:40:46,280 line:-1
让我们谈谈用户


736
00:40:46,880 --> 00:40:50,551 line:-2
我们意识到低延迟HLS是一个
重大的变更


737
00:40:51,151 --> 00:40:56,290 line:-1
因此我们允许你花点时间来了解它


738
00:40:56,857 --> 00:40:57,891 line:-1
并且我们…


739
00:40:57,958 --> 00:41:01,261 line:-1
支持你对客户端的实施


740
00:41:01,962 --> 00:41:04,198 line:-1
简而言之


741
00:41:04,264 --> 00:41:06,600 line:-1
你需要一个低延迟模式的app权利


742
00:41:06,834 --> 00:41:08,202 line:-2
这允许你通过TestFlight
面向最多10000名测试用户


743
00:41:08,402 --> 00:41:10,237 line:-1
创建你的app、测试你的视频流


744
00:41:10,304 --> 00:41:12,639 line:-1
甚至是部署视频流


745
00:41:13,006 --> 00:41:14,508 line:-1
然后一旦你确认


746
00:41:14,741 --> 00:41:16,844 line:-2
一切都没问题了
那么测试阶段就结束了


747
00:41:17,044 --> 00:41:19,112 line:-1
你就可以把app提交到商店中了


748
00:41:19,546 --> 00:41:22,683 line:-1
因此总而言之 请一定要看规范文档


749
00:41:23,217 --> 00:41:24,418 line:-1
在测试模式中试着用一下


750
00:41:25,385 --> 00:41:28,555 line:-2
并开始创建你的后台
以支持低延迟现场直播视频流


751
00:41:29,089 --> 00:41:30,657 line:-1
为了帮助你们实现这个操作


752
00:41:31,124 --> 00:41:34,161 line:-2
今天或本周我们有一些
HLS相关的演讲


753
00:41:34,595 --> 00:41:37,497 line:-1
我和我们团队的一些同事将会参加


754
00:41:37,564 --> 00:41:40,501 line:-2
我们将非常乐于回答
关于低延迟HLS的任何疑问


755
00:41:40,801 --> 00:41:42,402 line:-1
以及其它关于HLS的任何疑问


756
00:41:42,636 --> 00:41:44,905 line:-2
第一场演讲是在
周四下午4点到6点


757
00:41:45,105 --> 00:41:48,609 line:-2
第二场演讲 我想是在周五的
上午11点到下午1点


758
00:41:49,142 --> 00:41:52,079 line:-1
非常感谢你们的参与


759
00:41:52,246 --> 00:41:53,714 line:-1
我希望每个人都有精彩的表现

