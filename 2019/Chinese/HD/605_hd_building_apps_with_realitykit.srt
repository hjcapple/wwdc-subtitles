1
00:00:00,506 --> 00:00:04,500
[音乐]


2
00:00:09,016 --> 00:00:10,236
[掌声]


3
00:00:10,236 --> 00:00:13,766
>> 大家好


4
00:00:13,766 --> 00:00:14,886
我叫 Ross


5
00:00:14,886 --> 00:00:16,666
是 Apple RealityKit 团队的工程师


6
00:00:16,666 --> 00:00:18,686
欢迎来到通过 RealityKit 构建 App


7
00:00:19,766 --> 00:00:23,076
本场会议是一个后续会议


8
00:00:23,076 --> 00:00:24,786
你可能需要先查看一下先前的会议


9
00:00:24,786 --> 00:00:27,206
RealityKit 和 Reality Composer 的介绍


10
00:00:27,686 --> 00:00:28,596
今天我们要讲的是


11
00:00:28,596 --> 00:00:30,216
RealityKit 的应用方法


12
00:00:30,216 --> 00:00:31,136
我们将指导你


13
00:00:31,136 --> 00:00:32,226
创建增强现实 App


14
00:00:32,226 --> 00:00:33,686
告诉你如何使用


15
00:00:33,686 --> 00:00:35,156
很多框架的关键功能


16
00:00:35,706 --> 00:00:36,856
在深入了解之前 先简单回顾一下


17
00:00:36,856 --> 00:00:38,386
RealityKit 是什么


18
00:00:39,056 --> 00:00:40,916
RealityKit 是 Apple 的新框架


19
00:00:40,916 --> 00:00:43,986
用于构建 AR App


20
00:00:44,076 --> 00:00:46,296
致力于为所有开发人员


21
00:00:46,296 --> 00:00:48,066
提供简单直观的体验


22
00:00:48,726 --> 00:00:50,636
可以让你从零开始使用 AR


23
00:00:50,636 --> 00:00:52,096
可以将渲染过的内容


24
00:00:52,096 --> 00:00:54,436
和真实世界的场景无缝融合


25
00:00:54,436 --> 00:00:57,126
它的 Swift API 操作简单


26
00:00:57,126 --> 00:00:58,536
功能强大 只需几行代码


27
00:00:58,536 --> 00:00:59,716
就可以帮你完成很多工作


28
00:01:00,586 --> 00:01:01,696
好了 让我们构建一个 App


29
00:01:02,956 --> 00:01:03,826
我们今天要构建的 App


30
00:01:03,826 --> 00:01:05,556
名字叫做 Memory Cards


31
00:01:05,816 --> 00:01:06,766
顾名思义


32
00:01:06,766 --> 00:01:08,476
就是一款卡片匹配游戏


33
00:01:09,736 --> 00:01:10,806
点按这张卡片选择它


34
00:01:10,806 --> 00:01:12,476
就可以看到它的图像


35
00:01:12,986 --> 00:01:14,946
选择另一张卡片 显示图像


36
00:01:14,946 --> 00:01:16,276
如果这对卡片是匹配的


37
00:01:16,276 --> 00:01:17,006
它们就被移除


38
00:01:17,726 --> 00:01:19,106
如果这两张卡片不匹配


39
00:01:19,106 --> 00:01:20,506
卡片就会翻过去


40
00:01:20,506 --> 00:01:21,226
你可以选择下一对


41
00:01:21,926 --> 00:01:23,636
这个游戏很简单


42
00:01:23,636 --> 00:01:24,726
但可以让我们关注和讨论


43
00:01:24,726 --> 00:01:26,016
很多 RealityKit 有用的功能


44
00:01:26,016 --> 00:01:28,186
我们将分四个阶段


45
00:01:28,186 --> 00:01:29,306
构建  Memory Cards


46
00:01:30,156 --> 00:01:30,876
首先 我们要合成一个原型


47
00:01:30,876 --> 00:01:33,226
能将我们的内容


48
00:01:33,226 --> 00:01:34,796
放在 AR 里


49
00:01:34,796 --> 00:01:35,976
还能做一些简单交互


50
00:01:37,596 --> 00:01:38,896
接下来我们要进行润色


51
00:01:38,896 --> 00:01:40,306
加一些精致的艺术元素


52
00:01:40,306 --> 00:01:41,916
提高性能和 AR 渲染


53
00:01:43,176 --> 00:01:46,406
然后利用实体组件系统来追踪


54
00:01:46,406 --> 00:01:47,186
用户状态信息


55
00:01:48,596 --> 00:01:49,706
最后我们向你展示


56
00:01:49,706 --> 00:01:50,706
如何使用 RealityKit 的内置网络支持


57
00:01:50,706 --> 00:01:53,576
在游戏中添加多人游戏


58
00:01:55,396 --> 00:01:57,226
好了 开始制作我们的原型


59
00:01:57,886 --> 00:01:59,856
在之前的介绍会议中提过


60
00:01:59,856 --> 00:02:01,346
有四个对象


61
00:02:01,346 --> 00:02:07,446
在每个 RealityKit App 中都会用到  


62
00:02:07,446 --> 00:02:11,636
ARView 场景 锚点 和 实体


63
00:02:12,206 --> 00:02:15,056
ARView 是你进入


64
00:02:15,056 --> 00:02:15,736
AR 世界的窗口


65
00:02:16,146 --> 00:02:17,946
也是使用 RealityKit 的起点


66
00:02:18,606 --> 00:02:19,896
它是一个视图


67
00:02:19,896 --> 00:02:21,136
属于 App 的视图层次结构


68
00:02:21,696 --> 00:02:24,106
场景包含虚拟内容


69
00:02:24,106 --> 00:02:25,086
用于构建你的 App


70
00:02:25,086 --> 00:02:26,816
它属于 ARView


71
00:02:29,506 --> 00:02:31,146
在 RealityKit 中 锚点描述


72
00:02:31,146 --> 00:02:32,846
对象与真实世界的关联


73
00:02:33,156 --> 00:02:34,116
需要有它们


74
00:02:34,316 --> 00:02:35,716
才能放置你的虚拟内容


75
00:02:36,326 --> 00:02:37,766
放置锚点的方法


76
00:02:37,766 --> 00:02:39,076
是将其添加在场景中


77
00:02:39,076 --> 00:02:40,406
如果合适的目标出现


78
00:02:40,406 --> 00:02:42,546
锚点将自动被放置在世界中


79
00:02:43,436 --> 00:02:44,636
对 Memory Cards 这个游戏


80
00:02:44,636 --> 00:02:45,656
我们用一个锚点


81
00:02:45,656 --> 00:02:46,886
将游戏面板放在水平面上


82
00:02:47,836 --> 00:02:49,606
实体用于表示


83
00:02:49,606 --> 00:02:50,916
你的虚拟内容


84
00:02:51,136 --> 00:02:52,676
也是构建场景的基本单位


85
00:02:53,196 --> 00:02:54,876
在 Memory Cards 中


86
00:02:54,876 --> 00:02:56,586
每张卡片都由一个实体表示


87
00:02:57,186 --> 00:02:58,716
你的游戏有 16 张卡片


88
00:02:58,716 --> 00:03:00,206
我们就需要 16 个实体


89
00:03:01,656 --> 00:03:02,996
我们现在已经知道了


90
00:03:02,996 --> 00:03:05,656
App 中所需要的重要元素


91
00:03:05,656 --> 00:03:07,216
现在谈谈如何创建锚点


92
00:03:07,216 --> 00:03:08,846
来将虚拟游戏面板


93
00:03:08,846 --> 00:03:11,126
放到现实世界中


94
00:03:12,216 --> 00:03:13,266
RealityKit 的锚定 


95
00:03:13,266 --> 00:03:14,976
基于 ARKit 并与之整合而成


96
00:03:14,976 --> 00:03:17,246
所以你可以使用它的完整功能集


97
00:03:18,516 --> 00:03:20,366
要定义锚点的内容


98
00:03:20,366 --> 00:03:21,446
你要创建一个锚点实体


99
00:03:22,146 --> 00:03:25,616
明确你要用的锚点类型


100
00:03:25,616 --> 00:03:27,076
然后把锚点实体加到场景中


101
00:03:27,556 --> 00:03:30,236
一旦 ARKit 发现合适目标


102
00:03:30,236 --> 00:03:33,426
锚点实体就会自动跟踪


103
00:03:33,426 --> 00:03:34,986
让你的虚拟内容


104
00:03:34,986 --> 00:03:35,956
如同在现实世界一样


105
00:03:35,956 --> 00:03:38,586
随着你设备的移动而移动


106
00:03:40,266 --> 00:03:41,276
像介绍会议中所说的


107
00:03:41,276 --> 00:03:43,016
RealityKit 支持


108
00:03:43,016 --> 00:03:44,026
ARKit 中所有类型的锚点


109
00:03:44,026 --> 00:03:45,206
能让我们能够锚定


110
00:03:45,206 --> 00:03:46,516
平面 人脸 图像 物体 


111
00:03:46,856 --> 00:03:49,696
新的 ARKit 3 


112
00:03:49,696 --> 00:03:51,836
还有身体锚点


113
00:03:53,376 --> 00:03:54,816
在 Memory Cards 中 我们只需要


114
00:03:54,816 --> 00:03:56,516
一个锚点放置游戏面板


115
00:03:57,686 --> 00:03:58,706
我们需要把它放在一个


116
00:03:58,706 --> 00:04:00,006
有足够空间的水平面上


117
00:04:00,006 --> 00:04:01,236
能放下所有卡片


118
00:04:01,236 --> 00:04:03,286
大约为 20 平方厘米


119
00:04:04,346 --> 00:04:05,416
这个锚点就代表


120
00:04:05,416 --> 00:04:07,176
在世界中的游戏面板


121
00:04:07,176 --> 00:04:08,626
我们把内容放在上面


122
00:04:09,416 --> 00:04:10,526
为此 我们需要写一些代码


123
00:04:11,706 --> 00:04:14,076
这是 Memory Cards 原型的视图控制器


124
00:04:14,586 --> 00:04:15,996
我们在视图层次结构中


125
00:04:15,996 --> 00:04:17,426
放置一个 ARView 


126
00:04:17,426 --> 00:04:18,706
我们已经准备好找锚点


127
00:04:18,706 --> 00:04:19,946
创建我们的虚拟内容


128
00:04:20,636 --> 00:04:23,606
我们将在 viewDidLoad 方法中创建


129
00:04:25,366 --> 00:04:26,946
为了定义我们的锚


130
00:04:26,946 --> 00:04:28,856
我们创建一个锚实体


131
00:04:28,856 --> 00:04:30,266
利用这个便捷的初始程序


132
00:04:30,266 --> 00:04:32,526
我们可以指定锚定的平面类型


133
00:04:32,526 --> 00:04:34,216
这个例子里是水平平面


134
00:04:35,336 --> 00:04:38,476
我们可以输入需要的最小面积


135
00:04:38,476 --> 00:04:39,326
20 平方厘米


136
00:04:40,246 --> 00:04:41,496
RealityKit 的单位是米


137
00:04:41,786 --> 00:04:44,166
所以 20 厘米乘以 20 厘米


138
00:04:44,166 --> 00:04:47,626
就应该是 0.2 乘以 0.2


139
00:04:48,086 --> 00:04:50,316
然后我们把锚点放在场景中


140
00:04:50,316 --> 00:04:51,566
只要 RealityKit 发现一个


141
00:04:51,566 --> 00:04:52,786
大于 20 平方厘米的水平平面


142
00:04:52,786 --> 00:04:54,656
我们放在这个锚点上的


143
00:04:54,656 --> 00:04:55,756
虚拟内容就会


144
00:04:55,756 --> 00:04:56,306
出现在 AR 里


145
00:04:56,946 --> 00:04:59,356
现在已经建好了锚点


146
00:04:59,356 --> 00:05:00,686
让我们加一些虚拟内容


147
00:05:01,346 --> 00:05:02,576
首先我们需要加载模型


148
00:05:03,326 --> 00:05:04,586
RealityKit 原生支持


149
00:05:04,586 --> 00:05:06,386
USDZ 格式的素材


150
00:05:06,516 --> 00:05:07,696
以及新的 Reality File 格式


151
00:05:08,766 --> 00:05:09,326
加载可以同步完成


152
00:05:09,326 --> 00:05:10,866
也可以异步完成


153
00:05:11,036 --> 00:05:13,176
现在我们从同步加载开始


154
00:05:13,176 --> 00:05:16,456
稍后 我们会仔细讲解


155
00:05:16,456 --> 00:05:18,236
当你加载 USDZ


156
00:05:18,236 --> 00:05:19,586
或者 Reality File 素材时


157
00:05:19,586 --> 00:05:20,956
RealityKit 会自动导入


158
00:05:20,956 --> 00:05:23,126
实体层次结构


159
00:05:23,126 --> 00:05:25,806
使用的网格 它的材料


160
00:05:25,806 --> 00:05:27,726
以及可能使用的动画


161
00:05:29,886 --> 00:05:31,396
让我们加载基本的卡片素材


162
00:05:31,966 --> 00:05:34,396
要加载模型


163
00:05:34,396 --> 00:05:36,026
你只需要调用 Entity.loadModel 方法


164
00:05:36,216 --> 00:05:37,196
并提供素材名称


165
00:05:37,866 --> 00:05:38,816
如果素材在你的 App 包里


166
00:05:38,816 --> 00:05:41,146
就不需要指定文件扩展名


167
00:05:42,426 --> 00:05:43,556
如果 RealityKit 可以加载素材


168
00:05:43,556 --> 00:05:44,766
它就会自动创建一个


169
00:05:44,766 --> 00:05:47,326
随时可用的实体供你使用


170
00:05:47,986 --> 00:05:49,146
我们在这里加载了


171
00:05:49,146 --> 00:05:50,666
八个基本的卡片模型


172
00:05:50,666 --> 00:05:51,316
存储在数组中


173
00:05:51,926 --> 00:05:55,376
Memory Cards 共有 16 张卡片


174
00:05:56,366 --> 00:05:57,876
有八种不同的卡片


175
00:05:57,876 --> 00:05:58,586
每种的图像不同


176
00:05:58,916 --> 00:06:00,666
每种类型需要有两个实例


177
00:06:00,666 --> 00:06:03,536
才能帮助我们创建八对卡片


178
00:06:04,436 --> 00:06:05,496
现在只加载了八个类型的模型


179
00:06:05,526 --> 00:06:07,346
另外八个模型应该怎么做呢


180
00:06:08,496 --> 00:06:10,466
我们可以再调用一次


181
00:06:10,466 --> 00:06:12,196
Entity.loadModel 方法


182
00:06:12,196 --> 00:06:13,476
之前我们在所有卡片上进行的设置


183
00:06:13,476 --> 00:06:14,846
也要在这些卡片上


184
00:06:14,846 --> 00:06:15,306
都进行一遍


185
00:06:16,746 --> 00:06:17,826
RealityKit 提供了更方便的解决方法


186
00:06:17,826 --> 00:06:19,616
实体克隆


187
00:06:20,206 --> 00:06:22,646
创建一个克隆体


188
00:06:22,646 --> 00:06:23,616
需要调用 Entity.clone 方法


189
00:06:24,966 --> 00:06:26,146
可以创建一个


190
00:06:26,146 --> 00:06:27,646
和原来一模一样的实体


191
00:06:28,996 --> 00:06:29,976
它引用的所有素材


192
00:06:29,976 --> 00:06:32,576
都和原实体一样


193
00:06:32,576 --> 00:06:33,486
克隆也可以递归完成


194
00:06:33,626 --> 00:06:36,176
这样可以克隆实体的所有子实体


195
00:06:36,176 --> 00:06:37,996
这在处理


196
00:06:37,996 --> 00:06:39,076
具有多层次机构的


197
00:06:39,136 --> 00:06:41,366
复杂场景时非常有用


198
00:06:41,996 --> 00:06:44,146
需要注意的是


199
00:06:44,146 --> 00:06:45,876
克隆实体是原实体的副本


200
00:06:45,876 --> 00:06:48,386
而不是实例


201
00:06:48,386 --> 00:06:49,906
如果你对原实体


202
00:06:49,906 --> 00:06:51,246
做了一些改变 比方说


203
00:06:51,246 --> 00:06:53,106
移除了一个子实体


204
00:06:53,106 --> 00:06:54,226
这个改变不会出现在


205
00:06:54,226 --> 00:06:55,366
已经存在的克隆体中


206
00:06:56,466 --> 00:06:57,866
让我们开始克隆


207
00:06:57,866 --> 00:06:58,506
制作卡片对


208
00:06:59,086 --> 00:07:01,836
我们在这里克隆了


209
00:07:01,836 --> 00:07:03,236
每种卡片类型的两个实例


210
00:07:03,236 --> 00:07:04,676
把它们储存在


211
00:07:04,676 --> 00:07:06,266
两个数组中


212
00:07:06,266 --> 00:07:07,096
用于构建我们的游戏面板


213
00:07:08,406 --> 00:07:09,696
我们可以使用原始的卡片模版


214
00:07:09,696 --> 00:07:10,626
只克隆一个新的实例


215
00:07:10,626 --> 00:07:12,206
但是这样将卡片模版单独保留


216
00:07:12,206 --> 00:07:13,286
稍后 我们可以


217
00:07:13,286 --> 00:07:14,456
轻松地再次引用


218
00:07:14,456 --> 00:07:15,616
重新创建游戏面板


219
00:07:15,856 --> 00:07:17,796
而不需要从头开始加载模版


220
00:07:19,916 --> 00:07:21,426
你现在有 16 张卡片


221
00:07:21,426 --> 00:07:22,806
我们需要把它们


222
00:07:22,806 --> 00:07:23,596
放在游戏面板中


223
00:07:24,336 --> 00:07:26,576
锚点居于游戏区域的中心位置


224
00:07:26,576 --> 00:07:27,706
我们把卡片摆成


225
00:07:27,826 --> 00:07:30,266
四乘四的网格状


226
00:07:30,706 --> 00:07:31,916
下面我们需要


227
00:07:31,916 --> 00:07:33,056
把每张卡片与锚点联系起来


228
00:07:33,056 --> 00:07:34,386
它们就会出现在 AR 里


229
00:07:35,026 --> 00:07:38,036
为此 我们需要计算


230
00:07:38,036 --> 00:07:39,426
每张卡片的位置


231
00:07:39,426 --> 00:07:41,286
根据其下标和数组


232
00:07:41,286 --> 00:07:42,496
确定它的位置属性


233
00:07:43,226 --> 00:07:45,336
当我们在锚点上


234
00:07:45,336 --> 00:07:47,066
添加卡片时


235
00:07:47,096 --> 00:07:48,156
锚点就相当于父项目


236
00:07:48,816 --> 00:07:51,376
这就是我们需要做的


237
00:07:51,376 --> 00:07:52,906
在 AR 中排列我们的卡片


238
00:07:52,956 --> 00:07:54,066
并进行渲染


239
00:07:54,736 --> 00:07:56,366
现在我们把卡片放在


240
00:07:56,366 --> 00:07:58,006
AR 中的一个平面上 


241
00:07:58,006 --> 00:07:59,186
但它们什么都做不了


242
00:07:59,186 --> 00:07:59,976
让我们添加交互


243
00:08:00,656 --> 00:08:02,946
我们希望点按它们的时候


244
00:08:02,946 --> 00:08:05,106
卡片翻转 为了达到这个效果


245
00:08:05,106 --> 00:08:06,466
我们需要把


246
00:08:06,466 --> 00:08:08,126
设备屏幕上的点按 


247
00:08:08,126 --> 00:08:09,836
转换为 AR 世界里的点按 这样


248
00:08:09,876 --> 00:08:11,486
我们就知道 点按的是什么


249
00:08:12,316 --> 00:08:13,156
RealityKit提供了一个点触检测


250
00:08:13,156 --> 00:08:14,966
来解决这个问题


251
00:08:16,386 --> 00:08:18,116
点触检测的工作原理


252
00:08:18,116 --> 00:08:19,556
是将设备屏幕上


253
00:08:19,556 --> 00:08:21,526
点按的 2D 点转换为


254
00:08:21,526 --> 00:08:22,396
虚拟场景中的光线


255
00:08:23,236 --> 00:08:24,826
然后将光线投射到场景中


256
00:08:24,826 --> 00:08:26,556
RealityKit 找到


257
00:08:26,556 --> 00:08:28,786
光线指向的所有对象


258
00:08:29,286 --> 00:08:31,086
并返回


259
00:08:31,086 --> 00:08:32,385
光线指向的


260
00:08:32,385 --> 00:08:34,256
所有实体


261
00:08:34,256 --> 00:08:35,606
让你知道点按的对象是什么


262
00:08:37,145 --> 00:08:38,405
ARView 提供了


263
00:08:38,405 --> 00:08:38,986
点触检测的方法


264
00:08:39,285 --> 00:08:40,535
entity(at point:)返回


265
00:08:40,535 --> 00:08:42,106
所给点距摄像头最近的实体


266
00:08:42,106 --> 00:08:44,066
entities(at point:)


267
00:08:44,066 --> 00:08:45,516
返回所给点处


268
00:08:45,516 --> 00:08:47,006
光线指向的


269
00:08:47,136 --> 00:08:48,146
所有实体


270
00:08:48,616 --> 00:08:51,196
我们可以轻松地将其


271
00:08:51,196 --> 00:08:52,216
集成到我们的 Memory Cards App 中


272
00:08:53,076 --> 00:08:54,746
我们有一个方法响应


273
00:08:54,786 --> 00:08:56,496
点按手势识别器


274
00:08:57,116 --> 00:08:58,556
我们在 ARView 中


275
00:08:58,556 --> 00:09:00,206
确定点按的位置 


276
00:09:00,206 --> 00:09:01,806
然后传递 entity(at:)


277
00:09:01,806 --> 00:09:03,456
因为我们只想获得


278
00:09:03,566 --> 00:09:04,626
最靠近设备的实体


279
00:09:05,596 --> 00:09:06,876
如果点按位置下有一个实体


280
00:09:06,876 --> 00:09:09,636
这个方法就会返回实体


281
00:09:09,636 --> 00:09:10,896
我们就可以


282
00:09:10,896 --> 00:09:12,616
和它进行交互


283
00:09:13,436 --> 00:09:14,506
但仍需要再做一件事


284
00:09:14,506 --> 00:09:15,586
才能使点按检测


285
00:09:15,586 --> 00:09:16,966
正常工作


286
00:09:18,646 --> 00:09:20,026
对点按检测的实体来说


287
00:09:20,086 --> 00:09:21,426
它们需要一个可碰撞的形状


288
00:09:22,926 --> 00:09:24,636
碰撞形状是一个简化的几何形状


289
00:09:24,636 --> 00:09:26,356
通常是个盒子


290
00:09:27,086 --> 00:09:28,346
它们很容易检测


291
00:09:28,346 --> 00:09:30,236
也可以进行有效的交叉


292
00:09:30,236 --> 00:09:31,736
和碰撞计算


293
00:09:32,426 --> 00:09:34,326
更重要的是


294
00:09:34,326 --> 00:09:36,086
没有碰撞形状


295
00:09:36,086 --> 00:09:37,296
实体则无法进行点按检测


296
00:09:37,516 --> 00:09:39,086
所以让我们给卡片增加形状


297
00:09:39,826 --> 00:09:43,426
这个代码和之前制作模型 


298
00:09:43,426 --> 00:09:44,766
创建卡片模版的代码相同


299
00:09:45,336 --> 00:09:47,836
我们在这里做一个小改动


300
00:09:47,836 --> 00:09:50,216
加上实体生成


301
00:09:50,276 --> 00:09:51,236
碰撞形状的方法


302
00:09:52,086 --> 00:09:53,446
这将自动为实体生成


303
00:09:53,676 --> 00:09:55,346
简单的盒子碰撞形状


304
00:09:55,346 --> 00:09:58,476
利用实体的视觉边界


305
00:09:59,016 --> 00:10:00,516
可以看到 与克隆相似


306
00:10:00,516 --> 00:10:01,886
这个方法可以递归地


307
00:10:01,966 --> 00:10:05,086
为实体所有的子实体


308
00:10:05,086 --> 00:10:06,176
创建碰撞形状


309
00:10:07,206 --> 00:10:08,126
说到克隆


310
00:10:08,446 --> 00:10:09,686
碰撞形状包含在


311
00:10:09,686 --> 00:10:10,986
实体克隆时


312
00:10:10,986 --> 00:10:11,886
复制的数据中


313
00:10:12,656 --> 00:10:13,806
由于我们已经准备好


314
00:10:13,806 --> 00:10:14,696
克隆卡片模版


315
00:10:14,696 --> 00:10:15,586
来构建游戏面板


316
00:10:15,586 --> 00:10:17,496
因此它们也就自动包含了


317
00:10:17,496 --> 00:10:18,446
这些碰撞形状


318
00:10:18,656 --> 00:10:21,346
现在我们可以弄清楚


319
00:10:21,346 --> 00:10:22,806
我们互动的实体是什么


320
00:10:22,976 --> 00:10:24,196
让我们加上一个动画


321
00:10:24,196 --> 00:10:25,266
点按卡片的时候就会播放


322
00:10:26,056 --> 00:10:27,946
RealityKit 支持两种动画


323
00:10:28,156 --> 00:10:30,356
第一个是变换动画


324
00:10:30,356 --> 00:10:31,776
可以让你在代码中


325
00:10:32,016 --> 00:10:36,446
为实体的位置 旋转 和缩放


326
00:10:36,446 --> 00:10:37,566
设计动画


327
00:10:38,186 --> 00:10:40,686
第二个是素材动画


328
00:10:40,686 --> 00:10:41,966
它播放的动画


329
00:10:41,966 --> 00:10:43,226
是嵌入到


330
00:10:43,226 --> 00:10:44,716
从 USDZ 或者 Reality File 中


331
00:10:44,716 --> 00:10:46,896
加载的素材里的


332
00:10:47,526 --> 00:10:49,506
RealityKit 还提供了


333
00:10:49,506 --> 00:10:50,856
完成处理器


334
00:10:50,856 --> 00:10:52,376
可应用于这两种动画


335
00:10:52,376 --> 00:10:54,006
让你知道 动画何时结束


336
00:10:55,166 --> 00:10:57,566
一旦我们的卡片素材


337
00:10:57,566 --> 00:10:59,236
没有嵌入的动画


338
00:10:59,236 --> 00:11:00,186
那么为了翻转卡片 


339
00:11:00,186 --> 00:11:02,136
我们将在卡片实体上使用变换动画


340
00:11:05,206 --> 00:11:06,506
变换动画可以使用


341
00:11:06,506 --> 00:11:07,696
多种多样的计时功能


342
00:11:07,696 --> 00:11:10,316
来控制动画的播放速度


343
00:11:11,306 --> 00:11:12,536
这是线性 以恒定速率


344
00:11:12,536 --> 00:11:13,776
播放动画


345
00:11:13,996 --> 00:11:15,306
加速和减速


346
00:11:15,306 --> 00:11:16,386
都是瞬时完成的


347
00:11:16,686 --> 00:11:19,116
这是渐入


348
00:11:19,116 --> 00:11:20,536
在持续的时间内


349
00:11:20,576 --> 00:11:21,626
逐渐提高动画速度


350
00:11:22,296 --> 00:11:24,696
渐出与渐入相反


351
00:11:24,696 --> 00:11:25,816
会使动画减速


352
00:11:25,816 --> 00:11:27,126
直至完成


353
00:11:27,796 --> 00:11:30,436
渐入渐出还可以


354
00:11:30,686 --> 00:11:32,056
结合使用


355
00:11:32,056 --> 00:11:33,056
将动画加速到时间轴的中点


356
00:11:33,056 --> 00:11:34,586
然后减速


357
00:11:34,586 --> 00:11:35,976
直至完成


358
00:11:36,546 --> 00:11:38,836
还有一个贝塞尔曲线


359
00:11:38,836 --> 00:11:40,436
可以定制你的


360
00:11:40,436 --> 00:11:41,126
计时功能


361
00:11:41,636 --> 00:11:43,346
让我们为翻转卡片


362
00:11:43,346 --> 00:11:43,886
创建一个动画


363
00:11:44,556 --> 00:11:46,966
我们首先要复制一下


364
00:11:47,076 --> 00:11:49,276
卡片当前的形状


365
00:11:49,936 --> 00:11:51,376
这可以确保 


366
00:11:51,376 --> 00:11:52,596
保留当前实体的


367
00:11:52,596 --> 00:11:54,196
比例和变化


368
00:11:54,296 --> 00:11:55,636
这是我们不想改变的


369
00:11:57,456 --> 00:11:59,346
接下来我们将使用四元参数


370
00:11:59,346 --> 00:12:01,566
将变换设置为


371
00:12:01,566 --> 00:12:03,616
围绕 X 轴的 180 度旋转


372
00:12:03,966 --> 00:12:05,596
这样就可以翻转卡片


373
00:12:05,596 --> 00:12:06,576
使图像朝上


374
00:12:06,656 --> 00:12:09,976
现在开始制作动画


375
00:12:10,606 --> 00:12:12,216
变换动画


376
00:12:12,216 --> 00:12:13,786
使用实体的 move(to:) 方法


377
00:12:15,136 --> 00:12:16,096
RealityKit 可以让


378
00:12:16,096 --> 00:12:17,176
加了动画的实体


379
00:12:17,176 --> 00:12:18,386
在当前状态和方法中的变换


380
00:12:18,386 --> 00:12:19,466
流畅过渡


381
00:12:19,986 --> 00:12:20,946
使用请求的计时功能


382
00:12:20,946 --> 00:12:22,556
在这个例子中


383
00:12:22,556 --> 00:12:24,566
是在给定的时间长度内执行 easeInOut


384
00:12:25,626 --> 00:12:27,406
这给了我们


385
00:12:27,406 --> 00:12:28,926
卡片翻转至正面向上所需的动画


386
00:12:29,386 --> 00:12:32,646
实体的 move 方法


387
00:12:32,646 --> 00:12:33,576
提供了播放控制器


388
00:12:33,576 --> 00:12:37,886
可以让你暂停 恢复 或停止动画或接收


389
00:12:37,886 --> 00:12:39,006
动画完成的通知


390
00:12:39,006 --> 00:12:40,426
就像我们现在做的一样


391
00:12:41,026 --> 00:12:43,806
然后翻转卡片


392
00:12:43,806 --> 00:12:45,236
使其正面向下


393
00:12:45,236 --> 00:12:46,976
我们只需要做个小调整


394
00:12:46,976 --> 00:12:49,096
让变换的旋转设置归零


395
00:12:49,296 --> 00:12:50,786
当我们调用这个 move 方法


396
00:12:50,786 --> 00:12:51,986
卡片就可以


397
00:12:51,986 --> 00:12:53,356
翻转朝下


398
00:12:55,406 --> 00:12:56,756
现在我们的 App


399
00:12:56,756 --> 00:12:58,056
能够互动了


400
00:12:58,056 --> 00:12:59,396
使用点按检测


401
00:12:59,396 --> 00:13:01,266
检查用户选择的对象


402
00:13:01,266 --> 00:13:02,976
用变换动画隐藏卡片


403
00:13:06,046 --> 00:13:07,056
现在我们完成了基本的工作


404
00:13:07,056 --> 00:13:08,326
让我们增加一些细节


405
00:13:08,326 --> 00:13:10,146
来改进一下


406
00:13:10,716 --> 00:13:12,976
我们已经加载了简单的卡片模型


407
00:13:12,976 --> 00:13:14,966
并把它们放在了 AR 里


408
00:13:14,966 --> 00:13:17,076
但卡片上的 2D 图像有些无趣


409
00:13:18,056 --> 00:13:19,176
感谢我们的美术团队


410
00:13:19,176 --> 00:13:20,366
创作了一系列高质量的模型


411
00:13:20,366 --> 00:13:21,866
我们把它们添加到组合中


412
00:13:21,866 --> 00:13:24,096
让我们的 App 更加立体


413
00:13:24,656 --> 00:13:27,156
我们可以用之前


414
00:13:27,156 --> 00:13:28,696
同步加载的 Entity.load 方法


415
00:13:28,696 --> 00:13:30,556
加载这些新的素材


416
00:13:31,076 --> 00:13:32,436
但是这些模型


417
00:13:32,436 --> 00:13:34,396
比之前简单的卡片素材


418
00:13:34,396 --> 00:13:35,226
复杂的多


419
00:13:35,226 --> 00:13:36,756
加载这些更大的素材


420
00:13:36,756 --> 00:13:37,446
需要更长时间


421
00:13:37,926 --> 00:13:40,096
加载可能会很快


422
00:13:40,096 --> 00:13:41,446
但加载的同时


423
00:13:41,446 --> 00:13:41,946
App 也可能会阻塞


424
00:13:42,926 --> 00:13:44,226
如果你正在加载大量素材


425
00:13:44,226 --> 00:13:45,186
而这些会累积起来


426
00:13:45,186 --> 00:13:47,316
造成明显延迟影响体验


427
00:13:48,136 --> 00:13:49,436
我们能做些什么改善情况呢


428
00:13:50,726 --> 00:13:51,806
还好我们之前提过


429
00:13:51,806 --> 00:13:53,106
RealityKit 支持


430
00:13:53,106 --> 00:13:54,786
同步加载和异步加载


431
00:13:55,576 --> 00:13:56,446
我们可以通过调用


432
00:13:56,446 --> 00:13:57,666
Entity.loadModelAsync 方法


433
00:13:57,666 --> 00:14:00,896
异步加载模型


434
00:14:01,046 --> 00:14:02,106
使用异步加载


435
00:14:02,556 --> 00:14:03,396
素材可以在后台加载


436
00:14:03,396 --> 00:14:05,836
这样就可以解放 App


437
00:14:05,836 --> 00:14:07,076
使它继续运行而不被干扰


438
00:14:07,116 --> 00:14:08,506
让你的 App


439
00:14:08,506 --> 00:14:10,266
响应流畅


440
00:14:10,266 --> 00:14:14,216
也让 ARKit 继续观察世界的情况


441
00:14:14,536 --> 00:14:16,266
当异步加载完成


442
00:14:16,266 --> 00:14:17,676
你会收到一个回调


443
00:14:17,676 --> 00:14:18,566
然后就可以使用你的素材


444
00:14:18,566 --> 00:14:21,136
就像在同步加载时所做的一样


445
00:14:21,946 --> 00:14:23,486
此外 你还可以把


446
00:14:23,486 --> 00:14:24,636
加载请求结合起来


447
00:14:24,636 --> 00:14:26,446
同时执行它们


448
00:14:26,726 --> 00:14:28,056
在所有素材加载完成以后


449
00:14:28,056 --> 00:14:29,136
接收通知


450
00:14:29,306 --> 00:14:30,186
所以你不需要一点一点地


451
00:14:30,186 --> 00:14:31,326
下载素材


452
00:14:32,136 --> 00:14:33,186
让我们编写一些代码


453
00:14:33,186 --> 00:14:34,796
异步加载我们的新模型


454
00:14:36,056 --> 00:14:37,426
我们首先异步加载


455
00:14:37,516 --> 00:14:39,046
单个模型


456
00:14:39,846 --> 00:14:41,516
Entity.loadModelAsync 方法


457
00:14:41,686 --> 00:14:43,176
需要素材的名称


458
00:14:43,436 --> 00:14:44,966
就像同步加载一样


459
00:14:45,656 --> 00:14:48,276
它会返回一个加载请求


460
00:14:48,276 --> 00:14:49,316
用于当模型加载完成并


461
00:14:49,316 --> 00:14:52,016
可以投入使用时接收通知


462
00:14:52,596 --> 00:14:54,546
我们采用闭包


463
00:14:54,546 --> 00:14:56,056
调用 sink 方法


464
00:14:56,056 --> 00:14:57,266
在素材准备完成时执行


465
00:14:58,246 --> 00:15:00,456
加载请求使用的 API


466
00:15:00,456 --> 00:15:01,536
是从新的 Swift 框架


467
00:15:01,536 --> 00:15:02,416
Combine 中引入的


468
00:15:02,816 --> 00:15:03,696
因此我推荐大家


469
00:15:03,696 --> 00:15:05,216
查看一下 Introducing Combine 和


470
00:15:05,216 --> 00:15:06,346
Advances in Foundation 两场会议


471
00:15:06,346 --> 00:15:08,656
这就是实现


472
00:15:08,656 --> 00:15:10,356
异步加载内容的操作


473
00:15:10,706 --> 00:15:11,856
现在你可以像这样


474
00:15:11,856 --> 00:15:13,416
分开下载所有的素材


475
00:15:13,856 --> 00:15:14,966
你也可以将多个加载请求


476
00:15:14,966 --> 00:15:16,716
合并为一个


477
00:15:19,046 --> 00:15:19,896
我们可以通过简单地


478
00:15:19,956 --> 00:15:21,146
将另一个加载请求


479
00:15:21,276 --> 00:15:22,126
附加在第一个上


480
00:15:22,676 --> 00:15:25,316
然后调用 collect


481
00:15:25,316 --> 00:15:26,326
将两个加载请求组合起来


482
00:15:26,876 --> 00:15:28,876
之后我们调用 sink


483
00:15:29,036 --> 00:15:30,506
当两个模型加载完成


484
00:15:30,506 --> 00:15:31,956
闭包就开始执行


485
00:15:31,956 --> 00:15:33,466
打包到数组


486
00:15:33,466 --> 00:15:35,896
参数模型中以便处理


487
00:15:38,256 --> 00:15:39,766
我们可以根据自己的需要进行扩展


488
00:15:40,356 --> 00:15:41,676
我们集合了


489
00:15:41,676 --> 00:15:43,046
八个复杂的卡片模型


490
00:15:43,046 --> 00:15:44,426
做成一个加载请求


491
00:15:45,916 --> 00:15:46,816
我们的 sink 闭包


492
00:15:46,816 --> 00:15:48,146
会在八个卡片模型加载结束后


493
00:15:48,396 --> 00:15:49,026
开始执行


494
00:15:49,656 --> 00:15:50,756
组合和加载请求的闭包


495
00:15:50,756 --> 00:15:52,346
让内容管理更加简单


496
00:15:55,106 --> 00:15:55,866
我们展示一下


497
00:15:55,866 --> 00:15:57,266
同步加载和异步加载的对比


498
00:15:57,266 --> 00:16:00,466
左边的 App 使用的是同步加载


499
00:16:00,466 --> 00:16:01,566
右边是异步加载


500
00:16:01,566 --> 00:16:03,306
一旦同步的 App 


501
00:16:03,306 --> 00:16:04,836
开始加载 其他的工作都停了


502
00:16:04,836 --> 00:16:06,596
因为 App 被阻塞


503
00:16:06,596 --> 00:16:07,556
直到加载完成


504
00:16:08,216 --> 00:16:09,806
作为对比 异步的 App


505
00:16:09,806 --> 00:16:11,076
还能继续响应


506
00:16:11,386 --> 00:16:12,506
用户的输入


507
00:16:12,506 --> 00:16:14,766
更新摄像头


508
00:16:14,766 --> 00:16:15,706
你还可以继续


509
00:16:15,706 --> 00:16:18,006
观察摄像头前的世界


510
00:16:18,196 --> 00:16:19,046
这两个 App 加载的时间


511
00:16:19,046 --> 00:16:20,836
都是相同的


512
00:16:20,836 --> 00:16:22,256
但使用异步加载的设备


513
00:16:22,256 --> 00:16:23,286
可以首先显示内容


514
00:16:23,606 --> 00:16:24,746
因为它可以让你


515
00:16:24,746 --> 00:16:26,076
在加载的同时


516
00:16:26,356 --> 00:16:26,986
继续观察世界的情况


517
00:16:27,186 --> 00:16:27,956
但使用同步加载的设备


518
00:16:27,956 --> 00:16:29,636
则无法做到


519
00:16:29,876 --> 00:16:31,706
所以异步加载更适合


520
00:16:31,706 --> 00:16:33,256
与 AR 一起使用


521
00:16:35,006 --> 00:16:35,626
所以 我们需要


522
00:16:35,626 --> 00:16:36,396
加载复杂模型


523
00:16:36,396 --> 00:16:37,506
而不用暂停 App


524
00:16:37,826 --> 00:16:39,526
但是精明的观察者


525
00:16:39,526 --> 00:16:40,446
可能已经注意到了


526
00:16:40,446 --> 00:16:42,076
卡片朝下时 还是能看到模型
 
00:16:43,356 --> 00:16:44,366
当卡片朝下时


527
00:16:44,366 --> 00:16:45,436
我们可以简单地隐藏模型


528
00:16:45,436 --> 00:16:46,356
但我们无法阻止


529
00:16:46,356 --> 00:16:47,626
用户弯腰查看


530
00:16:47,626 --> 00:16:48,996
卡片下面的内容


531
00:16:48,996 --> 00:16:49,876
查找配对的卡片


532
00:16:50,126 --> 00:16:52,606
而不是翻转卡片


533
00:16:52,716 --> 00:16:54,386
所以 RealityKit 有一个


534
00:16:54,386 --> 00:16:56,696
特别有用的方法来解决遮挡材料


535
00:16:57,396 --> 00:16:58,496
遮挡材料是不可见的


536
00:16:58,496 --> 00:17:00,056
当应用在场景中的


537
00:17:00,056 --> 00:17:01,516
几何体上时


538
00:17:01,516 --> 00:17:03,136
就会隐藏后面的虚拟内容


539
00:17:03,886 --> 00:17:05,146
显示穿过虚拟内容的影像


540
00:17:05,685 --> 00:17:06,836
这里你们可以看到


541
00:17:06,836 --> 00:17:07,896
我们在场景中


542
00:17:07,896 --> 00:17:09,086
加了遮挡几何体


543
00:17:09,086 --> 00:17:10,256
还有一些标记


544
00:17:10,256 --> 00:17:11,705
将不可见物体的


545
00:17:11,796 --> 00:17:12,675
形状显示出来


546
00:17:13,476 --> 00:17:15,356
在遮挡动画上下移动时


547
00:17:15,356 --> 00:17:16,566
它与机器人相交的部分被隐藏


548
00:17:16,656 --> 00:17:18,175
而背后的真实世界


549
00:17:18,445 --> 00:17:19,455
显示出来


550
00:17:20,616 --> 00:17:21,576
遮挡材料非常适合


551
00:17:21,576 --> 00:17:22,796
模仿真实世界的物体


552
00:17:22,796 --> 00:17:24,215
这些物体会阻挡


553
00:17:24,215 --> 00:17:26,086
虚拟物体 


554
00:17:26,086 --> 00:17:26,856
就像桌子和墙


555
00:17:27,276 --> 00:17:29,066
在我们的 App 中使用一下


556
00:17:30,076 --> 00:17:31,346
首先在我们的游戏面板上


557
00:17:31,346 --> 00:17:32,956
加一个遮挡面


558
00:17:33,526 --> 00:17:34,756
我们要创建一个


559
00:17:34,756 --> 00:17:36,216
半米宽半米深的平面网格


560
00:17:37,476 --> 00:17:38,436
然后创建遮挡材料


561
00:17:38,436 --> 00:17:41,346
再接着创建一个模型实体


562
00:17:41,346 --> 00:17:43,176
把它用在平面网格上


563
00:17:43,876 --> 00:17:45,276
把它放在游戏面板


564
00:17:45,276 --> 00:17:46,206
下面一点


565
00:17:46,206 --> 00:17:48,166
就不会与我们模型底部交叉


566
00:17:49,106 --> 00:17:50,196
之后 把它添加在锚点上


567
00:17:50,196 --> 00:17:51,736
以便把遮挡材料


568
00:17:51,786 --> 00:17:52,856
放在场景中


569
00:17:54,366 --> 00:17:56,876
这里我们能看到遮挡平面在工作


570
00:17:57,106 --> 00:17:59,166
粗略一看 好像很好的解决了问题


571
00:17:59,166 --> 00:18:00,456
但当我们


572
00:18:00,456 --> 00:18:02,046
向下移动设备时


573
00:18:02,046 --> 00:18:03,676
可以看到遮挡平面的边缘


574
00:18:03,676 --> 00:18:04,896
看到桌子里


575
00:18:04,896 --> 00:18:06,456
虚拟内容的渲染


576
00:18:06,456 --> 00:18:08,016
所以 游戏面板之上


577
00:18:08,016 --> 00:18:09,396
这个平面做的很好


578
00:18:09,396 --> 00:18:10,406
但这种情况下


579
00:18:10,406 --> 00:18:13,476
我们需要在任意角度都要遮挡


580
00:18:13,646 --> 00:18:14,976
解决方案是使用


581
00:18:14,976 --> 00:18:16,466
遮挡盒子而非遮挡平面


582
00:18:16,986 --> 00:18:20,016
我们要生成一个遮挡盒子


583
00:18:20,016 --> 00:18:20,846
使用相同的遮挡材料


584
00:18:20,846 --> 00:18:23,036
然后创造一个模型实体


585
00:18:23,036 --> 00:18:24,566
使用遮挡盒子


586
00:18:24,566 --> 00:18:25,336
取代遮挡平面


587
00:18:26,806 --> 00:18:28,256
生成的几何对象


588
00:18:28,256 --> 00:18:30,106
默认位于锚点中心


589
00:18:30,106 --> 00:18:31,176
所以我们要将它下移半个盒子的距离


590
00:18:31,176 --> 00:18:31,716
再下移一点点


591
00:18:31,716 --> 00:18:32,806
这样盒子的顶部


592
00:18:32,806 --> 00:18:34,096
就刚好位于


593
00:18:34,096 --> 00:18:35,006
游戏板底部的下方


594
00:18:36,376 --> 00:18:38,246
我们再次把它


595
00:18:38,246 --> 00:18:39,266
加到锚点上


596
00:18:39,266 --> 00:18:42,496
将遮挡盒子放在场景中


597
00:18:43,136 --> 00:18:44,696
表面看来


598
00:18:44,696 --> 00:18:46,656
和遮挡平面作用相同


599
00:18:46,656 --> 00:18:48,096
但当我们开始向下移动设备


600
00:18:48,736 --> 00:18:50,716
我们会看到


601
00:18:50,716 --> 00:18:52,096
已经看不到我们的虚拟内容了


602
00:18:52,746 --> 00:18:54,026
我们的遮挡盒子可以阻止


603
00:18:54,026 --> 00:18:55,396
内容在桌子内渲染


604
00:18:55,396 --> 00:18:57,046
在虚拟场景中


605
00:18:57,046 --> 00:18:58,856
模拟出了真实世界的对象


606
00:19:00,226 --> 00:19:01,266
现在我们的 App


607
00:19:01,266 --> 00:19:02,386
可以将虚拟卡片放在


608
00:19:02,386 --> 00:19:03,896
现实世界里 进行互动


609
00:19:03,896 --> 00:19:06,366
我们采用异步加载资源


610
00:19:06,366 --> 00:19:07,736
利用遮挡几何模拟


611
00:19:07,736 --> 00:19:08,916
虚拟内容


612
00:19:08,916 --> 00:19:10,906
被真实世界对象遮住


613
00:19:11,566 --> 00:19:13,116
现在我想邀请


614
00:19:13,116 --> 00:19:14,236
我的同事 Courtland


615
00:19:14,236 --> 00:19:16,036
讲讲追踪游戏状态 Courtland


616
00:19:17,016 --> 00:19:21,500
[掌声]


617
00:19:25,236 --> 00:19:25,816
>> 谢谢 Ross


618
00:19:26,476 --> 00:19:27,776
大家好 我是 Courtland


619
00:19:27,776 --> 00:19:29,666
Apple RealityKit 团队的工程师


620
00:19:30,396 --> 00:19:31,766
我们刚刚了解了


621
00:19:31,766 --> 00:19:33,756
如何为一个 AR 游戏制作原型


622
00:19:33,756 --> 00:19:36,006
添加互动 增加艺术素材


623
00:19:36,876 --> 00:19:38,056
现在我想向大家展示


624
00:19:38,056 --> 00:19:39,396
如何利用自定义组件和实体


625
00:19:39,396 --> 00:19:40,796
追踪你的状态 


626
00:19:41,146 --> 00:19:42,916
以及最后的如何添加多人游戏


627
00:19:43,896 --> 00:19:45,446
我们先说追踪状态


628
00:19:46,606 --> 00:19:48,106
正如在介绍会议中所讲


629
00:19:48,106 --> 00:19:49,936
RealityKit 使用


630
00:19:49,936 --> 00:19:51,296
实体—组件设计模式


631
00:19:51,446 --> 00:19:53,306
在虚拟世界中构建对象


632
00:19:53,476 --> 00:19:56,326
实体本身由称为


633
00:19:56,326 --> 00:19:57,676
组件的部分组成


634
00:19:58,616 --> 00:20:00,396
这些组件可以定义


635
00:20:00,396 --> 00:20:02,536
添加到各个实体的


636
00:20:02,536 --> 00:20:03,856
特定行为和数据


637
00:20:04,846 --> 00:20:06,546
使用实体和组件


638
00:20:06,546 --> 00:20:08,286
可以重复使用代码


639
00:20:08,286 --> 00:20:09,126
而且使用灵活


640
00:20:09,786 --> 00:20:10,956
我们来看一下


641
00:20:10,956 --> 00:20:11,806
怎么运用组件


642
00:20:12,356 --> 00:20:14,986
我们用 RealityKit 的模型实体


643
00:20:14,986 --> 00:20:16,646
来代表我们的卡片


644
00:20:17,096 --> 00:20:18,226
它给我们提供了


645
00:20:18,226 --> 00:20:19,806
一组组件


646
00:20:19,806 --> 00:20:22,196
可表示常见的虚拟对象


647
00:20:22,946 --> 00:20:24,306
我们将模型组件


648
00:20:24,306 --> 00:20:25,796
应用于视觉外观


649
00:20:25,796 --> 00:20:28,276
将碰撞组件应用于点按检测


650
00:20:29,436 --> 00:20:30,936
模型实体还包含


651
00:20:30,936 --> 00:20:32,626
一个物理组件


652
00:20:32,626 --> 00:20:34,326
能让实体


653
00:20:34,326 --> 00:20:35,736
以物理逼真的方式


654
00:20:35,816 --> 00:20:37,496
移动以及与其他对象互动


655
00:20:37,496 --> 00:20:38,246
虽然这里没有使用


656
00:20:39,836 --> 00:20:40,996
RealityKit 可以让你


657
00:20:40,996 --> 00:20:42,006
自定义实体


658
00:20:42,626 --> 00:20:43,866
通过使用实体组件设计


659
00:20:43,866 --> 00:20:45,206
你可以留下想要的行为


660
00:20:45,206 --> 00:20:47,116
排除那些


661
00:20:47,116 --> 00:20:49,296
你不需要的


662
00:20:49,296 --> 00:20:50,166
增加你自己的新行为


663
00:20:51,196 --> 00:20:52,926
让我们为卡片定制


664
00:20:53,636 --> 00:20:54,826
这个实体


665
00:20:54,966 --> 00:20:56,746
模型实体有我们需要的大部分内容


666
00:20:57,476 --> 00:20:58,996
我们需要移除物理


667
00:20:58,996 --> 00:20:59,506
因为我们没有使用


668
00:21:00,746 --> 00:21:01,986
我们想储存卡片属性


669
00:21:01,986 --> 00:21:03,716
表明它是显示还是隐藏状态


670
00:21:03,826 --> 00:21:06,076
还有卡片种类


671
00:21:06,116 --> 00:21:07,616
用来确定两张卡片是否配对


672
00:21:08,736 --> 00:21:10,286
为此我们需要创建


673
00:21:10,286 --> 00:21:12,226
一个具有这些属性的


674
00:21:12,226 --> 00:21:13,296
新卡片组件


675
00:21:13,296 --> 00:21:13,956
把它加到实体中


676
00:21:15,266 --> 00:21:16,906
究竟什么是组件


677
00:21:17,626 --> 00:21:20,196
一个 RealityKit 组件是一个


678
00:21:20,196 --> 00:21:22,046
包含属性的 Swift 结构体


679
00:21:23,046 --> 00:21:24,366
它符合组件协议


680
00:21:24,366 --> 00:21:27,086
可以被添加到实体上


681
00:21:28,466 --> 00:21:30,376
遵循 Codable 也是一个好主意
 
00:21:30,376 --> 00:21:32,556
我们在多人游戏部分将会看到


682
00:21:33,496 --> 00:21:34,066
我们开始动手做


683
00:21:35,076 --> 00:21:37,506
首先声明我们的结构体


684
00:21:37,866 --> 00:21:38,936
命名为 CardComponent


685
00:21:39,966 --> 00:21:42,036
我们采用了 Codable 协议中的 Component


686
00:21:44,066 --> 00:21:45,086
接下来 加上两个属性


687
00:21:45,086 --> 00:21:46,626
一个名为 revealed 的布尔值


688
00:21:46,626 --> 00:21:48,066
表示卡片的内容


689
00:21:48,066 --> 00:21:49,226
是隐藏还是显示


690
00:21:49,226 --> 00:21:51,006
还有一个字符串 kind


691
00:21:51,496 --> 00:21:52,946
可以用来匹配两张卡片


692
00:21:53,726 --> 00:21:54,476
这就是所有类型


693
00:21:55,396 --> 00:21:56,476
我们先从之前 Ross


694
00:21:56,476 --> 00:21:57,826
加载的一个卡片模型开始


695
00:21:58,446 --> 00:22:01,106
为了演示目的


696
00:22:01,106 --> 00:22:02,226
我将展示如何删除


697
00:22:02,256 --> 00:22:02,936
physicBody 组件


698
00:22:03,696 --> 00:22:05,036
模型实体提供了


699
00:22:05,036 --> 00:22:06,346
一个 physicBody 属性


700
00:22:06,346 --> 00:22:07,156
这就简单多了


701
00:22:08,016 --> 00:22:11,806
我们赋值为 nil 就完成了


702
00:22:12,026 --> 00:22:13,986
现在我们加载卡片组件


703
00:22:13,986 --> 00:22:16,336
通过赋值给组件类型索引的


704
00:22:16,336 --> 00:22:17,236
组件数组来完成


705
00:22:18,246 --> 00:22:19,376
这一操作将增加组件


706
00:22:19,376 --> 00:22:21,006
如果实体上


707
00:22:21,816 --> 00:22:23,046
原来没有这一组件的话


708
00:22:23,246 --> 00:22:24,756
更改 kind 属性也是一样的


709
00:22:25,726 --> 00:22:28,666
索引到实体组件数组


710
00:22:28,666 --> 00:22:29,476
赋值给 kind 属性


711
00:22:30,406 --> 00:22:31,766
不是每个实体


712
00:22:31,766 --> 00:22:33,506
都有一个卡片组件


713
00:22:33,506 --> 00:22:36,216
访问器将返回一个备选值


714
00:22:37,266 --> 00:22:38,846
对于你游戏中


715
00:22:38,876 --> 00:22:40,056
使用的组件通用配置


716
00:22:40,056 --> 00:22:41,566
我们可以更进一步


717
00:22:41,566 --> 00:22:42,736
创建我们自己的


718
00:22:42,806 --> 00:22:43,476
自定义实体


719
00:22:44,466 --> 00:22:45,746
RealityKit 附带有很多


720
00:22:45,746 --> 00:22:47,346
实体配置


721
00:22:47,346 --> 00:22:49,306
如平行光和模型实体


722
00:22:49,816 --> 00:22:51,166
你可以轻松制作自己的配置


723
00:22:51,926 --> 00:22:53,156
我们在游戏中随处可见卡片


724
00:22:53,156 --> 00:22:55,336
所以把它转化为实体


725
00:22:55,336 --> 00:22:56,866
是一个理想的候选


726
00:22:58,006 --> 00:22:59,386
我们将获得这些对象的


727
00:22:59,386 --> 00:23:00,836
编译时输入检查


728
00:23:00,836 --> 00:23:01,496
和代码补全


729
00:23:01,996 --> 00:23:03,346
也可以添加方法


730
00:23:03,346 --> 00:23:05,366
封装功能


731
00:23:06,726 --> 00:23:08,126
这特别有用


732
00:23:08,126 --> 00:23:11,106
当你需要同时更改多个组件时


733
00:23:11,106 --> 00:23:12,156
比如在掀开卡片的同时


734
00:23:12,156 --> 00:23:14,146
将卡片状态改为


735
00:23:14,146 --> 00:23:16,326
revealed


736
00:23:16,576 --> 00:23:18,486
创造新实体只需几步


737
00:23:19,736 --> 00:23:21,266
首先需要一个新的类


738
00:23:21,296 --> 00:23:24,196
代表我们的实体


739
00:23:24,406 --> 00:23:25,906
然后添加我们需要的


740
00:23:25,906 --> 00:23:27,566
RealityKit 组件


741
00:23:28,696 --> 00:23:31,016
然后添加任意的自定义组件


742
00:23:31,226 --> 00:23:32,136
我们之前看到了


743
00:23:32,136 --> 00:23:33,316
模型实体上的


744
00:23:33,316 --> 00:23:34,816
physicBody 属性


745
00:23:34,816 --> 00:23:36,356
这是访问 physicBody 属性


746
00:23:36,356 --> 00:23:37,496
简便的语法


747
00:23:38,066 --> 00:23:39,966
我们将对卡片进行相同操作


748
00:23:40,976 --> 00:23:42,516
我们之前扩展了


749
00:23:43,646 --> 00:23:45,366
reveal 和 hide 方法


750
00:23:46,466 --> 00:23:49,246
因此我们创建了派生于实体的


751
00:23:49,246 --> 00:23:51,136
卡片实体类


752
00:23:52,666 --> 00:23:54,726
接下来要添加 RealityKit 组件


753
00:23:55,356 --> 00:23:57,136
我们加上 HasModel


754
00:23:57,136 --> 00:23:58,386
还有 HasCollision 协议


755
00:23:59,146 --> 00:24:01,766
这些协议让我们通过属性


756
00:24:01,766 --> 00:24:04,056
或它们提供的其他方法


757
00:24:04,056 --> 00:24:05,186
比如生成碰撞形状


758
00:24:05,466 --> 00:24:06,996
来访问模型和碰撞组件


759
00:24:07,496 --> 00:24:10,356
最后我们添加一个卡片属性


760
00:24:10,816 --> 00:24:11,936
可以返回 CardComponent


761
00:24:12,626 --> 00:24:13,976
因为所有卡片都需要卡片组件


762
00:24:13,976 --> 00:24:15,636
所以将其设置为非可选


763
00:24:16,276 --> 00:24:19,246
get 可以从数组中


764
00:24:19,246 --> 00:24:20,096
获取我们的


765
00:24:20,096 --> 00:24:20,706
CardComponent


766
00:24:21,686 --> 00:24:22,736
如果我们没有准备好卡片


767
00:24:22,736 --> 00:24:24,466
就使用空合运算符


768
00:24:24,466 --> 00:24:25,996
返回默认值


769
00:24:27,236 --> 00:24:28,986
set 将复制新值


770
00:24:28,986 --> 00:24:29,626
到组件数组中


771
00:24:29,626 --> 00:24:32,776
现在我们有了类


772
00:24:32,776 --> 00:24:33,566
并用方法进行了扩展


773
00:24:34,276 --> 00:24:37,926
我用 reveal 方法


774
00:24:38,086 --> 00:24:39,466
来展示轻松地


775
00:24:39,466 --> 00:24:40,596
协调多个更新 


776
00:24:41,756 --> 00:24:43,366
我们首先更新卡片的状态


777
00:24:43,456 --> 00:24:44,646
表示它是显示的


778
00:24:45,596 --> 00:24:46,986
我们立即执行此操作


779
00:24:46,986 --> 00:24:48,196
而不是等到动画结束之后


780
00:24:48,576 --> 00:24:50,626
是为了防止你在动画播放时再次点按


781
00:24:51,886 --> 00:24:53,596
接下来 我们使用


782
00:24:53,596 --> 00:24:55,016
Ross 之前使用的代码


783
00:24:55,016 --> 00:24:56,126
来翻转卡片


784
00:24:57,006 --> 00:24:58,406
就是这样


785
00:24:58,506 --> 00:24:59,816
hide 方法是相反的


786
00:25:00,436 --> 00:25:02,016
设置 revealed 为假


787
00:25:02,016 --> 00:25:03,066
翻转卡片向下


788
00:25:04,106 --> 00:25:05,756
我们看看现在使用是什么样


789
00:25:07,156 --> 00:25:08,676
我们回到 onTap 处理器


790
00:25:09,866 --> 00:25:11,636
调用相同的 arView.entity(at:)方法


791
00:25:11,636 --> 00:25:13,756
但是这次需要


792
00:25:13,756 --> 00:25:15,206
将结果投射到卡片实体


793
00:25:16,136 --> 00:25:18,896
虽然我们的游戏中只有卡片


794
00:25:18,896 --> 00:25:19,676
但你的 App 中可能有多种实体


795
00:25:20,926 --> 00:25:22,596
转换为卡片实体


796
00:25:22,856 --> 00:25:24,716
可以执行对卡片的特定操作


797
00:25:26,186 --> 00:25:27,546
有新的卡片实体和组件


798
00:25:27,546 --> 00:25:29,106
我们可以询问


799
00:25:29,106 --> 00:25:30,346
卡片是否显示


800
00:25:30,346 --> 00:25:32,366
如果它当前是显示的


801
00:25:32,846 --> 00:25:34,136
我们就隐藏


802
00:25:34,256 --> 00:25:37,926
反之 就显示隐藏和显示被封装


803
00:25:37,926 --> 00:25:39,226
为实体的方法


804
00:25:39,226 --> 00:25:40,726
我们不需要关注


805
00:25:40,726 --> 00:25:42,076
隐藏和显示


806
00:25:42,076 --> 00:25:43,606
卡片的具体操作


807
00:25:44,226 --> 00:25:46,726
我们让代码清晰明了


808
00:25:46,726 --> 00:25:48,136
通过在实体中


809
00:25:48,136 --> 00:25:50,056
添加自定义组件


810
00:25:50,056 --> 00:25:51,336
并在此做了一项重要功能性改进


811
00:25:52,426 --> 00:25:53,686
我们现在知道 一张显示的卡片


812
00:25:53,686 --> 00:25:55,536
点按之后就可隐藏起来


813
00:25:55,536 --> 00:25:57,186
如果它不是


814
00:25:57,186 --> 00:25:57,996
你记住的卡片


815
00:25:58,686 --> 00:26:00,906
我们已经为状态构建


816
00:26:00,906 --> 00:26:02,386
组件和实体


817
00:26:02,386 --> 00:26:04,786
现在该进入游戏的下一阶段


818
00:26:05,316 --> 00:26:06,506
还能添什么简单的东西呢


819
00:26:11,086 --> 00:26:12,436
只需添加多人游戏了


820
00:26:15,636 --> 00:26:17,706
AR 游戏很有意思


821
00:26:17,706 --> 00:26:19,286
能和朋友一起玩更有意思


822
00:26:20,666 --> 00:26:21,986
多人游戏能将简单的


823
00:26:21,986 --> 00:26:23,386
卡片配对游戏变成


824
00:26:23,386 --> 00:26:25,766
一场比赛


825
00:26:25,766 --> 00:26:27,576
但是制作多人 AR 游戏


826
00:26:27,576 --> 00:26:28,986
有很多其他的挑战


827
00:26:28,986 --> 00:26:30,886
在非 AR 游戏中不会遇到


828
00:26:32,076 --> 00:26:33,356
当他们把虚拟对象


829
00:26:33,356 --> 00:26:35,056
放到真实世界里


830
00:26:35,056 --> 00:26:36,516
我们希望所有玩家


831
00:26:36,516 --> 00:26:37,316
看到对象都在同一个位置


832
00:26:37,316 --> 00:26:39,966
因为所有人都在一个地方


833
00:26:39,966 --> 00:26:41,496
我们希望设备之间的


834
00:26:41,536 --> 00:26:43,286
更新速度可以很快


835
00:26:43,286 --> 00:26:45,236
以保持现实的共享


836
00:26:46,376 --> 00:26:47,506
为了实现这一点


837
00:26:47,506 --> 00:26:49,276
我们从头开发了 RealityKit 


838
00:26:49,276 --> 00:26:50,446
去支持多人 AR 游戏


839
00:26:51,386 --> 00:26:52,226
结合 ARKit 的 Collaborative Session


840
00:26:52,226 --> 00:26:53,826
今年的会议也有介绍


841
00:26:53,826 --> 00:26:55,576
它提供了一个工具


842
00:26:55,576 --> 00:26:57,146
可以给你的 AR 体验


843
00:26:57,146 --> 00:26:59,506
增加多用户的支持


844
00:27:00,916 --> 00:27:02,146
我们先看一下多人游戏


845
00:27:02,146 --> 00:27:04,816
对我们的游戏意味着什么


846
00:27:04,956 --> 00:27:05,976
玩家会同时在游戏中


847
00:27:05,976 --> 00:27:07,986
可能在任何时间


848
00:27:07,986 --> 00:27:09,156
翻转卡片


849
00:27:10,486 --> 00:27:11,986
每个人都会看到显示的卡片


850
00:27:12,146 --> 00:27:13,896
因此 如果你关注


851
00:27:13,896 --> 00:27:15,096
其他玩家的情况


852
00:27:15,096 --> 00:27:16,346
就会获得一定优势


853
00:27:16,346 --> 00:27:18,726
我们加上一个白色的小圈


854
00:27:18,726 --> 00:27:20,366
用来提示玩家


855
00:27:20,636 --> 00:27:21,976
他们正在翻转的卡片


856
00:27:25,176 --> 00:27:26,616
我们看一下 RealityKit 中的


857
00:27:26,816 --> 00:27:27,456
多人游戏功能


858
00:27:28,236 --> 00:27:29,786
RealityKit 提供


859
00:27:29,916 --> 00:27:30,836
场景自动同步


860
00:27:31,676 --> 00:27:33,276
更改会在所有设备上


861
00:27:33,276 --> 00:27:35,206
自动更新


862
00:27:36,576 --> 00:27:38,136
提升了 MultipeerConnectivity


863
00:27:38,136 --> 00:27:39,836
的设备发现和连接


864
00:27:40,856 --> 00:27:42,316
这样就能轻松查找


865
00:27:42,316 --> 00:27:43,406
并连接附近设备


866
00:27:44,096 --> 00:27:45,756
而无需维护服务器


867
00:27:45,756 --> 00:27:46,846
甚至无需连接到


868
00:27:46,846 --> 00:27:47,476
相同的 Wi-Fi 网络


869
00:27:48,016 --> 00:27:49,966
它提供了一个易于使用的


870
00:27:49,966 --> 00:27:51,406
所有权模型


871
00:27:51,406 --> 00:27:52,826
能让你控制


872
00:27:52,826 --> 00:27:54,376
允许哪个玩家更改哪个实体


873
00:27:55,006 --> 00:27:57,986
即使是网络繁忙的 Wi-Fi


874
00:27:57,986 --> 00:27:59,466
也能降低延迟


875
00:27:59,466 --> 00:28:01,496
这对加强 AR 体验十分重要


876
00:28:04,256 --> 00:28:05,826
下面进行下一步


877
00:28:05,826 --> 00:28:07,356
为我们游戏增加多人游戏


878
00:28:08,386 --> 00:28:10,156
首先需要指定一个发起人


879
00:28:10,526 --> 00:28:11,406
我们来放置游戏面板


880
00:28:12,696 --> 00:28:13,826
在游戏的主菜单上


881
00:28:13,826 --> 00:28:15,756
请用户选择


882
00:28:16,686 --> 00:28:18,486
然后把会话连起来


883
00:28:18,486 --> 00:28:20,426
它们之间就可以相互交流


884
00:28:21,686 --> 00:28:23,776
我们还使用 ARKit 的


885
00:28:23,776 --> 00:28:25,326
Collaborative Session


886
00:28:25,326 --> 00:28:26,386
可以让我们的玩家


887
00:28:26,386 --> 00:28:27,726
创建一个共享的环境地图


888
00:28:28,826 --> 00:28:30,136
我们创建一个同步锚点


889
00:28:30,136 --> 00:28:31,966
它可以将我们的游戏面板


890
00:28:31,966 --> 00:28:33,786
连接到世界的特定位置


891
00:28:33,786 --> 00:28:35,956
并在玩家之间进行协调


892
00:28:36,786 --> 00:28:38,476
最后 我们利用所有权


893
00:28:38,476 --> 00:28:39,676
对游戏面板进行更改


894
00:28:40,076 --> 00:28:42,316
例如翻转卡片 移除卡片


895
00:28:43,126 --> 00:28:45,166
我们请用户在主菜单中


896
00:28:45,166 --> 00:28:46,676
选择发起 或加入


897
00:28:47,406 --> 00:28:49,056
现在我们需要建立一个连接


898
00:28:50,286 --> 00:28:51,506
我们使用 MultipeerConnectivity 框架


899
00:28:51,506 --> 00:28:54,396
进行连接


900
00:28:54,396 --> 00:28:56,356
我们不会过多介绍


901
00:28:56,356 --> 00:28:57,416
MultipeerConnectivity 的细节


902
00:28:57,416 --> 00:28:58,946
如果你想了解


903
00:28:58,946 --> 00:29:02,246
请查看 2014 年的会议


904
00:29:02,306 --> 00:29:03,006
Cross Platform Nearby Networking


905
00:29:04,186 --> 00:29:06,876
首先创建一个 MCPeerID 和 MCSession


906
00:29:07,976 --> 00:29:09,426
一定要启用加密


907
00:29:09,426 --> 00:29:11,116
因为要和 RealityKit 一起使用


908
00:29:14,036 --> 00:29:14,966
在继续推进之前


909
00:29:14,966 --> 00:29:15,696
我们先检查用户角色


910
00:29:16,426 --> 00:29:17,586
如果他们选择发起


911
00:29:17,586 --> 00:29:19,266
我们将使用


912
00:29:19,316 --> 00:29:21,166
MCNearbyServiceAdvertiser 传播会话


913
00:29:21,906 --> 00:29:23,046
这说明我们有一个


914
00:29:23,046 --> 00:29:23,766
可用的会话


915
00:29:24,416 --> 00:29:26,316
客户端创建了一个


916
00:29:26,396 --> 00:29:28,366
MCNearbyServiceBrowser 


917
00:29:28,366 --> 00:29:29,066
开始查找会话


918
00:29:29,936 --> 00:29:30,786
现在我们有了一个 MCSession 


919
00:29:30,836 --> 00:29:32,796
我们需要让


920
00:29:32,796 --> 00:29:34,586
RealityKit 使用进行同步


921
00:29:35,406 --> 00:29:36,766
我们创建一个 MultipeerConnectivityService


922
00:29:36,806 --> 00:29:38,706
来实现这一点


923
00:29:38,706 --> 00:29:40,496
该服务是一个 RealityKit 类


924
00:29:40,546 --> 00:29:42,126
它包含着 MCSession 


925
00:29:42,126 --> 00:29:43,726
使其可应用于场景同步


926
00:29:44,626 --> 00:29:45,966
我们创建一个该服务


927
00:29:45,966 --> 00:29:47,316
并把它赋值给场景中的


928
00:29:47,416 --> 00:29:50,136
synchronizationService 属性


929
00:29:50,316 --> 00:29:51,246
现在我们连接了两个设备


930
00:29:51,246 --> 00:29:52,836
同步了他们的场景


931
00:29:53,786 --> 00:29:55,246
但是他们还不知道


932
00:29:55,246 --> 00:29:56,426
他们在物理世界中


933
00:29:56,426 --> 00:29:57,896
相对于彼此的位置


934
00:29:59,076 --> 00:30:00,056
让我们使用


935
00:30:00,056 --> 00:30:01,466
ARKit 3 的 Collaborative Session


936
00:30:01,466 --> 00:30:03,976
RealityKit 提供了对其原生的支持


937
00:30:05,486 --> 00:30:06,786
Collaborative Session 可以让我们


938
00:30:06,786 --> 00:30:07,966
更快地建立世界


939
00:30:08,266 --> 00:30:09,776
让多用户可以共享


940
00:30:09,776 --> 00:30:10,956
相同的世界体验


941
00:30:10,956 --> 00:30:13,646
因为我们想要协作映射


942
00:30:13,646 --> 00:30:15,006
就需要打开它


943
00:30:15,646 --> 00:30:17,236
我们在 viewDidLoad 的最后来做


944
00:30:18,226 --> 00:30:19,976
我们要创建一个新的


945
00:30:19,976 --> 00:30:20,756
WorldTrackingConfiguration


946
00:30:21,876 --> 00:30:24,016
设置 isCollaborationEnabled 为真


947
00:30:25,066 --> 00:30:27,916
指示 AR 会话去运行我们的配置


948
00:30:29,176 --> 00:30:30,736
现在我们有 Collaborative Session


949
00:30:30,736 --> 00:30:32,346
可以让我们创建一个


950
00:30:32,346 --> 00:30:33,856
同步锚点


951
00:30:34,616 --> 00:30:36,436
之前我们创建了一个


952
00:30:36,436 --> 00:30:38,266
锚实体 


953
00:30:38,266 --> 00:30:39,536
要求有一个


954
00:30:39,536 --> 00:30:40,536
不小于 20 平方厘米的水平面


955
00:30:41,386 --> 00:30:42,556
因为现在是多玩家 我们希望


956
00:30:42,556 --> 00:30:43,586
游戏面板放在一个好位置上


957
00:30:43,626 --> 00:30:45,206
能让两个玩家使用


958
00:30:45,676 --> 00:30:46,996
为达到这个效果 我们让


959
00:30:46,996 --> 00:30:47,886
游戏发起人放置游戏面板


960
00:30:48,676 --> 00:30:49,926
因为希望所有玩家看到


961
00:30:49,926 --> 00:30:51,636
相同的世界位置


962
00:30:51,636 --> 00:30:53,376
我们让 ARKit 同步锚点


963
00:30:54,396 --> 00:30:54,976
那应该怎么做呢


964
00:30:58,416 --> 00:31:00,516
发起人这端 我们使用


965
00:31:00,516 --> 00:31:02,066
之前用过的 onTap 控制器


966
00:31:03,106 --> 00:31:04,816
我们想挑选一个点适合所有人


967
00:31:05,076 --> 00:31:06,736
我们将光线投射到现实世界


968
00:31:07,926 --> 00:31:09,416
这和 Ross 之前展示过的


969
00:31:09,416 --> 00:31:11,296
点按检测相似


970
00:31:11,496 --> 00:31:12,546
但这个是针对


971
00:31:12,546 --> 00:31:14,006
现实世界判断


972
00:31:14,456 --> 00:31:15,696
而不是虚拟对象来运行的


973
00:31:16,236 --> 00:31:17,926
我们的游戏面板需要


974
00:31:17,926 --> 00:31:19,726
一个平坦的表面


975
00:31:19,726 --> 00:31:20,916
所以我们要找一个水平面


976
00:31:21,576 --> 00:31:24,226
如果它找到一个水平面


977
00:31:24,696 --> 00:31:25,976
我们就采用 worldTransform


978
00:31:25,976 --> 00:31:27,516
创建一个 AR 锚点


979
00:31:28,206 --> 00:31:30,146
这是一个 ARKit 锚点


980
00:31:30,146 --> 00:31:32,286
我们将其添加到视图提供的 AR 会话


981
00:31:33,126 --> 00:31:34,516
这会创建一个同步锚点


982
00:31:34,516 --> 00:31:36,796
它在真实世界的位置


983
00:31:36,796 --> 00:31:38,266
会由 ARKit 协调


984
00:31:39,696 --> 00:31:41,416
使用那个 AR 锚点


985
00:31:41,416 --> 00:31:42,356
我们创建了一个


986
00:31:42,356 --> 00:31:42,736
RealityKit 锚点实体


987
00:31:43,426 --> 00:31:44,936
这是 ARKit 和 RealityKit 


988
00:31:45,106 --> 00:31:47,706
之间的桥梁 允许我们添加卡片


989
00:31:47,706 --> 00:31:50,086
我们已经有 Ross 之前展示过的


990
00:31:50,236 --> 00:31:51,276
游戏面板了


991
00:31:52,326 --> 00:31:54,326
只有发起人需要建立随机游戏面板


992
00:31:55,146 --> 00:31:56,116
其他人通过


993
00:31:56,116 --> 00:31:58,266
网络同步自动接收


994
00:31:59,526 --> 00:32:00,636
我们加载的模型


995
00:32:00,636 --> 00:32:01,716
不会作为场景的一部分


996
00:32:01,716 --> 00:32:02,996
进行同步 


997
00:32:02,996 --> 00:32:03,506
因为数据量太大


998
00:32:04,446 --> 00:32:05,666
还记得 Ross 向我们展示


999
00:32:05,666 --> 00:32:07,286
如何加载卡片模板吗


1000
00:32:07,606 --> 00:32:09,296
保证我们在所有的外观上都这样做


1001
00:32:10,046 --> 00:32:11,166
这就足够让我们的游戏


1002
00:32:11,166 --> 00:32:12,396
开始运行


1003
00:32:15,206 --> 00:32:16,676
在左边 我们能看到


1004
00:32:16,676 --> 00:32:17,766
发起人放置了游戏面板


1005
00:32:18,056 --> 00:32:18,986
参与者也看到了


1006
00:32:19,476 --> 00:32:20,676
在真实世界里的位置


1007
00:32:20,676 --> 00:32:21,106
是相同的


1008
00:32:22,076 --> 00:32:23,386
看发起人翻动卡片


1009
00:32:23,386 --> 00:32:24,846
然后是另一张


1010
00:32:25,456 --> 00:32:26,536
好吧 不是一对


1011
00:32:27,206 --> 00:32:28,226
可以看到它在参与者这边


1012
00:32:28,226 --> 00:32:29,656
是自动反应的


1013
00:32:29,656 --> 00:32:30,856
动画也非常流畅	


1014
00:32:31,526 --> 00:32:32,796
不需要网络程序


1015
00:32:33,776 --> 00:32:35,836
现在来看参与者翻转卡片


1016
00:32:36,396 --> 00:32:38,626
参与者的屏幕上翻转了


1017
00:32:39,076 --> 00:32:40,266
但发起人的屏幕上没有


1018
00:32:40,776 --> 00:32:41,926
为了解释这一现象


1019
00:32:41,926 --> 00:32:43,476
需要先解释一下所有权


1020
00:32:44,046 --> 00:32:45,696
所有权是什么？


1021
00:32:46,596 --> 00:32:48,386
它是修改实体的权利


1022
00:32:49,636 --> 00:32:51,496
在一个共享会话中


1023
00:32:51,496 --> 00:32:53,536
一个实体一次只有一个所有者


1024
00:32:53,536 --> 00:32:55,256
默认为是创造这个实体的人


1025
00:32:56,056 --> 00:32:58,246
在我们的例子中就是发起人


1026
00:33:00,226 --> 00:33:02,276
所有权是可以转移的


1027
00:33:02,276 --> 00:33:03,086
这也是允许其他玩家


1028
00:33:03,176 --> 00:33:04,216
作出更改的方法


1029
00:33:05,006 --> 00:33:06,266
所有权的转移是可配置的


1030
00:33:06,266 --> 00:33:08,486
所以你可以决定


1031
00:33:08,486 --> 00:33:09,196
哪些实体可以转移


1032
00:33:09,196 --> 00:33:10,836
什么时间转移


1033
00:33:11,926 --> 00:33:13,416
为了阐明所有权


1034
00:33:13,416 --> 00:33:14,686
我们看看在游戏中发生了什么


1035
00:33:17,006 --> 00:33:18,096
发起人创建了卡片


1036
00:33:18,546 --> 00:33:19,546
说明他拥有这些卡片


1037
00:33:20,126 --> 00:33:22,106
这些卡片会自动出现在


1038
00:33:22,106 --> 00:33:22,866
参与者屏幕上


1039
00:33:23,426 --> 00:33:25,506
当实体的所有者


1040
00:33:25,506 --> 00:33:27,146
进行更改 比如


1041
00:33:27,146 --> 00:33:29,306
翻转卡片 这个改变


1042
00:33:29,306 --> 00:33:30,786
会发送给参与者


1043
00:33:30,786 --> 00:33:31,316
反映在他们的场景中


1044
00:33:32,486 --> 00:33:33,666
由于 RealityKit 从头开始


1045
00:33:33,666 --> 00:33:34,696
构建多人游戏


1046
00:33:34,696 --> 00:33:37,326
我们只能将指令同步到动画


1047
00:33:37,326 --> 00:33:39,906
而不能转换每一帧


1048
00:33:40,506 --> 00:33:41,876
所以在参与者界面上


1049
00:33:41,876 --> 00:33:42,406
看起来十分流畅


1050
00:33:43,126 --> 00:33:45,476
现在参与者翻转卡片


1051
00:33:46,506 --> 00:33:47,756
由于参与者不是


1052
00:33:47,756 --> 00:33:49,756
实体的拥有者


1053
00:33:49,756 --> 00:33:50,466
因此不会同步更改


1054
00:33:51,616 --> 00:33:52,596
虽然还是可以在


1055
00:33:52,626 --> 00:33:53,956
本地做出更改


1056
00:33:53,956 --> 00:33:55,696
但下次所有者发送更新时


1057
00:33:55,696 --> 00:33:57,076
它们可能会被覆盖


1058
00:33:58,096 --> 00:33:59,456
这会陷入两难境地


1059
00:33:59,456 --> 00:34:00,956
因为我们确实希望对卡片做些改变


1060
00:34:01,696 --> 00:34:03,036
让我们退一步


1061
00:34:03,036 --> 00:34:04,746
退到参与者翻转机器人卡片之前


1062
00:34:05,956 --> 00:34:06,796
我之前提过


1063
00:34:07,716 --> 00:34:08,766
所有权可以转移


1064
00:34:09,476 --> 00:34:11,896
任何参与者都可以请求实体的所有权


1065
00:34:12,726 --> 00:34:13,815
在更改之前


1066
00:34:13,815 --> 00:34:15,275
我们让参与者请求


1067
00:34:15,626 --> 00:34:16,806
黄色机器人卡片的所有权


1068
00:34:18,106 --> 00:34:19,456
它向发起人发送了请求


1069
00:34:19,806 --> 00:34:20,726
要求所有权


1070
00:34:21,826 --> 00:34:23,036
实体的所有者决定


1071
00:34:23,036 --> 00:34:24,166
是否转移所有权


1072
00:34:24,755 --> 00:34:26,076
他可能会拒绝


1073
00:34:26,076 --> 00:34:28,186
如果存在另一名参与者请求所有权


1074
00:34:28,186 --> 00:34:29,826
或者对象的转移模式发生改变


1075
00:34:30,835 --> 00:34:32,565
在默认状态 


1076
00:34:32,565 --> 00:34:34,496
发起人接受请求


1077
00:34:34,496 --> 00:34:36,176
将所有权转移给参与者


1078
00:34:37,286 --> 00:34:38,856
参与者现在可以


1079
00:34:38,856 --> 00:34:39,726
随意更改卡片


1080
00:34:40,505 --> 00:34:42,136
我们可以显示卡片


1081
00:34:42,136 --> 00:34:44,186
发起人那里也会显示更改


1082
00:34:45,206 --> 00:34:46,716
我们让这一过程易于实现


1083
00:34:47,255 --> 00:34:50,306
参与者开始请求


1084
00:34:50,306 --> 00:34:51,496
实体的所有权


1085
00:34:52,485 --> 00:34:54,516
如果我们已经拥有这个对象就没问题


1086
00:34:55,176 --> 00:34:56,246
该请求将被通过


1087
00:34:56,246 --> 00:34:58,266
不需进行额外工作


1088
00:34:59,236 --> 00:35:00,106
请求所有权的信息返回时


1089
00:35:00,106 --> 00:35:01,586
我们就会知道


1090
00:35:01,586 --> 00:35:03,266
请求有没有被批准


1091
00:35:04,046 --> 00:35:05,846
如果被批准了


1092
00:35:05,846 --> 00:35:06,966
对卡片调用 reveal 翻转卡片


1093
00:35:07,996 --> 00:35:09,156
但是 如果请求被拒绝了


1094
00:35:09,196 --> 00:35:10,676
比如说 其他人


1095
00:35:10,676 --> 00:35:12,166
翻转了卡片


1096
00:35:12,166 --> 00:35:14,176
我们会给用户选择其他不同卡片的机会


1097
00:35:15,246 --> 00:35:16,246
这就是我们要做的 


1098
00:35:16,246 --> 00:35:18,096
翻转卡片并在让所有游戏玩家看到


1099
00:35:18,676 --> 00:35:20,006
但是我们还想再进一步


1100
00:35:21,006 --> 00:35:22,466
当卡片处于显示状态时


1101
00:35:22,466 --> 00:35:24,236
我们希望它的所有权不会改变


1102
00:35:24,966 --> 00:35:26,666
当卡片处于显示状态时


1103
00:35:26,666 --> 00:35:28,196
我们想拒绝


1104
00:35:28,196 --> 00:35:28,606
对这张卡片所有权的全部请求


1105
00:35:29,576 --> 00:35:30,956
我们回到 reveal 方法


1106
00:35:33,066 --> 00:35:34,656
我们之前将


1107
00:35:34,826 --> 00:35:36,116
revealed 属性设为真


1108
00:35:37,166 --> 00:35:38,436
因为我们在卡片组件上


1109
00:35:38,436 --> 00:35:40,856
采用了 Codable 协议


1110
00:35:40,926 --> 00:35:42,686
它将自动在参与者界面上更新


1111
00:35:42,936 --> 00:35:43,896
不需要额外做什么


1112
00:35:44,546 --> 00:35:46,726
我们把卡片的 revealed 属性


1113
00:35:46,726 --> 00:35:48,916
设置为真


1114
00:35:48,916 --> 00:35:50,316
所有权转移模式设置为 manual


1115
00:35:51,036 --> 00:35:52,936
这会自动拒绝


1116
00:35:52,936 --> 00:35:56,226
任何实体所有权转移的请求


1117
00:35:56,486 --> 00:35:57,756
当我们翻转卡片 将状态改为隐藏


1118
00:35:57,756 --> 00:35:59,096
我们想开始


1119
00:35:59,096 --> 00:36:00,656
接受所有权转移的请求


1120
00:36:02,036 --> 00:36:03,566
hide 方法看起来就是这个样子


1121
00:36:04,856 --> 00:36:05,846
把 revealed 属性设置为假


1122
00:36:05,896 --> 00:36:07,776
我们把所有权转移模式


1123
00:36:07,776 --> 00:36:09,476
设置为 autoAccept


1124
00:36:10,286 --> 00:36:11,776
这将指示 RealityKit


1125
00:36:11,776 --> 00:36:13,126
自动接受


1126
00:36:13,126 --> 00:36:14,806
实体所有权转移的请求


1127
00:36:16,096 --> 00:36:17,056
我需要指出一件事


1128
00:36:17,056 --> 00:36:19,166
对所有权来说


1129
00:36:19,296 --> 00:36:20,196
发起人并不是特殊的


1130
00:36:21,036 --> 00:36:22,786
他放置了游戏面板


1131
00:36:22,926 --> 00:36:24,506
初始时拥有所有的卡片


1132
00:36:25,096 --> 00:36:26,756
但其他方面和参与者


1133
00:36:26,756 --> 00:36:28,086
没有差别


1134
00:36:28,406 --> 00:36:29,676
一旦实体的所有权转移


1135
00:36:29,886 --> 00:36:30,946
如果发起人想要翻转


1136
00:36:30,946 --> 00:36:32,836
他也需要请求


1137
00:36:34,006 --> 00:36:36,046
可以使用所有权转移模式 改变这个行为


1138
00:36:36,046 --> 00:36:37,306
以适应你的 App


1139
00:36:38,336 --> 00:36:39,636
我们的 App 还有


1140
00:36:40,336 --> 00:36:41,136
最后一个细节


1141
00:36:41,396 --> 00:36:42,326
当你和两个或更多玩家


1142
00:36:42,326 --> 00:36:43,596
一起玩游戏 你会发现


1143
00:36:43,596 --> 00:36:44,976
游戏板会让人困惑


1144
00:36:45,516 --> 00:36:47,096
你很难知道


1145
00:36:47,096 --> 00:36:48,296
你选择了哪张卡


1146
00:36:48,296 --> 00:36:49,586
别人选择了哪张


1147
00:36:50,246 --> 00:36:51,636
我们想添加一个透明圆圈


1148
00:36:51,636 --> 00:36:53,026
显示我们的选择


1149
00:36:53,936 --> 00:36:55,946
正如我们所见


1150
00:36:55,946 --> 00:36:56,296
一切都是共享的


1151
00:36:56,596 --> 00:36:57,846
这会显示给所有人


1152
00:36:57,846 --> 00:36:59,076
与它的意图不符


1153
00:37:00,426 --> 00:37:02,256
幸运的是 RealityKit


1154
00:37:02,256 --> 00:37:03,366
支持仅本地可见的实体


1155
00:37:04,206 --> 00:37:05,636
这非常适合展示


1156
00:37:05,636 --> 00:37:07,086
选择的标志或隐藏的信息


1157
00:37:07,086 --> 00:37:08,916
就像玩扑克的手


1158
00:37:09,876 --> 00:37:12,926
为此 我们移除了同步组件


1159
00:37:12,926 --> 00:37:14,566
在其他功能上


1160
00:37:14,566 --> 00:37:15,266
和别的实体一样


1161
00:37:15,896 --> 00:37:19,166
如果实体有子实体


1162
00:37:19,166 --> 00:37:20,286
它们也不会被共享


1163
00:37:20,776 --> 00:37:21,866
这对于将一整个实体树


1164
00:37:21,866 --> 00:37:23,996
设为本地可见十分有用


1165
00:37:25,316 --> 00:37:26,936
这里我就不展示了


1166
00:37:26,936 --> 00:37:28,346
我创建了一个 SelectionEntity 类


1167
00:37:28,346 --> 00:37:30,036
可以代表我们的选择


1168
00:37:30,736 --> 00:37:32,186
它的初始化增加了


1169
00:37:32,466 --> 00:37:33,746
一个略透明的白色圆圈


1170
00:37:35,046 --> 00:37:35,986
我们将它添加到


1171
00:37:35,986 --> 00:37:37,536
之前的 reveal 方法中


1172
00:37:38,176 --> 00:37:40,606
我们创建了实体和位置


1173
00:37:40,606 --> 00:37:42,316
稍微高于这个卡片


1174
00:37:43,516 --> 00:37:45,166
然后我们把同步组件


1175
00:37:45,166 --> 00:37:46,196
设置为 nil 


1176
00:37:46,866 --> 00:37:48,176
这将指示 RealityKit


1177
00:37:48,176 --> 00:37:49,466
我们不想分享这个实体


1178
00:37:50,226 --> 00:37:51,756
我们把子实体正常


1179
00:37:52,196 --> 00:37:53,106
加入层次结构中


1180
00:37:54,206 --> 00:37:55,416
现在已经添加到了 reveal 中


1181
00:37:55,416 --> 00:37:57,806
我们也需要在隐藏卡片时移除它


1182
00:37:58,336 --> 00:38:01,506
这是之前的 hide 方法


1183
00:38:02,766 --> 00:38:04,026
更改其他属性后


1184
00:38:04,316 --> 00:38:05,486
我们将使用 for 循环


1185
00:38:05,746 --> 00:38:06,416
迭代子实体


1186
00:38:07,256 --> 00:38:08,796
我们可以使用 where 子句


1187
00:38:08,796 --> 00:38:11,026
查找类型为 selection 的实体


1188
00:38:12,206 --> 00:38:14,556
一旦找到 就会从父实体中移除


1189
00:38:15,416 --> 00:38:16,336
因为我们知道


1190
00:38:16,336 --> 00:38:17,896
只会有一个 selection 实体


1191
00:38:17,896 --> 00:38:21,126
我们将跳出循环 就是这样


1192
00:38:21,456 --> 00:38:22,266
我们正确处理了所有权


1193
00:38:22,266 --> 00:38:23,926
为选择而添加或移除了


1194
00:38:23,926 --> 00:38:25,656
本地实体


1195
00:38:25,966 --> 00:38:27,886
现在我们的游戏


1196
00:38:27,886 --> 00:38:28,816
在两个设备上正常运行


1197
00:38:29,706 --> 00:38:30,966
我们的演示为求简单


1198
00:38:30,966 --> 00:38:33,446
只使用两个设备进行游戏


1199
00:38:33,446 --> 00:38:35,676
事实上我们还能支持更多设备


1200
00:38:35,676 --> 00:38:36,906
而不需增加代码


1201
00:38:42,906 --> 00:38:43,996
让我们回顾一下


1202
00:38:44,036 --> 00:38:44,316
我们学了什么


1203
00:38:44,876 --> 00:38:46,236
我们今天展示了


1204
00:38:46,236 --> 00:38:47,696
RealityKit 如何简单快速的


1205
00:38:47,696 --> 00:38:49,236
构建 AR App


1206
00:38:50,486 --> 00:38:51,506
我们介绍了 


1207
00:38:51,506 --> 00:38:53,656
如何用锚放置内容


1208
00:38:53,656 --> 00:38:55,246
同步和异步


1209
00:38:55,246 --> 00:38:57,446
加载素材


1210
00:38:57,446 --> 00:38:59,176
在点按检测中集成交互


1211
00:39:00,266 --> 00:39:03,196
实体中创建自定义组件


1212
00:39:03,196 --> 00:39:05,506
以及如何在 AR 体验中增加多玩家


1213
00:39:06,506 --> 00:39:07,506
我希望能让你们更了解


1214
00:39:07,506 --> 00:39:08,746
RealityKit 是什么


1215
00:39:08,746 --> 00:39:10,626
能做什么


1216
00:39:11,386 --> 00:39:12,846
我们迫不及待地想看看


1217
00:39:12,846 --> 00:39:13,806
你们能用它做什么


1218
00:39:14,616 --> 00:39:16,246
获取更多信息


1219
00:39:16,296 --> 00:39:18,036
以及会议视频


1220
00:39:18,036 --> 00:39:18,966
请查看会议的网站


1221
00:39:19,916 --> 00:39:22,686
并查看 Introducing RealityKit and Reality Composer


1222
00:39:22,956 --> 00:39:25,526
获取更多 RealityKit 的相关信息


1223
00:39:25,526 --> 00:39:27,506
不要错过 Introducing ARKit 3


1224
00:39:27,506 --> 00:39:28,816
可以了解 Collaborative Session


1225
00:39:29,146 --> 00:39:30,116
和其他新功能的更多信息


1226
00:39:31,326 --> 00:39:32,276
请一定要来我们的实验室


1227
00:39:32,276 --> 00:39:34,886
时间是今天下午以及


1228
00:39:34,886 --> 00:39:35,506
明天下午 3 点


1229
00:39:36,966 --> 00:39:38,976
谢谢大家 请好好享受接下来的会议


1230
00:39:39,516 --> 00:39:42,500
[掌声]

