1
00:00:07,040 --> 00:00:11,645 line:0
（Clang和LLVM中的
新功能）


2
00:00:11,712 --> 00:00:13,146 line:-1
在去年


3
00:00:13,680 --> 00:00:16,783 line:-1
我们一直非常努力地向编译器中


4
00:00:16,850 --> 00:00:17,951 line:-1
添加一些很棒的新功能


5
00:00:18,585 --> 00:00:19,520 line:-1
我是Jessica


6
00:00:19,853 --> 00:00:22,923 line:0
今天我和我的同事JF和Devin


7
00:00:23,190 --> 00:00:26,193 line:-1
将与你们分享其中一些非常棒的功能


8
00:00:27,461 --> 00:00:29,096 line:-1
今天我们有许多内容要讲


9
00:00:29,730 --> 00:00:31,999 line:-1
我们要讲新平台支持；


10
00:00:32,566 --> 00:00:34,801 line:-1
一些低级代码尺寸优化；


11
00:00:35,235 --> 00:00:38,038 line:-1
一些语言级代码尺寸优化；


12
00:00:38,505 --> 00:00:40,340 line:-1
一些很棒的新诊断；


13
00:00:40,607 --> 00:00:43,810 line:-2
然后最后我们讲
新的静态分析器检查


14
00:00:43,877 --> 00:00:45,779 line:-1
那会帮助你查找你代码中的错误


15
00:00:46,980 --> 00:00:48,749 line:-1
我们先讲新平台支持


16
00:00:48,815 --> 00:00:50,017 line:-1
（新平台支持）


17
00:00:50,083 --> 00:00:53,287 line:-2
我要特别讲一下
Series 4 Watch


18
00:00:55,455 --> 00:00:59,092 line:-2
Series 4 Watch
使用了全64位芯片


19
00:01:00,727 --> 00:01:04,464 line:-2
但所有App Store app
使用的都是32位芯片


20
00:01:06,633 --> 00:01:09,837 line:-1
对此稀奇的是你们所有的app


21
00:01:10,304 --> 00:01:14,107 line:-2
都将在Series 4 Watch上
第一次无缝运行


22
00:01:16,610 --> 00:01:17,878 line:-1
这听起来像是一种魔法


23
00:01:18,312 --> 00:01:19,947 line:-1
你不需要重新编译任何东西


24
00:01:20,681 --> 00:01:22,316 line:-1
但所有的app都能无缝运行


25
00:01:24,218 --> 00:01:25,185 line:-1
这是怎么发生的呢？


26
00:01:26,186 --> 00:01:28,121 line:-2
现在如果坐在前排的观众
或坐在任意一排的观众


27
00:01:28,188 --> 00:01:30,624 line:-1
可以给我这样一个击鼓声真是太棒了


28
00:01:30,691 --> 00:01:31,959 line:-1
但如果你们不愿意也没关系


29
00:01:33,026 --> 00:01:35,796 line:-1
答案是Bitcode


30
00:01:37,564 --> 00:01:39,533 line:-1
我什么也没解释


31
00:01:39,600 --> 00:01:42,469 line:-1
因此…请允许我给你们解释一下


32
00:01:44,171 --> 00:01:46,507 line:-2
让我们看一些源代码
是用你们最喜欢的语言写的


33
00:01:47,140 --> 00:01:50,010 line:-1
我们要做的就是要把它交给编译器


34
00:01:50,744 --> 00:01:52,646 line:-1
现在一般来说你们在这里会


35
00:01:53,113 --> 00:01:55,983 line:-1
继续标准的编译过程


36
00:01:56,049 --> 00:01:58,752 line:-1
你会得到 比如二进制或什么东西


37
00:01:59,453 --> 00:02:00,587 line:-1
但我们不要这样做


38
00:02:01,421 --> 00:02:03,123 line:-1
我们要做的是


39
00:02:03,190 --> 00:02:05,826 line:-1
提前停止编译过程


40
00:02:06,326 --> 00:02:09,029 line:-2
我们要生成
LLVM Bitcode


41
00:02:12,032 --> 00:02:14,535 line:-2
关于LLVM Bitcode
很酷的一件事


42
00:02:15,235 --> 00:02:18,672 line:-1
就是它在编译器中编码一个中间状态


43
00:02:18,739 --> 00:02:20,174 line:-2
（什么是
LLVM Bitcode？）


44
00:02:20,641 --> 00:02:23,043 line:-1
你可以用这个中间状态


45
00:02:23,810 --> 00:02:27,281 line:-1
从你停止它的地方


46
00:02:27,814 --> 00:02:28,682 line:-1
继续进行编译过程


47
00:02:29,917 --> 00:02:30,817 line:-1
这就是我们要做的操作


48
00:02:31,451 --> 00:02:33,487 line:-2
这一次我们要在
App Store中完成


49
00:02:35,022 --> 00:02:37,891 line:-2
这样我们可以从一个app中
获取一个Bitcode


50
00:02:37,958 --> 00:02:40,294 line:-1
并从中生成两个不同的app


51
00:02:40,360 --> 00:02:42,162 line:-1
一个在32位芯片上运行


52
00:02:42,629 --> 00:02:45,365 line:-1
一个在新型64位芯片上运行


53
00:02:47,401 --> 00:02:49,903 line:-1
现在这里有个问题


54
00:02:50,704 --> 00:02:53,707 line:-1
问题就是编译器实际上不知道


55
00:02:53,774 --> 00:02:57,544 line:-1
你将在一个64位的设备上执行代码


56
00:02:58,345 --> 00:02:59,446 line:-1
如果它知道的话


57
00:02:59,813 --> 00:03:03,717 line:-2
它实际上可以利用那个信息
来进一步优化app


58
00:03:04,318 --> 00:03:06,253 line:-1
为了应付这个问题


59
00:03:06,320 --> 00:03:09,556 line:0
我们也收集64位芯片的
Bitcode


60
00:03:10,424 --> 00:03:13,160 line:0
那可以让我们从
Bitcode中创建一个


61
00:03:13,827 --> 00:03:14,695 line:0
速度非常非常快的app


62
00:03:15,362 --> 00:03:17,297 line:0
这非常酷


63
00:03:17,364 --> 00:03:18,198 line:0
这就像…


64
00:03:19,499 --> 00:03:21,835 line:0
这是其中一件
让编译器变得有魔力的事


65
00:03:22,269 --> 00:03:23,337 line:-1
非常棒 嗯？


66
00:03:25,038 --> 00:03:27,975 line:-1
现在让我们转到代码尺寸改进上


67
00:03:28,041 --> 00:03:29,343 line:-1
这是我最喜欢的话题之一


68
00:03:29,409 --> 00:03:30,544 line:-2
（代码尺寸改进
低级别代码尺寸优化）


69
00:03:30,611 --> 00:03:33,447 line:-1
我们一直致力于让编译器生成


70
00:03:33,514 --> 00:03:34,882 line:-1
尽可能少的代码


71
00:03:35,816 --> 00:03:38,852 line:-1
现在代码尺寸非常重要


72
00:03:38,919 --> 00:03:42,556 line:-1
因为代码越多意味着下载越大、越慢


73
00:03:42,990 --> 00:03:46,660 line:-2
app越大会占用
用户设备更多的空间


74
00:03:46,960 --> 00:03:48,262 line:-1
并且你也注意到了这种事


75
00:03:48,896 --> 00:03:53,600 line:-2
因此为了支持用户
我们想优化代码尺寸


76
00:03:53,901 --> 00:03:55,936 line:-1
这个需求超越了其它的度量


77
00:03:56,870 --> 00:03:59,840 line:-2
我们在Xcode中添加了一个
新优化级别


78
00:04:00,908 --> 00:04:04,144 line:-1
即-Oz


79
00:04:05,279 --> 00:04:07,548 line:-1
我要继续说-Oz


80
00:04:07,614 --> 00:04:10,918 line:-2
因为我是加拿大人 因此
我们也可以叫它Oh Canada


81
00:04:16,255 --> 00:04:19,760 line:-1
今天我要给大家展示的是一个


82
00:04:19,826 --> 00:04:21,295 line:-1
-Oz优化的例子


83
00:04:22,029 --> 00:04:23,497 line:-1
但在此之前


84
00:04:24,331 --> 00:04:27,701 line:-1
接下来的几分钟时间 我要尽我所能


85
00:04:27,768 --> 00:04:28,936 line:-1
给你们讲一下编译器是如何运作的


86
00:04:29,002 --> 00:04:30,137 line:-1
（编译器是如何运作的？）


87
00:04:31,805 --> 00:04:33,040 line:-1
当你编译一些代码时


88
00:04:33,974 --> 00:04:36,977 line:-1
初始表示是非常非常目标独立的


89
00:04:37,044 --> 00:04:38,011 line:-1
这是源代码


90
00:04:38,679 --> 00:04:40,347 line:-1
当你把源代码放到编译器中时


91
00:04:41,248 --> 00:04:44,718 line:0
它被降级为IR 一种中间表示


92
00:04:45,352 --> 00:04:49,523 line:0
这种中间表示的大部分
仍然是目标独立的


93
00:04:50,190 --> 00:04:52,826 line:0
但它确实有一些内置的目标依赖功能


94
00:04:53,994 --> 00:04:55,729 line:0
看起来有点像通用程序集


95
00:04:56,830 --> 00:05:00,267 line:0
这时候你就可以停止编译过程


96
00:05:00,334 --> 00:05:01,802 line:0
并给出一些Bitcode


97
00:05:02,302 --> 00:05:03,203 line:0
但我们不会这样做


98
00:05:03,270 --> 00:05:04,271 line:0
我们要继续进行编译


99
00:05:05,606 --> 00:05:07,040 line:0
那个表示…


100
00:05:07,107 --> 00:05:10,244 line:0
将被进一步降级到一个叫做
MIR的级别


101
00:05:10,310 --> 00:05:12,179 line:0
它是Machine IR的缩写


102
00:05:13,247 --> 00:05:14,948 line:0
在编译过程的最后


103
00:05:15,015 --> 00:05:18,952 line:0
Machine IR看起来
与目标的程序集几乎相同


104
00:05:19,319 --> 00:05:21,221 line:0
在这个例子中是64位程序集


105
00:05:21,989 --> 00:05:23,924 line:0
我们可以比如说把代码并排放在一起


106
00:05:25,492 --> 00:05:28,996 line:-1
在我们要讲的优化中


107
00:05:29,730 --> 00:05:32,299 line:-1
我们要使用Machine IR


108
00:05:33,066 --> 00:05:35,302 line:-1
但为了让你们感到熟悉


109
00:05:35,369 --> 00:05:37,671 line:-1
我将在程序集中完成我们所有的示例


110
00:05:37,738 --> 00:05:39,139 line:-1
因为那看起来没有那么可怕


111
00:05:40,974 --> 00:05:43,877 line:-1
我要讲的是一种叫做函数概述的


112
00:05:43,944 --> 00:05:45,212 line:-1
代码尺寸优化


113
00:05:45,279 --> 00:05:46,547 line:-2
（函数概述
一种-OZ代码尺寸优化）


114
00:05:46,613 --> 00:05:49,950 line:-1
函数概述是其中一种优化


115
00:05:50,017 --> 00:05:52,319 line:-1
它会尽可能地为你缩小一些尺寸


116
00:05:52,953 --> 00:05:54,821 line:-2
它在编译器中发挥作用的时间
非常非常晚


117
00:05:55,289 --> 00:05:58,225 line:-2
它实际上不依赖于任意一种
源代码语言


118
00:05:59,593 --> 00:06:02,296 line:-1
最好是通过例子来解释它的作用


119
00:06:03,430 --> 00:06:06,333 line:-1
假如你有一些这样的程序集


120
00:06:07,067 --> 00:06:10,804 line:-2
hasse和kakutani是
一个随机程序中的两个随机函数


121
00:06:11,872 --> 00:06:14,508 line:-2
对于hasse和kakutani
有意思的是


122
00:06:15,108 --> 00:06:18,011 line:-1
它们有一些相同的指令


123
00:06:19,279 --> 00:06:20,547 line:-1
我们可以用它


124
00:06:20,614 --> 00:06:23,150 line:-1
我们可以获取这些相同的指令


125
00:06:24,151 --> 00:06:26,153 line:-1
并把它们输出到一个新函数中


126
00:06:27,387 --> 00:06:29,690 line:-1
在我们把它们输入到新函数之后


127
00:06:30,357 --> 00:06:31,525 line:-1
我们要做的就是


128
00:06:31,592 --> 00:06:34,127 line:-1
替换我们所发现的序列


129
00:06:34,595 --> 00:06:36,463 line:-1
通过调用或分支实现


130
00:06:37,197 --> 00:06:39,900 line:-2
结果就是我们最后会得到一个
尺寸较小的程序


131
00:06:41,068 --> 00:06:42,002 line:-1
有多小呢？


132
00:06:42,402 --> 00:06:46,139 line:-2
嗯 对于我们的测试程序来说
尺寸最多可以缩减25%


133
00:06:50,210 --> 00:06:52,279 line:-1
现在有些人可能在想


134
00:06:52,346 --> 00:06:54,581 line:-1
好的 嗯 这里从哪里节约来的呢？


135
00:06:55,282 --> 00:06:57,317 line:-1
是否是因为复制和粘贴的代码？


136
00:06:57,818 --> 00:06:59,786 line:-1
是否是因为你的代码需要被重构？


137
00:07:00,554 --> 00:07:03,824 line:-2
嗯 都不是 实际上这里所发生的事
有一点深奥


138
00:07:04,124 --> 00:07:06,593 line:-1
如果你复制和粘贴了一堆代码


139
00:07:07,094 --> 00:07:08,962 line:-1
那会影响概述行为


140
00:07:09,029 --> 00:07:11,031 line:-1
但那还不是最重要的事


141
00:07:12,332 --> 00:07:13,500 line:-1
让我们来看另一个例子


142
00:07:14,902 --> 00:07:16,203 line:-1
假如你有这个函数


143
00:07:17,571 --> 00:07:19,506 line:-1
这个函数是做什么的没有关系


144
00:07:19,573 --> 00:07:23,177 line:-1
但我们想提出的是


145
00:07:23,243 --> 00:07:25,979 line:-2
如果我们把这个函数放到编译器中
会发生什么


146
00:07:26,346 --> 00:07:27,314 line:-1
我们会得到一些程序集


147
00:07:28,615 --> 00:07:32,252 line:-1
嗯 你可能会得到像这样的东西


148
00:07:33,420 --> 00:07:36,690 line:-1
再一次 你其实无需了解这个程序集


149
00:07:37,591 --> 00:07:39,526 line:-1
但我想让你们注意一下…


150
00:07:40,060 --> 00:07:43,263 line:-1
函数开端和末端的指令


151
00:07:45,165 --> 00:07:47,234 line:-1
这些叫做函数的序言与结语


152
00:07:47,901 --> 00:07:51,705 line:-2
这些指令不响应源代码中的
任意一行代码


153
00:07:52,673 --> 00:07:55,309 line:-1
这些是由编译器插入的指令


154
00:07:55,843 --> 00:07:57,945 line:-1
用于满足某种系统要求


155
00:07:59,446 --> 00:08:01,849 line:-1
因此这些东西 比如这些存储…


156
00:08:02,583 --> 00:08:03,984 line:-1
和这些负载


157
00:08:04,051 --> 00:08:06,353 line:-1
可能会在你整个程序的多个地方出现


158
00:08:07,120 --> 00:08:10,791 line:-1
这就是概述程序可以用于


159
00:08:10,858 --> 00:08:12,860 line:-1
缩小程序整体尺寸的东西


160
00:08:16,096 --> 00:08:17,564 line:-1
但有一些与此相关的陷阱


161
00:08:17,631 --> 00:08:18,498 line:-1
（陷阱）


162
00:08:19,299 --> 00:08:21,802 line:-1
首先当你进行概述时


163
00:08:22,769 --> 00:08:24,471 line:-1
你会修改程序的控制流


164
00:08:25,405 --> 00:08:29,009 line:-2
在这里你最初可能有ulam
叫做collatz


165
00:08:29,576 --> 00:08:32,479 line:-2
然后你可能把调用概述
到collatz


166
00:08:33,347 --> 00:08:36,116 line:-1
这里发生的事就是


167
00:08:36,183 --> 00:08:38,952 line:-1
我们修改了程序的控制流


168
00:08:40,220 --> 00:08:43,857 line:-1
那么问题是…


169
00:08:44,491 --> 00:08:46,593 line:-2
如果在collatz内
发生了崩溃会怎样？


170
00:08:47,828 --> 00:08:49,363 line:-1
嗯 结果就是


171
00:08:49,630 --> 00:08:51,365 line:-1
你要把你的程序


172
00:08:51,431 --> 00:08:52,966 line:-1
扔到LLDB中


173
00:08:54,201 --> 00:08:57,571 line:-2
你将在反向追踪中看到
你添加的概述函数


174
00:08:57,638 --> 00:08:59,840 line:-1
这是你要留意的东西


175
00:08:59,907 --> 00:09:01,608 line:-1
如果你实际上在概述代码的话


176
00:09:03,343 --> 00:09:05,279 line:-1
另一件事是概述


177
00:09:05,345 --> 00:09:07,281 line:-1
可以增加程序的执行时间


178
00:09:08,815 --> 00:09:09,850 line:-1
你增加了调用


179
00:09:09,917 --> 00:09:11,919 line:-1
并且调用会增加执行时间


180
00:09:12,819 --> 00:09:14,988 line:-1
但这其实还好 因为


181
00:09:15,355 --> 00:09:18,625 line:-1
-Oz优化了尺寸 这超越了一切


182
00:09:19,293 --> 00:09:21,762 line:-2
当你在-Oz时
你就在表达说让它变小点


183
00:09:23,664 --> 00:09:24,731 line:-1
因为这个原因


184
00:09:24,798 --> 00:09:29,203 line:-2
我们不推荐你用-Oz
编译性能敏感性代码


185
00:09:30,237 --> 00:09:32,306 line:-1
如果执行时间对你的程序至关重要


186
00:09:32,806 --> 00:09:34,341 line:-1
-Oz并不是最好的方案


187
00:09:34,408 --> 00:09:35,609 line:-2
（不要用-Oz编译
性能敏感性代码！）


188
00:09:35,676 --> 00:09:39,646 line:-2
然而我们的确推荐你们使用
Instruments


189
00:09:40,347 --> 00:09:41,782 line:-1
Instruments会告诉你


190
00:09:41,849 --> 00:09:44,051 line:-1
你程序中的热点在哪儿


191
00:09:44,117 --> 00:09:46,854 line:-1
这可以让你做出


192
00:09:47,554 --> 00:09:49,957 line:-1
关于app优化的最佳决策


193
00:09:50,924 --> 00:09:53,760 line:-1
编译器有许多不同的优化级别


194
00:09:55,495 --> 00:09:57,030 line:-1
这些优化级别


195
00:09:58,298 --> 00:09:59,766 line:-1
都优化不同的东西


196
00:10:01,768 --> 00:10:02,870 line:-1
比如


197
00:10:03,270 --> 00:10:06,607 line:-1
-Oz不惜任何代价优化代码尺寸


198
00:10:07,274 --> 00:10:09,843 line:-1
结果是你可能会有


199
00:10:10,244 --> 00:10:12,012 line:-1
稍微慢一点点的执行时间


200
00:10:12,646 --> 00:10:14,181 line:-1
但在另一方面


201
00:10:15,616 --> 00:10:16,884 line:-1
你有-O3


202
00:10:16,950 --> 00:10:20,921 line:-2
-O3会不惜任何代价
优化程序的执行时间


203
00:10:20,988 --> 00:10:22,823 line:-1
结果就是


204
00:10:22,890 --> 00:10:24,124 line:-1
你可能会得到一个尺寸较大的程序


205
00:10:26,226 --> 00:10:31,732 line:-2
-Os是Xcode中的
默认优化级别


206
00:10:31,999 --> 00:10:35,769 line:-1
因为它很好地平衡了速度和尺寸


207
00:10:36,937 --> 00:10:39,840 line:-2
但你知道的
你可能有不同的优化需要


208
00:10:39,907 --> 00:10:42,009 line:-2
因此你可以利用
Instruments来解决


209
00:10:44,111 --> 00:10:46,680 line:-1
编译器还提供一些额外的优化


210
00:10:47,181 --> 00:10:48,882 line:-1
我没有足够的时间讲这些


211
00:10:48,949 --> 00:10:50,884 line:-1
不过我还是想稍微提一下


212
00:10:51,952 --> 00:10:53,520 line:-1
它提供PGO


213
00:10:53,787 --> 00:10:55,322 line:-1
即配置文件引导的优化


214
00:10:55,389 --> 00:10:56,323 line:-1
（额外优化）


215
00:10:56,390 --> 00:10:57,824 line:-1
PGO非常酷


216
00:10:57,891 --> 00:11:00,694 line:-1
因为它允许你实际上执行你的程序


217
00:11:01,161 --> 00:11:04,131 line:-1
然后收集关于程序运行得如何的信息


218
00:11:04,631 --> 00:11:08,802 line:-2
然后当你再次编译程序时
你可以用那个信息来指导编译器


219
00:11:10,070 --> 00:11:11,471 line:-1
它还提供LTO


220
00:11:11,538 --> 00:11:12,973 line:-1
即链接时间优化


221
00:11:13,607 --> 00:11:15,943 line:-1
关于链接时间优化的很酷的事就是


222
00:11:16,009 --> 00:11:18,212 line:-1
以编译时间为代价


223
00:11:18,278 --> 00:11:20,647 line:-1
你可以告诉编译器说


224
00:11:21,081 --> 00:11:23,650 line:-1
“好的 让我们等待直到


225
00:11:23,717 --> 00:11:26,253 line:-1
我们在程序中得到每一个文件


226
00:11:26,320 --> 00:11:30,557 line:-2
并用每一个文件来
比如说提供更好的代码嵌入或概述”


227
00:11:31,191 --> 00:11:33,527 line:-1
优化比如代码嵌入或概述


228
00:11:33,861 --> 00:11:36,730 line:-2
如果有更多的情境 会更好发挥作用
因此LTO会提供帮助


229
00:11:37,831 --> 00:11:40,868 line:-1
你还可以合并使用这些额外的优化


230
00:11:40,934 --> 00:11:43,036 line:-1
通过现有优化级别实现


231
00:11:43,337 --> 00:11:46,206 line:-1
从而获得非常非常优秀的实际性能


232
00:11:47,774 --> 00:11:50,677 line:-1
因为我没有足够的时间一一讲到


233
00:11:51,245 --> 00:11:54,548 line:-2
我推荐你们查看之前的
LLVM中的新功能演讲


234
00:11:54,948 --> 00:11:56,517 line:-1
你可以了解更多信息


235
00:11:58,719 --> 00:12:00,521 line:-1
了解这些之后 你可能在想 好的


236
00:12:00,587 --> 00:12:01,855 line:-1
我要如何启用-Oz？


237
00:12:01,922 --> 00:12:04,358 line:-1
嗯 只需要进入项目的创建设置


238
00:12:04,791 --> 00:12:07,194 line:-1
并选择-Oz作为优化级别


239
00:12:08,195 --> 00:12:11,298 line:-1
你还可以在Xcode的特定文件上


240
00:12:11,365 --> 00:12:13,333 line:-1
启用-Oz或其它优化级别


241
00:12:13,700 --> 00:12:18,038 line:-2
通过进入项目的创建阶段
进入编译源列表


242
00:12:18,105 --> 00:12:19,540 line:-1
并设置编译器标志实现


243
00:12:21,642 --> 00:12:23,377 line:-1
好的 我给你们讲了很多内容


244
00:12:23,443 --> 00:12:26,480 line:-2
你很可能在想 好的
这对app的代码尺寸有何影响呢？


245
00:12:26,980 --> 00:12:28,749 line:-1
我该如何得到这种信息？


246
00:12:28,815 --> 00:12:29,650 line:-2
（这会对app代码尺寸
产生何种影响？）


247
00:12:29,716 --> 00:12:32,219 line:-1
嗯 要得到代码尺寸


248
00:12:32,819 --> 00:12:35,689 line:-1
我推荐一个叫做Size的小工具


249
00:12:36,990 --> 00:12:38,258 line:-1
我经常使用这个工具


250
00:12:38,325 --> 00:12:39,593 line:-1
它是一个很不错的小的终端app


251
00:12:40,227 --> 00:12:41,828 line:-1
Size会为你提供


252
00:12:41,895 --> 00:12:46,200 line:-2
关于你app的一些很不错的
低级二进制信息


253
00:12:46,533 --> 00:12:49,403 line:-1
它不会告诉你app的实际总尺寸


254
00:12:49,469 --> 00:12:52,005 line:-1
因为它不包含比如像资产一样的东西


255
00:12:52,439 --> 00:12:54,975 line:-2
如果你在app中
有一个比如巨型照片


256
00:12:55,042 --> 00:12:56,677 line:-2
并且有像Hello World
这样的代码


257
00:12:56,743 --> 00:12:58,378 line:-1
编译器将不会给你提供帮助


258
00:12:59,980 --> 00:13:01,682 line:-1
但假如你想使用Size


259
00:13:02,482 --> 00:13:03,784 line:-1
这是使用方法 非常简单


260
00:13:03,851 --> 00:13:07,020 line:-2
你只需要告诉Size说
这是进入我的二进制的路径


261
00:13:07,921 --> 00:13:09,022 line:-1
它将会


262
00:13:09,089 --> 00:13:11,558 line:-1
它将为你提供像这样的输出


263
00:13:12,359 --> 00:13:14,261 line:-1
它会告诉你


264
00:13:14,328 --> 00:13:16,430 line:-1
你二进制中的每个片段的尺寸


265
00:13:16,830 --> 00:13:19,499 line:-1
并且它还会告诉你二进制的整体尺寸


266
00:13:20,534 --> 00:13:22,703 line:-1
但问题是…


267
00:13:23,203 --> 00:13:27,508 line:-2
二进制中的每个片段实际上
包含许多部分


268
00:13:28,742 --> 00:13:32,112 line:-1
在这个例子中我只关心可执行指令


269
00:13:32,179 --> 00:13:34,281 line:-1
因此我要做的就是


270
00:13:34,815 --> 00:13:37,351 line:-1
为Size提供一些额外标志


271
00:13:38,018 --> 00:13:42,222 line:-1
这些额外标志是-l和-m标志


272
00:13:42,923 --> 00:13:45,292 line:-1
我这样做Size将


273
00:13:45,659 --> 00:13:47,895 line:-1
给我提供每个部分的尺寸


274
00:13:48,395 --> 00:13:51,265 line:-2
如果我想了解
关于可执行指令的更多信息


275
00:13:51,532 --> 00:13:53,734 line:-1
我只需要查看文本部分即可


276
00:13:55,636 --> 00:13:57,871 line:-1
我希望这些可以帮助你们


277
00:13:57,938 --> 00:14:00,474 line:-1
获得关于app代码尺寸的更多理解


278
00:14:01,074 --> 00:14:03,143 line:-2
现在我要走了
我要把舞台交给我同事


279
00:14:03,210 --> 00:14:05,078 line:-1
同样是加拿大人的JF


280
00:14:05,145 --> 00:14:08,182 line:-2
他会与大家分享一些
语言级的代码尺寸改进


281
00:14:08,248 --> 00:14:10,284 line:-2
（代码尺寸改进
语言级优化）


282
00:14:10,350 --> 00:14:11,485 line:-1
谢谢Jessica


283
00:14:13,887 --> 00:14:16,823 line:-1
我是Jeff 我要讲语言级优化


284
00:14:17,124 --> 00:14:21,061 line:-2
Jessica给你们讲了低级别
有点像是程序集优化


285
00:14:21,461 --> 00:14:23,397 line:0
我要讲的是


286
00:14:23,463 --> 00:14:24,865 line:0
当你使用语言自身时所发生的事


287
00:14:24,932 --> 00:14:26,900 line:0
好的 那么是你编写代码的构造


288
00:14:26,967 --> 00:14:28,969 line:0
我今天要讲四种优化


289
00:14:29,236 --> 00:14:30,604 line:0
它们也会影响代码尺寸


290
00:14:32,472 --> 00:14:35,809 line:-2
第一个与Objective C
有关 当你使用代码块时 是的


291
00:14:35,876 --> 00:14:38,178 line:-1
那么代码块有一堆相关联的元数据


292
00:14:38,245 --> 00:14:39,947 line:-1
是编译器为你生成的


293
00:14:40,647 --> 00:14:43,851 line:-1
它有元数据以及帮助函数


294
00:14:44,218 --> 00:14:46,720 line:-1
我们会通过一些例子来看具体的内容


295
00:14:47,487 --> 00:14:50,724 line:-2
假如说你写了一些代码
看起来是这样的


296
00:14:51,358 --> 00:14:53,227 line:-1
好的 那么请注意…


297
00:14:53,527 --> 00:14:55,863 line:-2
我有两个不同的代码块
位于两个不同的函数中


298
00:14:55,929 --> 00:14:57,297 line:-1
代码并不重要


299
00:14:57,364 --> 00:15:01,435 line:-2
但重点是要注意
代码块执行的是完全不同的功能


300
00:15:01,502 --> 00:15:03,370 line:-1
好的 代码之间并没有任何关系


301
00:15:03,537 --> 00:15:05,138 line:-1
但它们的结构非常相似


302
00:15:05,205 --> 00:15:07,908 line:-2
在这一点上
捕获代码块的方式是相似的


303
00:15:07,975 --> 00:15:11,245 line:-2
在这个例子中
我捕获了两个强健的ARC指针


304
00:15:12,212 --> 00:15:15,682 line:-2
现在我告诉你每个代码块都有
与之相关联的元数据


305
00:15:15,749 --> 00:15:16,717 line:-1
那是什么样子的？


306
00:15:17,150 --> 00:15:19,853 line:-1
嗯 这是我们正在讲的元数据 好的


307
00:15:19,920 --> 00:15:22,589 line:-1
编译器自动为你生成元数据


308
00:15:22,656 --> 00:15:25,893 line:-2
当你使用代码块来追踪
与代码块相关的信息


309
00:15:25,959 --> 00:15:28,128 line:-1
并给它们提供语言担保的行为时


310
00:15:28,929 --> 00:15:30,898 line:-1
你要注意的是有代码块尺寸


311
00:15:31,031 --> 00:15:32,799 line:-1
有一个复制帮助和销毁帮助


312
00:15:32,866 --> 00:15:35,536 line:-1
我们需要稍微了解一下这两个方法


313
00:15:35,802 --> 00:15:38,405 line:-2
还有一个代码块方法签名
以及代码块布局信息


314
00:15:39,139 --> 00:15:40,607 line:-1
好的 如果你看一下


315
00:15:40,674 --> 00:15:41,942 line:-1
屏幕上的例子


316
00:15:42,009 --> 00:15:45,379 line:-1
这实际上是编译器生成的合成代码


317
00:15:45,445 --> 00:15:47,347 line:-1
那看起来是一堆技术术语


318
00:15:47,414 --> 00:15:51,485 line:-1
但重要的是结构自身是一样的


319
00:15:51,552 --> 00:15:53,320 line:-1
因此我们可以在许多例子中进行复制


320
00:15:53,720 --> 00:15:55,355 line:-1
请注意在这个例子中我们不能复制


321
00:15:55,656 --> 00:15:59,426 line:-1
因为除了捕获两个强健的ARC指针


322
00:15:59,493 --> 00:16:02,696 line:-2
还存在其它捕获
并且代码块尺寸自身也不一样


323
00:16:03,330 --> 00:16:05,699 line:-1
好的 我们不能合并这些情况 好的


324
00:16:05,766 --> 00:16:09,903 line:-2
但总的来说 在某些情况下
我们可以合并它们 是的


325
00:16:10,270 --> 00:16:12,239 line:-1
请注意在这个例子中


326
00:16:13,740 --> 00:16:17,911 line:-2
我们有函数 是的
复制帮助和销毁帮助可以合并


327
00:16:18,478 --> 00:16:21,548 line:-2
请注意自Xcode 11起
我们把它们合并了 是的


328
00:16:21,615 --> 00:16:22,482 line:-1
那么这些是一样的


329
00:16:22,883 --> 00:16:23,617 line:-1
那意味着什么？


330
00:16:23,684 --> 00:16:27,354 line:-1
嗯 复制帮助用于帮助你移动代码块


331
00:16:27,688 --> 00:16:31,458 line:-2
是的 销毁帮助用于帮你移除代码块
是的


332
00:16:31,525 --> 00:16:34,394 line:-1
当你这样做时 编译器合成的代码


333
00:16:35,095 --> 00:16:36,864 line:-1
看起来就像这样


334
00:16:38,165 --> 00:16:40,200 line:-2
好的 那么在我的例子中
你记得我说过


335
00:16:40,267 --> 00:16:42,669 line:-1
我们有两个强健的ARC指针


336
00:16:42,936 --> 00:16:45,172 line:-2
我们所生成的代码是像那样的代码
我们复制它时 就会保留它


337
00:16:45,239 --> 00:16:47,541 line:-1
当你销毁它时 就会释放它


338
00:16:48,041 --> 00:16:51,011 line:-1
现在当你复制或销毁时


339
00:16:51,078 --> 00:16:52,446 line:-1
代码块还有一堆其它事要做


340
00:16:52,713 --> 00:16:54,181 line:-1
你可能有C++对象


341
00:16:54,248 --> 00:16:55,883 line:-2
在这种情况下你需要调用
复制构造函数


342
00:16:56,350 --> 00:16:58,785 line:-2
你可能有…以及销毁构造函数
是的


343
00:16:58,852 --> 00:17:01,221 line:-1
你可能有一些很弱的ARC指针


344
00:17:01,288 --> 00:17:04,424 line:-2
你可能有具有意义的C类型
或类似的东西 是的


345
00:17:04,491 --> 00:17:06,593 line:-1
还需要发生许多其它事


346
00:17:06,727 --> 00:17:08,561 line:-1
但基本上来说 你使用代码块写代码


347
00:17:08,628 --> 00:17:11,298 line:-1
当编译器检测到有冗余时


348
00:17:11,365 --> 00:17:13,099 line:-1
我们尝试尽可能地剔除它


349
00:17:13,767 --> 00:17:15,169 line:-1
这会得到多少好处？


350
00:17:15,234 --> 00:17:17,503 line:-2
嗯 我们发现在
Objective C app中


351
00:17:17,570 --> 00:17:21,040 line:-2
尺寸大致会缩减百分之二到百分之七
是的


352
00:17:21,108 --> 00:17:22,009 line:-1
并且这是你免费获得的


353
00:17:22,075 --> 00:17:23,210 line:-1
它是默认启用的


354
00:17:27,247 --> 00:17:29,216 line:-1
我要讲的第二个优化


355
00:17:29,316 --> 00:17:33,320 line:-2
与NSObject的
直接子类的实例变量有关


356
00:17:33,787 --> 00:17:35,055 line:-1
这太拗口了


357
00:17:35,122 --> 00:17:36,256 line:-1
我要给你看一个例子


358
00:17:36,323 --> 00:17:38,225 line:-1
并解释一下具体是什么意思 好的


359
00:17:38,292 --> 00:17:39,626 line:-1
假如我正在写一个卡牌游戏


360
00:17:39,960 --> 00:17:41,795 line:-1
我的代码就像这样


361
00:17:41,895 --> 00:17:42,829 line:-1
关键是要记住


362
00:17:42,896 --> 00:17:45,399 line:-2
我正在从NSObject中
直接提交 是的


363
00:17:45,732 --> 00:17:47,835 line:-2
当我写
Objective C代码时


364
00:17:47,901 --> 00:17:51,738 line:-1
我的属性响应实例变量 是的


365
00:17:51,805 --> 00:17:54,174 line:-1
会自动生成实例变量用于备份


366
00:17:54,241 --> 00:17:56,109 line:-1
我在这里所拥有的属性 是的


367
00:17:56,677 --> 00:17:58,679 line:-1
现在我所编写的那个类自身


368
00:17:59,413 --> 00:18:01,615 line:-1
编译器查看它并生成一个结构


369
00:18:01,682 --> 00:18:03,684 line:-1
看起来大概就像这样 是的


370
00:18:04,084 --> 00:18:06,587 line:-1
它列出了成员 一个接一个


371
00:18:07,187 --> 00:18:08,956 line:-2
在Objective C中的
问题是


372
00:18:09,022 --> 00:18:12,125 line:-1
你可以从它派生出一个基类


373
00:18:12,192 --> 00:18:15,262 line:-2
然后把一个框架中的代码
修改为另一个框架的代码


374
00:18:15,562 --> 00:18:18,699 line:-2
然后基类也会改变
并拥有新成员等等


375
00:18:18,765 --> 00:18:20,934 line:-1
派生类不会中断 是的


376
00:18:21,001 --> 00:18:23,270 line:-2
并且Objective…
在C++中你就不能这样做


377
00:18:23,337 --> 00:18:26,406 line:-1
如果你派生 就会改变基类的布局


378
00:18:26,473 --> 00:18:27,307 line:-1
你就有新的尺寸


379
00:18:27,875 --> 00:18:29,910 line:-2
在这里
我从NSObject中进行派生


380
00:18:29,977 --> 00:18:34,081 line:-2
NSObject实际上
是平台的ABI的一部分


381
00:18:34,147 --> 00:18:36,183 line:-1
我们知道它不会发生改变 是的


382
00:18:36,483 --> 00:18:39,119 line:-1
因此我们有类的这种布局


383
00:18:39,453 --> 00:18:41,522 line:-1
当我们实施类时 是的


384
00:18:41,588 --> 00:18:43,724 line:-2
我实施这个
initWithName方法


385
00:18:44,157 --> 00:18:47,461 line:-2
我就知道类中的每一个东西的布局
是的


386
00:18:47,728 --> 00:18:51,231 line:-1
那么自Xcode 11起 编译器


387
00:18:51,298 --> 00:18:53,233 line:-2
就可以说我知道插件在哪儿
我可以对它们进行硬编码


388
00:18:53,767 --> 00:18:55,435 line:-1
嗯 好的 那实际上是什么意思？


389
00:18:55,936 --> 00:18:57,638 line:-2
我要看一下这个
initWithName方法


390
00:18:59,139 --> 00:19:00,741 line:-1
它看起来是这样的东西 是的


391
00:19:00,807 --> 00:19:02,743 line:-2
我让
self.name = name


392
00:19:03,010 --> 00:19:05,512 line:-1
现在设置函数为它生成了一段代码


393
00:19:05,579 --> 00:19:08,415 line:-2
在Xcode 11之前
看起来是类似这样的代码 是的


394
00:19:08,482 --> 00:19:12,052 line:-1
它把查找合成到了一个


395
00:19:12,119 --> 00:19:14,821 line:-2
了解名称属性的插件
或名称IVAR的插件的表中


396
00:19:15,422 --> 00:19:17,257 line:-1
代码量很少


397
00:19:17,558 --> 00:19:20,260 line:0
但自Xcode 11起
我们想实现的是这样的操作 是的


398
00:19:20,327 --> 00:19:23,130 line:0
当你实施方法时 我们要硬编码插件


399
00:19:23,397 --> 00:19:25,933 line:0
那个方法是S对象的直接派生物


400
00:19:26,433 --> 00:19:28,068 line:0
这就可以理解了 我们知道它不会变


401
00:19:28,135 --> 00:19:30,337 line:0
因为我们实施的是你刚写的方法


402
00:19:30,571 --> 00:19:31,405 line:-1
这看起来不重要


403
00:19:31,471 --> 00:19:33,207 line:-1
只是三个指令中的一个 是的


404
00:19:33,273 --> 00:19:36,076 line:-2
但它会缩减app
大概百分之二的尺寸


405
00:19:36,910 --> 00:19:37,845 line:-1
非常棒


406
00:19:40,514 --> 00:19:42,616 line:-1
我要讲的下一个尺寸优化


407
00:19:42,850 --> 00:19:45,452 line:-1
是对C++类型改进了可调试性


408
00:19:45,519 --> 00:19:47,521 line:-1
你可能会说 等一下 这不是尺寸


409
00:19:47,821 --> 00:19:49,156 line:-1
它是尺寸 让我来解释一下


410
00:19:49,857 --> 00:19:51,258 line:-1
好的 我说我写了一些代码


411
00:19:52,025 --> 00:19:53,227 line:-1
这是非常直截了当的代码


412
00:19:53,493 --> 00:19:55,162 line:-1
它是命令行app 是的


413
00:19:55,596 --> 00:19:59,800 line:-2
我要做的就是从命令行中取出参数
作为字符串


414
00:20:00,200 --> 00:20:02,135 line:-1
并把它们转换为整型


415
00:20:02,202 --> 00:20:03,871 line:-2
并把它们放到
std::vector中


416
00:20:03,937 --> 00:20:06,206 line:-2
然后把它们一个接一个地打印出来
是的


417
00:20:06,273 --> 00:20:07,975 line:-1
这是一个非常直截了当的演示app


418
00:20:08,208 --> 00:20:12,179 line:-1
重点是我使用了标准库的类型


419
00:20:12,646 --> 00:20:14,815 line:-2
特别是我使用了矢量
pushback


420
00:20:14,882 --> 00:20:16,783 line:-1
我想在这里放一个断点


421
00:20:17,451 --> 00:20:21,421 line:-2
这在Xcode 11之前
可能不那么好用


422
00:20:21,488 --> 00:20:24,224 line:-1
原因是我们控制着


423
00:20:24,591 --> 00:20:27,995 line:-1
库C++方法的可见性


424
00:20:28,061 --> 00:20:31,565 line:-2
就像pushback强制把它们
嵌入你的代码中一样 是吧


425
00:20:31,632 --> 00:20:32,699 line:-1
一般来说没有问题


426
00:20:32,766 --> 00:20:36,170 line:-2
问题是pushback是一系列
复杂操作 然后优化程序进城去


427
00:20:36,236 --> 00:20:37,638 line:-1
四处游逛 删除一些代码


428
00:20:37,938 --> 00:20:40,340 line:-2
而调试程序 当你告诉它
在pushback时停止时


429
00:20:40,407 --> 00:20:41,742 line:-1
你不是在尝试进入pushback


430
00:20:41,808 --> 00:20:43,544 line:-1
你只是想在那一行代码中放一个断点


431
00:20:43,644 --> 00:20:45,112 line:-2
其实调试程序不知道
pushback在哪


432
00:20:45,179 --> 00:20:47,181 line:-1
因为到处都是 对吧


433
00:20:47,548 --> 00:20:50,384 line:-1
那么自Xcode 11起


434
00:20:50,450 --> 00:20:51,885 line:-1
我们不再强制代码嵌入


435
00:20:52,152 --> 00:20:55,522 line:-2
我们让代码嵌入程序决定
何时应该发生代码嵌入 是的


436
00:20:55,589 --> 00:20:57,958 line:-1
在这个具体的例子中


437
00:20:58,025 --> 00:20:59,226 line:-1
在Xcode 11之前


438
00:20:59,293 --> 00:21:02,930 line:-2
你放在那儿的断点实际上会在
第二个循环时停止 对吧


439
00:21:02,996 --> 00:21:04,998 line:-1
因为到处都是pushbacks


440
00:21:05,699 --> 00:21:07,801 line:-2
自Xcode 11起
我们不再强制代码嵌入


441
00:21:07,868 --> 00:21:10,037 line:-1
这是调试会话


442
00:21:10,103 --> 00:21:11,305 line:-1
假如我运行lldb


443
00:21:11,772 --> 00:21:14,408 line:-2
我运行我的程序
假如我在第12行放了一个断点


444
00:21:15,342 --> 00:21:16,643 line:-1
是的 非常简单明了


445
00:21:17,244 --> 00:21:19,213 line:-2
调试程序进入并说耶 断点
找到它了


446
00:21:19,746 --> 00:21:20,981 line:-1
现在我点击运行


447
00:21:21,348 --> 00:21:22,182 line:-1
现在会发生这样的事


448
00:21:23,417 --> 00:21:26,086 line:-1
好的 那么我在第12行停止了


449
00:21:26,153 --> 00:21:27,421 line:-1
酷 起作用了 是的


450
00:21:27,788 --> 00:21:30,023 line:-2
这个演示有点无聊
因为它达到了你的预期


451
00:21:31,358 --> 00:21:33,794 line:-1
它原来不会 现在很酷的是


452
00:21:34,127 --> 00:21:35,696 line:-1
我正在讲代码尺寸优化 是的


453
00:21:35,762 --> 00:21:38,332 line:-2
嗯 这个 因为我们不强制嵌入
非常大的东西


454
00:21:38,398 --> 00:21:40,634 line:-1
如果你在代码中频繁使用stl


455
00:21:40,701 --> 00:21:43,203 line:-1
你会创建相当大量的代码膨胀


456
00:21:43,670 --> 00:21:46,874 line:-1
我们测量了在大app发布模式上


457
00:21:46,940 --> 00:21:49,443 line:-2
如果你这样做 你会缩减代码尺寸
最多可以缩减百分之七


458
00:21:49,843 --> 00:21:51,612 line:-1
再一次 这是在发布模式中 对吧


459
00:21:52,079 --> 00:21:55,549 line:-2
这节约了相当大量的代码
并进行了相当好的调试


460
00:21:55,983 --> 00:21:56,817 line:-1
非常棒


461
00:21:57,618 --> 00:21:59,319 line:-1
我要讲的最后一个缩小代码尺寸的是


462
00:21:59,386 --> 00:22:01,622 line:-1
C++静态销毁程序抑制


463
00:22:01,688 --> 00:22:02,523 line:-1
（C++静态销毁程序抑制）


464
00:22:02,589 --> 00:22:03,557 line:-1
再一次


465
00:22:03,824 --> 00:22:06,260 line:-2
让我们通过一个例子来解释
我具体表达的是什么意思


466
00:22:07,027 --> 00:22:09,763 line:-2
假如我写了一些
非常通用的C++代码


467
00:22:09,830 --> 00:22:12,966 line:-2
大部分app最后都会有一个记录器
就是像这样的东西 是吧


468
00:22:13,333 --> 00:22:14,268 line:-1
当你记录时


469
00:22:14,334 --> 00:22:16,537 line:-1
你不想在app中传递记录器


470
00:22:16,603 --> 00:22:18,572 line:-2
因此你有一个全局变量
叫做logger


471
00:22:19,106 --> 00:22:20,340 line:-1
非常简单明了


472
00:22:20,641 --> 00:22:22,543 line:-2
在C++中 当你拥有一个这样的
全局变量时


473
00:22:22,609 --> 00:22:25,979 line:-2
会有一个销毁程序
它在app的生命周期的末端运行


474
00:22:26,580 --> 00:22:27,781 line:-1
好的 请注意


475
00:22:27,848 --> 00:22:30,017 line:-2
logger包含一个缓冲区
是字符串的std::vector


476
00:22:30,083 --> 00:22:32,419 line:-1
这就是销毁程序的功能


477
00:22:32,486 --> 00:22:34,454 line:-1
它会销毁字符串的那个矢量 是的


478
00:22:34,821 --> 00:22:36,023 line:-1
目前来说简单明了


479
00:22:36,256 --> 00:22:37,524 line:-1
现在我进入我的app


480
00:22:37,891 --> 00:22:38,892 line:-1
它是个游戏


481
00:22:39,359 --> 00:22:40,761 line:-1
是的 我在这里添加这段代码


482
00:22:40,827 --> 00:22:43,297 line:-2
它只是个游戏
我只有一个app


483
00:22:43,363 --> 00:22:46,600 line:-2
和一个游戏
所以我在这里有一个全局变量


484
00:22:47,134 --> 00:22:48,702 line:-1
代码完全合理 是吧


485
00:22:49,236 --> 00:22:53,540 line:-1
现在问题是如果我进入


486
00:22:53,941 --> 00:22:55,075 line:-1
并在游戏结构中添加一些记录代码


487
00:22:55,709 --> 00:22:58,545 line:-2
嗯 请注意
logger是全局变量


488
00:22:58,612 --> 00:22:59,780 line:-1
游戏也是全局的


489
00:23:00,047 --> 00:23:01,548 line:-1
那可能不太管用


490
00:23:01,615 --> 00:23:04,718 line:-2
原因是在C++中
在不同的翻译单元之间


491
00:23:05,018 --> 00:23:08,522 line:-1
不能保证调用销毁程序的次序 是的


492
00:23:08,589 --> 00:23:11,692 line:-2
在许多情况下 你会在销毁游戏之前
销毁logger


493
00:23:12,025 --> 00:23:15,262 line:-1
这会导致崩溃 非常不好 是吧


494
00:23:15,662 --> 00:23:17,264 line:-1
这个问题有点头疼


495
00:23:17,931 --> 00:23:20,200 line:-2
然后让我们再深入去看
C++是如何运作的


496
00:23:20,267 --> 00:23:23,170 line:-1
这是C++在我心目中的样子 是的


497
00:23:23,537 --> 00:23:25,973 line:-1
那么你开始添加线程本地存储


498
00:23:26,039 --> 00:23:27,040 line:-1
你开始添加线程


499
00:23:27,341 --> 00:23:30,277 line:-1
比如C++销毁程序次序的图表


500
00:23:30,344 --> 00:23:32,479 line:-1
非常复杂 它太过复杂了


501
00:23:32,546 --> 00:23:35,249 line:-2
甚至和编译器的复杂程度差不多
人们想要了解它是如何运作的


502
00:23:35,682 --> 00:23:37,784 line:-2
但却没有任何概念 几个月前我需要
在Clang中修复一个错误


503
00:23:37,851 --> 00:23:40,354 line:-2
在非常罕见的情况下
当我尝试清理Clang自身时


504
00:23:40,621 --> 00:23:43,524 line:-1
Clang会在终端发生崩溃 是吧


505
00:23:43,590 --> 00:23:44,625 line:-1
这有点尴尬


506
00:23:44,691 --> 00:23:47,628 line:-1
这只是表明要得到正确的销毁次序


507
00:23:47,694 --> 00:23:49,897 line:-1
并不是一件小事 好吧


508
00:23:50,264 --> 00:23:52,199 line:-1
让我们在深入一点 在iOS上…


509
00:23:52,266 --> 00:23:54,868 line:-1
这是app的生命周期 是的


510
00:23:54,935 --> 00:23:58,038 line:-2
其实app并没有
一个关闭的合理时间


511
00:23:58,305 --> 00:24:00,974 line:-2
有时候当app进入前台时
却进入了后台


512
00:24:01,041 --> 00:24:03,410 line:-1
并且关闭了 但跟销毁一样


513
00:24:03,477 --> 00:24:06,780 line:-2
好像app的关闭
对于那种类型的生命周期来说


514
00:24:06,847 --> 00:24:08,081 line:-1
意义不大


515
00:24:08,549 --> 00:24:11,251 line:-1
最后的结果就是你实施回调


516
00:24:11,552 --> 00:24:12,986 line:-1
类似这样的东西 是的


517
00:24:13,053 --> 00:24:14,788 line:-1
然后app告诉你 你将进入后台


518
00:24:14,855 --> 00:24:16,023 line:-1
你将返回去 类似这样的


519
00:24:16,089 --> 00:24:18,292 line:-2
销毁程序不完全是在一个
合理的地方运行


520
00:24:19,092 --> 00:24:21,161 line:-1
如果我们返回我们之前的代码 是的


521
00:24:21,228 --> 00:24:22,796 line:-2
它是个app
它有一个logger


522
00:24:23,397 --> 00:24:24,464 line:-1
这是我们写的


523
00:24:24,531 --> 00:24:27,234 line:-1
嗯 其实并没有一个合理的时间


524
00:24:27,301 --> 00:24:29,670 line:-2
让这个logger
刷新它的缓冲区 是吧


525
00:24:30,037 --> 00:24:32,673 line:-1
但跟在销毁程序中一样


526
00:24:32,739 --> 00:24:35,409 line:-2
你真正想要做的就是说
嗯 如果你要进入后台


527
00:24:35,475 --> 00:24:37,010 line:-1
请首先刷新缓冲区 是吧


528
00:24:37,277 --> 00:24:39,479 line:-1
你在销毁程序中没有任何清理要执行


529
00:24:39,780 --> 00:24:41,448 line:-1
销毁程序看起来有点傻


530
00:24:41,515 --> 00:24:44,218 line:-2
生成了一大堆代码
但却没有发挥任何功能 是吧


531
00:24:44,284 --> 00:24:46,486 line:-2
那么自Xcode 11起
我们添加了一个属性


532
00:24:46,553 --> 00:24:49,022 line:-2
允许你说 嘿 不要销毁这个东西
是的


533
00:24:49,089 --> 00:24:50,991 line:-1
它是全局属性 它不需要销毁程序


534
00:24:52,426 --> 00:24:55,229 line:-2
当然了 当发生回调时
你仍需要手动刷新


535
00:24:55,295 --> 00:24:57,965 line:-2
并且你可以在Xcode中
进入整个app


536
00:24:58,031 --> 00:25:00,934 line:-2
并使用设置对整个app设置
那个全局属性


537
00:25:01,535 --> 00:25:02,569 line:-1
看起来非常微不足道


538
00:25:02,636 --> 00:25:05,005 line:-2
但它却根据你在代码中
使用了多少C++


539
00:25:05,072 --> 00:25:07,908 line:-2
给你提供也许是缩减百分之一的
代码尺寸 是的 那非常棒


540
00:25:08,742 --> 00:25:11,111 line:-1
让我们从代码尺寸缩减继续讲


541
00:25:11,411 --> 00:25:13,514 line:-1
我们要讲一下诊断


542
00:25:13,981 --> 00:25:16,250 line:-1
我要讲五种诊断


543
00:25:16,316 --> 00:25:19,152 line:-2
在Xcode 11中
默认都是开启状态


544
00:25:20,087 --> 00:25:23,390 line:-2
第一个是
call-to-pure-virtual函数


545
00:25:23,457 --> 00:25:25,259 line:-1
来自构造程序或销毁程序


546
00:25:25,726 --> 00:25:26,793 line:-1
那是什么意思？


547
00:25:26,860 --> 00:25:28,762 line:-1
让我们写一些面向对象的代码


548
00:25:28,829 --> 00:25:30,564 line:-1
从表开始 好吧


549
00:25:30,831 --> 00:25:31,999 line:-1
我有这个表


550
00:25:32,065 --> 00:25:34,535 line:-1
我想用一个纯虚函数来说明


551
00:25:34,601 --> 00:25:35,435 line:-1
我正在说什么


552
00:25:35,502 --> 00:25:38,005 line:-1
我要写这个galahad函数


553
00:25:38,071 --> 00:25:39,173 line:-1
它是纯虚函数


554
00:25:39,540 --> 00:25:41,275 line:-1
我要给表添加一个销毁程序


555
00:25:41,341 --> 00:25:42,643 line:-1
当表被销毁时 我要说


556
00:25:42,709 --> 00:25:44,745 line:-1
galahad 请查找把手 是的


557
00:25:45,279 --> 00:25:46,113 line:-1
这非常有意义


558
00:25:46,180 --> 00:25:48,415 line:-1
我那样做了 我得到了一个警告


559
00:25:49,016 --> 00:25:51,585 line:-2
自Xcode 11起
你得到这个新警告的原因是


560
00:25:51,652 --> 00:25:54,388 line:-1
因为从构造程序或销毁程序中


561
00:25:54,454 --> 00:25:56,323 line:-1
调用纯虚函数没有任何意义


562
00:25:56,390 --> 00:25:57,424 line:-1
没什么可以调用的函数


563
00:25:57,791 --> 00:26:00,127 line:-1
因为表是基类


564
00:26:00,194 --> 00:26:04,164 line:-2
绝大部分派生类已经在这种情况下
被销毁了 是的


565
00:26:04,231 --> 00:26:07,067 line:-1
没有任何实施需要再调用


566
00:26:07,134 --> 00:26:08,235 line:-1
这个galahad函数了


567
00:26:09,002 --> 00:26:10,270 line:-1
那你要如何修复这个问题呢？


568
00:26:10,337 --> 00:26:11,205 line:-1
嗯 你可以


569
00:26:11,271 --> 00:26:13,240 line:-2
进入实施那个
galahad的派生类


570
00:26:13,307 --> 00:26:18,245 line:-2
其销毁程序调用查找galahad
并返回一个grail或类似的东西


571
00:26:18,846 --> 00:26:19,980 line:-1
那就有点道理了


572
00:26:20,681 --> 00:26:22,583 line:-1
好的 让我们继续看下一个诊断


573
00:26:24,284 --> 00:26:25,853 line:-1
带转置参数的memset


574
00:26:26,520 --> 00:26:29,523 line:-1
假如我这个叫做收件箱的结构


575
00:26:29,790 --> 00:26:31,225 line:-1
其中有一些邮件


576
00:26:31,291 --> 00:26:33,794 line:-1
我度假回来 我看到收件箱是零


577
00:26:33,861 --> 00:26:36,230 line:-2
我该怎么做？我只是把
整个收件箱memset为零


578
00:26:36,830 --> 00:26:38,799 line:-2
现在我写了这段代码
谁可以指出错误？


579
00:26:40,234 --> 00:26:42,269 line:-2
是的 我把参数调换成了
memset


580
00:26:42,636 --> 00:26:44,905 line:-1
我时常会犯这种错误


581
00:26:44,972 --> 00:26:47,708 line:-2
因为我不知道要memset
参数的顺序是什么


582
00:26:47,774 --> 00:26:50,944 line:-1
我尝试设置销毁的值是否是


583
00:26:51,278 --> 00:26:54,515 line:-2
第一个参数或是否是第二个参数
是的


584
00:26:54,848 --> 00:26:56,583 line:-1
它是否是我尝试要设置的尺寸


585
00:26:56,650 --> 00:26:58,719 line:-2
那么现在自Xcode 11起
我们会对其进行检测


586
00:26:58,785 --> 00:26:59,620 line:-1
并告诉你


587
00:26:59,686 --> 00:27:00,954 line:-1
你该如何修复它？非常简单


588
00:27:01,021 --> 00:27:02,956 line:-1
你只需要把参数翻转过来即可 是的


589
00:27:03,490 --> 00:27:05,826 line:-1
在这里你可能想要考虑的一件事是


590
00:27:05,893 --> 00:27:07,661 line:-1
不想使用难以获取的memset


591
00:27:07,728 --> 00:27:08,962 line:-1
甚至像看代码一样


592
00:27:09,029 --> 00:27:10,864 line:-1
仍然不明确它是否正确 是的


593
00:27:11,331 --> 00:27:13,767 line:-2
你想要做的可能是使用像
std::fill这样的东西


594
00:27:13,834 --> 00:27:15,002 line:-1
在某些情况下讲得通


595
00:27:15,369 --> 00:27:17,237 line:-2
你重写代码
看起来就像是那样的代码


596
00:27:18,138 --> 00:27:19,239 line:-1
现在出错几率更小了


597
00:27:19,306 --> 00:27:21,241 line:-1
但是更容易了解它正在做什么了


598
00:27:21,675 --> 00:27:22,843 line:-1
是的 看起来有点整洁了


599
00:27:23,977 --> 00:27:25,679 line:-1
我要讲的第三个警告是…


600
00:27:26,647 --> 00:27:27,681 line:-1
标准的move返回


601
00:27:27,748 --> 00:27:30,217 line:-1
move在C++中有点复杂


602
00:27:30,284 --> 00:27:32,553 line:-1
但总是有许多诊断可以帮助你


603
00:27:32,619 --> 00:27:34,488 line:-1
以合适的方式使用它 是的


604
00:27:34,888 --> 00:27:37,057 line:-2
那么再一次
让我们写一段面向对象的代码


605
00:27:37,124 --> 00:27:38,692 line:-1
来了解我正在讲什么


606
00:27:38,759 --> 00:27:41,595 line:-1
假如我有三个结构 狮子、山羊和蛇


607
00:27:41,962 --> 00:27:43,397 line:-1
以及爱面向对象


608
00:27:43,463 --> 00:27:45,365 line:-1
我要把它们合成奇美拉 是的


609
00:27:45,899 --> 00:27:46,733 line:-1
代码不错


610
00:27:46,900 --> 00:27:49,937 line:-2
我要进入并分配
Bellerophon


611
00:27:50,003 --> 00:27:51,505 line:-1
我想杀死奇美拉


612
00:27:51,572 --> 00:27:53,340 line:-1
然后返回一个我杀死了它的证据


613
00:27:53,674 --> 00:27:56,443 line:-2
嗯 现在有个诊断告诉我说
嘿 你知道吗？


614
00:27:56,710 --> 00:27:58,378 line:-1
比如你正在返回奇美拉


615
00:27:58,712 --> 00:28:01,448 line:-1
但你只是比如你正在返回的返回类型


616
00:28:01,515 --> 00:28:02,883 line:-1
实际上是山羊 是的


617
00:28:02,950 --> 00:28:05,018 line:-1
我要获取那个矢量 复制它


618
00:28:05,085 --> 00:28:08,121 line:-1
因为从奇美拉中切出矢量


619
00:28:08,188 --> 00:28:09,823 line:-1
并把矢量放到山羊中是没有意义的


620
00:28:10,324 --> 00:28:12,960 line:-1
好的 那么你在这里做什么


621
00:28:13,026 --> 00:28:15,429 line:-2
你所写的代码基本上就是
你要执行的操作


622
00:28:15,495 --> 00:28:16,763 line:-1
与std::move有关


623
00:28:16,830 --> 00:28:19,633 line:-2
你依赖于copy elision
是的


624
00:28:19,700 --> 00:28:22,870 line:-2
在绝大多数时候 当你执行
返回时不需要std::move


625
00:28:23,203 --> 00:28:25,339 line:-2
在这个例子中你却需要它
因为它执行复制 是的


626
00:28:25,405 --> 00:28:28,442 line:-1
语言说返回 只是切出类的一部分


627
00:28:28,509 --> 00:28:29,643 line:-1
不管怎样 听起来有点古怪


628
00:28:29,710 --> 00:28:31,745 line:-1
move不应该是隐含的 是吧


629
00:28:32,112 --> 00:28:35,082 line:-2
因此警告告诉你
你很可能不想这样做 是吧


630
00:28:35,382 --> 00:28:38,285 line:-2
第一种修复方式是进入并调用
std::move


631
00:28:39,586 --> 00:28:43,190 line:-2
好的 现在那会把矢量移动到山羊中
是吧


632
00:28:43,257 --> 00:28:45,492 line:-1
这样执行move更有效率一些


633
00:28:46,093 --> 00:28:48,495 line:-1
你可能想要做的另一件事是


634
00:28:48,562 --> 00:28:51,665 line:-1
不仅仅返回山羊 还要让人们相信你


635
00:28:51,732 --> 00:28:52,833 line:-1
它实际上是奇美拉


636
00:28:52,900 --> 00:28:54,034 line:-1
嗯 你只要返回奇美拉


637
00:28:54,101 --> 00:28:56,436 line:-2
那就讲得通了 在这里你得到了
copy elision 是的


638
00:28:56,503 --> 00:28:58,772 line:-2
如果你添加了std::move
编译器会告诉你


639
00:28:58,839 --> 00:29:00,807 line:-2
你正在通过添加move
让事情变得糟糕


640
00:29:01,441 --> 00:29:03,110 line:-1
你想要做的另一件事 因为你不确定


641
00:29:03,177 --> 00:29:04,645 line:-1
你是否会得到奇美拉


642
00:29:04,945 --> 00:29:06,847 line:-2
就是你可能想返回一个带
std::optional奇美拉


643
00:29:06,914 --> 00:29:08,115 line:-1
这再一次做了对的事情


644
00:29:08,182 --> 00:29:10,884 line:-1
它不会从类中切出东西 因此语言说


645
00:29:10,951 --> 00:29:12,686 line:-2
是的 这会得到隐含的
copy elision


646
00:29:13,487 --> 00:29:15,656 line:-1
好的 我想讲的另一个诊断是


647
00:29:16,023 --> 00:29:17,191 line:-1
size-of-pointer-div


648
00:29:17,891 --> 00:29:20,127 line:-2
它是什么样的？
嗯 假如我写了这段代码


649
00:29:20,794 --> 00:29:21,662 line:-1
相当不错的代码


650
00:29:22,062 --> 00:29:23,897 line:-1
目前没有任何问题 是吧


651
00:29:23,964 --> 00:29:25,499 line:-1
我说的是我有这个数组


652
00:29:25,999 --> 00:29:29,169 line:-1
取数组的大小除以第零个元素


653
00:29:29,236 --> 00:29:31,471 line:-1
那会给你提供数组内的元素数量


654
00:29:31,805 --> 00:29:34,608 line:-1
这是C样式代码的标准代码 是吧


655
00:29:35,943 --> 00:29:36,877 line:-1
一个很常用的计算


656
00:29:36,944 --> 00:29:39,813 line:-1
这里的问题是如果我重构这段代码


657
00:29:40,614 --> 00:29:41,648 line:-1
我做这样的操作


658
00:29:41,715 --> 00:29:43,984 line:-1
我把数组作为参数进行传递


659
00:29:44,585 --> 00:29:48,288 line:-1
嗯 那样C规则会说数组


660
00:29:48,355 --> 00:29:49,523 line:-1
现在衰减到一个指针


661
00:29:50,123 --> 00:29:51,625 line:-1
而新诊断告诉你说 嘿


662
00:29:51,692 --> 00:29:53,460 line:-1
这很可能不是你想要的结果 是吧


663
00:29:53,527 --> 00:29:55,762 line:-1
这不会给你返回数组中的元素数量


664
00:29:56,697 --> 00:29:58,098 line:-1
这是一个问题


665
00:29:59,032 --> 00:30:01,301 line:-1
我们发现了它 你该如何修复它呢？


666
00:30:01,368 --> 00:30:03,637 line:-1
嗯 你可以用稍微不同的方式写代码


667
00:30:03,704 --> 00:30:05,105 line:-1
我们不使用那种常见的计算


668
00:30:05,739 --> 00:30:08,442 line:-2
是的 你可用类似
std::size这样的东西


669
00:30:08,509 --> 00:30:11,612 line:-1
意思是我们不错误地重构代码


670
00:30:11,912 --> 00:30:14,681 line:-2
当你尝试重构代码时
你会遇到那个问题 是吧


671
00:30:14,748 --> 00:30:16,450 line:-2
std::size
恰好会为你处理这个问题


672
00:30:16,984 --> 00:30:19,853 line:-1
这是一种警告 它捕捉错误


673
00:30:21,121 --> 00:30:22,523 line:-1
我要讲的最后一个诊断是


674
00:30:22,589 --> 00:30:24,057 line:-1
defaulted-function-delete


675
00:30:24,525 --> 00:30:27,060 line:-2
再一次 假如我在这里写了
这段漂亮的代码 好的


676
00:30:27,127 --> 00:30:28,462 line:-1
我的代码结构失常


677
00:30:28,529 --> 00:30:30,531 line:-2
我有一些浮动的眼柄
一些眼睛和嘴巴


678
00:30:30,898 --> 00:30:32,900 line:-1
我想默认这种异常结构


679
00:30:32,966 --> 00:30:34,401 line:-1
请给我一个默认的异常结构


680
00:30:34,601 --> 00:30:36,470 line:-1
嗯 编译器会告诉你说 嘿


681
00:30:36,537 --> 00:30:38,305 line:-1
我不知道什么是默认的异常结构


682
00:30:38,372 --> 00:30:40,107 line:-2
为什么不知道呢？
嗯 我有一个浮动引用


683
00:30:40,174 --> 00:30:43,110 line:-2
我不能为那个引用
合成错误的构造程序


684
00:30:43,644 --> 00:30:46,747 line:-2
那是一种我不能默认创建的类型
是的


685
00:30:47,080 --> 00:30:50,184 line:-2
有许多其它方式
不只是在C++中进行引用


686
00:30:50,250 --> 00:30:52,386 line:-1
要创建非默认构造的东西


687
00:30:52,452 --> 00:30:53,954 line:-1
编译器现在会告诉你


688
00:30:54,021 --> 00:30:55,489 line:-1
如果你请求默认构造程序


689
00:30:55,556 --> 00:30:57,758 line:-2
它会告诉你我不能给你提供
默认的构造程序


690
00:30:57,925 --> 00:31:00,594 line:-2
你该如何修复这个问题呢？
嗯 其中一种方式就是


691
00:31:01,461 --> 00:31:02,462 line:-1
自己创建构造程序


692
00:31:02,529 --> 00:31:05,432 line:-2
当你传入眼柄时
那会自动创建一个引用


693
00:31:05,766 --> 00:31:06,600 line:-1
看起来很整洁


694
00:31:06,667 --> 00:31:10,404 line:-1
但就我而言 我认为情人眼里出西施


695
00:31:10,470 --> 00:31:12,706 line:-2
但也许这个异常应该以不同的方式
进行编码


696
00:31:12,773 --> 00:31:14,541 line:-1
而不是通过一个浮动引用


697
00:31:14,608 --> 00:31:16,143 line:-1
也许你应该这样做 是的


698
00:31:16,210 --> 00:31:18,245 line:-1
这样做好多了 是的


699
00:31:18,312 --> 00:31:20,480 line:-1
现在我可以默认创建异常了


700
00:31:21,148 --> 00:31:22,983 line:-1
好的 那么这就是


701
00:31:23,050 --> 00:31:24,184 line:-1
我想与你们分享的诊断


702
00:31:24,251 --> 00:31:25,652 line:-1
现在我要把舞台交给Devin


703
00:31:25,719 --> 00:31:27,921 line:-1
他会讲一下新的静态分析器检查


704
00:31:29,857 --> 00:31:31,258 line:0
（新静态分析器检查）


705
00:31:32,926 --> 00:31:34,494 line:-1
到目前为止


706
00:31:34,962 --> 00:31:36,296 line:-1
我们在本场演讲中所讲的警告


707
00:31:36,363 --> 00:31:38,465 line:0
都来自你创建时的编译器


708
00:31:39,199 --> 00:31:41,502 line:0
但我们还有其它工具
可以帮你查找错误


709
00:31:42,503 --> 00:31:43,971 line:0
其中一个就是静态分析器


710
00:31:46,740 --> 00:31:49,243 line:-1
分析器查找你代码深处的错误


711
00:31:49,309 --> 00:31:51,612 line:-1
甚至不运行你的app就可以实现


712
00:31:52,479 --> 00:31:53,947 line:-1
这使它擅长测试


713
00:31:54,214 --> 00:31:56,517 line:-1
和捕捉那些难以再现的错误


714
00:31:56,917 --> 00:31:59,453 line:-1
你甚至从未想过为之写测试代码


715
00:32:00,153 --> 00:32:02,523 line:-1
它甚至会给你显示


716
00:32:02,923 --> 00:32:04,458 line:-1
错误产生的步骤序列


717
00:32:05,259 --> 00:32:08,428 line:-1
这样易于理解问题并修复问题


718
00:32:10,230 --> 00:32:14,067 line:-2
今天我要讲我们所添加的三种
新C++检查


719
00:32:14,868 --> 00:32:16,336 line:-1
一种检查用在move错误之后；


720
00:32:16,937 --> 00:32:20,440 line:-2
一种检查用于通过C++ std::string
把C字符串指针挂起；


721
00:32:21,108 --> 00:32:25,479 line:-2
还有一种检查用于在新的DriverKit
和IOKit中引用计数错误


722
00:32:26,880 --> 00:32:28,448 line:-1
让我们从第一个开始讲


723
00:32:31,351 --> 00:32:32,619 line:-1
在C++中


724
00:32:32,686 --> 00:32:35,556 line:-1
move可以让你避免多余的复制


725
00:32:35,622 --> 00:32:37,891 line:-2
这里有个例子 在这个例子中
你可能就想要做这样的操作


726
00:32:39,259 --> 00:32:41,361 line:-1
让我们假设我写了一本小说


727
00:32:41,962 --> 00:32:44,498 line:-2
如果你们了解我的话
我是一个非常啰嗦的人


728
00:32:45,065 --> 00:32:47,668 line:-1
当我把它交给我的发行商时


729
00:32:47,968 --> 00:32:51,772 line:-2
我不想支付关于复制小说的
全部文本方面的性能成本


730
00:32:52,539 --> 00:32:54,374 line:-1
所以我使用了一个move


731
00:32:55,843 --> 00:32:59,479 line:-2
这会从源变量中把它移出来
而不是复制它


732
00:33:00,514 --> 00:33:01,782 line:-1
最棒的是


733
00:33:01,849 --> 00:33:05,519 line:-1
它允许我强制执行唯一所有权语义


734
00:33:05,919 --> 00:33:09,289 line:-2
这样就不再混淆
谁拥有小说的最新版本了


735
00:33:09,823 --> 00:33:11,024 line:-1
我或我的发行商


736
00:33:12,259 --> 00:33:13,961 line:-1
但我在这里的确需要小心一些


737
00:33:14,528 --> 00:33:18,832 line:0
那是因为move会让源变量
处于一个未指定状态


738
00:33:20,334 --> 00:33:21,568 line:0
让我们看看这是如何出错的


739
00:33:24,371 --> 00:33:28,942 line:-2
假如我要在发行小说之后
添加一个调用来进行拼写检查


740
00:33:31,278 --> 00:33:33,714 line:-2
这可能会导致出乎意料的结果
或甚至会崩溃


741
00:33:33,981 --> 00:33:36,183 line:-1
取决于所实施的书的类型


742
00:33:37,718 --> 00:33:41,221 line:-2
幸运的是静态分析器现在可以捕捉
这种错误


743
00:33:43,190 --> 00:33:45,993 line:-2
要修复这个错误
我应该对代码进行重排序


744
00:33:46,793 --> 00:33:51,431 line:-2
在我发行小说之前进行拼写检查
非常有必要


745
00:33:54,234 --> 00:33:55,169 line:-1
好的


746
00:33:55,569 --> 00:33:59,039 line:-2
让我们继续讲来自
std::string的挂起指针


747
00:33:59,106 --> 00:34:00,607 line:-2
（来自std::string
的挂起指针）


748
00:34:00,941 --> 00:34:03,544 line:-2
你们中搞不清楚
C++和C字符串的那些人


749
00:34:03,610 --> 00:34:05,746 line:-1
知道这非常棘手


750
00:34:06,680 --> 00:34:07,648 line:-1
这里有个例子


751
00:34:09,116 --> 00:34:11,752 line:-2
我创建了这个
generateGreeting函数


752
00:34:11,818 --> 00:34:15,722 line:-2
它接受一个C字符串名称
并返回一个C字符串问候


753
00:34:16,723 --> 00:34:18,592 line:-1
在这个函数的实施中


754
00:34:19,025 --> 00:34:21,527 line:-2
我选择使用
C++ std::string


755
00:34:21,929 --> 00:34:23,397 line:-1
因为它易于操作


756
00:34:24,665 --> 00:34:26,233 line:-2
我声明了一个
std::string局部变量


757
00:34:26,300 --> 00:34:27,467 line:-1
把它初始化为hello…


758
00:34:28,601 --> 00:34:31,538 line:-1
附加上所传入的名称 然后


759
00:34:31,905 --> 00:34:34,107 line:-1
因为函数返回一个C字符串


760
00:34:34,641 --> 00:34:38,312 line:-2
我在C++字符串上
调用c str方法


761
00:34:38,579 --> 00:34:40,480 line:-1
然后从这里开始就出问题了


762
00:34:41,481 --> 00:34:42,882 line:-1
在这里有一个关键点要注意


763
00:34:43,150 --> 00:34:45,886 line:-2
就是c str给
std::string内的缓冲区


764
00:34:46,453 --> 00:34:48,322 line:-1
返回一个内部指针


765
00:34:49,456 --> 00:34:53,493 line:-2
std::string超出范围时
这个缓冲区就被解除分配了


766
00:34:55,262 --> 00:34:58,498 line:-1
这意味着我正在给一个


767
00:34:58,966 --> 00:35:00,133 line:-2
即将被接触分配的内存
返回一个指针


768
00:35:00,701 --> 00:35:03,770 line:-2
然后当我使用那个内存时
程序会崩溃


769
00:35:05,806 --> 00:35:08,041 line:-1
现在静态分析器可以捕捉这种错误了


770
00:35:10,844 --> 00:35:11,912 line:-1
那么该如何修复这个错误呢？


771
00:35:12,946 --> 00:35:17,518 line:-2
嗯 我们推荐匹配你的C++
和C字符串的生命周期


772
00:35:18,986 --> 00:35:21,255 line:-2
在这里我修改了
generateGreeting函数


773
00:35:21,522 --> 00:35:22,890 line:-1
以返回一个std::string


774
00:35:23,657 --> 00:35:26,693 line:-1
然后我把结果存储到一个局部变量中


775
00:35:28,529 --> 00:35:30,664 line:-1
这意味着当我调用c str方法时


776
00:35:31,465 --> 00:35:35,536 line:-2
只要我需要使用C字符串
那个局部变量都将保留在范围内


777
00:35:37,304 --> 00:35:40,174 line:-2
实质上我在这里所做的就是
修改std::string的范围


778
00:35:40,541 --> 00:35:41,909 line:-2
把它的范围改为
只要我需要它就一直持续


779
00:35:43,544 --> 00:35:48,081 line:-1
请注意 尽可能长时间地


780
00:35:48,549 --> 00:35:49,883 line:-1
保留在C++内总是很容易


781
00:35:50,484 --> 00:35:53,954 line:-2
只需要在我需要的那一时刻
取出C字符串即可


782
00:35:56,623 --> 00:35:58,392 line:0
好的 让我们继续


783
00:35:58,458 --> 00:36:00,928 line:-1
我要讲的第三个也是最后一个检查


784
00:36:01,328 --> 00:36:05,265 line:-2
是在DriverKit中
和IOKit中引用计数错误


785
00:36:08,202 --> 00:36:10,904 line:-1
这些驱动框架使用手动保留/释放


786
00:36:11,338 --> 00:36:12,673 line:-1
来管理内存


787
00:36:13,407 --> 00:36:16,009 line:-2
对于熟悉
CoreFoundation的人来说


788
00:36:16,376 --> 00:36:18,879 line:-2
或熟悉不带自动引用计数的
Objective-C的人来说


789
00:36:19,313 --> 00:36:20,547 line:-1
非常类似


790
00:36:20,614 --> 00:36:21,982 line:-1
（使用手动保留/释放的驱动）


791
00:36:22,049 --> 00:36:25,652 line:-2
手动保留/释放可以给你提供
大量内存管理方面的控制


792
00:36:26,186 --> 00:36:28,722 line:-1
但它确实伴随着一些附加的责任


793
00:36:30,224 --> 00:36:32,926 line:-1
你需要注意不要过度释放内存


794
00:36:33,861 --> 00:36:34,828 line:-1
因为如果你释放过度


795
00:36:35,128 --> 00:36:37,931 line:-2
内存可能会被解除配置
然后当你使用它时


796
00:36:37,998 --> 00:36:39,132 line:-1
你的程序会发生崩溃


797
00:36:41,702 --> 00:36:44,304 line:-1
类似地 你也不应该内存释放不足


798
00:36:44,705 --> 00:36:46,240 line:-1
因为内存可能会发生泄漏


799
00:36:49,076 --> 00:36:50,377 line:-1
让我给你一个内存泄漏的例子


800
00:36:51,845 --> 00:36:56,116 line:-2
在这里我写了一些代码
分配一批新设备


801
00:36:56,950 --> 00:36:59,786 line:-2
然后它会填写那些设备
并对它们进行设置


802
00:37:01,221 --> 00:37:02,489 line:-1
这里的重点是


803
00:37:02,923 --> 00:37:04,758 line:-2
那个
OSArray::withCapacity


804
00:37:05,292 --> 00:37:08,462 line:-1
它分配一个新数组并返回保留它


805
00:37:09,763 --> 00:37:14,001 line:-2
这意味着如果那个数组不被释放
它将会发生泄漏


806
00:37:16,270 --> 00:37:18,539 line:-1
现在分析器可以捕捉这种错误


807
00:37:20,274 --> 00:37:21,208 line:-1
那我该如何修复这个错误呢？


808
00:37:22,109 --> 00:37:26,246 line:-2
我要做的就是确保当我用完数组后
释放它


809
00:37:29,082 --> 00:37:33,487 line:-1
现在内存管理规则都是基于命名约定


810
00:37:34,054 --> 00:37:38,091 line:-2
这在实质上与CoreFoundation
和Objective-C非常类似


811
00:37:38,158 --> 00:37:39,459 line:-1
在手动保留/释放方面


812
00:37:40,694 --> 00:37:44,998 line:-2
但我想指出IOKit和
DriverKit的关键不同点


813
00:37:46,133 --> 00:37:50,003 line:-1
即默认约定返回保留


814
00:37:50,504 --> 00:37:52,506 line:-1
或者我们有时候把它叫做at +1


815
00:37:53,740 --> 00:37:56,777 line:-1
意思是客户必须


816
00:37:57,077 --> 00:37:59,179 line:-1
在他们调用的方法的结果上调用释放


817
00:38:00,214 --> 00:38:01,782 line:-1
否则对象会发生泄漏


818
00:38:04,084 --> 00:38:06,019 line:-1
这个规则的一个重要的例外情况是


819
00:38:06,086 --> 00:38:08,222 line:-1
getter返回不保留


820
00:38:08,689 --> 00:38:10,123 line:-1
或我们把它叫做at +0


821
00:38:11,091 --> 00:38:14,494 line:-1
客户不应该释放getter的结果


822
00:38:14,862 --> 00:38:16,430 line:-1
（内存管理约定）


823
00:38:17,831 --> 00:38:21,768 line:-2
现在你编写的代码
可能与这个约定不符


824
00:38:21,835 --> 00:38:23,604 line:-1
这是我写的一个示例代码


825
00:38:25,439 --> 00:38:28,141 line:-1
这个方法在数组中查找第一台设备


826
00:38:29,443 --> 00:38:31,545 line:-1
它应用了默认约定


827
00:38:31,612 --> 00:38:32,713 line:-1
它应该返回保留


828
00:38:33,881 --> 00:38:35,616 line:-1
但如果我们看一下实施


829
00:38:36,316 --> 00:38:38,452 line:-1
它返回了getter的结果


830
00:38:39,119 --> 00:38:40,721 line:-1
并且getter返回不保留


831
00:38:41,588 --> 00:38:42,823 line:-1
那么这里就发生了不匹配


832
00:38:44,391 --> 00:38:46,527 line:-2
幸运的是分析器现在可以替我们指出
这个问题了


833
00:38:48,362 --> 00:38:49,396 line:-1
那我该如何修复这个错误呢？


834
00:38:50,464 --> 00:38:52,900 line:-1
嗯 我有三种可选方案


835
00:38:53,800 --> 00:38:57,104 line:-1
第一种是修改行为 使其遵守约定


836
00:38:58,105 --> 00:39:00,440 line:-1
在这里约定是方法应该返回保留


837
00:39:01,041 --> 00:39:03,977 line:-1
所以我可以在返回结果之前保留它


838
00:39:05,913 --> 00:39:08,515 line:-1
另一种可能性是重命名方法


839
00:39:09,650 --> 00:39:11,985 line:-2
如果我看一下这个
findFirstDevice方法


840
00:39:12,352 --> 00:39:14,254 line:-1
它看起来很像是个getter


841
00:39:14,955 --> 00:39:17,224 line:-2
我可以把它重命名为
getFirstDevice


842
00:39:17,291 --> 00:39:18,792 line:-1
那会遵守约定


843
00:39:20,627 --> 00:39:23,564 line:-2
但你可能还有一个方法用于实施
你想要的行为


844
00:39:24,131 --> 00:39:25,265 line:-1
并且它的名称很合理


845
00:39:25,766 --> 00:39:27,034 line:-1
你不想修改它


846
00:39:27,401 --> 00:39:28,535 line:-1
没关系


847
00:39:29,536 --> 00:39:32,306 line:-1
在这种情况下 你应该添加一个注释


848
00:39:32,840 --> 00:39:36,243 line:-1
告诉代码的阅读器和分析器


849
00:39:36,577 --> 00:39:38,879 line:-1
你是有意不遵守约定的


850
00:39:40,514 --> 00:39:44,785 line:-2
在这种情况下 我可以添加
DRIVERKIT返回非保留注释


851
00:39:45,185 --> 00:39:46,520 line:-1
来表明我的意图


852
00:39:48,856 --> 00:39:50,691 line:-1
如果你有一个IOKit驱动


853
00:39:50,757 --> 00:39:52,860 line:-2
或你正在编写一个
新DriverKit驱动


854
00:39:53,427 --> 00:39:56,430 line:-1
我强烈鼓励你在代码上运行分析器


855
00:39:57,898 --> 00:40:01,502 line:-2
要运行分析器 你要做的就是
进入Xcode的产品菜单


856
00:40:01,802 --> 00:40:03,237 line:-1
并选择分析


857
00:40:04,071 --> 00:40:05,806 line:-1
你甚至可以让Xcode


858
00:40:05,873 --> 00:40:08,175 line:-1
在你每次点击创建时都运行分析器


859
00:40:08,876 --> 00:40:12,913 line:-2
通过进入目标的创建设置
并启动在创建过程中分析实现


860
00:40:13,881 --> 00:40:16,850 line:-2
这会帮助你捕捉错误
甚至在你提交之前就捕捉到错误


861
00:40:20,020 --> 00:40:22,489 line:-1
好的 我们今天讲了许多内容


862
00:40:23,557 --> 00:40:27,628 line:-2
我们讲了
LLVM Bitcode如何启动


863
00:40:27,995 --> 00:40:29,196 line:-2
针对watchOS的
无缝的64位转换


864
00:40:29,263 --> 00:40:33,400 line:-2
而你的32位app将第一次
在Series 4 Watch上运行


865
00:40:34,835 --> 00:40:37,638 line:-1
我们讲了如何通过新的编译器优化


866
00:40:37,704 --> 00:40:38,705 line:-1
和语言功能缩减代码尺寸


867
00:40:38,972 --> 00:40:41,408 line:-2
以及如何在你的代码上运行
静态分析器


868
00:40:43,043 --> 00:40:45,612 line:0
要获取更多信息 请查看演讲网站


869
00:40:46,079 --> 00:40:48,615 line:0
我们非常希望能在实验室中
与你们沟通


870
00:40:49,249 --> 00:40:50,317 line:0
谢谢

