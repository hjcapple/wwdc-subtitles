1
00:00:00,506 --> 00:00:04,516
[音乐]


2
00:00:05,116 --> 00:00:07,116
[掌声]


3
00:00:07,216 --> 00:00:07,966
>> 早上好


4
00:00:08,516 --> 00:00:10,806
[掌声]


5
00:00:11,306 --> 00:00:12,166
我是 Nick Gillett


6
00:00:12,256 --> 00:00:13,716
一名 Apple Core Data 团队的工程师


7
00:00:13,716 --> 00:00:15,246
欢迎大家来到


8
00:00:15,346 --> 00:00:18,556
Using Core Data with CloudKit 会议


9
00:00:19,496 --> 00:00:20,826
今天 我们要谈的是


10
00:00:20,826 --> 00:00:22,746
这样的一种想法


11
00:00:22,746 --> 00:00:24,326
我们想要数据随时可用


12
00:00:24,326 --> 00:00:26,036
不论我使用什么设备


13
00:00:26,066 --> 00:00:27,516
也不论我身处何方


14
00:00:28,166 --> 00:00:30,796
如果想要实现这种设想


15
00:00:30,796 --> 00:00:32,756
我们需要让


16
00:00:32,756 --> 00:00:34,286
添加该功能到你的 App 上这个步骤


17
00:00:34,286 --> 00:00:35,346
变得更加方便


18
00:00:36,096 --> 00:00:37,346
我相信今天在座的各位


19
00:00:37,346 --> 00:00:39,016
大多数都携带了 iPhone


20
00:00:39,016 --> 00:00:40,716
也许在家还有一台 Mac


21
00:00:41,176 --> 00:00:42,826
而此时此刻你的背包里


22
00:00:42,826 --> 00:00:44,506
或许还有一台 MacBook


23
00:00:44,506 --> 00:00:46,326
或者 MacBook Pro


24
00:00:46,906 --> 00:00:48,906
我们在这些设备上


25
00:00:48,906 --> 00:00:50,816
操作的所有数据


26
00:00:50,816 --> 00:00:52,976
都存储在本地上 对吧


27
00:00:52,976 --> 00:00:54,656
对于我们来说


28
00:00:54,656 --> 00:00:55,956
不用任何交互 把数据从一个设备上


29
00:00:55,956 --> 00:00:58,546
转移到另外一个设备 还是比较麻烦的


30
00:00:59,196 --> 00:01:01,306
现在为了解决这个问题


31
00:01:01,306 --> 00:01:03,066
我们想到了云存储


32
00:01:03,446 --> 00:01:05,266
因为它可以让我们


33
00:01:05,385 --> 00:01:06,756
把一个设备上的数据 


34
00:01:06,756 --> 00:01:08,556
无缝透明地


35
00:01:08,556 --> 00:01:10,096
转移到我们所拥有的


36
00:01:10,096 --> 00:01:11,496
其他设备上


37
00:01:12,076 --> 00:01:13,956
即使我们只有一台设备


38
00:01:13,956 --> 00:01:15,726
云存储也是非常好用的


39
00:01:15,726 --> 00:01:17,306
对吧


40
00:01:17,306 --> 00:01:18,986
当 App 在设备上产生数据


41
00:01:18,986 --> 00:01:22,466
它在云端备份并存储


42
00:01:22,966 --> 00:01:24,136
所以当我们主动或碰巧


43
00:01:24,136 --> 00:01:26,396
使用一台新的设备


44
00:01:26,396 --> 00:01:28,176
别问我是怎么知道的 


45
00:01:28,336 --> 00:01:30,326
在踏出商店之后


46
00:01:30,326 --> 00:01:32,026
这台新设备就能变成


47
00:01:32,026 --> 00:01:33,976
我们熟悉和深爱的那个


48
00:01:34,546 --> 00:01:36,316
这也许会让你感到惊讶


49
00:01:36,316 --> 00:01:37,406
现在我们平台上


50
00:01:37,406 --> 00:01:39,066
已经有一些技术


51
00:01:39,066 --> 00:01:40,556
可以帮助我们解决这个问题


52
00:01:40,556 --> 00:01:43,406
例如 Core Data 提供了


53
00:01:43,406 --> 00:01:44,936
一套健壮的 API


54
00:01:44,936 --> 00:01:46,526
在 App 和磁盘上


55
00:01:46,526 --> 00:01:48,766
管理本地数据


56
00:01:48,766 --> 00:01:51,666
而 CloudKit 框架可以访问


57
00:01:51,666 --> 00:01:53,246
世界上最大的


58
00:01:53,246 --> 00:01:54,026
分布式数据库之一


59
00:01:54,526 --> 00:01:57,976
这两个框架在 Apple 的所有平台上均可用


60
00:01:58,236 --> 00:02:00,106
正因如此 我们才能


61
00:02:00,106 --> 00:02:02,526
创作出各种各样的 App


62
00:02:03,316 --> 00:02:04,806
事实上 这些框架


63
00:02:04,806 --> 00:02:06,116
其实很相似


64
00:02:06,666 --> 00:02:10,826
它们甚至用同一套模式和范例


65
00:02:11,276 --> 00:02:13,106
来根据对象 模型和存储


66
00:02:13,106 --> 00:02:15,646
对它们的 API 进行建模


67
00:02:16,346 --> 00:02:18,726
在 Core Data 我们把对象实例


68
00:02:18,726 --> 00:02:21,726
叫做 NSManagedObject


69
00:02:21,726 --> 00:02:23,096
它们可以让我们的 App


70
00:02:23,096 --> 00:02:25,926
访问存储在磁盘上的值


71
00:02:26,636 --> 00:02:28,956
相似的 CloudKit 利用


72
00:02:29,076 --> 00:02:31,086
类似键值对的 CKRecord 来实现


73
00:02:31,086 --> 00:02:32,606
可以访问你存储在


74
00:02:32,606 --> 00:02:34,166
云端的数据


75
00:02:35,036 --> 00:02:37,026
这些对象


76
00:02:37,026 --> 00:02:38,466
是用模型来描述的


77
00:02:38,906 --> 00:02:40,736
在 Core Data 我们把它叫做


78
00:02:40,796 --> 00:02:42,856
NSManagedObjectModel


79
00:02:42,856 --> 00:02:44,686
你可以使用代码


80
00:02:44,686 --> 00:02:46,106
或者是 Xcode 模型编辑器创作出来


81
00:02:46,926 --> 00:02:49,586
非常相似 CloudKit 使用的是 Schema


82
00:02:50,196 --> 00:02:51,696
CloudKit Schema


83
00:02:51,696 --> 00:02:53,096
可以在你使用 CKRecords 开发时


84
00:02:53,136 --> 00:02:55,626
由 CloudKit 动态定义


85
00:02:55,626 --> 00:02:59,056
或者使用 CloudKit 仪表盘定义


86
00:02:59,796 --> 00:03:01,776
最终 使用 Core Data


87
00:03:01,776 --> 00:03:03,686
将对象持久化


88
00:03:04,116 --> 00:03:05,856
这也是我们称作的存储


89
00:03:06,266 --> 00:03:07,906
在 Core Data 中叫做


90
00:03:07,906 --> 00:03:09,396
NSPersistentStore 实例


91
00:03:09,756 --> 00:03:12,436
但是在 CloudKit 里


92
00:03:12,436 --> 00:03:15,146
CKRecords 是储存在 CKRecordZone


93
00:03:15,246 --> 00:03:16,166
或者 CKDatabase 中的


94
00:03:16,866 --> 00:03:18,696
正如你们所见


95
00:03:18,696 --> 00:03:19,956
当然很多人也曾经


96
00:03:20,076 --> 00:03:20,976
向我指出


97
00:03:20,976 --> 00:03:22,926
如果我们可以


98
00:03:22,926 --> 00:03:24,786
把两个相似机制的框架


99
00:03:24,786 --> 00:03:26,416
结合的过程变得简单


100
00:03:26,416 --> 00:03:27,106
那就再好不过了


101
00:03:27,776 --> 00:03:29,216
为了给你们展示


102
00:03:29,276 --> 00:03:30,436
我们这些年的成果


103
00:03:30,436 --> 00:03:31,586
我将带领你们看一下


104
00:03:31,626 --> 00:03:32,996
在 Xcode 中


105
00:03:32,996 --> 00:03:34,996
制作一款新 App 是什么感受


106
00:03:35,296 --> 00:03:37,766
大家请看 我打开 Xcode


107
00:03:38,176 --> 00:03:39,666
我要制作一款


108
00:03:39,786 --> 00:03:42,926
Master-Detail App 模版的 iOS 项目


109
00:03:43,416 --> 00:03:44,356
我喜欢 Master-Detail App


110
00:03:44,356 --> 00:03:45,636
是因为它给我们


111
00:03:45,636 --> 00:03:47,646
提供了很棒的 UI


112
00:03:47,646 --> 00:03:49,596
可以在探索 Core Data 功能时使用


113
00:03:50,086 --> 00:03:51,896
所以我选择它 然后点按 Next


114
00:03:51,896 --> 00:03:54,956
给我的 App 命名


115
00:03:55,186 --> 00:03:57,436
此情此景 就叫 WWDC Demo 吧


116
00:03:58,106 --> 00:03:59,476
然后 因为我们是来了解


117
00:03:59,476 --> 00:04:01,246
Core Data


118
00:04:01,246 --> 00:04:02,546
我们需要打开它的复选框


119
00:04:03,066 --> 00:04:05,176
在 Xcode 11 里面 


120
00:04:05,176 --> 00:04:06,346
它叫做 Use CloudKit


121
00:04:06,826 --> 00:04:08,346
这一步是告诉 Xcode


122
00:04:08,346 --> 00:04:09,746
我们想要制作一款 App


123
00:04:09,746 --> 00:04:11,336
而它需要同时用到


124
00:04:11,336 --> 00:04:12,646
Core Data 和 CloudKit


125
00:04:12,806 --> 00:04:14,876
那么让我们选中


126
00:04:14,876 --> 00:04:16,536
然后我们点按 Next


127
00:04:16,536 --> 00:04:18,676
设置 App 在文件系统中的存储位置


128
00:04:19,676 --> 00:04:21,495
当我们点按 Create


129
00:04:21,495 --> 00:04:23,196
Xcode 就为我们生成了 App


130
00:04:23,396 --> 00:04:24,716
如果你之前已经构建过


131
00:04:24,716 --> 00:04:26,246
使用 CloudKit 的 App


132
00:04:26,806 --> 00:04:27,716
那么你就知道


133
00:04:27,716 --> 00:04:29,266
在它准备构建运行之前


134
00:04:29,266 --> 00:04:30,866
我们还需要


135
00:04:30,866 --> 00:04:31,986
添加一些其他的东西


136
00:04:32,476 --> 00:04:35,606
这些额外的功能要在


137
00:04:35,606 --> 00:04:37,226
Signing & Capabilities 标签中添加


138
00:04:37,766 --> 00:04:38,786
我们需要加上这两个


139
00:04:39,396 --> 00:04:41,516
第一个是 iCloud 功能


140
00:04:41,706 --> 00:04:42,936
所以我点按


141
00:04:42,936 --> 00:04:43,776
Capability 旁边的 + 号 


142
00:04:43,776 --> 00:04:46,556
输入 iCloud 然后点按回车键


143
00:04:47,256 --> 00:04:49,706
当我做这一步的时候


144
00:04:49,706 --> 00:04:51,436
我可以打开 CloudKit 的复选框


145
00:04:51,436 --> 00:04:52,486
你可以看到它还给我


146
00:04:52,486 --> 00:04:54,366
添加了 Push Notifications 复选框


147
00:04:54,856 --> 00:04:56,556
Xcode 也能自动


148
00:04:56,556 --> 00:05:01,056
为我的 App 创作 iCloud 容器标识符


149
00:05:01,276 --> 00:05:03,926
下面 我们要添加后台模式功能


150
00:05:04,446 --> 00:05:05,396
为了添加功能


151
00:05:05,396 --> 00:05:06,636
再次点击 + 号


152
00:05:06,696 --> 00:05:07,726
输入 Background 再点按回车键


153
00:05:08,266 --> 00:05:09,616
我们这么做的原因是


154
00:05:09,616 --> 00:05:11,276
启用远程通知


155
00:05:11,276 --> 00:05:12,836
这样就可以使我们的 App


156
00:05:12,836 --> 00:05:14,756
在非运行状态


157
00:05:14,756 --> 00:05:15,506
接收推送通知


158
00:05:16,356 --> 00:05:18,086
那么 让我们运行这个 App


159
00:05:18,126 --> 00:05:20,316
看看效果如何


160
00:05:21,506 --> 00:05:22,706
现在你可以看到


161
00:05:22,706 --> 00:05:24,636
我们已经有了一个很简单的 App


162
00:05:24,636 --> 00:05:25,446
有两个视图控制器


163
00:05:25,556 --> 00:05:27,096
左侧是表格视图


164
00:05:27,096 --> 00:05:28,636
右侧是详情视图控制器


165
00:05:29,316 --> 00:05:30,836
现在我为 App 添加数据


166
00:05:30,836 --> 00:05:33,756
点按右上角的 + 号


167
00:05:34,286 --> 00:05:35,746
默认状态下 Xcode 会生成


168
00:05:35,746 --> 00:05:37,596
一个简单的 Core Data 模型


169
00:05:37,686 --> 00:05:39,766
仅仅是一个时间戳


170
00:05:40,506 --> 00:05:42,276
但是 我们可以看到


171
00:05:42,276 --> 00:05:43,806
同步功能是如何运行的


172
00:05:44,076 --> 00:05:46,636
这样我们就需要另外一个设备


173
00:05:46,766 --> 00:05:48,186
现在在我们的 iPhone


174
00:05:48,236 --> 00:05:48,816
上面运行这个 App


175
00:05:49,246 --> 00:05:50,516
你们可以看到 我们已经


176
00:05:50,516 --> 00:05:52,576
有了主视图控制器


177
00:05:52,576 --> 00:05:55,446
以及我们在 iPad 上添加的所有数据


178
00:05:55,976 --> 00:05:57,856
现在 让我们使用手机添加数据


179
00:05:58,376 --> 00:06:01,796
当然了 数据也会同步给 iPad


180
00:06:02,306 --> 00:06:04,066
现在 因为我手中的遥控器


181
00:06:04,066 --> 00:06:05,596
有着神奇的推送功能


182
00:06:05,596 --> 00:06:07,496
任何时间我都可以进行推送


183
00:06:08,216 --> 00:06:09,566
现在让我们


184
00:06:09,566 --> 00:06:11,106
更真实一点


185
00:06:11,106 --> 00:06:13,156
我要删除所有


186
00:06:13,156 --> 00:06:14,336
从 iPhone 上面添加到


187
00:06:14,336 --> 00:06:17,016
我的 iPad 的数据


188
00:06:17,016 --> 00:06:18,206
只留下前四行


189
00:06:18,746 --> 00:06:20,346
然后 我要做相同的事


190
00:06:20,446 --> 00:06:22,146
在 iPhone 上删除所有


191
00:06:22,146 --> 00:06:24,476
从 iPad 导入的数据


192
00:06:25,326 --> 00:06:28,596
我之前使用了遥控器


193
00:06:28,816 --> 00:06:29,966
现在 我不会再去


194
00:06:29,966 --> 00:06:30,916
碰那个遥控器


195
00:06:31,056 --> 00:06:32,756
我就继续播放视频


196
00:06:32,756 --> 00:06:34,326
然后你们可以看到


197
00:06:34,326 --> 00:06:35,866
当我拍摄视频时


198
00:06:35,866 --> 00:06:40,796
这两个设备是如何同步数据的 对吧


199
00:06:41,806 --> 00:06:43,086
虽然看起来不太自然


200
00:06:43,146 --> 00:06:44,396
但很棒的是


201
00:06:44,396 --> 00:06:46,476
仅仅点按了几下


202
00:06:46,476 --> 00:06:47,936
我们就构建了一个 App


203
00:06:47,936 --> 00:06:49,896
使用 Core Data 和 CloudKit 端对端同步数据


204
00:06:50,486 --> 00:06:51,526
如果我不告诉你们


205
00:06:51,526 --> 00:06:52,666
AppDelegate 中实际上隐藏了


206
00:06:52,666 --> 00:06:54,236
15000 行代码 


207
00:06:54,286 --> 00:06:55,806
那就是我的不对了


208
00:06:56,366 --> 00:06:58,126
所以让我们看看这部分代码


209
00:06:59,836 --> 00:07:01,526
这是一个非常标准的


210
00:07:01,526 --> 00:07:02,716
AppDelegate


211
00:07:02,806 --> 00:07:04,086
事实上 如果你以前


212
00:07:04,086 --> 00:07:05,496
用 Xcode 构建过


213
00:07:05,496 --> 00:07:07,326
Core Data App


214
00:07:07,326 --> 00:07:09,246
那你应该会非常熟悉 


215
00:07:09,246 --> 00:07:10,726
包括这部分


216
00:07:10,726 --> 00:07:11,766
设置 Core Data 堆栈的代码


217
00:07:12,166 --> 00:07:13,376
这个 App 唯一有些不同的地方


218
00:07:13,376 --> 00:07:16,676
就是今年 Core Data 里面的一个新 API


219
00:07:17,066 --> 00:07:19,086
叫做 NSPersistentCloudKitContainer


220
00:07:19,626 --> 00:07:20,786
它的设计目的就是为了帮助你


221
00:07:20,786 --> 00:07:22,266
来管理 CloudKit 数据库中 


222
00:07:22,266 --> 00:07:24,686
的 Core Data 存储


223
00:07:26,216 --> 00:07:28,236
现在 如果你之前


224
00:07:28,236 --> 00:07:29,626
就用 Xcode 做过 Core Data App


225
00:07:29,766 --> 00:07:31,556
那么你在此处看到的是


226
00:07:31,666 --> 00:07:33,216
NSPersistentContainer


227
00:07:33,216 --> 00:07:37,606
它是 NSPersistentCloudKitContainer 的父类


228
00:07:37,816 --> 00:07:41,086
正因如此 你可以只改一行代码 


229
00:07:41,086 --> 00:07:42,736
就给你现有的 Core Data App


230
00:07:42,786 --> 00:07:45,036
增加 CloudKit 功能


231
00:07:45,336 --> 00:07:46,716
所以到底什么是


232
00:07:46,866 --> 00:07:48,576
NSPersistentCloudKitContainer


233
00:07:49,426 --> 00:07:51,836
其实它是封装了


234
00:07:51,836 --> 00:07:53,466
一套非常常见的模版


235
00:07:53,466 --> 00:07:54,896
每个人都必须构建


236
00:07:54,986 --> 00:07:56,346
才能使用 CloudKit


237
00:07:56,346 --> 00:07:58,496
实现端对端同步


238
00:07:58,976 --> 00:08:00,316
它可以让你省去


239
00:08:00,316 --> 00:08:02,296
成千上万行代码的麻烦


240
00:08:03,636 --> 00:08:05,276
它也是我们


241
00:08:05,276 --> 00:08:06,676
今后希望和你们共同完成


242
00:08:06,756 --> 00:08:08,656
不断迭代的基础


243
00:08:09,066 --> 00:08:11,436
当然了 为了实现这个目标


244
00:08:11,436 --> 00:08:13,596
说到重点了 我们需要你们的帮助


245
00:08:15,376 --> 00:08:17,206
我们现在需要你们的反馈


246
00:08:17,356 --> 00:08:18,696
比如 NSPersistentCloudKitContainer 效果如何


247
00:08:18,696 --> 00:08:20,696
还缺失什么功能


248
00:08:20,696 --> 00:08:22,246
亦或者在工作的过程中


249
00:08:22,246 --> 00:08:25,626
现有功能是否满足了你 App 的需求


250
00:08:25,856 --> 00:08:27,396
所以 让我再仔细介绍一下


251
00:08:27,666 --> 00:08:29,296
它的部分功能


252
00:08:30,266 --> 00:08:31,796
NSPersistentCloudKitContainer


253
00:08:31,796 --> 00:08:33,566
可以为你的 App 


254
00:08:33,566 --> 00:08:34,385
提供本地副本


255
00:08:34,806 --> 00:08:36,936
一个完全一致的


256
00:08:36,936 --> 00:08:38,126
Core Data 或者 CloudKit


257
00:08:38,155 --> 00:08:39,486
数据库镜像


258
00:08:40,265 --> 00:08:42,596
它还具备健壮的


259
00:08:42,596 --> 00:08:44,135
调度以及错误恢复事件循环


260
00:08:44,135 --> 00:08:45,076
因此你的 App


261
00:08:45,076 --> 00:08:46,116
完全不用担心


262
00:08:46,116 --> 00:08:47,716
任何运维方面的问题


263
00:08:47,886 --> 00:08:49,986
最后 它还有


264
00:08:49,986 --> 00:08:51,876
NSManagedObject 实例


265
00:08:51,916 --> 00:08:53,096
和 CKRecord 之间的


266
00:08:53,096 --> 00:08:55,636
转化功能


267
00:08:57,406 --> 00:09:00,236
现在本地副本非常重要


268
00:09:01,096 --> 00:09:02,056
但是这意味着


269
00:09:02,056 --> 00:09:03,676
当你的 App 处理对象时


270
00:09:03,866 --> 00:09:07,766
它会将其写入 Core Data 管理的本地存储文件中


271
00:09:08,256 --> 00:09:09,626
而且 它也会从本地存储文件中


272
00:09:09,626 --> 00:09:11,006
读取对象


273
00:09:11,006 --> 00:09:14,176
这是由于本地数据库


274
00:09:14,176 --> 00:09:18,056
与云存储的性能不太相同 对吧


275
00:09:18,536 --> 00:09:19,646
当我们谈到


276
00:09:19,646 --> 00:09:21,116
访问本地文件的延迟


277
00:09:21,116 --> 00:09:23,396
读取磁盘上的文件


278
00:09:23,396 --> 00:09:24,796
都是以毫秒为单位


279
00:09:24,796 --> 00:09:25,926
即使在最坏的情况下也是如此


280
00:09:26,126 --> 00:09:27,256
然而如果通过网络 


281
00:09:27,256 --> 00:09:28,806
可能会花上几秒甚至几分钟


282
00:09:28,806 --> 00:09:30,846
才能获取 App 所需的数据


283
00:09:31,496 --> 00:09:33,066
同样地 本地存储


284
00:09:33,066 --> 00:09:34,396
可以为你的 App 提供


285
00:09:34,396 --> 00:09:36,146
更高的带宽


286
00:09:36,146 --> 00:09:37,756
即使在我们的 iPhone 上面


287
00:09:37,756 --> 00:09:39,606
可以以 gb/s 为单位


288
00:09:40,096 --> 00:09:41,396
而云端的可用带宽


289
00:09:41,396 --> 00:09:45,116
被限制在 kb/s 或者 mb/s


290
00:09:46,316 --> 00:09:47,816
本地副本


291
00:09:47,816 --> 00:09:49,876
必然将增加


292
00:09:49,876 --> 00:09:51,926
程序的复杂性


293
00:09:51,926 --> 00:09:53,776
因此 NSPersistentCloudKitContainer


294
00:09:53,776 --> 00:09:55,536
需要一个健壮的调度和


295
00:09:55,536 --> 00:09:57,336
错误恢复事件循环


296
00:09:57,796 --> 00:09:59,136
所以当你的 App


297
00:09:59,136 --> 00:10:00,666
将数据写入本地存储时


298
00:10:01,116 --> 00:10:02,736
NSPersistentCloudKitContainer


299
00:10:02,736 --> 00:10:04,956
自动将这些内容上传到云


300
00:10:06,376 --> 00:10:08,846
当 CloudKit 上的内容发生变化


301
00:10:08,846 --> 00:10:10,336
NSPersistentCloudKitContainer


302
00:10:10,336 --> 00:10:11,816
就会在系统上调度工作


303
00:10:12,216 --> 00:10:14,086
将这些对象


304
00:10:14,086 --> 00:10:15,136
传输到你的本地数据库


305
00:10:15,136 --> 00:10:17,846
供你的 App 使用


306
00:10:18,776 --> 00:10:20,846
当然 在这个过程中


307
00:10:20,846 --> 00:10:22,546
你的对象需要


308
00:10:22,546 --> 00:10:24,116
被 NSPersistentCloudKitContainer


309
00:10:24,116 --> 00:10:26,426
从 NSManagedObject 实例 


310
00:10:26,426 --> 00:10:29,726
转变为 CKRecord 实例


311
00:10:30,736 --> 00:10:32,606
同样的 当有些内容


312
00:10:32,606 --> 00:10:34,016
在云上发生变化


313
00:10:34,016 --> 00:10:35,086
那些 CKRecord 实例


314
00:10:35,086 --> 00:10:37,106
就会作为 NSManagedObject 实例


315
00:10:37,196 --> 00:10:38,636
被存放在本地储存文件中


316
00:10:38,636 --> 00:10:41,726
这就是


317
00:10:41,726 --> 00:10:43,146
NSPersistentCloudKitContainer


318
00:10:43,246 --> 00:10:44,486
可以为你的 App 所做的事


319
00:10:44,856 --> 00:10:46,406
它就是一个


320
00:10:46,406 --> 00:10:47,676
CloudKit 的


321
00:10:47,676 --> 00:10:49,106
私人数据库本地副本


322
00:10:49,706 --> 00:10:53,116
你要知道我们制作了一个特定区域


323
00:10:53,406 --> 00:10:54,506
用于 Core Data 同步


324
00:10:55,096 --> 00:10:57,566
我们实现了自动调度


325
00:10:57,566 --> 00:10:58,876
因此你不用担心


326
00:10:58,876 --> 00:11:00,576
如何优化操作


327
00:11:00,576 --> 00:11:02,886
或在系统调度它们


328
00:11:03,356 --> 00:11:04,856
我认为更重要的是


329
00:11:04,916 --> 00:11:05,966
你无需担心


330
00:11:05,966 --> 00:11:07,436
在 App 中实现任何


331
00:11:07,436 --> 00:11:08,866
错误恢复逻辑问题


332
00:11:10,066 --> 00:11:11,956
最后 我们实现了


333
00:11:11,956 --> 00:11:12,986
从 NSManagedObject 到 CKRecord 的


334
00:11:12,986 --> 00:11:15,286
自动序列化


335
00:11:15,626 --> 00:11:17,106
并且我们是使用


336
00:11:17,106 --> 00:11:18,916
NSManagedObject 模型实现的


337
00:11:20,476 --> 00:11:24,256
如果我站在这里 告诉你们


338
00:11:24,256 --> 00:11:25,176
只要采用 NSPersistentCloudKitContainer


339
00:11:25,236 --> 00:11:26,916
你就将拥有一个


340
00:11:26,966 --> 00:11:28,066
功能齐全的 App


341
00:11:28,066 --> 00:11:29,616
那我就太愚蠢了


342
00:11:29,696 --> 00:11:33,026
所以我就想用剩下的时间谈一谈


343
00:11:33,026 --> 00:11:34,866
在 NSPersistentCloudKitContainer 的基础上


344
00:11:34,936 --> 00:11:36,486
可以做到什么


345
00:11:36,986 --> 00:11:38,216
我认为首先


346
00:11:38,266 --> 00:11:39,656
要从利用 Core Data


347
00:11:39,656 --> 00:11:40,886
制作优秀的 App 讲起


348
00:11:41,836 --> 00:11:43,356
然后 我们再看一看


349
00:11:43,356 --> 00:11:44,906
你如何能够扩展


350
00:11:44,906 --> 00:11:45,966
我们在 NSPersistentCloudKitContainer 


351
00:11:46,056 --> 00:11:48,026
中已经构建的基础


352
00:11:48,026 --> 00:11:49,496
以此来更精准地满足你的使用需求


353
00:11:50,746 --> 00:11:52,256
现在 对于我来说


354
00:11:52,256 --> 00:11:53,616
用 Core Data 来打造优秀的 App


355
00:11:54,066 --> 00:11:56,326
需要用足够的知识


356
00:11:56,846 --> 00:12:00,286
为此 我们今年已经写了


357
00:12:00,286 --> 00:12:02,496
无数的文档来具体解释


358
00:12:02,496 --> 00:12:04,476
NSPersistentCloudKitContainer 如何工作


359
00:12:04,476 --> 00:12:05,806
以及如何将它融入到你的 App 中


360
00:12:07,376 --> 00:12:08,526
Core Data 有很多功能


361
00:12:08,526 --> 00:12:10,276
都可以搭配


362
00:12:10,276 --> 00:12:12,076
NSPersistentCloudKitContainer 使用


363
00:12:12,596 --> 00:12:14,776
比如 FetchResultsController


364
00:12:14,776 --> 00:12:16,376
它可以帮助你


365
00:12:16,376 --> 00:12:17,486
构建可扩展用户界面


366
00:12:17,486 --> 00:12:18,956
并由大量数据支持


367
00:12:19,796 --> 00:12:21,726
而查询生成则可以帮助你


368
00:12:21,726 --> 00:12:23,446
维护界面的稳定性


369
00:12:23,446 --> 00:12:24,966
在后台可能发生一些变化的时候


370
00:12:24,966 --> 00:12:26,436
不受影响


371
00:12:27,196 --> 00:12:29,776
比如来自 NSPersistentCloudKitContainer 的变化


372
00:12:30,846 --> 00:12:34,176
最后 还需要回溯到几年前


373
00:12:34,176 --> 00:12:35,506
我们曾经介绍过的内容


374
00:12:35,506 --> 00:12:36,956
帮助你理解


375
00:12:36,956 --> 00:12:37,576
数据库到底有了什么改变


376
00:12:37,956 --> 00:12:39,756
并且有了 NSPersistentCloudKitContainer


377
00:12:39,756 --> 00:12:41,486
你可以使用它来决定


378
00:12:41,486 --> 00:12:42,816
后台更新是否与


379
00:12:42,816 --> 00:12:46,146
你的用户正在做的事情有所关联


380
00:12:47,026 --> 00:12:48,216
我们将在星期三的下午三点


381
00:12:48,216 --> 00:12:51,326
对这些功能以及其他更多内容进行介绍


382
00:12:51,966 --> 00:12:55,216
与此同时


383
00:12:55,216 --> 00:12:56,776
我们今年还将推出


384
00:12:57,086 --> 00:12:59,566
一款全新的 App 样例


385
00:12:59,566 --> 00:13:00,306
让你们实际感受到


386
00:13:00,366 --> 00:13:01,846
NSPersistentCloudKitContainer


387
00:13:01,846 --> 00:13:03,816
和 Core Data 其他功能


388
00:13:03,816 --> 00:13:04,926
共同工作的优势所在


389
00:13:05,546 --> 00:13:07,016
它是用来管理


390
00:13:07,116 --> 00:13:07,746
帖子的一款 App


391
00:13:07,986 --> 00:13:09,506
而帖子是我们


392
00:13:09,506 --> 00:13:10,806
过去几年在 Core Data 中


393
00:13:10,806 --> 00:13:13,046
一直研究的主题 对吧


394
00:13:13,096 --> 00:13:14,536
它们是很棒的对象


395
00:13:14,536 --> 00:13:15,726
能让我们了解


396
00:13:15,876 --> 00:13:17,206
对象图的不同部分


397
00:13:17,206 --> 00:13:19,306
是如何受到 CloudKit 影响的


398
00:13:19,836 --> 00:13:21,186
在这里 你可以看到


399
00:13:21,186 --> 00:13:22,726
我们的数据模型非常简单 是吧


400
00:13:22,776 --> 00:13:24,046
我们有一个标题


401
00:13:24,046 --> 00:13:24,426
以及一些内容


402
00:13:24,426 --> 00:13:26,116
然后 我们还有一堆标签


403
00:13:26,116 --> 00:13:28,266
可以与每个帖子相关联


404
00:13:28,326 --> 00:13:29,606
这款 App 甚至可以


405
00:13:29,606 --> 00:13:31,016
让你看到 CloudKit


406
00:13:31,016 --> 00:13:32,156
是如何管理照片的


407
00:13:32,506 --> 00:13:35,746
App 允许你从设备的照片库


408
00:13:35,746 --> 00:13:39,716
附加文件至帖子


409
00:13:39,896 --> 00:13:43,586
现在 我们谈谈如何基于


410
00:13:42,376 --> 00:13:43,586
NSPersistentCloudKitContainer


411
00:13:43,656 --> 00:13:45,206
进行开发


412
00:13:45,696 --> 00:13:47,606
正如你们所期待的那样


413
00:13:47,606 --> 00:13:49,606
这一部分绝对是今天会议的重点


414
00:13:50,106 --> 00:13:51,236
但是你们也应该知道


415
00:13:51,236 --> 00:13:52,966
我们的文档其实包括


416
00:13:52,966 --> 00:13:55,486
我们今天所讲内容的更多细节


417
00:13:56,006 --> 00:13:57,776
所以不用担心


418
00:13:57,776 --> 00:13:58,676
会漏掉什么内容


419
00:13:58,796 --> 00:14:04,626
我们看到有很多客户用了不同的方法


420
00:14:04,786 --> 00:14:06,276
扩展 NSPersistentCloudKitContainer


421
00:14:06,876 --> 00:14:09,096
有的是从多个存储开始扩展


422
00:14:10,006 --> 00:14:11,916
还有的客户


423
00:14:11,916 --> 00:14:14,206
喜欢自定义 Schema


424
00:14:14,206 --> 00:14:16,586
并用于 CloudKit


425
00:14:16,616 --> 00:14:18,216
当然也用于 NSPersistentCloudKitContainer


426
00:14:18,826 --> 00:14:20,166
你们都知道


427
00:14:20,166 --> 00:14:21,756
因为 CloudKit


428
00:14:21,756 --> 00:14:23,446
在很多平台都是可用的


429
00:14:23,496 --> 00:14:25,436
不仅仅局限于 Apple


430
00:14:25,436 --> 00:14:27,056
还适用于 Web Services


431
00:14:27,056 --> 00:14:27,706
或者 JavaScript 


432
00:14:28,286 --> 00:14:29,466
所以你应该可以使用


433
00:14:29,526 --> 00:14:30,006
NSPersistentCloudKitContainer 对象


434
00:14:30,036 --> 00:14:33,366
即使不是在


435
00:14:33,366 --> 00:14:34,736
Apple 的平台上


436
00:14:35,686 --> 00:14:37,316
最后来看看


437
00:14:37,406 --> 00:14:39,146
协同数据建模


438
00:14:40,656 --> 00:14:42,176
现在 我们有很多理由


439
00:14:42,176 --> 00:14:45,486
在 App 中使用多存储文件


440
00:14:45,486 --> 00:14:48,126
尤其是处理网络存储时


441
00:14:48,816 --> 00:14:50,086
多存储文件能够帮助我们


442
00:14:50,186 --> 00:14:51,676
在 App 中


443
00:14:51,676 --> 00:14:53,636
为不同的用例隔离数据


444
00:14:54,206 --> 00:14:56,926
而且还能给我们


445
00:14:57,086 --> 00:14:59,786
提供不同类型的限制 对吧


446
00:14:59,786 --> 00:15:01,146
所以 如果我们想要


447
00:15:01,146 --> 00:15:02,786
使用一个存储文件


448
00:15:02,786 --> 00:15:04,126
管理一组非常特殊的验证限制


449
00:15:04,126 --> 00:15:05,786
可能用于验证用户输入


450
00:15:05,786 --> 00:15:07,476
我们可以为此


451
00:15:07,476 --> 00:15:09,266
单独使用一个存储文件


452
00:15:10,766 --> 00:15:12,316
多存储文件也能够很好的


453
00:15:12,316 --> 00:15:15,856
来节流或合并设备上


454
00:15:15,856 --> 00:15:16,526
频繁写的数据


455
00:15:17,446 --> 00:15:18,586
当你从设备上读取的内容


456
00:15:18,586 --> 00:15:19,426
产生自设备本身 


457
00:15:19,426 --> 00:15:21,066
或者产生自


458
00:15:21,066 --> 00:15:22,556
创建数据的算法


459
00:15:22,556 --> 00:15:24,546
这种情况可能就会发生


460
00:15:25,206 --> 00:15:26,726
如果这个算法


461
00:15:26,726 --> 00:15:28,216
产生数据的速度很快


462
00:15:28,216 --> 00:15:29,866
那么持续同步到 CloudKit


463
00:15:29,866 --> 00:15:31,796
就会极其昂贵


464
00:15:32,406 --> 00:15:34,006
因此我们发现客户会嵌入


465
00:15:34,006 --> 00:15:36,136
另外的存储文件


466
00:15:36,136 --> 00:15:37,866
并使用它来合并数据


467
00:15:37,866 --> 00:15:41,366
直到做好分析的准备再上传至


468
00:15:41,366 --> 00:15:42,186
CloudKit


469
00:15:42,936 --> 00:15:46,316
为了向你们展示工作原理


470
00:15:46,316 --> 00:15:47,566
以及 Core Data 如何把这个过程


471
00:15:47,566 --> 00:15:49,186
变得更加简单 我们将利用


472
00:15:49,186 --> 00:15:50,316
NSManagedObjectModel 


473
00:15:50,346 --> 00:15:52,706
的一个名叫做配置的功能


474
00:15:53,366 --> 00:15:55,856
现在 你们可以看到


475
00:15:55,856 --> 00:15:56,656
我们的 App 示例


476
00:15:56,906 --> 00:15:58,626
XCode 模型编辑器里面的


477
00:15:58,626 --> 00:15:59,886
NSManagedObjectModel


478
00:16:00,526 --> 00:16:02,016
现在 假设我想


479
00:16:02,016 --> 00:16:04,396
在帖子中添加位置 对吧


480
00:16:04,396 --> 00:16:06,966
我想记录下


481
00:16:07,376 --> 00:16:08,476
帖子被创建时的位置


482
00:16:08,976 --> 00:16:12,716
位置可以由系统高速生成


483
00:16:12,716 --> 00:16:16,106
但我只有在帖子被创建时


484
00:16:16,106 --> 00:16:16,866
才需要当前的位置


485
00:16:16,966 --> 00:16:19,036
让我们将它们与


486
00:16:19,036 --> 00:16:20,036
数据模型的其余部分分开


487
00:16:21,416 --> 00:16:24,706
我将点按左下角 + 号


488
00:16:24,706 --> 00:16:26,496
添加新的实体


489
00:16:26,496 --> 00:16:28,156
存储我的位置信息


490
00:16:28,786 --> 00:16:30,796
现在 我的位置信息将非常简单


491
00:16:30,796 --> 00:16:34,036
它将只包括双精度的纬度和经度


492
00:16:34,036 --> 00:16:36,946
即 Core Location 框架中提供的信息


493
00:16:37,296 --> 00:16:38,546
当然 你也可以包括


494
00:16:38,546 --> 00:16:39,986
其他方面的信息 


495
00:16:39,986 --> 00:16:41,000
如海拔或精度


496
00:16:45,126 --> 00:16:46,336
现在 我们想将位置信息


497
00:16:46,336 --> 00:16:48,166
与我们其他的数据隔离


498
00:16:48,406 --> 00:16:50,006
为此 我将创建一个新的配置


499
00:16:50,006 --> 00:16:53,526
再次点击这个 + 号按钮


500
00:16:53,526 --> 00:16:55,496
但是这次 我将长按


501
00:16:55,496 --> 00:16:56,886
直到出现一个菜单


502
00:16:56,886 --> 00:16:58,036
可以让我添加配置


503
00:16:58,916 --> 00:17:00,106
我将此配置命名为


504
00:17:00,106 --> 00:17:01,946
Cloud 并且添加


505
00:17:01,946 --> 00:17:03,196
全部的四个


506
00:17:03,196 --> 00:17:05,165
需要同步的实体


507
00:17:06,036 --> 00:17:07,376
现在你们可以看到


508
00:17:07,376 --> 00:17:09,396
Cloud 配置中


509
00:17:09,396 --> 00:17:11,445
这些我想要与 CloudKit 同步的实体


510
00:17:12,076 --> 00:17:13,526
让我们创建一个新的配置


511
00:17:13,526 --> 00:17:14,915
叫做 Local


512
00:17:14,915 --> 00:17:15,886
用来储存我们的位置对象


513
00:17:22,566 --> 00:17:23,925
仅仅几行代码


514
00:17:24,026 --> 00:17:25,205
它就能为我们工作


515
00:17:25,205 --> 00:17:27,406
允许 Core Data


516
00:17:27,406 --> 00:17:28,986
自动告诉存储文件


517
00:17:28,986 --> 00:17:30,526
存储对象的类型


518
00:17:30,526 --> 00:17:32,506
第一行你可以看到我们创建了


519
00:17:32,506 --> 00:17:33,186
一个 NSPersistentCloudKitContainer 实例


520
00:17:33,186 --> 00:17:36,506
然后我们利用


521
00:17:36,506 --> 00:17:38,396
NSPersistentStoreDescription


522
00:17:38,896 --> 00:17:39,566
它可以告诉


523
00:17:39,566 --> 00:17:41,126
NSPersistentCloudKitContainer


524
00:17:41,126 --> 00:17:42,506
目前正在处理的


525
00:17:42,506 --> 00:17:43,196
储存类型


526
00:17:43,946 --> 00:17:45,036
我们创建的


527
00:17:45,036 --> 00:17:46,526
NSPersistentStoreDescription 实例


528
00:17:46,936 --> 00:17:48,296
指向 local.sqlite 文件


529
00:17:48,296 --> 00:17:51,056
作为储存位置信息的地方


530
00:17:51,526 --> 00:17:52,866
我们将其分配给


531
00:17:52,866 --> 00:17:55,286
刚才创建的本地配置


532
00:17:56,066 --> 00:17:57,856
然后 我们建立了自己的云存储


533
00:17:58,366 --> 00:18:00,346
同样 我们创建一个


534
00:18:00,386 --> 00:18:03,706
NSPersistentStoreDescription 实例


535
00:18:03,706 --> 00:18:05,416
指向 cloud.sqlite


536
00:18:06,056 --> 00:18:08,786
然后给它刚才的云配置


537
00:18:08,786 --> 00:18:10,306
告诉 NSPersistentCloudKitContainer


538
00:18:10,306 --> 00:18:14,596
只有类似帖子标签还有附件


539
00:18:14,596 --> 00:18:16,906
图片这类内容才能在库中存储


540
00:18:17,936 --> 00:18:19,996
最后 我们为它分配


541
00:18:19,996 --> 00:18:23,706
NSPersistentCloudKitContainerOptions 的实例


542
00:18:23,706 --> 00:18:24,086
它可以告诉


543
00:18:24,226 --> 00:18:25,776
NSPersistentCloudKitContainer


544
00:18:25,916 --> 00:18:27,916
这个存储应该与什么


545
00:18:28,286 --> 00:18:29,776
iCloud 容器标识符同步


546
00:18:30,386 --> 00:18:32,336
最后我们分配


547
00:18:32,336 --> 00:18:33,736
这两个存储说明


548
00:18:33,736 --> 00:18:35,256
给 PersistentStoreDescription 的 


549
00:18:35,486 --> 00:18:37,866
NSPersistentCloudKitContainer 属性


550
00:18:38,886 --> 00:18:40,806
有了 NSPersistentCloudKitContainer 


551
00:18:40,806 --> 00:18:42,246
可以更好地利用它


552
00:18:42,946 --> 00:18:44,766
我们现在已经有了本地存储


553
00:18:44,766 --> 00:18:45,396
还有一个云存储


554
00:18:45,396 --> 00:18:47,066
如果我们想要


555
00:18:47,066 --> 00:18:48,666
在多个正在运行的 App 之间


556
00:18:48,666 --> 00:18:50,156
共享一些存储在


557
00:18:50,156 --> 00:18:50,676
CloudKit 的数据怎么办呢


558
00:18:51,226 --> 00:18:53,006
NSPersistentCloudKitContainer


559
00:18:53,006 --> 00:18:54,196
同样可以做到


560
00:18:54,856 --> 00:18:56,356
事实上因为你在


561
00:18:56,356 --> 00:18:57,876
使用 Core Data


562
00:18:57,946 --> 00:18:59,636
是非常容易就可以


563
00:18:59,636 --> 00:19:01,876
让你的 App 同时处理这些存储中的所有数据


564
00:19:02,456 --> 00:19:04,216
并且 Core Data


565
00:19:04,216 --> 00:19:05,556
还能自动帮助你处理


566
00:19:05,796 --> 00:19:07,186
写入数据


567
00:19:07,186 --> 00:19:09,196
自动插入到正确的存储文件里


568
00:19:10,476 --> 00:19:11,846
仅仅加了三行代码


569
00:19:11,916 --> 00:19:13,586
我们就能实现这个功能 对吧


570
00:19:13,586 --> 00:19:15,056
我们创建一个新的 StoreDescription


571
00:19:15,056 --> 00:19:16,266
然后指向我们分享的


572
00:19:16,266 --> 00:19:17,636
存储文件


573
00:19:17,636 --> 00:19:18,856
并且给它一个新配置


574
00:19:18,856 --> 00:19:20,046
命名为 Shared


575
00:19:20,736 --> 00:19:22,466
然后 我们给它分配


576
00:19:22,466 --> 00:19:23,846
NSPersistentCloudKitContainerOptions 实例


577
00:19:23,846 --> 00:19:25,546
它可以


578
00:19:25,546 --> 00:19:27,406
指定容器


579
00:19:27,406 --> 00:19:28,956
用于存储我们的共享数据


580
00:19:29,296 --> 00:19:32,696
现在是 iCloud.com.wwdc.shared


581
00:19:33,366 --> 00:19:34,626
当然 最后重要的一点


582
00:19:34,626 --> 00:19:36,776
我们将给它分配一个


583
00:19:36,776 --> 00:19:38,116
PersistentStoreDescriptions


584
00:19:38,486 --> 00:19:40,246
现在谈谈 Schema


585
00:19:41,036 --> 00:19:43,586
现在我想介绍


586
00:19:43,686 --> 00:19:44,956
关于 Schema 的


587
00:19:44,956 --> 00:19:46,436
几个重点


588
00:19:46,436 --> 00:19:48,486
是当你在读取 CloudKit 中


589
00:19:48,566 --> 00:19:49,686
创建的记录时


590
00:19:49,686 --> 00:19:50,576
你需要知道的东西


591
00:19:51,556 --> 00:19:54,736
我就从如何管理记录类型


592
00:19:54,736 --> 00:19:56,416
以及管理实体开始讲起


593
00:19:56,416 --> 00:19:58,776
这是你在 NSManagedObjectModel 创建的东西


594
00:19:59,466 --> 00:20:01,126
然后 我们将看看


595
00:20:01,126 --> 00:20:02,616
如何实现数据外化功能


596
00:20:02,616 --> 00:20:05,826
也就是使用


597
00:20:05,826 --> 00:20:07,566
NSPersistentCloudKitContainer


598
00:20:07,566 --> 00:20:08,626
将任意大的数据


599
00:20:08,656 --> 00:20:09,936
无缝存储在 CloudKit


600
00:20:10,436 --> 00:20:12,846
最后 我们将谈谈


601
00:20:12,846 --> 00:20:14,916
如何管理关系


602
00:20:14,916 --> 00:20:16,166
它可能与你曾经使用


603
00:20:16,166 --> 00:20:17,766
CloudKit 的经验有所不同


604
00:20:18,726 --> 00:20:22,526
我们将在 App 样例中


605
00:20:22,526 --> 00:20:23,596
使用 ManageObjectModel


606
00:20:23,966 --> 00:20:26,816
然后我将从 Post 实体开始讲起


607
00:20:27,356 --> 00:20:28,546
你可以看到它有两个属性


608
00:20:28,546 --> 00:20:30,746
标题字符串


609
00:20:30,746 --> 00:20:31,486
以及内容字符串


610
00:20:31,946 --> 00:20:33,066
而且它还有两个关系


611
00:20:33,066 --> 00:20:36,386
分别是对附件和标签实体


612
00:20:37,386 --> 00:20:39,206
Core Data 可以为你生成一个类


613
00:20:39,206 --> 00:20:40,906
在代码中使用


614
00:20:40,906 --> 00:20:42,586
作为 NSManagedObject 的子类


615
00:20:42,586 --> 00:20:43,596
看起来是这样的


616
00:20:44,216 --> 00:20:47,406
你可以看到所有的属性和关系


617
00:20:47,406 --> 00:20:49,756
都是在这个类中展示


618
00:20:49,756 --> 00:20:53,266
这是 CloudKit 中


619
00:20:53,266 --> 00:20:55,146
在帖子生成时创建的记录


620
00:20:55,936 --> 00:20:57,156
这些都是我用来


621
00:20:57,156 --> 00:20:58,326
填充记录的样例值


622
00:20:58,756 --> 00:21:02,496
使记录具体化


623
00:21:03,436 --> 00:21:04,836
现在 我还想与你们


624
00:21:04,836 --> 00:21:06,236
强调另外一些事情


625
00:21:06,716 --> 00:21:07,466
那就是记录 ID


626
00:21:07,996 --> 00:21:09,956
Core Data 有一个记录 ID


627
00:21:09,956 --> 00:21:11,286
对应在 CloudKit 中


628
00:21:11,286 --> 00:21:12,436
创建的每一个对象


629
00:21:12,866 --> 00:21:14,356
对于每一个对象


630
00:21:14,356 --> 00:21:16,836
都会生成一个简单的 UUID


631
00:21:16,836 --> 00:21:17,776
作为其记录的名称


632
00:21:18,336 --> 00:21:19,806
当这个记录名称与


633
00:21:19,806 --> 00:21:21,816
区域标识符合并之后


634
00:21:21,816 --> 00:21:22,806
你就得到了 CKRecord ID


635
00:21:23,076 --> 00:21:26,126
下面两行你看到的是


636
00:21:26,126 --> 00:21:28,156
Core Data 如何处理类型信息


637
00:21:28,826 --> 00:21:30,556
这里有两个比较


638
00:21:30,556 --> 00:21:33,516
有意思的事情


639
00:21:33,516 --> 00:21:34,866
第一个是 CD_ 到底是什么意思


640
00:21:35,906 --> 00:21:37,276
这是 Core Data 


641
00:21:37,276 --> 00:21:41,296
用来分开自身处理任务


642
00:21:41,296 --> 00:21:42,706
和 CloudKit 为你运行的


643
00:21:42,706 --> 00:21:44,386
任务的一种方式


644
00:21:44,386 --> 00:21:46,166
你不会相信有多少人会给 CKRecord


645
00:21:46,166 --> 00:21:47,236
添加修改日期


646
00:21:48,006 --> 00:21:49,386
或者区分用户


647
00:21:49,386 --> 00:21:49,906
自己添加的东西


648
00:21:50,056 --> 00:21:51,906
因此 我们提前标好前缀


649
00:21:51,906 --> 00:21:53,576
记录类型和所有的字段名称


650
00:21:53,676 --> 00:21:55,466
都包含 CD_ 前缀


651
00:21:56,386 --> 00:21:58,666
但是在 CD_entityName 字段


652
00:21:59,046 --> 00:22:01,096
我们会保留


653
00:22:01,096 --> 00:22:03,966
记录中对象实体的真实名称


654
00:22:04,896 --> 00:22:06,206
这么做是为了


655
00:22:06,206 --> 00:22:07,386
可以实现


656
00:22:07,386 --> 00:22:09,346
实体继承的功能


657
00:22:09,346 --> 00:22:11,406
你可以创建帖子的子类


658
00:22:11,406 --> 00:22:15,056
比如 像是一个图像帖子或者是


659
00:22:15,056 --> 00:22:18,186
视频帖子 实际的实体一般都会


660
00:22:18,186 --> 00:22:19,826
被在 CD_entityName


661
00:22:19,826 --> 00:22:21,156
标示出来


662
00:22:22,096 --> 00:22:23,296
我们这么做是为了


663
00:22:23,296 --> 00:22:26,156
在查询时


664
00:22:26,156 --> 00:22:28,156
只要查询一个记录类型


665
00:22:28,156 --> 00:22:30,126
就能得到所有你感兴趣的


666
00:22:30,126 --> 00:22:31,196
实体层次结构


667
00:22:32,456 --> 00:22:33,486
现在看看我们如何


668
00:22:33,486 --> 00:22:35,016
实现这两个字符串


669
00:22:35,066 --> 00:22:38,166
因为这些字段的长度是可变的


670
00:22:38,166 --> 00:22:39,666
还有我们将其上传至 CloudKit 中时


671
00:22:39,666 --> 00:22:41,696
也有很多有趣的习惯


672
00:22:43,336 --> 00:22:44,516
你会看到我们已经将其


673
00:22:44,516 --> 00:22:46,246
填充进四个字段中


674
00:22:46,586 --> 00:22:48,306
而这么做的原因是


675
00:22:48,366 --> 00:22:49,946
我们使用了


676
00:22:49,946 --> 00:22:51,006
数据外化的方式


677
00:22:51,716 --> 00:22:52,816
你可以看到我们


678
00:22:52,866 --> 00:22:54,506
既有了 CD_content


679
00:22:54,576 --> 00:22:58,326
又有了 CD_content_CKAsset


680
00:22:58,806 --> 00:23:00,416
借此 我们可以储存字符串


681
00:23:00,456 --> 00:23:02,106
无论它们有多长


682
00:23:02,466 --> 00:23:04,666
从几 kb


683
00:23:04,666 --> 00:23:06,146
再到几百 mb


684
00:23:06,146 --> 00:23:08,356
甚至是以 gb 计算都可以储存


685
00:23:09,626 --> 00:23:11,036
当我说 这个记录


686
00:23:11,036 --> 00:23:11,976
已经进行了全部的具体化


687
00:23:11,976 --> 00:23:13,446
我的意思是


688
00:23:13,446 --> 00:23:15,516
你不会在同一时间


689
00:23:15,516 --> 00:23:17,586
看到全部的四个字段


690
00:23:18,206 --> 00:23:19,286
如果字符串很短


691
00:23:19,286 --> 00:23:20,676
那么你会看到记录中有


692
00:23:20,676 --> 00:23:22,406
CD_content


693
00:23:22,406 --> 00:23:23,686
和 CD_title


694
00:23:24,216 --> 00:23:25,456
但是 如果它们变得


695
00:23:25,456 --> 00:23:27,656
非常很长


696
00:23:27,656 --> 00:23:30,446
大于 750 kb


697
00:23:30,446 --> 00:23:32,316
又或者整个记录的大小


698
00:23:32,566 --> 00:23:34,296
超过了 CloudKit 的 1 mb 的限制


699
00:23:34,296 --> 00:23:38,686
那么你就会看到 asset 字段  


700
00:23:38,686 --> 00:23:42,276
也就是现在的 CD_content_CKAsset


701
00:23:43,016 --> 00:23:44,326
如果你需要一直


702
00:23:44,326 --> 00:23:45,546
使用我们的记录


703
00:23:45,576 --> 00:23:47,316
那你需要检查这两个字段


704
00:23:47,316 --> 00:23:48,946
看看某个属性


705
00:23:48,946 --> 00:23:50,000
是否被赋了某个值


706
00:23:54,066 --> 00:23:57,016
现在看看 Post 里面的关系


707
00:23:57,546 --> 00:23:58,576
你可以看到它们


708
00:23:58,576 --> 00:24:00,796
都是 Core Data 为你在对象中创建且


709
00:24:00,796 --> 00:24:03,626
可供你使用的 NSSet 实例


710
00:24:04,126 --> 00:24:05,976
这是因为 Post 中


711
00:24:06,086 --> 00:24:07,536
有我们所谓的


712
00:24:07,536 --> 00:24:08,456
多元关系


713
00:24:08,936 --> 00:24:10,226
这意味着 一个帖子


714
00:24:10,226 --> 00:24:12,406
可以有多个附件


715
00:24:12,616 --> 00:24:16,846
或者它可以有多个标签


716
00:24:16,846 --> 00:24:17,686
我们一般称附件关系为


717
00:24:17,686 --> 00:24:19,126
多对一


718
00:24:19,126 --> 00:24:21,646
因为一个附件只能被分配给一个帖子


719
00:24:23,266 --> 00:24:24,686
当我们写代码的时候


720
00:24:24,686 --> 00:24:26,016
你可以看到 Post


721
00:24:26,016 --> 00:24:27,876
中有一个 NSSet


722
00:24:27,876 --> 00:24:30,346
但 Attachment ManageObject


723
00:24:30,566 --> 00:24:32,406
仅有一个 Post 对象


724
00:24:33,506 --> 00:24:36,876
这就是为附件生成的记录


725
00:24:37,366 --> 00:24:39,316
你可以看到它已经有了一个 UUID


726
00:24:39,316 --> 00:24:40,526
一个实体名称和记录类型


727
00:24:40,526 --> 00:24:42,576
就像 Post 一样


728
00:24:42,576 --> 00:24:43,886
但是你也看到了


729
00:24:43,886 --> 00:24:46,196
这里有一个叫做 CD_post 的字段


730
00:24:46,576 --> 00:24:47,546
这是我们如何储存


731
00:24:47,546 --> 00:24:50,316
多对一的关系


732
00:24:51,046 --> 00:24:53,446
在 CloudKit 中 相关记录的 UUID


733
00:24:53,446 --> 00:24:57,236
始终会储存在与它相关联的对象中


734
00:24:57,806 --> 00:24:59,696
并且 也许你会想


735
00:24:59,696 --> 00:25:00,726
为什么我们不用


736
00:25:00,726 --> 00:25:02,006
CKReference 来处理这个问题呢


737
00:25:02,006 --> 00:25:04,076
那是因为 CKReference


738
00:25:04,076 --> 00:25:05,536
有一些我们认为


739
00:25:05,536 --> 00:25:07,116
对于 Core Data 客户来说


740
00:25:07,116 --> 00:25:07,906
并不是很友好的地方


741
00:25:08,386 --> 00:25:11,996
那就是它对象的数量只能限制在 750 之内


742
00:25:12,376 --> 00:25:13,686
但是通过这样储存关系


743
00:25:13,756 --> 00:25:15,426
你可以在 CloudKit 容器中


744
00:25:15,426 --> 00:25:17,006
存储足够多的关系


745
00:25:17,626 --> 00:25:20,866
现在看看多对多关系


746
00:25:21,156 --> 00:25:22,336
在本例中


747
00:25:22,336 --> 00:25:23,736
也就是帖子和它的标签之间的关系


748
00:25:24,976 --> 00:25:26,226
你可以看到对象中


749
00:25:26,306 --> 00:25:29,146
有两个 NSSet 


750
00:25:29,146 --> 00:25:31,326
这是因为两个对象都


751
00:25:31,326 --> 00:25:33,436
与其他的很多类型相连


752
00:25:33,436 --> 00:25:35,586
当我们生成


753
00:25:35,586 --> 00:25:37,186
这些对象的记录时


754
00:25:37,186 --> 00:25:39,116
我们没有具体化的字段


755
00:25:39,116 --> 00:25:40,426
来存储这种关系


756
00:25:41,176 --> 00:25:43,556
而是 Core Data


757
00:25:43,556 --> 00:25:44,976
具体化了一种自定义连接记录


758
00:25:45,406 --> 00:25:46,626
现在如果你对于


759
00:25:46,656 --> 00:25:48,566
关系数据库很熟悉


760
00:25:48,566 --> 00:25:49,866
你会理解这个概念


761
00:25:50,026 --> 00:25:51,816
基本上来说 它就是


762
00:25:51,816 --> 00:25:53,876
对于连接表中一行的外推


763
00:25:54,466 --> 00:25:57,276
被叫做 CDMR 或者是


764
00:25:57,276 --> 00:25:58,466
Core Data 镜像关系


765
00:25:59,176 --> 00:26:01,426
CDMR 包含了一对元组


766
00:26:01,426 --> 00:26:02,736
这是为了描述


767
00:26:02,736 --> 00:26:04,166
两个相关联对象


768
00:26:04,566 --> 00:26:06,106
首先是相关联对象的


769
00:26:06,106 --> 00:26:07,306
实体名称


770
00:26:07,306 --> 00:26:09,446
以及记录名称


771
00:26:09,916 --> 00:26:13,216
我之前说过 这不是记录 ID


772
00:26:13,596 --> 00:26:15,156
这是记录名称


773
00:26:15,156 --> 00:26:16,576
需要你把它和


774
00:26:16,576 --> 00:26:18,436
区域标识符结合起来


775
00:26:18,436 --> 00:26:22,536
然后得到 CDMR 相连的记录的标识符


776
00:26:22,946 --> 00:26:27,306
最后 我们也将此关联的


777
00:26:27,306 --> 00:26:28,546
确切关系进行记录


778
00:26:30,996 --> 00:26:33,396
那么为什么我要花费这么多时间


779
00:26:33,396 --> 00:26:34,126
来和你们介绍关系呢


780
00:26:35,486 --> 00:26:38,326
因为它们会影响我们


781
00:26:38,416 --> 00:26:40,676
协作进行数据建模的方式


782
00:26:41,346 --> 00:26:42,926
我也需要说清楚


783
00:26:42,926 --> 00:26:46,676
协作并非冲突解决


784
00:26:47,296 --> 00:26:50,586
冲突解决可以通过


785
00:26:50,586 --> 00:26:52,246
NSPersistentCloudKitContainer


786
00:26:52,296 --> 00:26:54,486
使用后写入为准的策略实现


787
00:26:55,166 --> 00:26:56,546
我们这么做的原因是


788
00:26:56,546 --> 00:27:00,036
冲突解决的作用是保持对象图


789
00:27:00,086 --> 00:27:01,726
以及 CloudKit 中的数据


790
00:27:02,086 --> 00:27:04,466
与你们建模的数据保持一致


791
00:27:05,286 --> 00:27:07,806
但是 这些年来


792
00:27:07,806 --> 00:27:09,396
一直进行的不尽如人意


793
00:27:09,936 --> 00:27:12,686
那么 现在看看你如何使用关系


794
00:27:12,686 --> 00:27:15,726
能更好地进行合并


795
00:27:15,766 --> 00:27:20,846
并且将合并行为与特定用户用例保持一致


796
00:27:22,436 --> 00:27:24,176
为了实现这个目标


797
00:27:24,176 --> 00:27:25,616
我们将再次使用 Post App


798
00:27:26,016 --> 00:27:27,456
我要创建一个帖子


799
00:27:27,906 --> 00:27:29,066
但是我这次不会给它


800
00:27:29,066 --> 00:27:29,826
分配任何内容


801
00:27:30,866 --> 00:27:32,516
我就让它同步给另外一个设备


802
00:27:32,516 --> 00:27:36,406
换句话说 我将同时在每台设备


803
00:27:36,406 --> 00:27:37,436
上面进行一些编辑


804
00:27:38,016 --> 00:27:39,316
现在 这才是我们


805
00:27:39,316 --> 00:27:41,406
传统概念上称作的冲突


806
00:27:41,936 --> 00:27:44,116
但是其实 这是一个


807
00:27:44,116 --> 00:27:45,446
两台设备想要对


808
00:27:45,446 --> 00:27:47,676
一个数值进行协同的好例子


809
00:27:48,416 --> 00:27:50,606
现在 NSPersistentCloudKitContainer


810
00:27:51,036 --> 00:27:52,196
已经发现 CloudKit 里面


811
00:27:52,196 --> 00:27:53,686
的内容发生了改变


812
00:27:53,686 --> 00:27:55,796
它将解决这个问题


813
00:27:55,796 --> 00:27:57,856
以保留两个数值中的一个 是吧


814
00:27:57,956 --> 00:27:59,876
使用后写入为准的策略


815
00:28:00,366 --> 00:28:01,276
这就意味着要么我们


816
00:28:01,276 --> 00:28:03,376
将协同做得很棒


817
00:28:03,826 --> 00:28:04,806
要么要修改两次


818
00:28:05,156 --> 00:28:09,056
的确如此 当然 也许你会想


819
00:28:09,056 --> 00:28:10,896
嗯 这是多此一举的


820
00:28:11,436 --> 00:28:12,566
Core Data 为什么不直接


821
00:28:12,596 --> 00:28:14,056
连接两个字符串呢


822
00:28:14,696 --> 00:28:15,576
我们的确能这么做


823
00:28:16,026 --> 00:28:17,346
除非你在过去的几年里


824
00:28:17,346 --> 00:28:20,506
采取了我们的建议实现了增量存储


825
00:28:20,856 --> 00:28:21,806
否则结果可能会是这样


826
00:28:21,806 --> 00:28:25,016
这不是我们想看到的


827
00:28:25,556 --> 00:28:26,796
而且它甚至还不是英文


828
00:28:28,446 --> 00:28:30,496
所以我们怎么才能改善呢 对吧


829
00:28:30,536 --> 00:28:31,966
很明显 这是一个


830
00:28:31,966 --> 00:28:33,426
不仅对我们 也是对客户来说


831
00:28:33,426 --> 00:28:35,056
至关重要的问题


832
00:28:35,806 --> 00:28:38,866
那么我们就看下 Post 实体


833
00:28:38,866 --> 00:28:41,046
看看能做哪些改进


834
00:28:41,716 --> 00:28:44,936
我们首要任务是停止


835
00:28:44,936 --> 00:28:47,126
在表面值上创建冲突


836
00:28:47,676 --> 00:28:49,986
内容只不过是表面上的字符串


837
00:28:50,026 --> 00:28:52,806
我们没办法仅仅通过它本身推断


838
00:28:52,806 --> 00:28:54,096
你想为字符串实行的


839
00:28:54,096 --> 00:28:55,236
合并策略


840
00:28:56,356 --> 00:29:01,406
但是 如果我们将它的关系进行分解


841
00:29:01,406 --> 00:29:05,816
多个设备将对内容字段做出贡献


842
00:29:06,336 --> 00:29:10,096
因为我们储存二对一关系的方式


843
00:29:10,096 --> 00:29:11,416
很多设备可以在


844
00:29:11,416 --> 00:29:13,246
同一时间里修改内容


845
00:29:13,246 --> 00:29:15,836
而且不会对 Post 对象产生冲突


846
00:29:16,936 --> 00:29:18,566
所以 我现在将其分解


847
00:29:18,566 --> 00:29:20,776
使之变成一个由简单字符串


848
00:29:21,126 --> 00:29:22,366
构成的 PostContent 实体


849
00:29:23,556 --> 00:29:25,756
现在 因为我们存储


850
00:29:25,756 --> 00:29:27,536
二对一关系的方式


851
00:29:27,536 --> 00:29:29,986
这些将会由设备自行合并


852
00:29:30,176 --> 00:29:31,796
对吧 我们得去研究它们


853
00:29:31,796 --> 00:29:33,546
以此来收集最终值


854
00:29:34,056 --> 00:29:36,506
我们将其称为最终一致性


855
00:29:36,926 --> 00:29:38,896
当两台设备一起


856
00:29:38,896 --> 00:29:40,026
修改 PostContent 对象的时候


857
00:29:40,026 --> 00:29:41,186
它们就会从对方那里


858
00:29:41,186 --> 00:29:42,736
下载 PostContent 对象


859
00:29:42,736 --> 00:29:45,026
并将其连接或者合并


860
00:29:45,026 --> 00:29:46,516
再或者其他你选择的连接方式


861
00:29:46,516 --> 00:29:48,326
用来解决这个问题


862
00:29:48,326 --> 00:29:49,606
以此收集最终值的操作


863
00:29:50,926 --> 00:29:52,786
但是我们想让这个过程


864
00:29:52,786 --> 00:29:54,766
在所有设备中都保持一致


865
00:29:54,836 --> 00:29:56,136
不同的下载顺序


866
00:29:56,136 --> 00:29:57,966
就可能导致最终值的不同


867
00:29:58,476 --> 00:30:00,536
因此 我们要用一些信息


868
00:30:00,536 --> 00:30:02,216
将它们排序 比如日期


869
00:30:02,806 --> 00:30:04,306
这样做的话 设备就可以


870
00:30:04,306 --> 00:30:05,876
在连接之前


871
00:30:05,876 --> 00:30:07,466
使用 Core Data 中简单的排序描述符


872
00:30:07,466 --> 00:30:10,716
对 PostContent 对象排序


873
00:30:10,716 --> 00:30:12,186
使下载顺序和合并策略


874
00:30:12,186 --> 00:30:14,336
在所有设备上保持一致


875
00:30:15,216 --> 00:30:17,106
然而 我还是比较喜欢研究


876
00:30:17,106 --> 00:30:20,166
分布式系统 而时间有其局限性


877
00:30:21,296 --> 00:30:22,826
事实上 如果设备们都在你的房间中


878
00:30:22,826 --> 00:30:24,276
那它们的时间


879
00:30:24,276 --> 00:30:24,976
可能都不会有所差别


880
00:30:26,716 --> 00:30:28,716
那么 我们可以把这一步


881
00:30:28,716 --> 00:30:32,306
做得更远


882
00:30:32,306 --> 00:30:33,546
利用修改的层级关系


883
00:30:33,546 --> 00:30:35,446
并给予实体一些


884
00:30:35,446 --> 00:30:38,476
关于正在进行实际工作的设备信息


885
00:30:38,476 --> 00:30:39,626
从而实现完整的因果树


886
00:30:40,326 --> 00:30:42,006
这样的话 我们就完成了


887
00:30:42,006 --> 00:30:43,326
一个称作无冲突


888
00:30:43,326 --> 00:30:45,526
复制数据类型的粗略草图


889
00:30:46,026 --> 00:30:47,626
这是一个极棒的


890
00:30:47,626 --> 00:30:49,376
新兴计算机科学领域


891
00:30:49,376 --> 00:30:52,866
它可以帮助我们部署算法 


892
00:30:52,866 --> 00:30:54,426
在不同的用户-用户场景之间


893
00:30:54,426 --> 00:30:55,806
生成一致的合并行为


894
00:30:56,316 --> 00:31:02,216
这就是在 Using Core Data with CloudKit 的主要内容


895
00:31:02,216 --> 00:31:03,386
我非常荣幸能够向你们展示


896
00:31:03,516 --> 00:31:05,046
NSPersistentCloudKitContainer


897
00:31:05,116 --> 00:31:07,886
以及对于你来说为自己的 App 实现


898
00:31:07,886 --> 00:31:08,886
同步功能有多简单


899
00:31:09,726 --> 00:31:10,876
今年 我们可以为你们提供


900
00:31:10,876 --> 00:31:12,316
非常棒的示例代码和文档


901
00:31:12,386 --> 00:31:15,046
并且我非常希望可以给你们带来


902
00:31:15,046 --> 00:31:16,466
全新 API 的极致体验


903
00:31:17,076 --> 00:31:19,516
最后 我已经迫不及待


904
00:31:19,516 --> 00:31:20,396
想看看你们如何使用


905
00:31:20,396 --> 00:31:21,946
NSPersistentCloudKitContainer


906
00:31:22,266 --> 00:31:24,476
以及如何去扩展它


907
00:31:24,626 --> 00:31:28,366
今年我们有很多实验室 这周每天都有


908
00:31:28,546 --> 00:31:30,026
正如你们所知道的 我们会在


909
00:31:30,026 --> 00:31:31,846
星期三的三点钟举办一个会议


910
00:31:31,846 --> 00:31:33,846
届时 Core Data 更多的功能将亮相


911
00:31:35,196 --> 00:31:36,246
非常感谢 我希望大家


912
00:31:36,246 --> 00:31:37,976
都能好好享受 WWDC


913
00:31:38,516 --> 00:31:42,500
[掌声]

