1
00:00:06,139 --> 00:00:09,843 line:0
（在HealthKit中
探究新数据表达）


2
00:00:12,212 --> 00:00:13,146 line:-1
下午好


3
00:00:13,914 --> 00:00:15,249 line:-1
我是Luke Spicer


4
00:00:15,315 --> 00:00:17,117 line:-1
今天我和我的同事Divya


5
00:00:17,184 --> 00:00:20,454 line:-1
要与大家分享HealthKit


6
00:00:20,521 --> 00:00:22,756 line:-1
如何在iOS 13中扩展数据表达


7
00:00:25,192 --> 00:00:26,660 line:-1
有许多人已经知道


8
00:00:27,027 --> 00:00:31,098 line:-2
HealthKit针对健康和健身
数据提供集中式数据存储


9
00:00:31,598 --> 00:00:35,235 line:-2
并且还为健康和健身app和体验
提供互操作性


10
00:00:36,370 --> 00:00:38,872 line:-2
如果你还不了解
HealthKit的使用


11
00:00:39,239 --> 00:00:42,476 line:-2
让我来提醒你一下
在App Store的


12
00:00:42,543 --> 00:00:44,578 line:-2
健康与健身类中
有七万多个app


13
00:00:44,978 --> 00:00:48,081 line:-2
并且它们均可
从HealthKit所提供的


14
00:00:48,148 --> 00:00:50,117 line:-1
互操作性和功能性中受益


15
00:00:51,652 --> 00:00:53,287 line:-2
今天我要讲一些
与HealthKit中的


16
00:00:53,353 --> 00:00:55,155 line:-1
数据表达相关的信息


17
00:00:55,889 --> 00:00:58,158 line:-2
从回顾HealthKit
数据模型开始


18
00:00:58,225 --> 00:00:59,059 line:-1
（HealthKit数据模型）


19
00:00:59,126 --> 00:01:02,329 line:-2
然后我要讲一些
主要应用于量化数据的特定API


20
00:01:03,664 --> 00:01:06,433 line:-2
稍后Divya会上台
来讲每搏测量、


21
00:01:06,834 --> 00:01:07,835 line:-1
心率事件


22
00:01:08,569 --> 00:01:11,572 line:-1
和有关听力健康的全新的API


23
00:01:13,207 --> 00:01:16,310 line:-2
让我们从HealthKit
数据模型开始讲


24
00:01:17,945 --> 00:01:19,646 line:-2
在HealthKit中
我们表达数据…


25
00:01:21,215 --> 00:01:23,317 line:-2
在HealthKit中
我们用样本表达数据


26
00:01:23,884 --> 00:01:26,186 line:-1
样本是在特定时间所进行的测量


27
00:01:26,553 --> 00:01:28,222 line:-1
有一定的时间跨度


28
00:01:29,656 --> 00:01:32,759 line:-1
绝大多数测量都是简单测量


29
00:01:33,160 --> 00:01:35,429 line:-2
比如通过
Apple Watch测量的心率


30
00:01:36,530 --> 00:01:40,300 line:-2
或通过已连接的Bluetooth
进行的身体质量测量


31
00:01:42,503 --> 00:01:44,605 line:-1
其它测量更加丰富和复杂


32
00:01:45,038 --> 00:01:47,207 line:-1
比如锻炼或临床病例


33
00:01:47,274 --> 00:01:49,176 line:-1
可直接下载到iPhone上


34
00:01:51,645 --> 00:01:55,215 line:-1
所有这些丰富的、复杂的数据表达


35
00:01:55,282 --> 00:01:56,350 line:-1
都共享一个通用结构


36
00:01:56,817 --> 00:02:00,087 line:-2
最高层级的样本
以一些专业数据表达为支撑


37
00:02:01,188 --> 00:02:02,222 line:-1
比如…


38
00:02:03,557 --> 00:02:06,960 line:-1
血压测量可以表达为一个相关样本


39
00:02:07,528 --> 00:02:09,830 line:-1
过敏资源来自病例


40
00:02:10,564 --> 00:02:13,567 line:-1
健身路线来自一系列样本


41
00:02:14,134 --> 00:02:16,737 line:-1
这些都是专业样本类型的示例


42
00:02:17,137 --> 00:02:19,540 line:-1
都有各自独特的备份数据格式


43
00:02:20,641 --> 00:02:22,509 line:-1
比如血压相关样本


44
00:02:22,576 --> 00:02:24,011 line:-1
是一组血压测量


45
00:02:24,578 --> 00:02:26,947 line:-1
过敏资源依赖于文件资源


46
00:02:28,282 --> 00:02:30,817 line:-1
健身路线是CL位置数据的一个数组


47
00:02:31,618 --> 00:02:34,988 line:-2
正因为HealthKit
对这些特殊的测量类型


48
00:02:35,055 --> 00:02:36,557 line:-1
提供这些专业数据表达


49
00:02:37,191 --> 00:02:39,893 line:-1
我们也针对最常见的测量类型


50
00:02:39,960 --> 00:02:41,461 line:-1
对数据表达进行了扩展


51
00:02:41,828 --> 00:02:42,796 line:-1
适用于量化数据


52
00:02:43,430 --> 00:02:45,933 line:-1
我们继续讲一下量化数据


53
00:02:45,999 --> 00:02:47,301 line:-1
（新的量化系列API）


54
00:02:48,502 --> 00:02:49,570 line:-1
快速回顾一下


55
00:02:49,937 --> 00:02:53,540 line:-2
HealthKit中的量化数据
适用于一些很常见的测量概念


56
00:02:54,908 --> 00:02:56,176 line:-1
比如步行距离、


57
00:02:56,543 --> 00:02:58,145 line:-1
身体质量和心率


58
00:02:59,046 --> 00:03:02,015 line:-2
我们把所有这些概念
都看作是量化类型


59
00:03:02,816 --> 00:03:04,785 line:-1
它们的测量看起来类似这样


60
00:03:06,720 --> 00:03:10,357 line:-2
每个测量都包含一个量化数据
它是一个值


61
00:03:10,724 --> 00:03:13,160 line:-1
和一个单位 以及一个时间区间


62
00:03:13,227 --> 00:03:15,629 line:-1
那表明测量所发生的时间区间


63
00:03:16,496 --> 00:03:18,732 line:-2
我们把每一个这样的测量
都叫做量化样本


64
00:03:20,400 --> 00:03:22,536 line:-1
根据这个描述 我们要讲


65
00:03:23,303 --> 00:03:25,005 line:-1
量化类型和量化样本


66
00:03:25,305 --> 00:03:27,908 line:-1
特别是如何有效地表达


67
00:03:27,975 --> 00:03:29,142 line:-1
大量的量化数据


68
00:03:29,676 --> 00:03:31,712 line:-2
但如果你想了解
关于这些概念的更多介绍


69
00:03:32,045 --> 00:03:34,581 line:-1
请参看我们2014年的演讲


70
00:03:34,982 --> 00:03:36,049 line:-1
关于HealthKit的介绍


71
00:03:37,317 --> 00:03:38,886 line:-1
为了继续推进我们对量化数据的讨论


72
00:03:38,952 --> 00:03:40,020 line:-1
我想描述一个情境


73
00:03:40,988 --> 00:03:43,090 line:-1
如果可以 请你想象一下


74
00:03:43,156 --> 00:03:45,092 line:-1
我们正在做一个全新的app


75
00:03:45,926 --> 00:03:48,762 line:-2
这个app连接了一个
以前从未见过的心率传感器


76
00:03:49,029 --> 00:03:51,131 line:-1
它被嵌入了一个视频游戏控制器中


77
00:03:52,132 --> 00:03:54,835 line:-2
我们的任务是
从这个心率传感器获取测量数据


78
00:03:54,902 --> 00:03:56,069 line:-2
并把它们保存到
HealthKit中


79
00:03:56,136 --> 00:03:58,138 line:-1
从而用户可以了解他们的心率是多少


80
00:03:58,205 --> 00:03:59,806 line:-1
当他们玩任意一款游戏时


81
00:04:01,875 --> 00:04:03,744 line:0
我们从传感器中收到的心率


82
00:04:03,810 --> 00:04:05,179 line:0
看起来就像这样


83
00:04:05,245 --> 00:04:07,548 line:0
一系列测量数据
会随时间进入我们的app


84
00:04:07,814 --> 00:04:09,149 line:0
当用户玩游戏时


85
00:04:09,816 --> 00:04:11,952 line:0
我们需要决定如何表达这个数据


86
00:04:12,219 --> 00:04:13,353 line:0
我们可以把它
保存到HealthKit中


87
00:04:14,655 --> 00:04:15,956 line:-1
我们可以采用的一种方法是


88
00:04:16,023 --> 00:04:18,125 line:-1
使用单一量化样本


89
00:04:18,825 --> 00:04:20,327 line:-1
看起来就像这样


90
00:04:21,394 --> 00:04:24,198 line:-2
这个单一量化样本
跨越了整个测量间隔


91
00:04:24,631 --> 00:04:26,667 line:-1
就是游戏的整个时长


92
00:04:27,067 --> 00:04:29,002 line:-1
并通过单一量化来表达


93
00:04:29,069 --> 00:04:30,571 line:-1
我们从传感器中接收的全部测量数据


94
00:04:30,938 --> 00:04:31,905 line:-1
也许是平均值


95
00:04:33,273 --> 00:04:35,142 line:-1
这个表达为我们提供了一个对象


96
00:04:35,742 --> 00:04:38,545 line:-2
来表达我们所获取的测量数据
即这个游戏过程中的心率


97
00:04:39,213 --> 00:04:42,282 line:-2
但如果稍后我们想了解
游戏结束后心率的变化


98
00:04:42,349 --> 00:04:44,785 line:-1
我们就没办法通过这种表达来实现


99
00:04:46,420 --> 00:04:47,955 line:-1
我们可以采取的另一种表达是


100
00:04:48,322 --> 00:04:51,859 line:-1
使用多个量化样本 看起来就像这样


101
00:04:52,459 --> 00:04:55,629 line:-1
每一个测量都表达不同的量化样本


102
00:04:56,697 --> 00:04:59,566 line:-1
这种表达允许我们保留


103
00:04:59,633 --> 00:05:00,701 line:-1
由传感器测量的全部数据


104
00:05:01,201 --> 00:05:05,339 line:-2
但这种数据表达并没有那么有效率
因为我们有冗余数据


105
00:05:05,973 --> 00:05:07,441 line:-1
全部这些量化样本


106
00:05:07,508 --> 00:05:09,943 line:-1
都有相同的元数据和设备信息


107
00:05:10,844 --> 00:05:13,480 line:-1
我们不再拥有那个便利的单一对象了


108
00:05:13,547 --> 00:05:15,616 line:-2
就是那个表达我们实际上
所获取的测量数据的单一对象


109
00:05:15,682 --> 00:05:17,317 line:-1
在游戏过程中是心率


110
00:05:18,752 --> 00:05:21,121 line:-1
谢天谢地 我们可以采用第三种方法


111
00:05:21,455 --> 00:05:23,090 line:-1
我们把它叫做量化系列


112
00:05:24,091 --> 00:05:26,894 line:-1
量化系列表达看起来像这样


113
00:05:28,028 --> 00:05:29,796 line:-1
单一量化样本


114
00:05:29,863 --> 00:05:31,598 line:-1
跨越了整个测量时间


115
00:05:32,432 --> 00:05:34,735 line:-2
但在这种情况下
我们不获取单一量化数据


116
00:05:35,035 --> 00:05:37,037 line:-1
而是多个量化数据


117
00:05:38,372 --> 00:05:41,808 line:-1
这种表达利用了以上两种方法的优点


118
00:05:42,109 --> 00:05:43,944 line:-1
用单一对象表达测量数据


119
00:05:44,611 --> 00:05:47,514 line:-2
会保留从传感器中获取的
全部测量数据


120
00:05:48,615 --> 00:05:52,085 line:-1
请注意我们移除了


121
00:05:52,152 --> 00:05:54,688 line:-2
之前存在于
单个量化样本上的冗余信息


122
00:05:54,755 --> 00:05:57,724 line:-2
因此我们在量化系列样本层级
我们只存储单一副本


123
00:05:58,625 --> 00:06:01,328 line:-1
我们都想尊重用户的设备存储


124
00:06:01,828 --> 00:06:03,130 line:-1
和设备性能


125
00:06:03,197 --> 00:06:05,132 line:-1
这种表达就可以让我们实现这个目的


126
00:06:07,000 --> 00:06:09,336 line:-1
因为量化系列样本是一种量化样本


127
00:06:10,037 --> 00:06:14,508 line:-2
我们需要一种方式来表达
有单一值的量化数据的顺序


128
00:06:15,242 --> 00:06:17,778 line:-2
并且在HealthKit中
我们通过一种叫做聚合的技术来实现


129
00:06:19,079 --> 00:06:22,783 line:-2
我们有两个主要的聚合类型：
积累和离散


130
00:06:23,550 --> 00:06:24,818 line:-1
积累聚合类型


131
00:06:25,152 --> 00:06:27,955 line:-2
适用于一些很常见的量化类型
比如距离、


132
00:06:28,021 --> 00:06:29,156 line:-1
卡路里和步数


133
00:06:30,090 --> 00:06:32,726 line:-2
全部这些量化类型
都被用户持续地累积


134
00:06:32,793 --> 00:06:35,596 line:-2
他们走更多的步数
燃烧更多的卡路里


135
00:06:35,662 --> 00:06:36,830 line:-1
和移动更远的距离


136
00:06:37,865 --> 00:06:41,134 line:-2
执行累积的最自然的方式—
针对这些类型


137
00:06:41,201 --> 00:06:42,936 line:-2
聚合多个量化数据的最自然的方式
是用合计


138
00:06:44,872 --> 00:06:45,939 line:-1
另一方面


139
00:06:46,240 --> 00:06:49,376 line:-2
我们还有一些其它常见的量化类型
不适用合计


140
00:06:50,277 --> 00:06:52,846 line:-1
比如心率、身体质量和身高


141
00:06:53,914 --> 00:06:55,883 line:-1
如果合计在一起没有任何意义


142
00:06:55,949 --> 00:06:58,218 line:-2
如果你一天量好几次心率
并把它们加在一起


143
00:06:58,886 --> 00:06:59,953 line:-1
你会得到一个荒谬的值


144
00:07:00,654 --> 00:07:04,258 line:-1
像这样聚合量化类型会更自然


145
00:07:04,324 --> 00:07:07,294 line:-1
取平均值 也许是其它聚合统计


146
00:07:07,661 --> 00:07:10,063 line:-1
比如最小值、最大值和最新值


147
00:07:12,533 --> 00:07:17,037 line:-2
再一次 我们可以看到
一系列的累积量化数据


148
00:07:17,337 --> 00:07:19,306 line:-1
可以通过合计来表达和聚合


149
00:07:20,207 --> 00:07:22,709 line:-1
而一系列的离散量化数据比如心率


150
00:07:23,177 --> 00:07:26,513 line:-1
将被聚合来产生一些统计数据


151
00:07:26,580 --> 00:07:29,316 line:-2
比如最小值、最大值、
平均值和最新值


152
00:07:31,385 --> 00:07:33,787 line:-2
在HealthKit中
我们使用量化聚合类型


153
00:07:33,854 --> 00:07:36,356 line:-1
来提供指定量化类型的聚合类型


154
00:07:37,291 --> 00:07:38,425 line:-1
并且在iOS 13中


155
00:07:39,026 --> 00:07:41,695 line:-1
我们决定不使用离散聚合类型


156
00:07:41,762 --> 00:07:46,333 line:-1
而使用一种新的离散算法聚合类型


157
00:07:47,067 --> 00:07:49,603 line:-2
我们之所以这样做是为了明确
根据这种聚合类型


158
00:07:49,670 --> 00:07:52,606 line:-2
所计算出来的平均值
是简单的算数平均数


159
00:07:53,674 --> 00:07:56,610 line:-1
我们还引入了一些新的聚合类型


160
00:07:56,977 --> 00:07:59,179 line:-2
让我们从
discreteTemporallyWeighted开始讲


161
00:07:59,580 --> 00:08:02,616 line:-2
它是一种特殊的聚合类型
使用时间加权平均值


162
00:08:03,016 --> 00:08:05,085 line:-1
应用于当我们聚合心率量化数据时


163
00:08:06,420 --> 00:08:09,456 line:-2
我们还添加了
discreteEquivalent ContinuousLevel


164
00:08:10,023 --> 00:08:13,460 line:-2
它是一种特殊的聚合类型
适用于音频暴露量化数据


165
00:08:14,361 --> 00:08:17,264 line:-1
Divya稍后会具体讲音频暴露


166
00:08:19,633 --> 00:08:22,503 line:-2
现在我们了解了如何聚合
多个量化数据


167
00:08:23,203 --> 00:08:24,571 line:-1
来生产统计数据


168
00:08:24,938 --> 00:08:27,774 line:-2
我们需要一个地方来存储
量化样本上的这个信息


169
00:08:28,909 --> 00:08:30,210 line:-2
我们在iOS 13中
实现了这个功能


170
00:08:30,277 --> 00:08:32,980 line:-1
通过引入两个新量化样本子类实现


171
00:08:33,046 --> 00:08:34,881 line:-1
从累积量化样本开始


172
00:08:34,948 --> 00:08:36,149 line:-1
它有一个合计属性


173
00:08:36,549 --> 00:08:37,885 line:-1
并且离散量化样本


174
00:08:38,352 --> 00:08:39,419 line:-1
它有


175
00:08:39,919 --> 00:08:42,890 line:-2
平均值、最小值、最大值
和最新值量化属性


176
00:08:43,991 --> 00:08:47,427 line:-1
我们还把量化样本作为抽象基类


177
00:08:47,895 --> 00:08:50,898 line:-1
意思是从现在起


178
00:08:50,964 --> 00:08:52,065 line:-1
你所交互的量化样本的全部实体


179
00:08:52,366 --> 00:08:55,302 line:-1
都将是这两个量化样本子类中的一个


180
00:08:55,369 --> 00:08:57,704 line:-1
取决于量化类型的聚合类型


181
00:08:58,972 --> 00:09:00,407 line:-1
并且我还想提醒一下


182
00:09:00,474 --> 00:09:03,577 line:-2
全部量化样本都可以被看作是
量化系列


183
00:09:03,944 --> 00:09:06,647 line:-2
只不过其中有些恰好只有一个
量化样本


184
00:09:07,948 --> 00:09:10,751 line:-1
我们还为这两个新样本类型


185
00:09:11,018 --> 00:09:12,486 line:-2
引入了相应的
Predicate键径


186
00:09:14,188 --> 00:09:17,324 line:-1
你可以查询这两种样本的相应属性


187
00:09:18,892 --> 00:09:20,894 line:-1
返回到我们的量化系列样本例子中


188
00:09:21,695 --> 00:09:23,797 line:-1
我们可以看到量化系列样本


189
00:09:23,864 --> 00:09:25,999 line:-1
可以通过我们的聚合统计进行合计


190
00:09:26,066 --> 00:09:27,668 line:-1
平均值、最小值、最大值和最新值


191
00:09:29,203 --> 00:09:32,039 line:-1
现在我要讲如何创建这种量化系列


192
00:09:33,140 --> 00:09:34,241 line:0
（创建量化系列）


193
00:09:34,308 --> 00:09:35,843 line:0
我们要从测量开始时


194
00:09:35,909 --> 00:09:37,377 line:0
讲量化系列


195
00:09:37,878 --> 00:09:39,580 line:0
在这个情境中是指游戏开始


196
00:09:40,814 --> 00:09:43,150 line:0
然后我们将收到
来自传感器的测量数据


197
00:09:43,217 --> 00:09:45,052 line:0
我们可以把它们插入到
这个量化系列中


198
00:09:45,485 --> 00:09:47,654 line:0
我们继续从传感器中获取测量数据


199
00:09:47,721 --> 00:09:49,256 line:0
并继续把它们插入到量化系列中


200
00:09:49,690 --> 00:09:51,158 line:0
一直到游戏结束


201
00:09:52,593 --> 00:09:54,127 line:0
最后当我们完成测量后


202
00:09:54,194 --> 00:09:55,796 line:-1
我们就可以结束量化系列


203
00:09:55,863 --> 00:09:58,799 line:-1
并返回合计的量化系列样本


204
00:10:01,635 --> 00:10:02,903 line:-1
现在让我们看看代码


205
00:10:05,772 --> 00:10:07,975 line:-2
所有HealthKit交互的
第一步


206
00:10:08,509 --> 00:10:12,045 line:-2
都是请求
计划要读取的数据类型的授权


207
00:10:12,446 --> 00:10:15,182 line:-1
在这个例子中我们要请求心率的授权


208
00:10:16,083 --> 00:10:17,484 line:-1
一旦我们请求了授权


209
00:10:18,519 --> 00:10:21,555 line:-2
我们就可以通过healthStore
创建量化系列样本创建器


210
00:10:21,622 --> 00:10:22,589 line:-1
数据类型


211
00:10:22,956 --> 00:10:25,526 line:-1
开始测量的时间和可选的HK设备


212
00:10:27,895 --> 00:10:30,197 line:-2
然后 只要我们收到
来自传感器的测量数据


213
00:10:30,264 --> 00:10:32,966 line:-2
我们就可以把它们插入到
量化系列样本创建器中


214
00:10:33,734 --> 00:10:35,536 line:-1
最后在游戏结束时


215
00:10:35,903 --> 00:10:37,704 line:-1
我们可以完成量化系列样本创建器


216
00:10:38,405 --> 00:10:40,807 line:-1
通过可选的元数据和测量结束时间


217
00:10:42,910 --> 00:10:46,246 line:-2
现在我们已经了解
如何有效率地表达量化数据


218
00:10:46,313 --> 00:10:47,814 line:-2
并把它作为量化系列
保存到HealthKit中


219
00:10:48,315 --> 00:10:51,084 line:-2
我们还可以思考通过数据
可以给app带来哪些体验


220
00:10:51,151 --> 00:10:52,819 line:-2
一旦数据被保存到
HealthKit中


221
00:10:53,887 --> 00:10:57,457 line:-1
也许我们想让app能记录


222
00:10:57,524 --> 00:10:58,458 line:-1
除心率以外的卡路里信息


223
00:10:58,926 --> 00:11:02,262 line:-2
因此我们可以给用户显示在某个时间
间隔内他们总共燃烧了多少卡路里


224
00:11:02,329 --> 00:11:05,933 line:-1
或只呈现一些很漂亮的图表


225
00:11:06,233 --> 00:11:08,035 line:-1
突显数据并帮助他们将数据可视化


226
00:11:08,101 --> 00:11:09,102 line:-2
（量化数据的查询
所燃烧的卡路里总量）


227
00:11:09,169 --> 00:11:10,437 line:-1
或者我们想指出平均值


228
00:11:10,504 --> 00:11:12,339 line:-1
是在某一个时间段内记录的平均值


229
00:11:12,406 --> 00:11:13,373 line:-2
（图表的数据
每天所燃烧的平均卡路里数）


230
00:11:13,440 --> 00:11:14,341 line:-1
（最小和最大心率）


231
00:11:14,408 --> 00:11:16,610 line:-2
或帮助用户了解
他们在某个特定游戏中


232
00:11:16,677 --> 00:11:18,045 line:-1
所达到的最小和最大心率值


233
00:11:19,146 --> 00:11:22,983 line:-1
或我们只想保持UI活跃并在收到


234
00:11:23,050 --> 00:11:25,586 line:-2
来自传感器的数据时
更新所记录的新数据


235
00:11:25,652 --> 00:11:26,787 line:-1
（最新心率）


236
00:11:27,554 --> 00:11:30,958 line:-2
我们可以实现这个功能并做得更好
通过单一HealthKit查询


237
00:11:33,427 --> 00:11:35,162 line:-1
HKStatisticsCollectionQuery


238
00:11:36,597 --> 00:11:39,266 line:-2
很多人已经熟悉
StatisticsCollectionQuery了


239
00:11:39,833 --> 00:11:41,401 line:-1
它非常棒


240
00:11:41,468 --> 00:11:43,837 line:-1
因此我只想重申它的功能


241
00:11:44,872 --> 00:11:48,709 line:-2
StatisticsCollectionQuery
可以帮助你计算多个统计


242
00:11:49,109 --> 00:11:50,878 line:-1
可以通过资料来源分隔开


243
00:11:51,745 --> 00:11:54,014 line:-2
并且只要有新数据
保存到HealthKit中


244
00:11:54,081 --> 00:11:55,782 line:-1
你就可以收到那些统计的更新数据


245
00:11:55,849 --> 00:11:57,351 line:-2
（生产多个统计
每个源可用的统计）


246
00:11:57,417 --> 00:11:58,585 line:-1
如果那还不够


247
00:11:58,652 --> 00:12:01,154 line:-2
我们还更新了
StatisticsCollectionQuery


248
00:12:01,221 --> 00:12:03,590 line:-1
用于支持新的聚合类型


249
00:12:04,157 --> 00:12:07,394 line:-2
并自动包含
存储在量化系列样本中的


250
00:12:07,461 --> 00:12:08,762 line:-1
（支持全部聚合类型）


251
00:12:09,062 --> 00:12:10,864 line:-1
全部备份量化数据


252
00:12:10,931 --> 00:12:11,832 line:-1
（自动包含量化系列数据）


253
00:12:12,165 --> 00:12:15,202 line:-2
如果你想获得关于
StatisticsCollectionQuery


254
00:12:15,269 --> 00:12:16,403 line:-2
和HKStatistics的
更多信息


255
00:12:16,837 --> 00:12:18,839 line:-2
你可以参考关于
HealthKit的介绍


256
00:12:21,842 --> 00:12:23,544 line:-1
虽然StatisticsCollectionQuery


257
00:12:24,044 --> 00:12:27,181 line:-2
应该是我们的首选工具
用于有效率地


258
00:12:27,247 --> 00:12:28,482 line:-2
与保存在HealthKit中的
量化数据进行交互


259
00:12:29,616 --> 00:12:33,287 line:-1
有时我们真的想枚举


260
00:12:33,353 --> 00:12:34,688 line:-2
存储在量化系列中的
每一个单一量化数据


261
00:12:35,589 --> 00:12:38,192 line:-1
比如 如果我们想做一些比如绘制


262
00:12:38,458 --> 00:12:40,827 line:-1
用户玩游戏时


263
00:12:40,894 --> 00:12:41,895 line:-1
通过我们的app测量的每一个心率


264
00:12:43,096 --> 00:12:46,934 line:-2
我们可以通过
QuantitySeriesSampleQuery实现


265
00:12:48,068 --> 00:12:51,038 line:-2
在iOS 13中我们改进了
QuantitySeriesSampleQuery


266
00:12:51,104 --> 00:12:54,374 line:-2
通过把NSPredicate中的
量化样本参数


267
00:12:54,842 --> 00:12:56,210 line:-1
替换为量化类型


268
00:12:58,111 --> 00:13:01,982 line:-2
现在不再简单地枚举
单一量化样本的量化数据


269
00:13:02,282 --> 00:13:04,351 line:-1
而是枚举多个量化样本


270
00:13:04,418 --> 00:13:05,886 line:-1
及其全部备份量化数据


271
00:13:07,521 --> 00:13:10,457 line:-1
我们还把时间参数升级为时间间隔


272
00:13:10,524 --> 00:13:12,893 line:-2
从而你可以在每个单一量化数据
被枚举时


273
00:13:12,960 --> 00:13:13,861 line:-1
获得它的完整时间间隔


274
00:13:14,828 --> 00:13:17,364 line:-1
我们还有一个可选的量化样本参数


275
00:13:17,664 --> 00:13:21,401 line:-1
可以提供当前被枚举的量化系列样本


276
00:13:24,371 --> 00:13:26,139 line:-2
这个查询通过可视化数据
做出了最好的表达


277
00:13:26,440 --> 00:13:27,574 line:0
因此我要给你们展示一下


278
00:13:28,442 --> 00:13:30,444 line:-1
在这里我们有两个量化系列样本


279
00:13:31,111 --> 00:13:32,646 line:-1
第一个量化系列样本


280
00:13:32,713 --> 00:13:35,415 line:0
包含由嵌入到
我们的视频游戏控制器中的


281
00:13:35,482 --> 00:13:36,917 line:0
心率传感器测量的量化数据


282
00:13:38,218 --> 00:13:41,522 line:0
第二个量化系列包含
由Apple Watch测量的量化数据


283
00:13:42,189 --> 00:13:45,092 line:0
因为我们的用户恰好同时
使用这两个设备


284
00:13:45,859 --> 00:13:47,728 line:0
这两个量化系列适时地相互重叠


285
00:13:48,996 --> 00:13:51,131 line:0
默认情况下
QuantitySeriesSampleQuery


286
00:13:51,198 --> 00:13:52,866 line:0
将以量化数据的开始时间为顺序


287
00:13:53,267 --> 00:13:56,303 line:0
枚举来自这两个量化系列的
全部量化数据


288
00:13:56,670 --> 00:13:57,604 line:-1
就像这样


289
00:13:58,338 --> 00:14:00,507 line:0
请注意在量化系列的末端


290
00:14:01,875 --> 00:14:03,210 line:-1
完成参数被设为真


291
00:14:05,312 --> 00:14:08,882 line:0
如果你需要获取
量化系列样本自身的参数


292
00:14:08,949 --> 00:14:11,552 line:-2
比如设备信息、来源、版本号
或元数据


293
00:14:11,919 --> 00:14:15,489 line:0
你可以在执行查询之前
把包含样本设置为真


294
00:14:16,156 --> 00:14:19,126 line:-2
请注意 在这个例子中
当枚举这些量化系列时


295
00:14:19,760 --> 00:14:23,197 line:-2
你可以在量化数据处理器中
获取相应的量化系列样本


296
00:14:26,967 --> 00:14:29,303 line:-1
现在我们已经了解如何使用量化系列


297
00:14:29,369 --> 00:14:31,171 line:-1
与量化数据进行有效地交互


298
00:14:31,238 --> 00:14:33,540 line:-1
我想告诉你们在游戏中添加


299
00:14:33,807 --> 00:14:35,976 line:-2
我们在本场演讲中所讲到的这种支持
有多么简单


300
00:14:36,677 --> 00:14:39,046 line:-2
跟着我一起进入Xcode
我会给你做一个简短的演示


301
00:14:44,484 --> 00:14:47,588 line:-1
这是游戏现在的形式


302
00:14:48,789 --> 00:14:50,891 line:-1
我实际上没有


303
00:14:50,958 --> 00:14:52,826 line:-2
嵌入到视频游戏控制器中的
心率传感器


304
00:14:52,893 --> 00:14:55,195 line:-2
但如果有人想做一个
稍后请给我打电话


305
00:14:56,330 --> 00:14:58,131 line:-1
但我有另一个外部心率传感器


306
00:14:58,198 --> 00:15:00,501 line:-1
我可以用来获取信息


307
00:15:01,034 --> 00:15:02,703 line:-1
请记住量化系列


308
00:15:02,769 --> 00:15:04,438 line:-1
可适用于任意量化类型


309
00:15:04,505 --> 00:15:05,506 line:-1
而不只是心率


310
00:15:05,839 --> 00:15:07,808 line:-1
并且数据可以来自于外部传感器、


311
00:15:07,875 --> 00:15:10,110 line:-1
外部数据库、磁盘上的文件


312
00:15:10,544 --> 00:15:13,046 line:-1
或由app直接输入


313
00:15:14,381 --> 00:15:15,916 line:-1
这个游戏有两个标签


314
00:15:16,917 --> 00:15:19,319 line:-2
第一个是Play标签 它会提出
PlayViewController


315
00:15:19,386 --> 00:15:20,387 line:-1
我们可以开始游戏


316
00:15:21,221 --> 00:15:23,090 line:-1
第二个标签是上一次游戏标签


317
00:15:23,156 --> 00:15:24,858 line:-2
它会提出
ResultsViewController


318
00:15:24,925 --> 00:15:26,527 line:-1
显示在上一次玩游戏时


319
00:15:26,593 --> 00:15:28,128 line:-1
所测量的心率


320
00:15:31,198 --> 00:15:33,000 line:-2
我要继续并切换回
PlayViewController


321
00:15:33,066 --> 00:15:35,068 line:-1
给你演示一局游戏该怎么玩


322
00:15:37,437 --> 00:15:39,473 line:-1
在这个游戏中我要击中热狗


323
00:15:39,540 --> 00:15:40,607 line:-1
而放过西兰花


324
00:15:41,141 --> 00:15:42,876 line:-2
也许对于健康类app来说
有点落伍了


325
00:15:43,477 --> 00:15:44,378 line:-1
但是我只有这个


326
00:15:45,479 --> 00:15:47,981 line:-1
每收获一个热狗就增加一分


327
00:15:48,048 --> 00:15:50,317 line:-1
当我玩游戏时 我的心率会增加


328
00:15:51,652 --> 00:15:52,719 line:-1
如果我切换回上一次游戏标签


329
00:15:52,786 --> 00:15:54,788 line:-1
我可以看到我还没有收到


330
00:15:54,855 --> 00:15:56,390 line:-2
在玩刚才的游戏时
所测量的任何心率数据


331
00:15:56,857 --> 00:15:58,458 line:-1
现在我们想给app添加那个支持


332
00:15:59,626 --> 00:16:01,328 line:-1
我们的第一步是…


333
00:16:01,962 --> 00:16:03,830 line:-1
让app请求授权


334
00:16:03,897 --> 00:16:05,232 line:-1
就像我们在PPT中所看到的那样


335
00:16:06,099 --> 00:16:09,636 line:-1
因为app总是会在用户玩游戏时


336
00:16:09,703 --> 00:16:10,671 line:-1
读写心率数据


337
00:16:10,737 --> 00:16:12,773 line:-1
我希望只要app启动完毕


338
00:16:13,774 --> 00:16:15,275 line:-1
就请求授权


339
00:16:15,342 --> 00:16:17,110 line:-1
那么我要在app中添加这个


340
00:16:17,177 --> 00:16:19,446 line:-2
在app委托中添加
didFinishLaunchingWithOptions


341
00:16:22,883 --> 00:16:24,117 line:-1
在这里我正在请求…


342
00:16:24,484 --> 00:16:27,554 line:-2
我正在创建一组专用于心率的
量化类型


343
00:16:28,021 --> 00:16:30,891 line:-2
我可以在
HK healthStore内


344
00:16:30,958 --> 00:16:32,025 line:-1
请求这些样本类型的授权


345
00:16:33,727 --> 00:16:35,229 line:-1
请求授权后


346
00:16:35,295 --> 00:16:37,030 line:-1
我们会获取来自传感器的测量数据


347
00:16:37,097 --> 00:16:39,032 line:-1
并把那个数据保存到量化系列中


348
00:16:40,200 --> 00:16:42,703 line:-1
我已经创建了一个类


349
00:16:43,103 --> 00:16:44,137 line:-1
用于压缩对外部传感器的连接


350
00:16:44,204 --> 00:16:45,606 line:-1
并且如果你想了解它是如何运作的


351
00:16:45,672 --> 00:16:48,375 line:-1
请参考与本场演讲相关联的示例项目


352
00:16:49,910 --> 00:16:51,979 line:-2
我现在要转到
PlayViewController


353
00:16:52,246 --> 00:16:54,648 line:-1
因为我们想添加连接


354
00:16:54,948 --> 00:16:56,116 line:-1
用于记录用户玩游戏时的心率


355
00:16:56,850 --> 00:16:58,085 line:-1
我要打开项目导航器


356
00:16:58,151 --> 00:16:59,887 line:-2
转到
PlayViewController


357
00:17:01,321 --> 00:17:03,490 line:-2
在PlayViewController中
有一个startNewGame函数


358
00:17:03,557 --> 00:17:06,260 line:-2
每当按下app中的开始游戏按钮时
就调用它


359
00:17:06,926 --> 00:17:08,896 line:-1
这里正适合我们创建


360
00:17:08,962 --> 00:17:10,163 line:-1
对外部心率传感器的连接


361
00:17:10,464 --> 00:17:12,199 line:-1
并开始量化系列…


362
00:17:12,266 --> 00:17:13,733 line:-1
量化系列样本创建器


363
00:17:14,601 --> 00:17:16,603 line:-1
首先我要创建对传感器的连接


364
00:17:20,574 --> 00:17:23,143 line:-2
HeartSensorSession
是我刚才提到过的那个类


365
00:17:23,210 --> 00:17:25,512 line:-1
它会压缩对传感器的连接


366
00:17:25,811 --> 00:17:27,580 line:-1
我把PlayViewController自身


367
00:17:27,915 --> 00:17:29,650 line:-1
作为HeartSensorSession的委托


368
00:17:31,051 --> 00:17:34,154 line:-2
现在我可以开始
心率的量化系列样本创建器了


369
00:17:37,057 --> 00:17:39,059 line:-2
在这里我创建了一个
量化系列样本创建器


370
00:17:39,126 --> 00:17:40,994 line:-2
healthStore
存储心率类型


371
00:17:41,328 --> 00:17:42,996 line:-1
测量的开始时间为当前时间


372
00:17:43,497 --> 00:17:46,600 line:-2
我要从HeartSensorSession中
获取HK设备信息


373
00:17:47,734 --> 00:17:50,304 line:-2
HeartSensorSession
通过它的委托协议


374
00:17:50,370 --> 00:17:52,339 line:-1
与PlayViewController通讯


375
00:17:53,273 --> 00:17:54,374 line:-1
HeartSensorSessionDelegate


376
00:17:54,675 --> 00:17:56,043 line:-1
有以下两个方法：


377
00:17:56,643 --> 00:17:58,745 line:-2
sessionDidReceiveHeartRate
和sessionDidEnd


378
00:18:00,047 --> 00:18:02,049 line:-2
通过sessionDidEnd…
DidReceiveHeartRate


379
00:18:02,316 --> 00:18:05,919 line:-2
HeartSensorSession
给它的委托提供心率测量数据


380
00:18:06,253 --> 00:18:08,088 line:-1
这正是我们获取测量数据的好地方


381
00:18:08,155 --> 00:18:10,324 line:-2
并且把它们插入到
量化系列样本创建器中


382
00:18:16,930 --> 00:18:18,999 line:-2
在这里我把从HeartSensorSession中
接收的心率


383
00:18:19,066 --> 00:18:21,368 line:-1
和时间间隔插入到


384
00:18:21,435 --> 00:18:22,903 line:-1
量化系列样本创建器中


385
00:18:24,805 --> 00:18:28,509 line:-2
最后当游戏结束时
HeartSensorSession结束时


386
00:18:28,876 --> 00:18:30,878 line:-2
由HeartSensorSession调用
sessionDidEnd


387
00:18:31,578 --> 00:18:34,481 line:-2
这是我们结束量化系列样本创建器的
完美场所


388
00:18:34,781 --> 00:18:38,018 line:-2
从而存留我们插入到HealthKit中的
心率量化数据


389
00:18:38,785 --> 00:18:40,754 line:-1
我们还可以关联


390
00:18:40,821 --> 00:18:42,322 line:-1
用元数据所创建的量化系列


391
00:18:42,723 --> 00:18:44,525 line:-1
在这个例子中 我要使用元数据


392
00:18:44,591 --> 00:18:47,828 line:-2
把这些心率与我们刚刚玩的
游戏会话关联起来


393
00:18:47,895 --> 00:18:49,830 line:-1
从而在ResultsViewController中


394
00:18:49,897 --> 00:18:53,000 line:-2
我们可以查询
与上一次游戏所关联的心率


395
00:18:57,905 --> 00:19:01,975 line:-2
在这里我要使用MetadataKey
ExternalUUID创建元数据词典


396
00:19:02,543 --> 00:19:04,845 line:-2
我在心率传感器的UUID字符串中
设置了MetadataKeyExternalUUID


397
00:19:05,646 --> 00:19:07,881 line:-1
我终于完成了量化系列


398
00:19:07,948 --> 00:19:09,983 line:-1
通过元数据


399
00:19:10,050 --> 00:19:11,718 line:-2
和从HeartSensorSession中
接收的结束测量的时间


400
00:19:14,154 --> 00:19:16,590 line:-2
现在我们已经把心率数据
保存到HealthKit中


401
00:19:16,890 --> 00:19:19,927 line:-1
我们想…


402
00:19:19,993 --> 00:19:21,128 line:-2
我们想在ResultsViewController中
给用户显示数据


403
00:19:21,195 --> 00:19:22,863 line:-2
那么让我们现在转到
ResultsViewController


404
00:19:28,969 --> 00:19:31,171 line:-2
在ResultsViewController
viewDidLoad函数中


405
00:19:31,238 --> 00:19:32,272 line:-1
我有一个应用函数


406
00:19:32,773 --> 00:19:33,941 line:-1
loadHeartRateQuanitites


407
00:19:34,274 --> 00:19:36,009 line:-1
它会查询


408
00:19:36,076 --> 00:19:38,278 line:-1
与上一次游戏会话相关联的心率数据


409
00:19:38,745 --> 00:19:41,982 line:-2
并在表视图中生成一个
可以显示出来的


410
00:19:42,049 --> 00:19:43,483 line:-1
每个量化数据的字符串表达


411
00:19:44,918 --> 00:19:49,089 line:-1
让我们继续并从添加量化系列样本


412
00:19:49,156 --> 00:19:51,658 line:-2
使其查询
与上一次游戏相关联的心率开始


413
00:19:51,725 --> 00:19:52,759 line:-1
如果玩过游戏的话


414
00:19:56,463 --> 00:19:59,166 line:-2
在这里要防范
没有玩过游戏的情况


415
00:20:00,367 --> 00:20:01,802 line:-1
如果我们有一个游戏识别器


416
00:20:01,869 --> 00:20:04,371 line:-1
我们可以继续并使用游戏识别器


417
00:20:04,438 --> 00:20:08,075 line:-2
为MetadataExternalKeyUUID
创建一个查询谓词


418
00:20:08,642 --> 00:20:10,177 line:-1
请记住 我们使用了这个元数据


419
00:20:10,244 --> 00:20:12,713 line:-1
从而稍后可以进行查询


420
00:20:12,779 --> 00:20:14,381 line:-1
与上一次游戏相关联的心率数据


421
00:20:16,717 --> 00:20:19,052 line:-1
然后我可以创建量化系列样本


422
00:20:19,119 --> 00:20:21,421 line:-2
使用我们上边创建的谓词
查询心率类型


423
00:20:22,890 --> 00:20:24,324 line:-1
在查询处理器内


424
00:20:24,391 --> 00:20:26,693 line:-1
我要枚举


425
00:20:26,760 --> 00:20:27,961 line:-2
与这个上一次游戏相关联的
量化数据和时间间隔


426
00:20:29,029 --> 00:20:31,465 line:-1
并且我要为每一个


427
00:20:31,532 --> 00:20:32,900 line:-1
都创建一个字符串表达


428
00:20:33,333 --> 00:20:35,102 line:-1
让我们继续并创建一组字符串


429
00:20:35,169 --> 00:20:38,005 line:-1
用于存储这些结果字符串


430
00:20:41,508 --> 00:20:44,545 line:-1
然后我们可以把它用在查询处理器中


431
00:20:48,248 --> 00:20:49,816 line:-1
首先我要防范枚举过程中


432
00:20:49,883 --> 00:20:51,919 line:-1
可能会返回的错误


433
00:20:52,553 --> 00:20:53,787 line:-1
如果没有任何错误


434
00:20:53,854 --> 00:20:56,323 line:-2
我就可以继续并使用
所枚举的量化数据


435
00:20:56,623 --> 00:20:58,892 line:-2
和时间间隔创建一个
heartRateDetailsStrings


436
00:20:59,359 --> 00:21:01,094 line:-1
并且我要把这些详情字符串分配给


437
00:21:01,161 --> 00:21:02,529 line:-2
heartRateStrings
数组


438
00:21:03,597 --> 00:21:06,300 line:-1
最后当枚举完成后


439
00:21:06,366 --> 00:21:07,935 line:-1
完成参数将被设为真


440
00:21:08,368 --> 00:21:11,338 line:-1
这正是取回主队列的好地方


441
00:21:11,638 --> 00:21:14,641 line:-2
从而重新加载ResultsViewController
以显示这些字符串


442
00:21:16,977 --> 00:21:19,613 line:-2
现在我想重新运行app
让你看看它现在看起来怎么样


443
00:21:19,680 --> 00:21:22,649 line:-2
现在我们已经添加了
对读写心率数据的支持


444
00:21:24,051 --> 00:21:26,520 line:-2
请记住 当app启动时
我们看到的第一件事


445
00:21:26,587 --> 00:21:27,955 line:-1
将是请求授权


446
00:21:30,891 --> 00:21:32,793 line:-1
我要继续并打开授权


447
00:21:33,160 --> 00:21:34,294 line:-1
从而读写心率数据


448
00:21:35,796 --> 00:21:37,431 line:-1
现在我要再玩一局游戏


449
00:21:39,032 --> 00:21:41,301 line:-1
请记住 我要击中热狗而放过西兰花


450
00:21:41,902 --> 00:21:43,770 line:-1
哦 零分 再来一局


451
00:21:49,476 --> 00:21:52,045 line:-1
哦 两分 但我仍可以看到心率如何


452
00:21:52,746 --> 00:21:53,714 line:-1
好了


453
00:21:53,780 --> 00:21:56,550 line:-2
我们拥有了一些心率数据
是在刚玩的那局游戏中测量的


454
00:22:03,524 --> 00:22:04,992 line:-2
（演示
读写量化系列）


455
00:22:05,392 --> 00:22:08,662 line:-2
刚才我们了解的是
如何通过量化系列样本创建器


456
00:22:09,296 --> 00:22:11,632 line:-1
有效率地保存量化数据


457
00:22:12,299 --> 00:22:15,702 line:-2
以及如何使用QuantitySeries
SampleQuery对其进行查询


458
00:22:16,603 --> 00:22:18,906 line:-2
现在我要邀请我的同事
Divya上台来


459
00:22:19,273 --> 00:22:22,743 line:-2
她会讲HealthKit
如何在心率方面


460
00:22:22,809 --> 00:22:24,178 line:-1
对表达进行了扩展


461
00:22:24,444 --> 00:22:26,513 line:-2
以及我们如何迁入到
全新的听力健康的健康域


462
00:22:26,580 --> 00:22:28,215 line:-1
谢谢大家


463
00:22:35,389 --> 00:22:37,424 line:-1
那么我的同事Luke刚给你们讲了


464
00:22:37,491 --> 00:22:41,595 line:-2
在iOS 13中存储HK
量化数据的有效率的新方式


465
00:22:42,496 --> 00:22:45,866 line:-2
并且HealthKit
越来越多地成为了一个


466
00:22:45,933 --> 00:22:47,634 line:-1
保存用户每日健康数据的仓库


467
00:22:48,468 --> 00:22:51,038 line:-1
除了存储越来越多的数据


468
00:22:51,305 --> 00:22:53,207 line:-1
我们还存储各种各样的数据


469
00:22:54,174 --> 00:22:57,578 line:-2
今年 我们在现有的支持中
添加了听力健康


470
00:22:57,644 --> 00:22:59,479 line:-1
并对听力健康添加了新支持


471
00:22:59,780 --> 00:23:01,248 line:-2
（新的健康类型
心脏和听力健康）


472
00:23:01,915 --> 00:23:06,086 line:-2
我们的用户自iOS 8起
就与心脏相关的功能进行交互


473
00:23:06,687 --> 00:23:09,056 line:-2
他们可以从
Apple Watch获取心率


474
00:23:09,356 --> 00:23:13,460 line:-2
或从由你们开发人员创建的
连接到传感器的app中获取心率


475
00:23:13,861 --> 00:23:16,163 line:-1
并在健康app中浏览全部数据


476
00:23:18,432 --> 00:23:20,901 line:0
HealthKit一直支持心率


477
00:23:21,568 --> 00:23:24,071 line:0
因此如果你的心率读数是这个


478
00:23:24,538 --> 00:23:27,241 line:0
你可以决定在五秒内


479
00:23:27,774 --> 00:23:30,978 line:0
平均心率是每分钟68次


480
00:23:32,112 --> 00:23:35,282 line:-2
并且在HealthKit中
你可以把它作为HK量化样本保存


481
00:23:37,918 --> 00:23:41,722 line:0
在iOS 11中
我们引入了心率变量SDNN


482
00:23:41,788 --> 00:23:42,623 line:0
（心率变量SDNN）


483
00:23:42,689 --> 00:23:45,692 line:0
心率变量是心跳和心跳之间


484
00:23:45,759 --> 00:23:47,995 line:0
在时间间隔内的测量的变化


485
00:23:48,529 --> 00:23:51,732 line:0
并且SDNN代表的是
正常心跳间隔的标准差


486
00:23:52,699 --> 00:23:55,435 line:0
因此Apple Watch
可以获取同样的心率读数


487
00:23:56,236 --> 00:23:58,739 line:0
并获取每次心跳之间的时间间隔


488
00:23:59,339 --> 00:24:01,241 line:0
来计算一个标准差


489
00:24:01,308 --> 00:24:03,977 line:-2
并把它作为量化样本
保存到HealthKit中


490
00:24:05,179 --> 00:24:07,014 line:-1
心率和心率变量


491
00:24:07,080 --> 00:24:10,517 line:-2
对于心血管健康来说
都是非常重要的度量


492
00:24:10,984 --> 00:24:13,620 line:-2
并且用户们也喜欢看一眼
就能了解这些信息


493
00:24:13,687 --> 00:24:15,756 line:-1
在日常工作生活中或更具体地


494
00:24:15,822 --> 00:24:16,890 line:-1
比如当他们健身时


495
00:24:19,026 --> 00:24:21,395 line:-1
那么让我们再看一次


496
00:24:21,461 --> 00:24:22,296 line:-1
这同一个心率读数


497
00:24:22,930 --> 00:24:26,633 line:-1
目前 我描述了我们可以总结


498
00:24:26,700 --> 00:24:27,734 line:-1
这个心率数据的方式


499
00:24:28,235 --> 00:24:31,171 line:-1
但有时候你想获得真实的底层数据


500
00:24:32,072 --> 00:24:34,308 line:0
那么假如我想获得时间…


501
00:24:34,775 --> 00:24:36,944 line:0
了解每次心跳所发生的时间


502
00:24:37,711 --> 00:24:39,546 line:0
返回到我们的情境中


503
00:24:39,880 --> 00:24:42,416 line:0
假如我们的游戏控制器有一个传感器


504
00:24:42,482 --> 00:24:45,419 line:0
可以在用户在玩游戏时


505
00:24:45,686 --> 00:24:46,854 line:0
有新的心跳进入时告诉我们


506
00:24:47,721 --> 00:24:51,158 line:0
那么在这里 第一次心跳发生在


507
00:24:51,558 --> 00:24:53,160 line:0
从数据收集开始的起始点
之后的0.5秒


508
00:24:53,594 --> 00:24:56,063 line:0
第二次发生在第1.49秒


509
00:24:56,430 --> 00:24:59,132 line:0
并且我们可以得到——
我们可以继续获得


510
00:24:59,399 --> 00:25:01,869 line:0
自数据收集开始起
这些心跳发生的其余的时间点


511
00:25:02,936 --> 00:25:06,273 line:0
那么你可以注意到
每次心跳都发生在一定的时间点


512
00:25:06,607 --> 00:25:09,643 line:0
把它们放在一起就组成了
一系列的心跳


513
00:25:10,511 --> 00:25:12,246 line:0
要把这个数据
保存到HealthKit中


514
00:25:12,513 --> 00:25:15,182 line:-2
我们有一个
HKHeartbeatSeriesSample


515
00:25:15,582 --> 00:25:18,385 line:-1
它会按照心跳发生的时间戳


516
00:25:18,452 --> 00:25:19,319 line:-1
来保存一系列的心跳


517
00:25:20,587 --> 00:25:24,091 line:-1
现在你可能注意到


518
00:25:24,157 --> 00:25:25,459 line:-2
这与Luke之前讲过的系列API
感觉很相似


519
00:25:26,260 --> 00:25:29,363 line:-2
但有一个重点需要注意
即心跳系列样本


520
00:25:29,429 --> 00:25:31,565 line:-1
压缩衍生自HealthKit中


521
00:25:31,632 --> 00:25:34,301 line:-1
其它样本类型的数据类型


522
00:25:35,068 --> 00:25:38,472 line:-1
没有值或单位 比如HK量化数据


523
00:25:38,539 --> 00:25:41,241 line:-1
它是量化系列背后的底层数据


524
00:25:41,675 --> 00:25:45,779 line:-2
因此我们可以更有效地
保存一系列时间戳


525
00:25:46,113 --> 00:25:47,614 line:-1
来表达一个心跳系列


526
00:25:47,681 --> 00:25:49,116 line:-2
（健康系列VS量化系列
没有值或单位 比如HK量化数据）


527
00:25:49,183 --> 00:25:50,117 line:-1
（一系列时间戳）


528
00:25:50,184 --> 00:25:52,819 line:-1
但因为我们仍然存储一系列数据


529
00:25:52,886 --> 00:25:55,455 line:-1
那可能会非常大 我们有…


530
00:25:55,522 --> 00:25:59,560 line:-1
我们设计了API来熟悉量化系列


531
00:26:00,394 --> 00:26:02,796 line:-2
因此我们配备了这个
HeartbeatSeriesSample


532
00:26:02,863 --> 00:26:04,698 line:-1
有它自己的创建器和自定义查询


533
00:26:07,000 --> 00:26:08,435 line:-1
与量化系列样本一样


534
00:26:08,702 --> 00:26:11,305 line:-1
心跳系列样本也是由创建器所创建


535
00:26:11,371 --> 00:26:12,873 line:-1
并当你完成保存数据后结束


536
00:26:13,740 --> 00:26:14,908 line:-1
那么让我们用代码来创建一个


537
00:26:16,510 --> 00:26:18,011 line:-1
第一步一如既往


538
00:26:18,078 --> 00:26:20,180 line:-1
是请求恰当的授权


539
00:26:21,114 --> 00:26:24,585 line:-2
对于这个例子
你需要请求新的心跳系列类型


540
00:26:24,918 --> 00:26:28,322 line:-1
以及我们从iOS 11中


541
00:26:28,388 --> 00:26:29,990 line:-2
重新引入的量化类型
heartRateVariabilitySDNN


542
00:26:30,891 --> 00:26:32,593 line:-1
你需要请求


543
00:26:32,659 --> 00:26:33,927 line:-1
这两种类型的授权


544
00:26:33,994 --> 00:26:37,464 line:-1
因为心率变量是一个


545
00:26:37,731 --> 00:26:39,099 line:-1
可直接衍生自心跳系列的度量


546
00:26:39,166 --> 00:26:41,635 line:-1
这样你的用户就清楚地了解


547
00:26:41,702 --> 00:26:43,937 line:-1
他们到底与你分享了哪种数据


548
00:26:45,472 --> 00:26:47,407 line:-1
一旦我们请求了授权


549
00:26:47,474 --> 00:26:51,078 line:-2
我们可通过heathStore、
gameDevice


550
00:26:51,144 --> 00:26:52,913 line:-2
和gameStartDate
初始化一个心跳系列创建器


551
00:26:52,980 --> 00:26:55,282 line:-1
那会表明何时开始数据收集


552
00:26:56,950 --> 00:27:00,053 line:-2
当游戏正在进行时
并且当用户正在玩游戏时


553
00:27:00,454 --> 00:27:02,489 line:-2
我们将向创建器中添加
带有时间间隔的心跳


554
00:27:02,556 --> 00:27:04,558 line:-1
自系列开始的时间起


555
00:27:06,627 --> 00:27:08,662 line:0
但你可能会遇到这样的情况


556
00:27:08,929 --> 00:27:12,699 line:0
传感器当掉了
在这里有一个数据收集的缺口


557
00:27:12,766 --> 00:27:14,334 line:-1
在第二秒和第三秒之间


558
00:27:15,369 --> 00:27:18,572 line:0
现在看起来
在第二个和第三个心跳之间


559
00:27:18,639 --> 00:27:20,174 line:0
有一个1.99秒的缺口


560
00:27:20,240 --> 00:27:24,311 line:0
那会导致
对用户的心跳数据的错误翻译


561
00:27:25,579 --> 00:27:26,980 line:-1
考虑到这个问题


562
00:27:27,047 --> 00:27:29,149 line:-2
我们要把
precededByGap设为是


563
00:27:29,416 --> 00:27:31,718 line:-2
你可以对你所添加的每一个心跳
进行设置


564
00:27:31,785 --> 00:27:34,221 line:-1
如果你注意到数据收集中


565
00:27:34,288 --> 00:27:35,455 line:-1
由于传感器当掉而存在缺口的话


566
00:27:37,724 --> 00:27:41,929 line:-2
现在我可以在创建器中添加元数据
与其它HK样本中的操作一样


567
00:27:43,063 --> 00:27:44,831 line:-1
当我完成数据保存之后


568
00:27:44,898 --> 00:27:48,869 line:-2
我会结束系列 那将把心跳系列样本
保存到HealthKit中


569
00:27:51,305 --> 00:27:54,775 line:-2
现在我已经在游戏中添加了
对逐拍测量的支持


570
00:27:54,842 --> 00:27:58,045 line:-2
并且我们已经准备好开始查询
底层心跳测量数据了


571
00:28:00,480 --> 00:28:02,683 line:-1
跟Luke之前讲过的一样


572
00:28:02,749 --> 00:28:05,719 line:-1
我们可以与标准的HK查询进行交互


573
00:28:06,086 --> 00:28:10,490 line:-2
以获取高层及样本
然后使用自定义查询


574
00:28:10,557 --> 00:28:12,159 line:-1
与更精细的数据进行交互


575
00:28:13,627 --> 00:28:17,164 line:-2
那么我的第一步就是
运行一个标准的HK样本查询


576
00:28:17,231 --> 00:28:19,499 line:-1
以获取我感兴趣的心跳系列样本


577
00:28:20,834 --> 00:28:21,835 line:-1
一旦完成


578
00:28:21,902 --> 00:28:24,738 line:-1
我将用那个样本初始化心跳系列查询


579
00:28:25,005 --> 00:28:27,908 line:-1
那会让我随时间枚举每一次心跳


580
00:28:29,977 --> 00:28:31,612 line:-1
最后我要执行查询


581
00:28:34,014 --> 00:28:36,917 line:-2
心跳系列对HealthKit来说
是个新添加的强大功能


582
00:28:36,984 --> 00:28:39,620 line:-2
但这并不是我们拥有的
与心脏相关的全部功能


583
00:28:40,754 --> 00:28:42,122 line:-1
自iOS 12起


584
00:28:42,189 --> 00:28:45,092 line:-2
Apple Watch
就开始通过心脏警告通知用户


585
00:28:46,426 --> 00:28:50,197 line:-2
当Apple Watch
检测到心率


586
00:28:50,264 --> 00:28:52,199 line:-2
低于指定BPM临界值时
会发出低心率警告


587
00:28:52,266 --> 00:28:53,100 line:-1
（心率事件）


588
00:28:53,166 --> 00:28:55,536 line:-1
当心率高于指定BPM临界值时


589
00:28:55,602 --> 00:28:57,471 line:-1
发出高心率警告


590
00:28:58,639 --> 00:29:01,241 line:-2
当Apple Watch检测到
可能象征房颤的节律时


591
00:29:01,308 --> 00:29:04,011 line:-1
发出心律不齐警告


592
00:29:05,879 --> 00:29:06,980 line:-1
嗯 在HealthKit中


593
00:29:07,047 --> 00:29:10,317 line:-1
这些警告的形式是三个新的类别类型


594
00:29:10,817 --> 00:29:14,354 line:-2
当Apple Watch检测到警告时
将被保存到HealthKit中


595
00:29:17,090 --> 00:29:19,359 line:-1
除了全部这些强大的心脏支持


596
00:29:19,660 --> 00:29:23,397 line:-2
我们在iOS 13中
还披露了这个新区域


597
00:29:24,131 --> 00:29:27,467 line:-1
我非常激动地与你们一起分享


598
00:29:27,534 --> 00:29:28,669 line:-2
听力健康在HealthKit中
找到了一席之地


599
00:29:28,735 --> 00:29:29,970 line:-1
（听力健康）


600
00:29:30,237 --> 00:29:31,605 line:-1
在你生命中的某个时间点


601
00:29:31,672 --> 00:29:33,574 line:-1
你可能记得做过听力测试


602
00:29:33,841 --> 00:29:35,676 line:-1
戴上耳机


603
00:29:36,043 --> 00:29:39,713 line:-1
并听一系列的声音


604
00:29:39,780 --> 00:29:41,949 line:-2
当某个声音大到你能听到它时
就举起手


605
00:29:42,883 --> 00:29:45,485 line:-1
嗯 这是纯音听力测试的一个例子


606
00:29:45,886 --> 00:29:48,422 line:-1
纯音是指一个具有单一频率的声音


607
00:29:50,724 --> 00:29:53,794 line:-1
纯音测试可以帮助识别


608
00:29:53,861 --> 00:29:56,129 line:-2
在一组频率不同的声音中
你所能听到的最轻的声音


609
00:29:56,196 --> 00:29:57,231 line:-1
（纯音测试）


610
00:29:57,297 --> 00:30:00,133 line:-1
并且它可以提供你可能具有的


611
00:30:00,200 --> 00:30:01,468 line:-1
听觉障碍或听力丧失的评估


612
00:30:03,036 --> 00:30:04,972 line:-1
纯音测试的结果


613
00:30:05,038 --> 00:30:08,175 line:-2
最常见的是显示在一个叫做
听力图的图表上


614
00:30:10,077 --> 00:30:12,346 line:-1
这是一个有轻微听觉障碍的人的


615
00:30:12,412 --> 00:30:14,748 line:-1
听力图的示例


616
00:30:15,382 --> 00:30:18,418 line:-1
让我们放大这个图表 更清楚地了解


617
00:30:18,485 --> 00:30:21,021 line:-1
听力图中所储存的数据


618
00:30:22,723 --> 00:30:24,324 line:0
那么在这里你可以看到两条线


619
00:30:24,758 --> 00:30:28,629 line:0
一条对应于左耳的纯音测试结果


620
00:30:28,896 --> 00:30:29,997 line:0
另一条对应的是右耳


621
00:30:30,531 --> 00:30:32,533 line:0
让我们先来看看


622
00:30:32,599 --> 00:30:34,034 line:0
位于125赫兹线上的前两个数据值


623
00:30:35,469 --> 00:30:39,907 line:0
这表示对于这个用户来说
要听到125赫兹频率的声音


624
00:30:40,274 --> 00:30:43,810 line:0
他们的左耳需要大概
11分贝听力单位


625
00:30:44,111 --> 00:30:45,279 line:0
而右耳需要31分贝


626
00:30:46,246 --> 00:30:49,550 line:0
分贝听力单位测量的是


627
00:30:49,917 --> 00:30:52,920 line:0
相对于一个年轻、健康的个体
所能听到的最轻的声音


628
00:30:52,986 --> 00:30:53,954 line:0
所能听到的声音的密度


629
00:30:55,222 --> 00:30:57,558 line:0
因此我们可以获得


630
00:30:57,624 --> 00:30:59,159 line:0
与这个听力图相关联的其余数据值


631
00:30:59,626 --> 00:31:01,862 line:0
为了把这个数据存储到
HealthKit中


632
00:31:02,129 --> 00:31:06,500 line:-1
我们引入了 它会存储一组


633
00:31:06,567 --> 00:31:09,536 line:-1
与听力测试相关联的听力敏度值


634
00:31:10,337 --> 00:31:12,472 line:-1
那么让我们创建听力图样本和代码


635
00:31:14,408 --> 00:31:18,145 line:-2
第一步是创建
HKAudiogramSensitivityPoint


636
00:31:18,579 --> 00:31:20,814 line:-1
压缩双耳所能听到的


637
00:31:20,881 --> 00:31:23,717 line:-1
指定频率的声音的密度


638
00:31:24,718 --> 00:31:29,556 line:-2
那么我要用新的HK单位赫兹单位
来创建频率量化数据


639
00:31:30,257 --> 00:31:32,726 line:-1
并用新的分贝听力单位来创建


640
00:31:32,793 --> 00:31:34,728 line:-1
左耳和右耳敏度量化数据


641
00:31:36,230 --> 00:31:38,832 line:-2
现在我已经准备好
创建听力图敏度值了


642
00:31:39,800 --> 00:31:43,203 line:-1
一旦你创建好一组听力图敏度值


643
00:31:43,670 --> 00:31:45,772 line:-2
你就可以把它保存到
audiogramSample中


644
00:31:46,607 --> 00:31:49,576 line:-1
现在一定要确保敏度值


645
00:31:49,643 --> 00:31:51,678 line:-1
都是唯一的并且是按顺序排列的


646
00:31:52,079 --> 00:31:53,947 line:-1
因为这是你稍后在分析或图表中


647
00:31:54,014 --> 00:31:56,717 line:-1
与这个数据进行交互的方式


648
00:31:58,151 --> 00:32:01,188 line:-2
最后我已经准备好把那个数据
存储到HealthKit中了


649
00:32:02,289 --> 00:32:05,626 line:-1
开始创建听力图样本


650
00:32:05,692 --> 00:32:07,895 line:-2
以及用HealthKit创建
听力健康app 就是这么简单


651
00:32:08,929 --> 00:32:12,633 line:-1
但听力图样本只代表


652
00:32:12,699 --> 00:32:15,102 line:-2
当你做听力测试时的指定时间点的
耳朵的健康程度


653
00:32:16,203 --> 00:32:19,506 line:-2
一天中的绝大多数时间
我们都暴露在各种声音之中


654
00:32:19,573 --> 00:32:22,309 line:-2
这些声音来自耳机
或来自我们在路上行走时的周围环境


655
00:32:22,776 --> 00:32:25,479 line:-1
那都会影响我们的听力健康


656
00:32:27,347 --> 00:32:30,918 line:-1
为了保持追踪来自耳机的音频暴露


657
00:32:31,218 --> 00:32:34,321 line:-2
我们有一个读写量化类型
headphoneAudioExposure


658
00:32:36,256 --> 00:32:37,457 line:-1
在一天中剩下的时间


659
00:32:37,524 --> 00:32:41,562 line:-2
当我们走在充斥着建筑工作声音
或交通声音的路上时


660
00:32:42,329 --> 00:32:46,400 line:-2
Apple Watch可以捕捉
环境中的音频暴露数据


661
00:32:46,466 --> 00:32:47,701 line:-1
并把它保存到HealthKit中


662
00:32:48,035 --> 00:32:50,637 line:-1
为此我们有一个类似的读写量化类型


663
00:32:50,971 --> 00:32:52,306 line:-1
environmentalAudioExposure


664
00:32:53,707 --> 00:32:57,311 line:-1
如果环境中的音频暴露太高


665
00:32:57,978 --> 00:33:00,581 line:-2
Apple Watch会生成一个
音频暴露警告


666
00:33:00,647 --> 00:33:03,217 line:-1
以确保你了解


667
00:33:03,283 --> 00:33:05,219 line:-2
那可能对你的耳朵健康
所产生的可能的影响


668
00:33:05,986 --> 00:33:08,722 line:-2
并且它会使用新audioExposureEvent
类别类型识别器


669
00:33:08,789 --> 00:33:12,059 line:-1
把这个保存为类别样本


670
00:33:14,595 --> 00:33:17,598 line:-1
那么我们讲了许多


671
00:33:17,664 --> 00:33:20,167 line:-2
在HealthKit和
iOS 13中可用的新的数据表达


672
00:33:20,901 --> 00:33:25,072 line:-2
从新的、有效率的系列表达
到对听力健康的新支持


673
00:33:26,707 --> 00:33:30,577 line:-2
现在你可以正式存储
大量的HK量化数据了


674
00:33:30,911 --> 00:33:33,614 line:-2
大多数冗余数据
保存在HealthKit中


675
00:33:33,680 --> 00:33:34,848 line:-1
（总结）


676
00:33:34,915 --> 00:33:37,818 line:-1
并且你可以表达更丰富的


677
00:33:38,352 --> 00:33:41,388 line:-1
关于心脏和听力健康的数据的表达


678
00:33:41,455 --> 00:33:42,623 line:-1
（有效率地存储大量HK量化数据）


679
00:33:42,990 --> 00:33:46,627 line:-2
要获取更多信息以及你在这里
所看到的示例代码项目


680
00:33:46,994 --> 00:33:51,532 line:-2
你可以访问我们的演讲链接
或在本场演讲结束后


681
00:33:51,598 --> 00:33:53,433 line:-2
与我们在健康与
健身技术实验室中沟通


682
00:33:54,902 --> 00:33:57,471 line:-1
谢谢大家 祝你们WWDC过得愉快

