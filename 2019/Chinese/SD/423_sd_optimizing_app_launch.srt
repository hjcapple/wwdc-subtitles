1
00:00:00,506 --> 00:00:04,500
[音乐]


2
00:00:07,516 --> 00:00:13,046
[掌声]


3
00:00:13,546 --> 00:00:16,216
>> 大家好 我是 Spencer Lewson


4
00:00:16,216 --> 00:00:17,876
我是 Apple 公司 Performance Team 


5
00:00:18,046 --> 00:00:18,566
的一名工程师


6
00:00:19,446 --> 00:00:21,116
今天我很高兴告诉你们


7
00:00:21,116 --> 00:00:23,786
如何优化你们 App 的启动


8
00:00:24,336 --> 00:00:27,196
我们今天将讨论


9
00:00:27,196 --> 00:00:28,006
这四个主要议题


10
00:00:28,746 --> 00:00:30,686
首先 什么是启动


11
00:00:31,256 --> 00:00:32,076
不同类型的启动有哪些


12
00:00:32,076 --> 00:00:33,516
以及我们如何


13
00:00:33,516 --> 00:00:35,486
将它们分解为不同的子阶段


14
00:00:36,576 --> 00:00:37,906
接下来 我们将讨论


15
00:00:37,906 --> 00:00:39,626
如何正确估测你们 App 的启动


16
00:00:40,646 --> 00:00:42,356
生活中 iOS 设备


17
00:00:42,356 --> 00:00:43,366
可能处于各种不同的


18
00:00:43,436 --> 00:00:46,226
状态和情况 并且这些


19
00:00:46,226 --> 00:00:48,126
状态和条件可能


20
00:00:48,126 --> 00:00:49,886
产生不一致的启动结果


21
00:00:50,566 --> 00:00:51,656
因此 了解这些状态


22
00:00:51,656 --> 00:00:53,136
以及如何在进行测量时


23
00:00:53,176 --> 00:00:54,596
减少其影响非常重要


24
00:00:55,266 --> 00:00:58,826
在这时候


25
00:00:58,826 --> 00:00:59,866
你们可以查看如何使用


26
00:01:00,006 --> 00:01:02,106
Instruments 来分析和了解


27
00:01:02,106 --> 00:01:03,476
你们的 App 以找到


28
00:01:03,476 --> 00:01:04,806
改进它的机会


29
00:01:06,026 --> 00:01:07,296
最后 我们将为你们提供


30
00:01:07,346 --> 00:01:09,406
有关如何监控 App 启动的


31
00:01:09,406 --> 00:01:10,616
一些可持续且适用于实战的


32
00:01:10,976 --> 00:01:12,856
提示和技巧


33
00:01:13,316 --> 00:01:14,806
以确保你们始终为


34
00:01:14,806 --> 00:01:17,866
所有用户提供愉快的体验


35
00:01:17,866 --> 00:01:21,356
那么 我正在谈论的


36
00:01:21,616 --> 00:01:22,466
App 启动是什么


37
00:01:23,226 --> 00:01:26,626
其实 App 启动是用户体验的中断


38
00:01:27,966 --> 00:01:28,996
这是什么意思呢


39
00:01:29,536 --> 00:01:30,076
让我们来看看


40
00:01:31,126 --> 00:01:34,136
好的 准备 开始


41
00:01:38,186 --> 00:01:40,546
哇 在这台 iPhone 6S Plus 上


42
00:01:41,176 --> 00:01:43,366
启动时间差不多 2.5 秒


43
00:01:44,176 --> 00:01:45,736
这并不像我们用户期望的


44
00:01:45,736 --> 00:01:46,946
那样令人愉快


45
00:01:48,326 --> 00:01:49,736
你们知道 令人愉悦的启动


46
00:01:49,736 --> 00:01:50,676
是非常重要的


47
00:01:51,326 --> 00:01:52,396
因为它经常发生


48
00:01:53,276 --> 00:01:55,746
事实上 在所有 iOS 设备中


49
00:01:56,316 --> 00:01:58,436
它每天都会发生数十亿次


50
00:01:59,666 --> 00:02:00,336
所以 我们做了一些


51
00:02:00,336 --> 00:02:02,286
简单计算 发现


52
00:02:02,286 --> 00:02:03,916
如果每次启动时我们


53
00:02:03,916 --> 00:02:05,476
节省一毫秒


54
00:02:05,476 --> 00:02:07,586
我们将节省共惊人的


55
00:02:07,586 --> 00:02:12,186
162 天启动时间


56
00:02:13,196 --> 00:02:15,026
是的 换句话说


57
00:02:16,506 --> 00:02:18,236
[掌声] 谢谢你们


58
00:02:18,236 --> 00:02:19,916
换句话说 这就是将火箭


59
00:02:19,916 --> 00:02:22,886
发送到火星所需的时间


60
00:02:23,626 --> 00:02:26,246
但由于其他一些原因 


61
00:02:26,246 --> 00:02:27,236
这同样很重要


62
00:02:27,926 --> 00:02:31,626
首先 你们 App 的启动是


63
00:02:31,706 --> 00:02:33,176
你们用户对你们 App


64
00:02:33,176 --> 00:02:35,216
的第一印象 


65
00:02:35,216 --> 00:02:35,946
因此它应该是愉悦的


66
00:02:37,236 --> 00:02:38,646
现在重要的是要记住


67
00:02:38,646 --> 00:02:40,326
作为开发者


68
00:02:40,326 --> 00:02:41,796
我们倾向于被更新的设备吸引


69
00:02:42,706 --> 00:02:43,766
因此 重要的是要确保


70
00:02:43,906 --> 00:02:45,126
你们在眼前


71
00:02:45,126 --> 00:02:46,876
看到的体验与


72
00:02:46,876 --> 00:02:48,146
你们的用户


73
00:02:48,626 --> 00:02:50,386
在不同 iOS 设备


74
00:02:50,386 --> 00:02:52,506
和不同条件下拥有的


75
00:02:53,016 --> 00:02:55,606
用户体验相同


76
00:02:57,356 --> 00:02:59,726
此外 启动涵盖了


77
00:02:59,726 --> 00:03:01,026
你们代码库的很大一部分


78
00:03:01,716 --> 00:03:02,736
从底层加工到初始化


79
00:03:02,736 --> 00:03:05,646
再到视图创建等等


80
00:03:06,316 --> 00:03:08,076
因此 如果你们发现


81
00:03:08,076 --> 00:03:09,976
你们的启动并不像


82
00:03:10,196 --> 00:03:11,546
用户期望的那样愉悦


83
00:03:12,226 --> 00:03:13,436
那么这也可能表明


84
00:03:13,436 --> 00:03:14,496
你们的代码库的


85
00:03:14,496 --> 00:03:17,896
其他部分也并不那么令人愉悦


86
00:03:18,066 --> 00:03:19,686
最后 启动是一个对于手机是


87
00:03:19,686 --> 00:03:20,726
非常紧张的时间


88
00:03:21,456 --> 00:03:23,326
会涉及大量 CPU 工作和


89
00:03:23,326 --> 00:03:24,046
大量内存工作


90
00:03:24,956 --> 00:03:25,846
因此 你们应该尝试减缓它


91
00:03:25,906 --> 00:03:27,486
因为它会影响系统性能


92
00:03:27,486 --> 00:03:30,306
当然还有你们用户的电池寿命


93
00:03:30,736 --> 00:03:33,496
那么 让我们来看看


94
00:03:33,696 --> 00:03:34,886
我之前谈过的那些启动


95
00:03:35,386 --> 00:03:40,386
有冷启动 暖启动


96
00:03:40,696 --> 00:03:42,056
继续运行通常被称为启动 


97
00:03:42,056 --> 00:03:43,216
但其实它不是一个启动


98
00:03:45,616 --> 00:03:47,166
重启后或你们的 App 


99
00:03:47,166 --> 00:03:49,316
很长时间未启动时


100
00:03:49,316 --> 00:03:50,666
会发生冷启动


101
00:03:52,116 --> 00:03:54,106
为了启动 App


102
00:03:54,106 --> 00:03:57,666
我们需要将它从磁盘带入内存


103
00:03:57,666 --> 00:03:58,906
启动支持你们 App 的系统端服务


104
00:03:58,906 --> 00:04:00,816
然后生成你们的进程


105
00:04:02,266 --> 00:04:03,616
正如你们所预料的那样


106
00:04:03,616 --> 00:04:05,886
这可能需要一点时间


107
00:04:05,916 --> 00:04:07,546
但幸运的是


108
00:04:07,546 --> 00:04:09,006
一旦发生一次 你们都将体验到暖启动


109
00:04:09,576 --> 00:04:12,496
在这种情况下 你们的 App 仍然


110
00:04:12,496 --> 00:04:14,516
需要被唤醒


111
00:04:14,516 --> 00:04:15,916
但我们已经将你们的 App 


112
00:04:15,916 --> 00:04:17,565
带入内存并启动了


113
00:04:17,565 --> 00:04:18,896
那些系统端服务


114
00:04:19,426 --> 00:04:20,255
所以 这会更快一点


115
00:04:20,255 --> 00:04:22,036
也会更一致


116
00:04:23,676 --> 00:04:25,206
最后 还要说说继续运行


117
00:04:26,256 --> 00:04:28,536
当用户从主屏幕


118
00:04:28,536 --> 00:04:30,066
或 App 切换器重新进入你们的 App 时


119
00:04:30,066 --> 00:04:31,306
会发生这种情况


120
00:04:32,336 --> 00:04:33,926
如你们所知


121
00:04:33,926 --> 00:04:35,546
该 App 在此时已经启动


122
00:04:35,546 --> 00:04:36,786
因此速度非常快


123
00:04:38,146 --> 00:04:39,066
你们需要记住的是


124
00:04:39,066 --> 00:04:41,256
在进行估量时 


125
00:04:41,396 --> 00:04:43,116
不要将继续运行与启动混淆


126
00:04:43,906 --> 00:04:46,436
所以 鉴于这些信息


127
00:04:46,936 --> 00:04:49,986
如果启动与继续运行一样快速


128
00:04:50,696 --> 00:04:56,006
和令人愉悦


129
00:04:56,516 --> 00:04:57,096
那不是很棒吗


130
00:04:57,826 --> 00:05:00,676
我们怎样才能做到这一点


131
00:05:02,036 --> 00:05:04,146
好吧 我们需要达到


132
00:05:04,146 --> 00:05:05,486
在 400 毫秒内渲染


133
00:05:05,626 --> 00:05:06,906
第一帧的目标


134
00:05:08,066 --> 00:05:09,266
这样我们就可以在


135
00:05:09,266 --> 00:05:10,866
启动动画期间


136
00:05:10,866 --> 00:05:13,116
向用户显示像素


137
00:05:13,116 --> 00:05:14,136
并且在启动动画完成时


138
00:05:14,136 --> 00:05:15,796
你们的 App 就具有


139
00:05:15,796 --> 00:05:17,506
交互性和响应性


140
00:05:18,096 --> 00:05:20,346
这样做的第一步是


141
00:05:20,346 --> 00:05:22,296
了解启动期间发生的情况


142
00:05:22,866 --> 00:05:24,666
那么 让我们启动《地图》


143
00:05:26,496 --> 00:05:28,126
如你们所知 


144
00:05:28,126 --> 00:05:29,606
启动通常发生在用户点按


145
00:05:29,606 --> 00:05:32,236
主屏幕上你们的图标时


146
00:05:32,406 --> 00:05:34,316
然后在接下来的 100 毫秒左右内


147
00:05:34,316 --> 00:05:36,136
iOS 将执行必要的


148
00:05:36,136 --> 00:05:37,916
系统端工作以


149
00:05:37,916 --> 00:05:39,746
初始化你们的 App


150
00:05:40,456 --> 00:05:42,386
这给了你们开发者有


151
00:05:42,786 --> 00:05:46,846
大约 300 毫秒来创建视图加载内容


152
00:05:46,846 --> 00:05:48,206
并生成第一帧


153
00:05:49,716 --> 00:05:51,506
现在这个帧不一定


154
00:05:51,506 --> 00:05:53,316
需要完全完成


155
00:05:53,316 --> 00:05:55,056
它可以有一些占位符


156
00:05:55,226 --> 00:05:58,996
用于异步加载数据


157
00:05:58,996 --> 00:06:00,706
但此时你们的 App 应该是


158
00:06:00,706 --> 00:06:01,356
可交互 且有响应的


159
00:06:02,536 --> 00:06:04,936
因此 在这个 Maps 的例子中 


160
00:06:04,936 --> 00:06:06,106
所有视窗尚未加载


161
00:06:06,526 --> 00:06:07,586
你们仍然可以启动搜索


162
00:06:07,586 --> 00:06:10,086
并浏览收藏夹


163
00:06:10,656 --> 00:06:13,786
然后在接下来的几百毫秒内


164
00:06:13,786 --> 00:06:15,006
你们可以显示异步加载的


165
00:06:15,006 --> 00:06:16,636
数据并为你们的用户


166
00:06:16,636 --> 00:06:17,646
生成最终帧


167
00:06:18,636 --> 00:06:19,976
让我们仔细看看这些阶段


168
00:06:24,156 --> 00:06:25,316
这六个阶段涵盖所有内容


169
00:06:25,316 --> 00:06:28,676
从系统初始化到 App 初始化


170
00:06:28,676 --> 00:06:32,716
再到视图创建和布局


171
00:06:32,716 --> 00:06:34,576
如果你们的 App 有需要的


172
00:06:34,576 --> 00:06:36,736
还可能有一个扩展阶段


173
00:06:37,036 --> 00:06:37,976
用于数据的异步加载


174
00:06:42,086 --> 00:06:44,666
系统界面的前半部分是 DYLD3


175
00:06:44,726 --> 00:06:47,476
对于你们中那些不熟悉的人


176
00:06:47,476 --> 00:06:49,356
动态链接器会加载


177
00:06:49,356 --> 00:06:50,536
你们的共享库和框架


178
00:06:52,156 --> 00:06:56,256
在 2017 年 我们引入了 DYLD3


179
00:06:56,296 --> 00:06:58,636
它为系统增加了


180
00:06:58,636 --> 00:07:00,026
令人兴奋的优化


181
00:07:01,096 --> 00:07:02,026
好吧 我们很高兴地宣布


182
00:07:02,026 --> 00:07:03,906
在 iOS 13 中 我们会为


183
00:07:03,906 --> 00:07:05,966
你们的 App 带来这些优化


184
00:07:07,176 --> 00:07:08,726
这意味着我们现在会为热启动


185
00:07:08,726 --> 00:07:10,166
缓存运行时依赖项


186
00:07:10,166 --> 00:07:13,486
这应该会给它们带来显著的速度提升 [掌声]


187
00:07:13,956 --> 00:07:15,446
谢谢你们


188
00:07:21,066 --> 00:07:22,566
现在有了一个新的链接器


189
00:07:22,566 --> 00:07:23,606
我们提出了一些新的建议


190
00:07:24,846 --> 00:07:26,126
为了充分利用这些新的改进


191
00:07:26,126 --> 00:07:28,606
我们建议你们


192
00:07:28,606 --> 00:07:30,276
避免链接未使用的框架


193
00:07:30,276 --> 00:07:32,786
因为这可能会产生潜在成本


194
00:07:32,786 --> 00:07:33,136
我们稍后会向你们展示


195
00:07:34,646 --> 00:07:37,186
我们还建议你们


196
00:07:37,186 --> 00:07:39,236
避免动态库加载


197
00:07:39,236 --> 00:07:42,086
例如 dlopen() 或 NSBundle 中的 load()


198
00:07:42,166 --> 00:07:43,666
因为这会损失你们


199
00:07:43,666 --> 00:07:46,516
在缓存中建立的那些优势


200
00:07:47,816 --> 00:07:49,216
最后 这意味着


201
00:07:49,216 --> 00:07:51,386
你们应该硬链接


202
00:07:51,386 --> 00:07:52,786
所有依赖项


203
00:07:52,916 --> 00:07:54,676
因为它现在甚至比以前更快


204
00:07:57,456 --> 00:07:58,886
系统接口的后半部分


205
00:07:58,886 --> 00:08:00,476
是 libSystem Init


206
00:08:01,616 --> 00:08:02,716
这是我们在 App 中


207
00:08:02,716 --> 00:08:05,336
初始化底层系统组件的时候


208
00:08:06,436 --> 00:08:08,106
现在这主要是系统方面的工作


209
00:08:08,106 --> 00:08:09,556
有固定成本


210
00:08:10,336 --> 00:08:11,976
因此 开发者不需要关注该部分


211
00:08:15,106 --> 00:08:16,956
接下来是静态运行时初始化


212
00:08:18,496 --> 00:08:19,406
这在系统初始化


213
00:08:19,406 --> 00:08:21,386
Objective-C 和 Swift 


214
00:08:21,386 --> 00:08:22,136
运行次数时会出现


215
00:08:23,666 --> 00:08:25,006
一般来说


216
00:08:25,006 --> 00:08:26,136
你们的 App 不应该在这里做任何工作


217
00:08:26,706 --> 00:08:29,416
除非你有可能存在于代码中的


218
00:08:29,416 --> 00:08:30,816
静态初始化方法


219
00:08:31,436 --> 00:08:33,446
或者更可能是你链接的


220
00:08:33,446 --> 00:08:35,246
框架带来的“惊喜”


221
00:08:36,056 --> 00:08:38,626
通常 我们不建议静态初始化


222
00:08:38,626 --> 00:08:40,395
所以 让我们花点时间谈谈


223
00:08:40,395 --> 00:08:42,186
如何减少其影响


224
00:08:43,376 --> 00:08:45,016
如果你们拥有一个


225
00:08:45,016 --> 00:08:46,336
使用静态初始化的框架


226
00:08:46,686 --> 00:08:48,916
你们要考虑暴露 API 以


227
00:08:48,916 --> 00:08:50,076
尽早初始化你们的栈


228
00:08:50,716 --> 00:08:52,636
但是如果必须使用静态初始化


229
00:08:52,636 --> 00:08:56,966
请考虑将代码移出 +[Class load]


230
00:08:56,966 --> 00:08:59,366
它在 App 启动期间


231
00:09:00,226 --> 00:09:01,906
总会被调用


232
00:09:01,906 --> 00:09:03,646
就在你在类中第一次使用方法的时候


233
00:09:03,646 --> 00:09:08,066
被懒调用


234
00:09:08,246 --> 00:09:09,946
接下来是 UIKit 初始化


235
00:09:11,266 --> 00:09:12,156
这就是系统实例化


236
00:09:12,186 --> 00:09:13,896
你们的 UIApplication 


237
00:09:13,896 --> 00:09:15,896
和 UIApplicationDelegate 的时候


238
00:09:16,566 --> 00:09:18,646
在大多数情况下


239
00:09:18,646 --> 00:09:20,036
这是系统方面的工作


240
00:09:20,036 --> 00:09:21,606
设置事件处理


241
00:09:21,606 --> 00:09:22,206
和与系统的集成


242
00:09:23,256 --> 00:09:24,226
但是你们其实仍然


243
00:09:24,226 --> 00:09:26,996
可以影响此阶段


244
00:09:26,996 --> 00:09:29,876
如果你们在子类 UIApplication


245
00:09:30,056 --> 00:09:31,926
或者在 UIApplicationDelegate


246
00:09:32,646 --> 00:09:35,746
初始化程序中做任何工作


247
00:09:35,746 --> 00:09:36,516
现在我们看看 App 初始化


248
00:09:37,436 --> 00:09:38,476
最重要的东西都在这里


249
00:09:38,896 --> 00:09:40,136
这是作为开发者


250
00:09:40,136 --> 00:09:40,996
可能在你们 App 启动时


251
00:09:40,996 --> 00:09:42,706
初始化程序中做任何工作地方


252
00:09:43,246 --> 00:09:45,586
对于你们之中尚未采用


253
00:09:45,586 --> 00:09:47,826
UIScene API 或针对 iOS 12 


254
00:09:49,146 --> 00:09:50,326
或更早版本的用户的人来说


255
00:09:50,326 --> 00:09:53,356
App 初始化


256
00:09:54,116 --> 00:09:55,766
仍然可以用这些


257
00:09:55,766 --> 00:09:56,426
代理回调方法


258
00:09:57,186 --> 00:09:57,736
application:willFinishLaunchingwithOptions


259
00:09:57,736 --> 00:10:01,216
和 application:didFinishLaunchingwithOptions


260
00:10:01,956 --> 00:10:04,196
当你们的 App 显示给用户时


261
00:10:04,196 --> 00:10:06,286
applicationDidBecomeActive 这个方法


262
00:10:07,006 --> 00:10:09,036
会被进一步调用


263
00:10:10,176 --> 00:10:11,356
现在重要的是要知道


264
00:10:11,356 --> 00:10:13,316
如果你没有采用 UIScene API


265
00:10:13,316 --> 00:10:14,116
你应该创建视图控制器


266
00:10:14,116 --> 00:10:16,546
和 didFinishLaunchingwithOptions


267
00:10:17,686 --> 00:10:19,276
这是因为使用 UIScene 时


268
00:10:19,666 --> 00:10:23,216
App 初始化的工作方式略有不同


269
00:10:23,216 --> 00:10:24,276
现在你仍然可以获得


270
00:10:24,276 --> 00:10:25,456
willFinishLaunching 和


271
00:10:25,456 --> 00:10:26,726
didFinishLaunchingwithOptions


272
00:10:27,546 --> 00:10:28,736
但是当你们的 App 显示给用户时


273
00:10:28,736 --> 00:10:30,126
你们将获得


274
00:10:30,126 --> 00:10:32,836
UISceneDelegate 生命周期回调


275
00:10:34,116 --> 00:10:35,986
当然就是带有选项的


276
00:10:35,986 --> 00:10:36,426
scene:willConnectToSession


277
00:10:36,846 --> 00:10:38,586
sceneWillEnterForeground 和


278
00:10:38,586 --> 00:10:39,446
sceneDidBecomeActive


279
00:10:40,106 --> 00:10:41,666
你们应该创建视图控制器


280
00:10:41,666 --> 00:10:43,446
和带有选项的


281
00:10:43,446 --> 00:10:44,866
scene:willConnectToSession


282
00:10:46,266 --> 00:10:48,016
重要的是要注意 


283
00:10:48,016 --> 00:10:49,206
你们应该只创建


284
00:10:49,206 --> 00:10:50,256
视图控制器和带有选项的


285
00:10:50,256 --> 00:10:51,406
scene:willConnectToSession


286
00:10:51,666 --> 00:10:52,836
以及带有选项的


287
00:10:52,836 --> 00:10:53,956
didFinishLaunching


288
00:10:54,416 --> 00:10:55,956
这是常见的陷阱


289
00:10:55,956 --> 00:10:59,176
当然会导致性能损失


290
00:10:59,476 --> 00:11:01,826
并且可能导致你们代码库中


291
00:11:04,316 --> 00:11:04,426
出现不可预测的错误


292
00:11:04,636 --> 00:11:05,716
无论你们是否


293
00:11:05,846 --> 00:11:07,256
采用了新的 UIScene API


294
00:11:07,326 --> 00:11:09,196
我们对此阶段的建议


295
00:11:09,196 --> 00:11:09,996
通常都是相同的


296
00:11:09,996 --> 00:11:12,896
你们应该推迟


297
00:11:12,896 --> 00:11:14,456
任何不相关的工作


298
00:11:14,456 --> 00:11:15,926
但是没有必要


299
00:11:15,926 --> 00:11:18,446
提交你的第一帧


300
00:11:18,446 --> 00:11:20,846
可以通过将其推送到后台队列


301
00:11:20,846 --> 00:11:22,346
或者稍后再完全执行


302
00:11:25,096 --> 00:11:27,386
如果你们确实采用了 UIScenes


303
00:11:27,386 --> 00:11:28,886
那么你们可以再做一件事


304
00:11:28,886 --> 00:11:31,506
那就是确保你们在场景之间共享资源


305
00:11:32,126 --> 00:11:33,486
当然 这是为了减少


306
00:11:33,486 --> 00:11:35,456
多次不必要地


307
00:11:35,456 --> 00:11:37,766
进行一些工作的开销


308
00:11:38,696 --> 00:11:40,206
要了解有关 UIScenes 的更多信息


309
00:11:40,636 --> 00:11:43,366
那就是确保你们在场景之间这两个会议 


310
00:11:46,126 --> 00:11:47,456
接下来是第一帧 渲染阶段


311
00:11:48,446 --> 00:11:50,066
这是相对简单的


312
00:11:50,506 --> 00:11:51,776
这是我们创建视图


313
00:11:51,776 --> 00:11:54,106
执行布局 然后绘制它们的时候


314
00:11:55,236 --> 00:11:56,486
然后我们获取该信息


315
00:11:56,956 --> 00:11:58,166
并将你们的第一帧渲染


316
00:11:58,166 --> 00:11:59,956
用漂亮的像素呈现出来


317
00:12:02,446 --> 00:12:03,816
你们可以通过减少


318
00:12:03,816 --> 00:12:05,876
层次结构中的视图数


319
00:12:05,876 --> 00:12:06,406
来影响此阶段


320
00:12:06,446 --> 00:12:08,466
你们也可以通过


321
00:12:08,656 --> 00:12:09,946
展平视图以减少使用


322
00:12:09,946 --> 00:12:13,156
或延迟加载在启动期间


323
00:12:13,546 --> 00:12:15,026
未显示的视图来实现


324
00:12:15,556 --> 00:12:18,946
你们还应该查看自动布局


325
00:12:18,946 --> 00:12:19,966
看看是否可以减少


326
00:12:19,966 --> 00:12:21,496
正在使用的约束数量


327
00:12:23,516 --> 00:12:25,416
最后 我们有一个扩展阶段


328
00:12:26,106 --> 00:12:27,776
这是从你们第一次


329
00:12:27,896 --> 00:12:29,786
提交到向用户显示


330
00:12:29,786 --> 00:12:31,976
最终帧的 App 特定时间段


331
00:12:33,016 --> 00:12:34,146
这是当你加载


332
00:12:34,146 --> 00:12:35,506
我们谈到的异步数据时


333
00:12:36,316 --> 00:12:38,826
其实不是每个 App 都有这个阶段


334
00:12:39,916 --> 00:12:41,546
但如果你们确实有这个阶段


335
00:12:42,736 --> 00:12:44,876
那么你们的 App 应该具有互动性和响应性


336
00:12:45,436 --> 00:12:47,936
如果你们确实有这个阶段


337
00:12:47,936 --> 00:12:49,366
我们只会就你应该如何处理


338
00:12:49,366 --> 00:12:50,956
这个问题提供广泛性建议


339
00:12:50,956 --> 00:12:52,216
那就是了解正在发生什么


340
00:12:52,216 --> 00:12:54,386
并且你们可以通过


341
00:12:54,386 --> 00:12:56,626
利用 os_signpost API 来标记和衡量


342
00:12:56,956 --> 00:13:00,336
在这两个时期发生的工作


343
00:13:04,476 --> 00:13:05,956
既然我们讨论了启动是什么


344
00:13:05,956 --> 00:13:08,886
让我们谈谈如何获得可用的测量


345
00:13:11,556 --> 00:13:14,236
在任何给定时间


346
00:13:14,236 --> 00:13:16,006
iOS 设备都处于各种


347
00:13:16,006 --> 00:13:17,836
不同的状态和情况下


348
00:13:17,836 --> 00:13:19,066
这可能会在启动时


349
00:13:19,066 --> 00:13:20,226
引入很大的差异


350
00:13:21,166 --> 00:13:22,506
因此 当我们分析和


351
00:13:22,506 --> 00:13:24,356
比较我们的启动结果时


352
00:13:24,846 --> 00:13:26,686
确保我们进行“Apple-Apple”的


353
00:13:26,686 --> 00:13:27,896
对比比较至关重要


354
00:13:27,896 --> 00:13:30,106
因为如果在进行任何更改之前


355
00:13:30,106 --> 00:13:33,396
你的启动结果完全不可预测


356
00:13:33,396 --> 00:13:35,146
你们如何知道


357
00:13:35,146 --> 00:13:36,356
自己是否取得了进展呢


358
00:13:36,896 --> 00:13:38,866
使其可预测的第一步是


359
00:13:38,866 --> 00:13:40,546
消除这些差异来源


360
00:13:40,546 --> 00:13:44,286
例如网络干扰和


361
00:13:44,286 --> 00:13:45,816
后台进程中的干扰


362
00:13:47,126 --> 00:13:48,526
现在我们意识到


363
00:13:48,576 --> 00:13:50,366
这听起来有悖常理


364
00:13:50,366 --> 00:13:51,836
因为这可能会导致


365
00:13:51,836 --> 00:13:53,366
启动不能完全


366
00:13:53,366 --> 00:13:55,506
代表常规使用 但我们想让


367
00:13:55,506 --> 00:13:57,276
你们知道这没关系


368
00:13:58,356 --> 00:13:59,456
拥有一致的结果可以


369
00:13:59,566 --> 00:14:01,286
使评估很好地进展


370
00:14:01,286 --> 00:14:02,416
这一点尤为重要


371
00:14:03,216 --> 00:14:07,186
在 Apple 我们一直在使用这种技术


372
00:14:07,276 --> 00:14:08,666
在开发过程中成功检测回归


373
00:14:09,186 --> 00:14:10,326
并缩短启动时间


374
00:14:11,106 --> 00:14:13,736
然后 我们通过使用


375
00:14:14,016 --> 00:14:15,626
在实际情况中收集的遥测数据


376
00:14:16,156 --> 00:14:17,406
来验证这些性能改进


377
00:14:17,586 --> 00:14:18,816
幸运的是 


378
00:14:18,816 --> 00:14:20,076
我们提供了一些关于建立干净


379
00:14:20,076 --> 00:14:21,066
和一致的环境的技巧


380
00:14:23,176 --> 00:14:25,146
首先 重启你们的设备


381
00:14:26,046 --> 00:14:26,976
这将清除任何


382
00:14:26,976 --> 00:14:28,616
不必要的状态


383
00:14:28,616 --> 00:14:29,996
然后让它在接下来的几分钟内


384
00:14:29,996 --> 00:14:31,506
安定下来以清除


385
00:14:31,506 --> 00:14:31,956
任何启动时间工作


386
00:14:34,256 --> 00:14:37,126
你们还可以通过打开飞行模式


387
00:14:37,126 --> 00:14:38,486
或在代码中标记


388
00:14:39,196 --> 00:14:40,306
网络依赖性来


389
00:14:40,306 --> 00:14:41,446
减少对网络的依赖


390
00:14:42,496 --> 00:14:45,156
网络可以引入相当多的差异


391
00:14:45,926 --> 00:14:48,056
接下来是 iCloud


392
00:14:49,176 --> 00:14:50,746
iCloud 是一个很棒的功能


393
00:14:50,776 --> 00:14:51,926
它可以在后台运行


394
00:14:51,926 --> 00:14:53,436
为我们的用户提供无缝体验


395
00:14:53,436 --> 00:14:55,726
但是在后台工作


396
00:14:55,726 --> 00:14:57,776
会干扰 App 的启动


397
00:14:58,246 --> 00:14:59,236
因此 在你们的测量过程中


398
00:15:00,106 --> 00:15:04,446
使用不变的 iCloud 帐户和不变的数据


399
00:15:04,446 --> 00:15:05,746
或完全注销 iCloud


400
00:15:06,296 --> 00:15:12,456
接下来一定要在进行测量时


401
00:15:12,456 --> 00:15:13,276
使用 App 的发布构建版本


402
00:15:13,946 --> 00:15:19,306
当然 这是为了减少测量期间


403
00:15:19,306 --> 00:15:22,796
不必要的调试代码的开销


404
00:15:22,796 --> 00:15:24,946
并利用编译时优化


405
00:15:26,276 --> 00:15:28,196
最后 你们应该使用


406
00:15:28,246 --> 00:15:30,216
热启动进行测量


407
00:15:30,216 --> 00:15:31,406
如前所述


408
00:15:31,406 --> 00:15:33,216
它们更加一致


409
00:15:33,216 --> 00:15:34,196
因为你们的某些 App 可能已经在内存中


410
00:15:34,996 --> 00:15:35,946
并且其中一些


411
00:15:35,946 --> 00:15:37,506
系统端服务可能已在运行


412
00:15:37,536 --> 00:15:41,786
现在我们可以设置


413
00:15:41,786 --> 00:15:42,196
一些数据来测试


414
00:15:43,286 --> 00:15:44,716
创建一致的模拟


415
00:15:44,806 --> 00:15:46,136
数据集非常重要


416
00:15:46,136 --> 00:15:48,296
你们可能需要


417
00:15:48,296 --> 00:15:49,366
为不同类型的用户


418
00:15:49,366 --> 00:15:51,376
提供一些数据集


419
00:15:51,376 --> 00:15:53,236
例如具有少量数据的用户


420
00:15:53,336 --> 00:15:55,966
和具有大量数据的用户


421
00:15:55,966 --> 00:15:58,406
但在理想情况下


422
00:15:58,406 --> 00:15:59,906
你们的 App 应该能够扩展到


423
00:15:59,906 --> 00:16:00,486
任何数量的数据


424
00:16:01,546 --> 00:16:02,826
这就是为什么


425
00:16:02,826 --> 00:16:04,066
在显示第一帧时


426
00:16:04,066 --> 00:16:04,716
只加载必要数据的原因


427
00:16:08,076 --> 00:16:09,526
现在我们准备挑选一些设备了


428
00:16:10,656 --> 00:16:11,906
你们应该选择


429
00:16:11,906 --> 00:16:13,126
对用户重要的各种设备


430
00:16:13,126 --> 00:16:14,636
然后坚持使用它们


431
00:16:14,636 --> 00:16:15,626
强制一致性


432
00:16:16,876 --> 00:16:18,466
请确保将最旧的


433
00:16:18,466 --> 00:16:19,416
设备包含在


434
00:16:19,416 --> 00:16:20,686
最早支持的版本中


435
00:16:21,436 --> 00:16:22,496
这是因为旧设备


436
00:16:22,496 --> 00:16:24,186
和较新设备之间


437
00:16:24,186 --> 00:16:26,136
的性能特征


438
00:16:26,136 --> 00:16:28,716
看起来不同


439
00:16:29,196 --> 00:16:31,636
后者具有不同数量的 RAM 和 CPU 内核


440
00:16:32,936 --> 00:16:33,856
这将确保你们的


441
00:16:33,856 --> 00:16:35,776
所有设备上的


442
00:16:35,776 --> 00:16:38,046
所有用户都能感到愉快


443
00:16:41,046 --> 00:16:41,836
现在我们准备


444
00:16:41,836 --> 00:16:42,276
进行一些测量


445
00:16:43,576 --> 00:16:45,076
我们可以利用新的 XCTest 


446
00:16:45,286 --> 00:16:46,916
来在 Xcode 11 中


447
00:16:46,916 --> 00:16:47,636
测试 App 性能


448
00:16:48,686 --> 00:16:49,936
只需几行代码


449
00:16:50,506 --> 00:16:51,446
Xcode 就会重复启动你们的 App 


450
00:16:51,496 --> 00:16:53,716
然后提供有关其


451
00:16:53,796 --> 00:16:55,626
执行情况的统计结果


452
00:16:56,856 --> 00:16:58,626
我们稍后会谈到这个


453
00:17:01,466 --> 00:17:03,026
所以 现在我们已经讨论了


454
00:17:03,026 --> 00:17:05,326
启动是什么以及如何衡量它


455
00:17:06,306 --> 00:17:09,126
让我们谈谈如何改进它


456
00:17:10,516 --> 00:17:11,715
当你们在代码和工具中


457
00:17:11,715 --> 00:17:13,556
查看 App 的启动时


458
00:17:13,556 --> 00:17:15,136
你们应该记住


459
00:17:15,136 --> 00:17:16,756
这三个提示和技巧


460
00:17:18,205 --> 00:17:20,066
首先是最小化你们的工作


461
00:17:20,066 --> 00:17:22,226
然后优先考虑你们的工作


462
00:17:23,006 --> 00:17:25,205
最后 优化你们的工作


463
00:17:27,016 --> 00:17:28,846
在最小化工作时


464
00:17:28,846 --> 00:17:30,696
你们应该推迟与


465
00:17:31,086 --> 00:17:32,536
生成第一帧无关的任何内容


466
00:17:33,356 --> 00:17:34,746
这意味着推迟


467
00:17:34,746 --> 00:17:36,746
未显示的视图或尚未使用的


468
00:17:36,746 --> 00:17:39,146
预加热功能等内容


469
00:17:41,216 --> 00:17:42,776
你们还应该避免阻塞主线程


470
00:17:42,776 --> 00:17:46,996
比如网络 I/O  文件 I/O 或其他


471
00:17:47,696 --> 00:17:48,836
因为这会影响启动


472
00:17:49,216 --> 00:17:50,826
将其移动到后台线程


473
00:17:51,756 --> 00:17:53,566
最后 你们应该注意


474
00:17:53,566 --> 00:17:56,556
减少内存使用量分配和操作


475
00:17:56,556 --> 00:18:00,686
内存可能需要时间


476
00:18:00,896 --> 00:18:02,286
接下来 优先工作


477
00:18:03,416 --> 00:18:04,206
这时你们应确保以


478
00:18:04,206 --> 00:18:06,976
正确的服务质量安排工作


479
00:18:08,296 --> 00:18:10,306
现在 在 iOS 13 中


480
00:18:10,306 --> 00:18:11,456
我们对排程器进行了


481
00:18:11,456 --> 00:18:14,006
一些令人兴奋的优化


482
00:18:14,006 --> 00:18:15,076
使你们的 App 启动速度更快


483
00:18:15,076 --> 00:18:16,876
但这意味着


484
00:18:16,876 --> 00:18:18,706
保持优先问题跨线程传播工作


485
00:18:18,706 --> 00:18:21,456
比以往任何时候都更加重要


486
00:18:22,196 --> 00:18:24,456
你们应该看看 2017 年 WWDC 的


487
00:18:24,456 --> 00:18:25,536
《Modernizing Grand Central 


488
00:18:25,536 --> 00:18:28,236
Dispatch Usage》


489
00:18:28,566 --> 00:18:30,056
它深入探讨了


490
00:18:30,056 --> 00:18:31,286
如何正确处理并发问题


491
00:18:33,916 --> 00:18:35,566
最后 我们要进行优化工作


492
00:18:36,696 --> 00:18:37,966
这应该是在最小化


493
00:18:37,966 --> 00:18:38,936
并考虑优先级之后


494
00:18:38,936 --> 00:18:40,746
剩下的所有东西了


495
00:18:41,366 --> 00:18:42,526
也就是说它应该是


496
00:18:42,526 --> 00:18:43,976
简化的和有限的


497
00:18:44,726 --> 00:18:46,376
例如 限制仅在


498
00:18:46,376 --> 00:18:48,016
启动期间获取所需


499
00:18:48,016 --> 00:18:50,306
数据的数据量


500
00:18:50,306 --> 00:18:52,186
或者懒计算


501
00:18:52,186 --> 00:18:53,406
所需的任何变量和结果


502
00:18:55,016 --> 00:18:56,486
当你们这样做时


503
00:18:56,486 --> 00:18:57,556
请查看你们的方法和算法


504
00:18:57,556 --> 00:19:00,896
看看你们是否可以优化它们


505
00:19:00,896 --> 00:19:02,196
因为你们可以通过


506
00:19:02,196 --> 00:19:03,596
不同的计算结果或


507
00:19:04,066 --> 00:19:05,006
使用不同的数据结构


508
00:19:05,006 --> 00:19:05,426
来获得显着的改进


509
00:19:06,006 --> 00:19:10,616
最后 你们应该缓存你们的资源和复杂功能


510
00:19:11,396 --> 00:19:12,476
当然 这是通过多次


511
00:19:12,526 --> 00:19:14,386
不必要地工作


512
00:19:14,386 --> 00:19:16,646
来减少 CPU 和内存开销


513
00:19:17,246 --> 00:19:20,506
现在 我想把舞台交给 Dan


514
00:19:20,506 --> 00:19:22,696
Dan 将为你们提供一个


515
00:19:22,696 --> 00:19:24,236
关于如何在 Xcode Instruments 中使用


516
00:19:24,236 --> 00:19:25,496
新的 App 启动模板


517
00:19:25,496 --> 00:19:27,696
来理解和改进我们的 App 发布的精彩演示


518
00:19:28,516 --> 00:19:34,176
[掌声]


519
00:19:34,676 --> 00:19:35,436
>> 谢谢 Spencer


520
00:19:36,336 --> 00:19:38,326
嗨 大家好 我是 Dan Sawada


521
00:19:38,376 --> 00:19:39,786
我也是 Apple 的


522
00:19:39,786 --> 00:19:41,686
性能工程师之一


523
00:19:42,666 --> 00:19:44,276
今天 我将介绍一个了解


524
00:19:44,356 --> 00:19:45,676
你们的 App 启动的


525
00:19:45,846 --> 00:19:47,616
典型工作流程


526
00:19:48,156 --> 00:19:49,686
并寻找最小化 


527
00:19:49,686 --> 00:19:53,886
优先处理 以及优化工作的机会


528
00:19:53,886 --> 00:19:55,166
以便你们可以真正提供


529
00:19:55,416 --> 00:19:57,596
令人愉悦的第一次用户体验


530
00:19:58,836 --> 00:19:59,606
那么 我们开始吧


531
00:19:59,606 --> 00:20:02,096
我今天要展示的 


532
00:20:02,096 --> 00:20:04,496
App 叫做《Star Searcher》


533
00:20:04,856 --> 00:20:06,186
这是我们为此次分享会


534
00:20:06,186 --> 00:20:08,366
专门编写的示例 App


535
00:20:09,106 --> 00:20:10,856
如你们所见


536
00:20:10,856 --> 00:20:13,686
这是一个非常典型的 UITableView


537
00:20:13,746 --> 00:20:14,976
列出了我所有想象中的星星


538
00:20:15,176 --> 00:20:17,556
如果单击单元格或星形


539
00:20:17,556 --> 00:20:19,936
除了图片之外


540
00:20:19,936 --> 00:20:21,436
它还会显示一些


541
00:20:21,436 --> 00:20:22,026
描述性模糊状


542
00:20:23,116 --> 00:20:24,496
但是 我们有一个问题 


543
00:20:25,496 --> 00:20:26,766
先让我们继续并启动它


544
00:20:28,176 --> 00:20:29,676
准备 开始


545
00:20:33,196 --> 00:20:38,926
所以 这需要花费惊人的 2.5 秒才能启动


546
00:20:38,926 --> 00:20:40,546
不知道我是否可以称之为 令人愉快的


547
00:20:40,896 --> 00:20:42,676
所以 让我们使用 Xcode 和


548
00:20:43,016 --> 00:20:44,606
Instruments 来看看


549
00:20:45,016 --> 00:20:46,786
我们能做些什么


550
00:20:49,106 --> 00:20:51,326
所以 这里我们有


551
00:20:51,386 --> 00:20:52,726
《Star Searcher》 的 Xcode 项目


552
00:20:53,456 --> 00:21:01,126
现在 在进行任何与性能相关的分析之前


553
00:21:01,956 --> 00:21:03,576
我们应该做的一件重要事情


554
00:21:03,576 --> 00:21:04,026
是在 Xcode 中选择“Profile”Scheme


555
00:21:04,856 --> 00:21:08,076
这将确保 Xcode 


556
00:21:08,076 --> 00:21:11,816
在发布模式下重新编译你们的 App


557
00:21:11,816 --> 00:21:14,646
以便你们可以利用编译器时间优化


558
00:21:15,716 --> 00:21:17,196
一旦 Xcode 重新编译你们的 App


559
00:21:17,756 --> 00:21:19,026
它将在你们的设备上安装它


560
00:21:19,026 --> 00:21:21,936
并启动 Instruments


561
00:21:22,736 --> 00:21:24,816
现在我们很高兴地宣布


562
00:21:25,056 --> 00:21:28,416
从 iOS 13 或 Xcode 11 开始


563
00:21:28,796 --> 00:21:29,896
我们现在有了


564
00:21:29,896 --> 00:21:31,316
App Launch 模板


565
00:21:31,316 --> 00:21:35,496
专门用于这样的情况


566
00:21:35,496 --> 00:21:36,616
弄清楚 App 启动的问题


567
00:21:37,366 --> 00:21:39,096
那么 让我们继续并


568
00:21:39,806 --> 00:21:42,256
双击 App Launch


569
00:21:42,826 --> 00:21:45,786
现在我们要做的


570
00:21:45,786 --> 00:21:49,876
第一件事就是点按记录按钮


571
00:21:52,776 --> 00:21:54,176
此时 Instruments 将自动


572
00:21:54,176 --> 00:21:57,826
启动我们的 App《Star Searcher》


573
00:21:57,826 --> 00:22:00,016
收集所有指标


574
00:22:00,586 --> 00:22:02,176
遥测数据 分析它们


575
00:22:02,176 --> 00:22:03,756
并为所有 App 启动阶段


576
00:22:03,756 --> 00:22:04,776
创建可视化


577
00:22:05,686 --> 00:22:06,816
所以 看一看


578
00:22:07,396 --> 00:22:09,906
标记为紫色的


579
00:22:09,906 --> 00:22:12,836
前几个阶段是


580
00:22:12,836 --> 00:22:14,316
在 App 中调用 main 函数


581
00:22:14,316 --> 00:22:15,506
之前发生的阶段


582
00:22:17,656 --> 00:22:19,316
在绿色阶段


583
00:22:19,316 --> 00:22:21,356
当你们的 App 完成其启动


584
00:22:21,356 --> 00:22:22,916
并在 UI 中绘制其第一帧


585
00:22:22,916 --> 00:22:24,426
早期的这些过程发生在


586
00:22:24,426 --> 00:22:26,556
你们的主要功能的


587
00:22:26,556 --> 00:22:29,746
第一阶段


588
00:22:29,906 --> 00:22:32,166
让我们继续并展开轨道


589
00:22:32,686 --> 00:22:34,566
在我们展开轨道时


590
00:22:34,716 --> 00:22:36,496
你们可以看到在 App 进程中


591
00:22:36,496 --> 00:22:37,956
响应的所有线程的


592
00:22:37,956 --> 00:22:39,126
详细状态


593
00:22:40,086 --> 00:22:41,966
显然 最重要的一个


594
00:22:41,966 --> 00:22:44,256
是主线程


595
00:22:44,296 --> 00:22:46,106
或者也称为 UI 线程


596
00:22:46,356 --> 00:22:47,936
它负责处理


597
00:22:47,936 --> 00:22:51,016
用户输入和绘制 UI


598
00:22:51,786 --> 00:22:53,416
让我们继续并确定


599
00:22:53,416 --> 00:22:54,646
与我们的目的相关的轨道


600
00:22:54,646 --> 00:22:56,206
从 App 启动阶段开始


601
00:22:56,386 --> 00:22:59,356
我们的主要线程


602
00:22:59,786 --> 00:23:01,436
还有一个工人线程


603
00:23:01,436 --> 00:23:02,616
在启动期间


604
00:23:02,826 --> 00:23:04,546
做了大量的工作


605
00:23:05,476 --> 00:23:08,086
所以 让我们继续下去 并将其


606
00:23:08,976 --> 00:23:10,136
固定下来


607
00:23:11,616 --> 00:23:13,426
说到线程状态 


608
00:23:13,426 --> 00:23:18,226
哎呀 像那样


609
00:23:21,076 --> 00:23:23,596
说到线程状态 


610
00:23:23,596 --> 00:23:24,856
灰色意味着它被阻止


611
00:23:24,856 --> 00:23:26,336
这意味着线程没有做任何工作


612
00:23:27,856 --> 00:23:30,016
红色意味着它可以运行


613
00:23:30,016 --> 00:23:31,546
这意味着计划完成工作


614
00:23:31,546 --> 00:23:34,326
但缺乏 CPU 资源


615
00:23:35,256 --> 00:23:37,046
橙色意味着它被抢先一步


616
00:23:37,166 --> 00:23:39,336
这意味着它正在开展工作


617
00:23:39,566 --> 00:23:41,376
但却被中断


618
00:23:41,466 --> 00:23:44,216
支持其他具有更高优先级的竞争工作


619
00:23:44,856 --> 00:23:47,046
最后但并非不重要的是


620
00:23:47,046 --> 00:23:48,376
蓝色表示它正在运行


621
00:23:48,376 --> 00:23:49,836
这意味着它实际上正在 


622
00:23:49,926 --> 00:23:50,676
CPU 核心上工作


623
00:23:50,676 --> 00:23:53,856
因此 有了这些信息


624
00:23:53,856 --> 00:23:57,266
让我们从系统界面初始化


625
00:23:57,266 --> 00:23:58,516
开始逐步查看


626
00:24:00,036 --> 00:24:01,736
如果我们点按一个阶段三次


627
00:24:02,706 --> 00:24:04,676
我们可以突出显示这个阶段


628
00:24:04,676 --> 00:24:06,016
并在屏幕下半部分


629
00:24:06,016 --> 00:24:07,236
获取详细信息


630
00:24:08,026 --> 00:24:09,776
在你们的左侧


631
00:24:09,776 --> 00:24:12,246
你们可以看到在此时间段内


632
00:24:12,246 --> 00:24:13,376
正在完成的所有工作的


633
00:24:13,376 --> 00:24:14,216
详细栈跟踪


634
00:24:14,926 --> 00:24:17,676
在右侧 你们也可以看到


635
00:24:17,676 --> 00:24:19,176
聚合栈跟踪


636
00:24:19,176 --> 00:24:21,786
其中列出了按 CPU 


637
00:24:21,786 --> 00:24:23,856
样本数量排序的所有符号


638
00:24:24,826 --> 00:24:29,366
现在请注意这个初始阶段


639
00:24:29,736 --> 00:24:32,576
在设置系统接口时只需要 6 毫秒


640
00:24:33,316 --> 00:24:35,196
这主要归功于 


641
00:24:35,196 --> 00:24:37,666
dyld3 的引入


642
00:24:37,946 --> 00:24:39,546
和第三方应 App 的优势


643
00:24:39,546 --> 00:24:42,086
以及其他系统层的增强功能


644
00:24:42,996 --> 00:24:45,316
因此 作为开发者


645
00:24:45,316 --> 00:24:46,706
我们可以利用所有这些


646
00:24:46,706 --> 00:24:49,906
增强功能 而无需编写任何代码


647
00:24:50,876 --> 00:24:54,386
让我们继续来看


648
00:24:54,386 --> 00:24:55,986
但在我们这样做之前


649
00:24:55,986 --> 00:24:56,806
我还应该指出另一件事


650
00:24:57,996 --> 00:25:00,156
请注意 虽然此阶段


651
00:25:00,156 --> 00:25:02,206
仅为《Star Searcher》 的


652
00:25:02,206 --> 00:25:05,876
CPU 占时上花费了 6 毫秒


653
00:25:05,876 --> 00:25:09,186
但它实际上花费了 149 毫秒


654
00:25:09,626 --> 00:25:11,366
这种差异来自


655
00:25:11,406 --> 00:25:13,016
分析机制本身的开销


656
00:25:13,016 --> 00:25:15,376
它确实为我们


657
00:25:15,376 --> 00:25:17,006
提供了大量的信息和想法


658
00:25:17,006 --> 00:25:18,886
但是它有自己的成本 


659
00:25:19,056 --> 00:25:21,156
因此 这就是将分析与


660
00:25:21,156 --> 00:25:23,016
测量结果区分开来


661
00:25:23,176 --> 00:25:24,946
非常重要的原因


662
00:25:25,186 --> 00:25:26,866
稍后我将对此进行解释


663
00:25:27,496 --> 00:25:30,506
进入下一阶段


664
00:25:30,506 --> 00:25:32,276
即静态运行时初始化


665
00:25:32,856 --> 00:25:35,566
现在我们注意到这个阶段


666
00:25:35,566 --> 00:25:38,616
耗时惊人的 375 毫秒


667
00:25:39,046 --> 00:25:40,866
这就有点太长了


668
00:25:42,316 --> 00:25:43,126
那我们来看看吧


669
00:25:43,866 --> 00:25:45,056
查看详细的栈跟踪


670
00:25:45,096 --> 00:25:47,566
我们看到一个带有


671
00:25:47,696 --> 00:25:50,576
蓝色图标的突出显示的符号


672
00:25:50,686 --> 00:25:54,366
标志着 CPU 工作量为 370 毫秒


673
00:25:54,716 --> 00:25:56,186
现在 所有这些突出显示的


674
00:25:56,256 --> 00:25:58,336
符号表示在我们的


675
00:25:58,376 --> 00:25:59,976
源中声明的代码


676
00:26:00,546 --> 00:26:02,796
我们来点按它


677
00:26:08,046 --> 00:26:09,826
现在通过扩展栈跟踪


678
00:26:09,866 --> 00:26:12,426
它将我们指向


679
00:26:12,426 --> 00:26:14,046
SLSuperFastLogger


680
00:26:14,456 --> 00:26:18,496
现在 如果一个库自称超高速（SuperFast）


681
00:26:18,596 --> 00:26:22,496
是有一些可疑的


682
00:26:22,496 --> 00:26:22,706
但还是让我们来看看


683
00:26:23,266 --> 00:26:26,266
那么 SLSuperFastLogger


684
00:26:26,266 --> 00:26:27,786
是我们专门导入 


685
00:26:27,786 --> 00:26:29,926
《Star Searcher》的外部框架


686
00:26:29,926 --> 00:26:34,606
可以利用强大而方便的日志记录


687
00:26:35,556 --> 00:26:37,256
但是 我们调用此框架的


688
00:26:37,256 --> 00:26:41,186
唯一位置是


689
00:26:41,186 --> 00:26:42,556
在 TableViewController 中


690
00:26:43,016 --> 00:26:44,296
具体说来


691
00:26:44,296 --> 00:26:46,146
在 didSelectRowAt 回调中


692
00:26:47,236 --> 00:26:49,816
现在这个回调完全在


693
00:26:49,816 --> 00:26:51,226
启动路径之外


694
00:26:51,406 --> 00:26:53,176
因为它只在用户点按


695
00:26:53,176 --> 00:26:54,026
一个单元格时调用


696
00:26:54,326 --> 00:26:56,616
那么 为什么它在之前的启动期间


697
00:26:56,616 --> 00:27:00,656
甚至在我们的主函数被调用之前


698
00:27:00,656 --> 00:27:02,976
它的工作量超过 300 毫秒呢


699
00:27:03,436 --> 00:27:04,836
好吧 我们来探个究竟


700
00:27:08,476 --> 00:27:10,696
通过搜索符号


701
00:27:10,696 --> 00:27:13,336
它指向我们在


702
00:27:13,376 --> 00:27:14,666
SLSuperFastLogger 类中


703
00:27:14,756 --> 00:27:16,006
声明的加载方法


704
00:27:16,796 --> 00:27:18,026
现在 这是一个


705
00:27:18,026 --> 00:27:20,816
静态初始化程序


706
00:27:20,816 --> 00:27:23,296
这意味着所有这些工作


707
00:27:23,296 --> 00:27:24,976
都将在调用 main 函数之前的


708
00:27:24,976 --> 00:27:26,486
早期启动时完成


709
00:27:26,486 --> 00:27:27,886
因为我们链接了它


710
00:27:28,416 --> 00:27:30,636
这里的重点是


711
00:27:30,636 --> 00:27:33,686
了解依赖在你们使用的


712
00:27:33,686 --> 00:27:37,296
框架中的影响 是非常重要的


713
00:27:38,016 --> 00:27:39,116
外部库和框架可能很方便


714
00:27:39,116 --> 00:27:40,676
也可能很强大


715
00:27:40,676 --> 00:27:42,976
但可能需要付出


716
00:27:42,976 --> 00:27:44,076
巨大的代价


717
00:27:44,456 --> 00:27:48,316
所以 如果这些成本带来了


718
00:27:48,316 --> 00:27:49,796
这些好处 那很好


719
00:27:49,796 --> 00:27:51,606
但对于我们的情况


720
00:27:51,606 --> 00:27:54,166
在启动期间的 300 毫秒


721
00:27:54,166 --> 00:27:55,536
对于它的价值来说有点花费太多了


722
00:27:56,316 --> 00:27:58,496
所以 让我们继续前进


723
00:27:58,496 --> 00:27:59,216
寻求替代方案


724
00:28:00,626 --> 00:28:02,296
在我们的例子中 让我们使用 os.log


725
00:28:02,346 --> 00:28:03,956
这是一个非常轻量级


726
00:28:03,956 --> 00:28:06,226
和高效的日志记录机制


727
00:28:06,226 --> 00:28:08,546
适用于 iOS 以及


728
00:28:08,716 --> 00:28:11,696
其他 Apple 平台


729
00:28:11,696 --> 00:28:15,076
一旦我们删除了依赖


730
00:28:15,076 --> 00:28:17,696
我们一定要记住一件事


731
00:28:18,176 --> 00:28:23,426
即删除实际的链接


732
00:28:23,946 --> 00:28:26,616
现在因为这里的成本


733
00:28:26,706 --> 00:28:28,476
是静态初始化程序


734
00:28:28,916 --> 00:28:31,936
我们需要确保删除链接


735
00:28:31,936 --> 00:28:36,766
以免影响我们


736
00:28:37,106 --> 00:28:40,066
那么 有了这个 让我们回到我们的跟踪


737
00:28:41,076 --> 00:28:44,706
下一阶段是 UIKit 初始化 


738
00:28:44,706 --> 00:28:48,316
实际上耗时 28 毫秒


739
00:28:48,746 --> 00:28:52,186
这几乎是所有 App 的固定成本


740
00:28:53,066 --> 00:28:58,596
除非你们将 UI App 子类化


741
00:28:58,596 --> 00:28:59,966
或在 UIApplicationDelegate 中执行


742
00:28:59,966 --> 00:29:02,136
自定义初始化工作


743
00:29:02,136 --> 00:29:03,196
否则它几乎是我们


744
00:29:03,196 --> 00:29:04,446
现在可以忽略的


745
00:29:04,976 --> 00:29:06,856
那么 让我们继续前进


746
00:29:08,416 --> 00:29:11,296
下一部分工作是


747
00:29:11,336 --> 00:29:13,046
你们的 App 初始化


748
00:29:13,566 --> 00:29:15,586
这基本是由你们控制的


749
00:29:16,146 --> 00:29:18,296
注意到使用 


750
00:29:18,296 --> 00:29:20,116
didFinishLaunchingWithOptions 


751
00:29:20,266 --> 00:29:25,306
回调进行了大量的工作


752
00:29:25,306 --> 00:29:26,736
这在时钟上花费了 791 毫秒


753
00:29:27,086 --> 00:29:28,706
这其实很长


754
00:29:29,546 --> 00:29:32,276
让我们来看看


755
00:29:32,536 --> 00:29:35,056
因此 此阶段立即


756
00:29:35,056 --> 00:29:36,846
指出我们在


757
00:29:36,846 --> 00:29:39,986
StarDataProvider 类中进行了大量工作


758
00:29:41,156 --> 00:29:42,276
也就是在载入星星


759
00:29:42,796 --> 00:29:48,076
好的 现在请注意主线程中


760
00:29:48,076 --> 00:29:50,776
存在巨大的阻塞


761
00:29:50,776 --> 00:29:52,066
这实际上是我们启动的延迟


762
00:29:52,596 --> 00:29:55,896
我们的主线程被阻止了 754 毫秒


763
00:29:56,306 --> 00:29:58,396
这很不理想


764
00:29:59,606 --> 00:30:00,266
让我们来看看


765
00:30:01,926 --> 00:30:03,126
因此 为了检查详细状态


766
00:30:03,126 --> 00:30:07,326
我们应该查看事件列表


767
00:30:09,016 --> 00:30:11,096
通过查看事件列表


768
00:30:11,096 --> 00:30:12,666
我们注意到它被


769
00:30:12,796 --> 00:30:15,756
阻止了 754 毫秒


770
00:30:15,796 --> 00:30:20,376
之后 它被线程 0x12253 解除阻塞


771
00:30:20,376 --> 00:30:22,576
或者说变得可运行了


772
00:30:23,396 --> 00:30:28,316
这对应着正在做大量工作的工人线程


773
00:30:29,636 --> 00:30:31,386
所以 这里有一些联系


774
00:30:32,576 --> 00:30:34,096
现在回到主线程


775
00:30:34,096 --> 00:30:36,256
注意它被安排


776
00:30:36,296 --> 00:30:38,816
在优先级 47 上工作


777
00:30:39,376 --> 00:30:41,356
47 个等同于


778
00:30:41,356 --> 00:30:45,066
用户交互 QoS


779
00:30:45,276 --> 00:30:47,016
现在注意到这些红色交汇处


780
00:30:47,016 --> 00:30:49,606
我们还有很多工作要做


781
00:30:49,646 --> 00:30:51,986
但是他缺少 CPU 资源


782
00:30:52,496 --> 00:30:54,196
好吧 让我们找出原因


783
00:30:55,446 --> 00:30:58,476
当我们点按工人线程时


784
00:30:58,476 --> 00:30:59,836
我们注意到有


785
00:30:59,836 --> 00:31:02,156
很多工作计划在


786
00:31:02,156 --> 00:31:03,456
优先级 4 下工作


787
00:31:03,966 --> 00:31:06,106
这相当于后台 QoS


788
00:31:06,106 --> 00:31:09,116
我们在这里


789
00:31:09,116 --> 00:31:11,326
实际看到的是一种被称为


790
00:31:11,326 --> 00:31:13,176
优先级倒置的问题


791
00:31:13,316 --> 00:31:15,186
其中给定线程被一个比自身


792
00:31:15,186 --> 00:31:17,406
具有更低 QoS 或优先级的


793
00:31:17,906 --> 00:31:19,386
单独线程阻塞


794
00:31:20,176 --> 00:31:21,676
显然 这并不理想


795
00:31:21,936 --> 00:31:23,816
因为它占用的资源


796
00:31:23,816 --> 00:31:25,286
超出了应有的范围


797
00:31:25,736 --> 00:31:30,346
所以 让我们继续尝试解决这个问题


798
00:31:30,346 --> 00:31:32,096
回顾一下这个问题的核心


799
00:31:32,096 --> 00:31:34,826
StarDataProvider 是一个


800
00:31:34,826 --> 00:31:36,576
非常简单的类


801
00:31:36,576 --> 00:31:38,016
它负责从 SQLite 数据库


802
00:31:38,506 --> 00:31:40,396
中获取我们的星星数据


803
00:31:40,396 --> 00:31:42,516
有一个具有


804
00:31:42,516 --> 00:31:44,456
后台 QoS 的专用调度队列


805
00:31:45,296 --> 00:31:47,286
并注意这是


806
00:31:47,286 --> 00:31:48,786
为了确保数据提取


807
00:31:48,786 --> 00:31:50,946
不会与 UI 竞争


808
00:31:50,946 --> 00:31:54,556
并且有两个 API 被暴露


809
00:31:55,246 --> 00:31:56,556
一个用于使用


810
00:31:56,556 --> 00:32:00,846
此 GrandCentralDispatch 的异步原语


811
00:32:00,886 --> 00:32:06,866
和另一个以同步方式加载数据的同步 API


812
00:32:08,446 --> 00:32:10,876
现在看看  


813
00:32:10,876 --> 00:32:12,026
didFinishLaunchingWithOptions


814
00:32:12,026 --> 00:32:13,686
中的实际调用站点


815
00:32:14,776 --> 00:32:15,916
我们正在利用


816
00:32:16,046 --> 00:32:19,486
异步 API


817
00:32:19,486 --> 00:32:20,706
但也利用调度 semaphore


818
00:32:20,816 --> 00:32:23,346
来确保在继续


819
00:32:23,346 --> 00:32:26,706
绘制 TableView 的第一帧之前


820
00:32:26,706 --> 00:32:29,816
等待所有数据都被提取


821
00:32:29,816 --> 00:32:32,626
现在 如果我们要这样做


822
00:32:32,626 --> 00:32:37,376
我们应该使用正确的并发原语


823
00:32:37,696 --> 00:32:41,736
也就是 GCD 中的同步原语


824
00:32:42,306 --> 00:32:45,436
用过使用正确的并发原语


825
00:32:45,746 --> 00:32:47,376
GrandCentralDispatch 将


826
00:32:47,376 --> 00:32:49,186
临时将主线程


827
00:32:49,246 --> 00:32:51,176
的优先级传播到


828
00:32:51,176 --> 00:32:52,626
工人线程 并将其提升为


829
00:32:52,626 --> 00:32:55,206
用户非活动状态


830
00:32:57,376 --> 00:32:57,546
以使其匹配


831
00:32:57,676 --> 00:32:59,986
所以 在这一点上


832
00:32:59,986 --> 00:33:01,916
我认为我们有可能


833
00:33:01,916 --> 00:33:03,186
解决优先级倒置问题


834
00:33:03,186 --> 00:33:04,456
但我还注意这儿


835
00:33:04,456 --> 00:33:05,066
有一个问题


836
00:33:06,326 --> 00:33:09,006
loadStarDataSync API 接受


837
00:33:09,006 --> 00:33:12,576
一系列行来加载数据


838
00:33:13,196 --> 00:33:15,016
在我们的例子中


839
00:33:15,296 --> 00:33:17,776
我们从第 0 行加载到最后一行


840
00:33:17,996 --> 00:33:19,766
这基本上就是一切


841
00:33:20,646 --> 00:33:22,946
现在 当你们考虑它时


842
00:33:22,946 --> 00:33:24,666
第一帧只能适合


843
00:33:24,666 --> 00:33:27,746
可能在屏幕尺寸上的


844
00:33:27,746 --> 00:33:28,706
有限数量的单元格


845
00:33:29,186 --> 00:33:30,506
在《Star Searcher》的情况下


846
00:33:30,986 --> 00:33:32,386
可能大约 10 到 15 个


847
00:33:32,736 --> 00:33:33,636
具体取决于设备


848
00:33:34,186 --> 00:33:36,186
所以 让我们继续并优化它


849
00:33:36,186 --> 00:33:38,086
而不是加载所有内容


850
00:33:38,216 --> 00:33:41,336
让我们只加载前 20 行


851
00:33:41,496 --> 00:33:44,806
就足以以同步方式


852
00:33:44,886 --> 00:33:47,006
绘制 TableView 的第一帧


853
00:33:47,846 --> 00:33:49,606
之后 我们应该在后台


854
00:33:49,606 --> 00:33:51,316
懒加载所有其余的


855
00:33:51,316 --> 00:33:53,156
只在启动后完成后


856
00:33:53,156 --> 00:33:55,566
更新 TableView


857
00:33:58,136 --> 00:33:58,916
让我们继续吧


858
00:33:59,696 --> 00:34:02,006
最后但也很重要的是回到追踪


859
00:34:02,396 --> 00:34:05,046
最后一个阶段是我们的


860
00:34:05,046 --> 00:34:06,256
第一个帧渲染


861
00:34:07,846 --> 00:34:11,126
请注意 这个阶段花了 951 毫秒


862
00:34:11,126 --> 00:34:12,656
这是非常长的


863
00:34:12,656 --> 00:34:15,866
考虑到这只是负责


864
00:34:15,866 --> 00:34:17,556
布局工作和我们


865
00:34:17,556 --> 00:34:18,186
第一帧的渲染


866
00:34:19,606 --> 00:34:22,656
现在让我们更深入地了解它


867
00:34:22,856 --> 00:34:28,206
它指向 StarTableViewController


868
00:34:29,906 --> 00:34:31,896
并查看详细的栈跟踪


869
00:34:31,936 --> 00:34:36,916
我们看到了很多工作和


870
00:34:36,916 --> 00:34:39,755
一个 cellForRowAt 回调


871
00:34:39,755 --> 00:34:42,485
它负责执行单元格的布局工作


872
00:34:42,485 --> 00:34:45,335
让我们继续并扩展我们所说的


873
00:34:46,216 --> 00:34:49,136
当我们扩展栈跟踪时


874
00:34:49,176 --> 00:34:53,815
它指明我们为 StarDetailViewController 进行了


875
00:34:53,815 --> 00:34:56,565
大量的初始化工作


876
00:34:56,565 --> 00:34:59,386
这在 CPU 上耗时 882 毫秒


877
00:34:59,466 --> 00:35:02,586
所以 在这一点上我们已经发现


878
00:35:02,586 --> 00:35:02,976
这几乎是这里的瓶颈


879
00:35:05,046 --> 00:35:06,626
我们来看看我们的代码吧


880
00:35:06,676 --> 00:35:12,416
现在查看 cellforRowAt 回调中的


881
00:35:12,556 --> 00:35:15,746
tableView 控制器


882
00:35:15,746 --> 00:35:17,406
我们使用自定义单元格创建单元格


883
00:35:18,576 --> 00:35:22,976
同时 我们进行推测性优化


884
00:35:22,976 --> 00:35:26,846
预热和缓存 DetailView 的 


885
00:35:27,036 --> 00:35:29,516
DetailViewControllers


886
00:35:29,516 --> 00:35:29,806
就像我们做布局工作一样


887
00:35:30,306 --> 00:35:31,686
这是希望简化从


888
00:35:32,046 --> 00:35:33,806
表格视图到


889
00:35:33,806 --> 00:35:35,266
详细视图的过渡


890
00:35:35,836 --> 00:35:38,456
但正如我们在追踪中所看到的


891
00:35:38,846 --> 00:35:40,126
这并不会产生高成本


892
00:35:41,196 --> 00:35:43,156
现在退一步


893
00:35:43,306 --> 00:35:44,296
当你想到它时


894
00:35:44,296 --> 00:35:45,816
详细的视图对


895
00:35:45,816 --> 00:35:47,356
我们的第一帧没有意义


896
00:35:47,816 --> 00:35:49,126
只有当用户点按


897
00:35:49,126 --> 00:35:50,376
一个单元格时才有意义


898
00:35:51,276 --> 00:35:54,336
所以 让我们继续推迟这项工作


899
00:35:57,356 --> 00:35:58,486
我们应该把它推迟到哪里


900
00:35:59,216 --> 00:36:01,566
也许是 didSelectRowAt 回调这里


901
00:36:01,566 --> 00:36:07,966
当用户点按一个单元格时调用它


902
00:36:09,336 --> 00:36:11,156
因此 此时 我们对 


903
00:36:11,276 --> 00:36:12,526
《Star Searcher》进行了


904
00:36:12,526 --> 00:36:14,316
一些改进或优化


905
00:36:14,466 --> 00:36:15,976
所以 让我们继续并重新分析它


906
00:36:23,086 --> 00:36:26,656
现在需要注意的一点是


907
00:36:26,656 --> 00:36:29,646
当你们进行增量更改时


908
00:36:29,646 --> 00:36:32,046
你们应该在进展时


909
00:36:32,046 --> 00:36:34,076
不断重新测量


910
00:36:34,076 --> 00:36:35,006
和重新分析


911
00:36:35,356 --> 00:36:37,676
这样 你们就可以


912
00:36:37,746 --> 00:36:41,776
真正了解你们增量变更集的确切影响


913
00:36:42,046 --> 00:36:43,416
但是为了这个演示


914
00:36:43,696 --> 00:36:44,916
我们实际上因为


915
00:36:44,916 --> 00:36:49,566
节省时间 把所有变化合并为一个 Boom


916
00:36:49,566 --> 00:36:51,086
有一点 UI 故障


917
00:36:51,086 --> 00:36:54,016
但我们可以立即看到


918
00:36:54,406 --> 00:36:56,456
我们的启动时间不到 500 毫秒


919
00:36:57,186 --> 00:37:02,346
现在 正如我之前所说


920
00:37:02,346 --> 00:37:04,296
分析机制确实带来了


921
00:37:04,296 --> 00:37:05,376
自己的成本


922
00:37:05,636 --> 00:37:06,896
因此 为了更好地了解


923
00:37:06,896 --> 00:37:08,816
我们的用户将


924
00:37:08,816 --> 00:37:11,486
体验到什么


925
00:37:12,476 --> 00:37:15,656
让我们继续使用


926
00:37:16,066 --> 00:37:17,626
新的 XCTest API 来测量


927
00:37:17,626 --> 00:37:18,886
我们测试中的启动性能


928
00:37:20,246 --> 00:37:21,986
只需几行代码


929
00:37:22,176 --> 00:37:23,886
我们就可以将


930
00:37:23,886 --> 00:37:25,876
启动性能测试


931
00:37:25,876 --> 00:37:27,766
或任何性能测试与 XCTest 集成在一起


932
00:37:28,306 --> 00:37:32,446
让我们继续 并启动测试


933
00:37:33,886 --> 00:37:39,636
现在 XCTest 将进行一次一次性的启动测试


934
00:37:39,846 --> 00:37:41,936
这将取消冷启动


935
00:37:42,536 --> 00:37:44,946
会产生的差异


936
00:37:45,466 --> 00:37:47,116
之后 它将执行


937
00:37:47,116 --> 00:37:48,676
指定的迭代次数


938
00:37:48,816 --> 00:37:51,326
或者默认执行


939
00:37:51,436 --> 00:37:54,016
五次迭代 并测量所花费的时间


940
00:37:54,856 --> 00:37:57,176
之后 它将产生一些


941
00:37:57,176 --> 00:38:01,986
很好的统计数据


942
00:38:02,186 --> 00:38:06,236
这项测试需要几分钟才能完成


943
00:38:06,236 --> 00:38:09,986
现在我们已经将《Star Searcher》的启动


944
00:38:10,106 --> 00:38:12,696
从 2.5 秒推到了


945
00:38:13,066 --> 00:38:16,536
刚刚超过 300 毫秒


946
00:38:17,031 --> 00:38:19,031
[掌声]


947
00:38:19,046 --> 00:38:21,346
为了结束演示


948
00:38:21,346 --> 00:38:22,136
我想向你们展示


949
00:38:22,686 --> 00:38:23,726
UI 上的实际情况


950
00:38:24,606 --> 00:38:26,276
好了 让我们确保漂亮得完成了


951
00:38:26,276 --> 00:38:29,126
《Star Searcher》真的很快


952
00:38:30,516 --> 00:38:33,500
[掌声]


953
00:38:38,056 --> 00:38:39,946
谢谢你们 交回给你 Spencer


954
00:38:41,516 --> 00:38:45,376
[掌声]


955
00:38:45,876 --> 00:38:47,066
>> 多谢 Dan 关于如何使用


956
00:38:47,066 --> 00:38:49,076
Xcode Instruments


957
00:38:49,486 --> 00:38:51,746
App Launch 模板


958
00:38:52,006 --> 00:38:53,766
来改善我们的 App 启动体验的精彩演示


959
00:38:54,526 --> 00:38:57,226
好的 我们意识到


960
00:38:57,226 --> 00:38:59,816
在你们的代码库中


961
00:38:59,816 --> 00:39:01,766
你们不会在代码中


962
00:39:01,766 --> 00:39:03,356
找到几个可以用几行修复的地方


963
00:39:03,356 --> 00:39:06,516
并获得如此重大的改进


964
00:39:07,546 --> 00:39:10,356
你很可能必须找到一堆


965
00:39:10,356 --> 00:39:12,396
5 到 10 毫秒的胜利


966
00:39:12,396 --> 00:39:13,586
然后将所有这些组合在一起


967
00:39:14,816 --> 00:39:15,866
我们想让你们知道


968
00:39:15,866 --> 00:39:16,396
我们已经在背后支持你们了


969
00:39:17,746 --> 00:39:20,146
我们已经进行了


970
00:39:20,146 --> 00:39:21,636
大量的 iOS 优化以改善


971
00:39:21,636 --> 00:39:23,146
你们的 App 的推出


972
00:39:23,146 --> 00:39:26,076
并帮助你们实现目标


973
00:39:26,076 --> 00:39:27,016
而你们几乎没有采用


974
00:39:28,016 --> 00:39:30,396
我想特别呼吁采用一些


975
00:39:30,956 --> 00:39:36,256
如前所述 dyld3 将运行时依赖项


976
00:39:36,256 --> 00:39:38,056
缓存到你们的 App 中


977
00:39:38,056 --> 00:39:39,276
你们在演示中看到了这些依赖项


978
00:39:39,426 --> 00:39:40,976
这提供了巨大的改进


979
00:39:41,496 --> 00:39:43,606
排程器还经过优化


980
00:39:43,606 --> 00:39:45,626
以帮助确定启动期间


981
00:39:45,626 --> 00:39:47,236
发生的工作的优先级


982
00:39:48,026 --> 00:39:50,126
我们还仔细看了 Auto Layout


983
00:39:50,126 --> 00:39:51,646
和 Objective-C


984
00:39:51,956 --> 00:39:53,736
并在那里进行了一系列优化


985
00:39:54,896 --> 00:39:56,526
最后 我们将在今年晚些时候


986
00:39:56,526 --> 00:39:57,566
对 App 打包进行


987
00:39:57,766 --> 00:39:59,386
激动人心的更改


988
00:40:00,436 --> 00:40:02,216
我们认为这些变化


989
00:40:02,216 --> 00:40:03,786
总会导致你们几乎没有


990
00:40:03,786 --> 00:40:09,176
采用优化的 App 的大幅改进


991
00:40:09,316 --> 00:40:10,956
所以 让我们总结


992
00:40:10,956 --> 00:40:12,316
一些提示和技巧


993
00:40:12,316 --> 00:40:13,266
了解如何在完成


994
00:40:13,306 --> 00:40:14,976
所有这些工作后确保你们的 App 令人愉悦


995
00:40:19,076 --> 00:40:20,276
首先 不要让性能


996
00:40:20,276 --> 00:40:21,546
成为事后的想法


997
00:40:22,326 --> 00:40:24,136
你们应该在每个 Bug 


998
00:40:24,136 --> 00:40:25,566
修复的开始


999
00:40:25,696 --> 00:40:27,036
每个参数改动的开始


1000
00:40:27,736 --> 00:40:30,316
以及每个功能研发的开始时


1001
00:40:30,316 --> 00:40:30,956
考虑并研究它


1002
00:40:32,286 --> 00:40:35,316
这是因为 引入回归非常容易


1003
00:40:35,756 --> 00:40:38,216
特别是像 2 毫秒这样的小回归


1004
00:40:39,026 --> 00:40:40,616
问题是这些小问题


1005
00:40:40,616 --> 00:40:43,026
加起来是一个大问题


1006
00:40:43,026 --> 00:40:45,576
如果你不立即解决它们


1007
00:40:45,576 --> 00:40:46,336
就很难找到它们


1008
00:40:46,336 --> 00:40:49,536
为了做到这一点 


1009
00:40:49,536 --> 00:40:51,096
为了要检测这些回归


1010
00:40:51,096 --> 00:40:52,926
你们应该定期绘制 App 的启动


1011
00:40:52,926 --> 00:40:54,896
并定期运行测试


1012
00:40:55,646 --> 00:40:58,016
这将确保你们达到目标


1013
00:40:58,016 --> 00:40:59,446
并立即知道你们


1014
00:40:59,446 --> 00:41:03,896
是否已回归了该目标


1015
00:41:03,986 --> 00:41:05,946
你们还应该看看


1016
00:41:05,946 --> 00:41:08,416
新的 Xcode 管理器


1017
00:41:08,816 --> 00:41:09,736
它可以让你们了解


1018
00:41:09,776 --> 00:41:10,586
你们 App 在现场的表现


1019
00:41:11,666 --> 00:41:13,366
在 iOS 13 中 对于已选择加入的用户


1020
00:41:13,366 --> 00:41:15,756
将收集有关你们 App 的


1021
00:41:15,756 --> 00:41:17,256
耗电和性能指标


1022
00:41:18,296 --> 00:41:19,816
然后 它们将在


1023
00:41:19,816 --> 00:41:21,456
24 小时内汇总


1024
00:41:21,456 --> 00:41:22,886
并发送回你们的组织者


1025
00:41:22,886 --> 00:41:25,936
你们可以通过软件版本和设备版本 


1026
00:41:25,936 --> 00:41:26,796
以直方图的形式查看它们


1027
00:41:28,136 --> 00:41:29,726
但是 如果你们希望


1028
00:41:29,726 --> 00:41:31,026
对该数据进行更多控制


1029
00:41:31,916 --> 00:41:33,236
你们可以采用 MetricKit


1030
00:41:34,636 --> 00:41:36,406
MetricKit 允许你们


1031
00:41:36,616 --> 00:41:38,386
指定自定义功率和性能指标


1032
00:41:39,886 --> 00:41:41,236
现在 与组织者一样


1033
00:41:41,236 --> 00:41:42,486
这些数据将在


1034
00:41:42,486 --> 00:41:44,046
24 小时内收集和汇总


1035
00:41:44,046 --> 00:41:46,226
然后通过你们 App 


1036
00:41:46,266 --> 00:41:49,276
中的授权方法 传回给你们


1037
00:41:50,066 --> 00:41:51,186
从那里开始 你们就可以


1038
00:41:51,186 --> 00:41:52,686
随意处理数据


1039
00:41:53,696 --> 00:41:54,976
要了解更多相关信息


1040
00:41:54,976 --> 00:41:55,846
我们建议你们查看


1041
00:41:55,996 --> 00:41:57,066
2019 年 WWDC 中的


1042
00:41:57,066 --> 00:41:59,846
提升电池寿命和性能


1043
00:42:03,096 --> 00:42:05,566
那么 总而言之


1044
00:42:05,756 --> 00:42:07,736
我们今天非常开心


1045
00:42:07,736 --> 00:42:09,146
通过 Xcode Instruments 中的新


1046
00:42:09,146 --> 00:42:10,596
App Lauch 模板开始


1047
00:42:10,596 --> 00:42:11,116
了解你们 App 的启动


1048
00:42:11,916 --> 00:42:12,616
看看你们是否能


1049
00:42:12,616 --> 00:42:16,816
找到最小化 最优排序和


1050
00:42:17,536 --> 00:42:17,626
优化你们工作的机会


1051
00:42:18,836 --> 00:42:21,036
接下来 虽然意图很好


1052
00:42:21,276 --> 00:42:22,786
但并非所有优化都能成功得到


1053
00:42:23,586 --> 00:42:24,596
例如 Dan 在他的演示中


1054
00:42:24,596 --> 00:42:26,936
提到的预热 DetailView 控制器


1055
00:42:27,936 --> 00:42:30,026
因此 每当你们进行更改时


1056
00:42:30,026 --> 00:42:32,596
请务必测量而不是


1057
00:42:32,596 --> 00:42:33,406
大致估计性能


1058
00:42:34,026 --> 00:42:35,646
再说一次 无意中


1059
00:42:35,646 --> 00:42:37,566
引入回归 非常容易


1060
00:42:38,956 --> 00:42:40,496
最后 你们应该


1061
00:42:40,496 --> 00:42:41,916
在开发的所有阶段


1062
00:42:41,916 --> 00:42:42,566
跟踪你们的表现


1063
00:42:43,576 --> 00:42:44,696
这意味着在各种设备上


1064
00:42:44,696 --> 00:42:48,826
使用新的 XCTest App 启动测量


1065
00:42:48,826 --> 00:42:50,156
并可能将其与


1066
00:42:50,156 --> 00:42:52,006
持续集成相结合


1067
00:42:53,176 --> 00:42:54,216
这将确保你们


1068
00:42:54,216 --> 00:42:57,356
始终为所有设备上的所有用户


1069
00:42:57,356 --> 00:42:59,546
提供令人愉快的 App 启动


1070
00:43:02,206 --> 00:43:03,896
有关更多信息


1071
00:43:03,896 --> 00:43:04,646
请查看我们今天


1072
00:43:04,646 --> 00:43:06,806
引用的会议


1073
00:43:06,806 --> 00:43:07,756
然后在周五下午


1074
00:43:07,756 --> 00:43:08,806
好好休息一下 多谢你们


1075
00:43:09,516 --> 00:43:12,500
[掌声]

