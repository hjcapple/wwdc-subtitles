1
00:00:06,974 --> 00:00:08,942 line:0
你好
我是Simon Gladman


2
00:00:09,009 --> 00:00:11,011 line:0
我是矢量和数字团队的一员


3
00:00:11,345 --> 00:00:14,515 line:0
在本次演讲中
我会介绍两个主题


4
00:00:14,581 --> 00:00:17,718 line:0
第一是我们为Accelerate
设计新Swift Overlay


5
00:00:17,784 --> 00:00:20,320 line:0
第二个是使用LINPACK
基准来测试Accelerate


6
00:00:20,387 --> 00:00:22,122 line:0
的性能表现


7
00:00:22,189 --> 00:00:24,224 line:-2
在我们深入了解
Swift Overlay之前


8
00:00:24,291 --> 00:00:28,028 line:-2
我们来确切地回顾一下
什么是Accelerate框架


9
00:00:29,229 --> 00:00:31,098 line:-1
Accelerate的主要使用


10
00:00:31,164 --> 00:00:34,034 line:-2
目的是提供许多
低级数学基元


11
00:00:34,101 --> 00:00:37,704 line:-2
它在CPU上运行
支持图片和信号处理


12
00:00:37,771 --> 00:00:41,375 line:-2
向量运算 线性代数
和机器学习


13
00:00:41,808 --> 00:00:46,180 line:-2
这些基元大多数是通过手动调整
给处理器的微体系结构的


14
00:00:46,246 --> 00:00:48,715 line:-1
这意味着我们获取了极佳的性能表现


15
00:00:48,782 --> 00:00:53,053 line:-1
这个性能表现会直接转变为节能


16
00:00:53,620 --> 00:00:54,888 line:-1
那么 如果你是一个app开发者


17
00:00:54,955 --> 00:00:56,757 line:-1
使用Accelerate框架


18
00:00:56,823 --> 00:00:59,393 line:-1
不仅会让你的app运行更快


19
00:00:59,459 --> 00:01:02,062 line:-1
你的电池寿命也会更长


20
00:01:03,497 --> 00:01:07,000 line:-2
我们提供的基元能
在所有的Apple平台运行


21
00:01:07,067 --> 00:01:11,305 line:-1
这不只包含macOS和iOS


22
00:01:11,371 --> 00:01:15,075 line:-2
也同样支持
watchOS和tvOS


23
00:01:15,742 --> 00:01:20,080 line:-2
这意味着你的用户能
获得一致的更好体验


24
00:01:21,582 --> 00:01:23,951 line:-1
Accelerate库非常强大


25
00:01:24,017 --> 00:01:24,952 line:-1
但到现在为止


26
00:01:25,018 --> 00:01:28,355 line:-2
它们的用户界面对
Swift开发者还不太友好


27
00:01:28,822 --> 00:01:30,190 line:-1
我们来看一下四个库


28
00:01:30,257 --> 00:01:32,693 line:-2
以及新创建的对
Swift友好的API


29
00:01:32,759 --> 00:01:36,096 line:-2
来使得在Swift项目中使用
Accelerate变得非常简单


30
00:01:36,496 --> 00:01:39,099 line:-1
关于这四个库 我们将主要关注：


31
00:01:39,433 --> 00:01:42,970 line:-2
vDSP提供的
数字信号处理运算


32
00:01:43,036 --> 00:01:46,773 line:-2
包括对大向量的运算
傅里叶变换


33
00:01:46,840 --> 00:01:50,110 line:-2
双二次过滤
和强大的类型转换


34
00:01:51,278 --> 00:01:54,882 line:-1
vForce提供的运算和超越函数


35
00:01:54,948 --> 00:01:58,118 line:-1
包括三角和对数运算


36
00:01:58,785 --> 00:02:03,123 line:-1
正交提供的函数的数值积分


37
00:02:03,891 --> 00:02:07,961 line:-2
vImage提供了一个多种类
的图像处理函数


38
00:02:08,027 --> 00:02:11,131 line:-2
它已被集成至Core Graphics
和Core Video


39
00:02:12,232 --> 00:02:16,136 line:-2
Accelerate通过向量化
来实现它优异的性能表现


40
00:02:17,304 --> 00:02:18,839 line:-1
为了了解向量化


41
00:02:18,906 --> 00:02:21,074 line:-1
我们首先来看一下一个简单的运算


42
00:02:21,141 --> 00:02:24,144 line:-1
在一个数组的元素中使用标量的代码


43
00:02:24,745 --> 00:02:26,914 line:-1
如果 比如你写的代码


44
00:02:26,980 --> 00:02:31,952 line:-2
一个数组中的每个元素和
另一个数组对应的元素相乘


45
00:02:32,019 --> 00:02:33,854 line:-1
你使用了一个for循环


46
00:02:33,921 --> 00:02:36,123 line:-1
每对元素都被分散地加载


47
00:02:36,190 --> 00:02:39,159 line:-2
相互相乘
保存结果


48
00:02:39,526 --> 00:02:42,829 line:-2
那么 当a和b中的第一个元素
相乘之后


49
00:02:42,896 --> 00:02:45,332 line:-1
成为c的第一个元素


50
00:02:45,399 --> 00:02:47,167 line:-1
第二对被处理了


51
00:02:48,068 --> 00:02:49,169 line:-1
接着 是第三对


52
00:02:49,970 --> 00:02:52,172 line:-1
以及 最后是第四对


53
00:02:55,042 --> 00:02:57,411 line:-2
不过 如果你在
处理一个数组里的元素


54
00:02:57,477 --> 00:02:58,612 line:-1
使用Accelerate


55
00:02:58,679 --> 00:03:02,449 line:-2
你的运算会在
单指令多数据中被实现


56
00:03:02,516 --> 00:03:04,184 line:-1
或simD寄存器


57
00:03:04,651 --> 00:03:06,820 line:-1
这些寄存器能


58
00:03:06,887 --> 00:03:08,689 line:-1
在多个数据项中执行相同的指令


59
00:03:08,755 --> 00:03:11,792 line:-2
通过将多个这些物件打包成
一个单个的寄存器


60
00:03:12,125 --> 00:03:15,462 line:-1
比如一个单个128位的寄存器


61
00:03:15,529 --> 00:03:19,833 line:-2
实际上能存储
4个32位的浮点值


62
00:03:19,900 --> 00:03:21,768 line:-1
所以 一个矢量乘法操作


63
00:03:21,835 --> 00:03:25,706 line:-1
能同时相乘4对元素


64
00:03:26,306 --> 00:03:29,042 line:-1
这意味着这个任务不仅会被加速执行


65
00:03:29,109 --> 00:03:32,212 line:-1
它也会更显著地节能


66
00:03:34,581 --> 00:03:36,316 line:-1
我们刚才看到的乘法函数


67
00:03:36,383 --> 00:03:40,721 line:-2
是Accelerate的数字
信号处理库vDSP的一部分


68
00:03:40,787 --> 00:03:43,690 line:-2
那么 我们从新的Swift
API是怎样通过


69
00:03:43,757 --> 00:03:46,260 line:-1
使用vDSP简化使用方式来开始吧


70
00:03:48,529 --> 00:03:52,466 line:-2
vDSP提供了矢量化数字
信号处理功能


71
00:03:52,533 --> 00:03:54,601 line:-1
包括傅里叶变换


72
00:03:54,935 --> 00:03:56,570 line:-1
双二次过滤


73
00:03:56,937 --> 00:03:59,239 line:-1
卷积和相关


74
00:03:59,740 --> 00:04:04,011 line:-2
更进一步 vDSP也提供了
一些强大的更常规的功能


75
00:04:04,077 --> 00:04:08,248 line:-1
包括元素级算术和类型转换


76
00:04:09,082 --> 00:04:11,652 line:-1
所以 即使你还没有一个迫切需求


77
00:04:11,718 --> 00:04:14,621 line:-1
比如计算两个信号之间的连贯性


78
00:04:14,688 --> 00:04:18,524 line:-2
你可能会发现
vDSP的常规运算程序


79
00:04:18,591 --> 00:04:21,862 line:-2
为你app的性能表现
提供了一个解决方案


80
00:04:24,665 --> 00:04:27,301 line:-1
我们来看看一些基本的运算


81
00:04:27,367 --> 00:04:28,869 line:-1
一个例子：


82
00:04:28,936 --> 00:04:31,972 line:-1
已知4个单精度值的数组


83
00:04:32,039 --> 00:04:33,006 line:-1
你需要计算


84
00:04:33,073 --> 00:04:35,275 line:-1
数组的二乘二的元素和


85
00:04:35,642 --> 00:04:37,711 line:-1
其他两个的各个元素都不同


86
00:04:37,778 --> 00:04:40,280 line:-1
使用一个for循环


87
00:04:41,682 --> 00:04:42,549 line:-1
来互乘这些结果


88
00:04:42,616 --> 00:04:45,185 line:-1
是这个问题的一个非常合理的选择


89
00:04:45,252 --> 00:04:47,621 line:-1
以及计算这些预期结果


90
00:04:48,422 --> 00:04:53,060 line:-2
这是你如何使用vDSP
经典的API来计算性能


91
00:04:53,560 --> 00:04:58,298 line:-2
使用vDSP大约比for
循环快三倍


92
00:04:59,566 --> 00:05:03,937 line:-2
这是使用我们新的为vDSP
设计Swift API相同的运算


93
00:05:04,438 --> 00:05:06,773 line:-2
我们暴露了
新的Swift友好的函数


94
00:05:06,840 --> 00:05:08,609 line:-1
通过我们的vDSP的命名空间


95
00:05:08,675 --> 00:05:12,312 line:-2
你能看到函数和
参数名称解释了操作


96
00:05:12,946 --> 00:05:15,115 line:-1
因为新的函数使用了相似的类型


97
00:05:15,182 --> 00:05:18,151 line:-2
包括数组和数组分片
而不是指针


98
00:05:18,218 --> 00:05:21,088 line:-1
你不再需要明确地传递数值


99
00:05:21,255 --> 00:05:25,325 line:-2
所以整个函数调用更直观
和更简洁了


100
00:05:27,027 --> 00:05:28,996 line:-1
传递一个初始化结果数组


101
00:05:29,062 --> 00:05:30,731 line:-1
提供了最好的性能表现


102
00:05:30,797 --> 00:05:33,934 line:-2
为了进一步的性能提升
你当然可以在其他操作中


103
00:05:34,001 --> 00:05:36,336 line:-1
重复使用那个数组


104
00:05:37,137 --> 00:05:41,074 line:-2
不过 我们也提供了
自调度函数


105
00:05:41,141 --> 00:05:46,180 line:-2
这些利用了Swift新的功能
来访问一个数组里未初始化的缓冲


106
00:05:46,246 --> 00:05:48,682 line:-1
返回运算的结果


107
00:05:49,183 --> 00:05:52,219 line:-2
虽然没有传递
现有的存储那么快


108
00:05:52,286 --> 00:05:54,421 line:-1
它还是比标量方式要快的


109
00:05:54,488 --> 00:05:57,891 line:-2
以及 在一些使用场景
它会简化你的代码


110
00:06:00,194 --> 00:06:02,796 line:-2
另一个常见的任务是
vDSP能够矢量化的


111
00:06:02,863 --> 00:06:04,498 line:-1
是类型转换


112
00:06:04,565 --> 00:06:08,335 line:-2
这个例子将一个具有双精度值
的数组转换为


113
00:06:08,402 --> 00:06:12,940 line:-2
16位的无符号整数的值
舍入到零


114
00:06:14,875 --> 00:06:18,378 line:-1
标量版本使用了显式四舍五入映射


115
00:06:18,445 --> 00:06:21,682 line:-2
再一次 这是一个
完全合理的技术使用


116
00:06:21,748 --> 00:06:25,786 line:-2
但vDSP能矢量化这个任务来
提升性能


117
00:06:27,254 --> 00:06:28,222 line:-1
在这个例子中


118
00:06:28,288 --> 00:06:34,061 line:-2
vDSP大约比之前的
标量实现快4倍


119
00:06:35,996 --> 00:06:40,400 line:-2
vDSP函数所在的新的Swift
版本提供了一个清晰的接口


120
00:06:40,634 --> 00:06:42,903 line:-1
这个函数获取一个源函数


121
00:06:42,970 --> 00:06:45,806 line:-1
你应该将每个元素转换成整型


122
00:06:45,873 --> 00:06:48,408 line:-1
和一个枚举来指定rounding


123
00:06:51,979 --> 00:06:54,381 line:-1
vDSP提供了傅里叶变换


124
00:06:54,448 --> 00:06:57,651 line:-1
在时域和频域之间


125
00:06:57,718 --> 00:07:00,187 line:-1
将一维数据转换至二维数据


126
00:07:01,588 --> 00:07:03,891 line:-1
一个信号的正向傅里叶变换


127
00:07:03,957 --> 00:07:06,860 line:-1
分解它成为它的组件的信号波


128
00:07:06,927 --> 00:07:09,429 line:-1
那就是频域所代表的


129
00:07:10,030 --> 00:07:14,134 line:-1
相反地 一个频域所展现的逆变换


130
00:07:14,201 --> 00:07:16,036 line:-1
重建了原始信号


131
00:07:16,103 --> 00:07:18,438 line:-1
那是时域所展现的


132
00:07:19,273 --> 00:07:23,377 line:-2
傅里叶变换在信号和
图像处理中有许多应用


133
00:07:23,443 --> 00:07:27,114 line:-1
比如只要一个音频信号被正向转换了


134
00:07:27,181 --> 00:07:31,919 line:-2
你可以很容易的减小或
增大一定的频率来平衡音频


135
00:07:33,253 --> 00:07:35,689 line:-1
经典的API是易于理解的


136
00:07:35,756 --> 00:07:37,124 line:-1
如果你对它熟悉


137
00:07:37,191 --> 00:07:39,293 line:-1
你从创建设置对象开始


138
00:07:39,359 --> 00:07:43,096 line:-2
指定元素的数量
你想要的转换和定位


139
00:07:43,430 --> 00:07:46,466 line:-2
接着
在创建完两个数组来获取结果之后


140
00:07:46,533 --> 00:07:48,368 line:-1
你调用执行函数


141
00:07:48,435 --> 00:07:50,904 line:-2
只要你在结束之后
你需要记得销毁设置


142
00:07:50,971 --> 00:07:53,473 line:-1
来释放为它分配的资源


143
00:07:54,808 --> 00:07:58,946 line:-1
新的API简化了设置对象的实例化


144
00:07:59,413 --> 00:08:02,583 line:-1
转换本身是一个带有


145
00:08:02,649 --> 00:08:04,484 line:-1
DFT实例参数名字的方法


146
00:08:04,551 --> 00:08:07,588 line:-1
现在 你不需要担心释放资源


147
00:08:07,654 --> 00:08:09,122 line:-1
我们会为你实现


148
00:08:11,024 --> 00:08:13,794 line:-1
就像我们看到的vDSP函数


149
00:08:13,861 --> 00:08:16,997 line:-1
它有一个自调度版本的转换函数


150
00:08:17,064 --> 00:08:20,501 line:-1
它为你创建和返回返回值的数组


151
00:08:24,004 --> 00:08:25,506 line:-1
如果你使用音频数据


152
00:08:25,572 --> 00:08:29,243 line:-2
你可能会熟悉双二次或
双二阶滤波器


153
00:08:29,643 --> 00:08:32,044 line:-1
双二阶滤波器能用来平衡音频


154
00:08:32,111 --> 00:08:33,746 line:-1
来形成频率响应


155
00:08:33,813 --> 00:08:38,519 line:-2
比如 它允许你能
移除低或高的频率


156
00:08:39,720 --> 00:08:41,421 line:-1
vDSP的双二阶功能


157
00:08:41,488 --> 00:08:44,458 line:-1
处理单个或多声道信号


158
00:08:44,525 --> 00:08:46,793 line:-1
使用一组单个过滤器


159
00:08:46,860 --> 00:08:48,262 line:-1
叫做sections的对象


160
00:08:48,328 --> 00:08:49,696 line:-1
过滤器是级联的


161
00:08:49,763 --> 00:08:51,832 line:-1
就是说它们是按顺序排列的


162
00:08:51,899 --> 00:08:55,536 line:-1
整个信号依次通过每个过滤器


163
00:08:56,003 --> 00:08:58,605 line:-1
过滤器被定义为一系列系数


164
00:08:58,672 --> 00:09:00,541 line:-1
它会被代入这里的这个方程中


165
00:09:03,544 --> 00:09:06,713 line:-2
在这里例子中
这些值来自一个低通滤波器


166
00:09:06,780 --> 00:09:09,683 line:-2
就是说
一种减少高频的滤波器


167
00:09:09,750 --> 00:09:12,853 line:-1
这是使用vDSP经典的API代码


168
00:09:12,920 --> 00:09:14,321 line:-1
来创建双二阶设置


169
00:09:14,388 --> 00:09:17,057 line:-1
使用之前的幻灯片的系数


170
00:09:18,091 --> 00:09:18,959 line:-1
这里是


171
00:09:19,026 --> 00:09:22,496 line:-2
运用双二阶过滤器
到一个叫做signal的数组


172
00:09:22,563 --> 00:09:25,566 line:-2
返回返回值到一个
叫做output的数组的代码


173
00:09:26,099 --> 00:09:30,170 line:-2
我们来看一下使用一个
新的API来实现相同的功能


174
00:09:32,072 --> 00:09:33,240 line:-1
如你所见


175
00:09:33,307 --> 00:09:37,244 line:-2
新的API大大地简化了
双二阶结构的创建


176
00:09:37,644 --> 00:09:40,781 line:-2
你很容易地传递
系数到双二阶初始化函数


177
00:09:40,848 --> 00:09:43,584 line:-1
指定频道的数量和部分


178
00:09:45,018 --> 00:09:48,589 line:-2
将双二阶过滤器运用到一个信号
是一个单次函数调用


179
00:09:52,693 --> 00:09:55,996 line:-2
现在我们来看一下新的API
我们为Accelerate的库


180
00:09:56,063 --> 00:10:00,601 line:-2
和对大的数组
vForce快速的数学运算创建的


181
00:10:01,969 --> 00:10:06,273 line:-2
vForce提供了vDSP
所没有的超越函数


182
00:10:06,540 --> 00:10:10,611 line:-1
这些包括指数 对数和三角操作


183
00:10:12,279 --> 00:10:13,981 line:-1
一个vForce的典型的例子


184
00:10:14,047 --> 00:10:17,618 line:-2
可能被用来计算一个大数组中
每个元素的平方根


185
00:10:18,018 --> 00:10:20,621 line:-1
这段代码的标量版本可以使用映射


186
00:10:22,256 --> 00:10:26,393 line:-2
vForce提供了一个矢量化函数
来计算平方根


187
00:10:26,460 --> 00:10:29,563 line:-1
在一些使用场合 它会


188
00:10:29,630 --> 00:10:31,632 line:-1
比标量的实现快10倍以上


189
00:10:33,166 --> 00:10:34,501 line:-1
新的Swift Overlay


190
00:10:34,568 --> 00:10:38,639 line:-2
提供了一个和vDSP
函数一致的新API


191
00:10:38,705 --> 00:10:41,742 line:-1
提供了向量化的性能表现


192
00:10:41,808 --> 00:10:43,243 line:-1
和能源效率的好处


193
00:10:45,245 --> 00:10:46,613 line:-1
就和我们早些时候看到的很类似


194
00:10:46,680 --> 00:10:49,783 line:-2
这是一个自调度版本
它会返回一个数组


195
00:10:49,850 --> 00:10:52,986 line:-2
包含了提供的数组中
每个元素的平方根


196
00:10:57,057 --> 00:11:01,161 line:-2
接下来 我们来看看我们
为正交创建的新的API


197
00:11:02,596 --> 00:11:06,667 line:-2
正交是判定一条曲线下区域
的一项有历史意义的条款


198
00:11:07,367 --> 00:11:10,737 line:-1
它提供了一个在有限或无限区间内


199
00:11:10,804 --> 00:11:13,674 line:-1
近似明确的集成函数


200
00:11:14,274 --> 00:11:18,579 line:-2
在示例中 我们会使用
正交来估量半圆的面积


201
00:11:18,645 --> 00:11:22,683 line:-2
这里的绿色的部分
通过对所示函数进行积分


202
00:11:25,352 --> 00:11:27,855 line:-1
很像vDSP的双二阶代码


203
00:11:27,921 --> 00:11:32,693 line:-2
需要相当多的代码来使用
已有的正交的API


204
00:11:33,293 --> 00:11:38,198 line:-2
第一步是定义一个
描述要集成函数的结构体


205
00:11:40,100 --> 00:11:42,936 line:-1
第二步是定义集成选项


206
00:11:43,003 --> 00:11:45,239 line:-1
包括集成算法


207
00:11:46,607 --> 00:11:49,643 line:-2
最后
使用选项定义的函数


208
00:11:49,710 --> 00:11:53,714 line:-1
你能使用正交积分函数来进行整合


209
00:11:56,416 --> 00:11:58,919 line:-1
新的API简化了代码


210
00:11:58,986 --> 00:12:02,022 line:-1
好处之一是你能指定被积函数


211
00:12:02,089 --> 00:12:04,157 line:-1
就是说 被集成的函数


212
00:12:04,224 --> 00:12:07,661 line:-2
作为一个交易的闭包
而不是一个C函数的指针


213
00:12:07,728 --> 00:12:10,731 line:-2
这意味着你能很容易的传值到
被积函数


214
00:12:12,266 --> 00:12:16,670 line:-2
你也要留意积分器现在
是拥有关联值的枚举


215
00:12:16,737 --> 00:12:20,007 line:-1
所以每次间隔无需提供没有必要的点


216
00:12:20,073 --> 00:12:21,742 line:-1
或是这里的最大间隔


217
00:12:23,143 --> 00:12:24,178 line:-1
比如


218
00:12:24,244 --> 00:12:27,514 line:-1
你可以传递枚举给全局自适应积分器


219
00:12:27,581 --> 00:12:31,318 line:-1
为间隔和最大间隔指定点


220
00:12:35,155 --> 00:12:37,424 line:-2
现在
我们来看一下我们为


221
00:12:37,491 --> 00:12:40,761 line:-2
Accelerate图像处理库
vImage创建的新的API


222
00:12:41,929 --> 00:12:43,497 line:-1
vImage是一个包含了


223
00:12:43,564 --> 00:12:46,333 line:-1
丰富的图片处理工具集的库


224
00:12:46,667 --> 00:12:52,139 line:-2
它被设计在Core Graphics
和Core Video间无缝运作


225
00:12:52,873 --> 00:12:55,776 line:-1
它包含了比如阿尔法混合


226
00:12:56,510 --> 00:12:58,612 line:-1
格式转换


227
00:12:58,679 --> 00:13:00,781 line:-1
直方图操作


228
00:13:00,848 --> 00:13:02,583 line:-1
卷积


229
00:13:02,649 --> 00:13:04,017 line:-1
几何学


230
00:13:04,084 --> 00:13:05,786 line:-1
以及形态的操作


231
00:13:08,355 --> 00:13:11,391 line:-2
我们新的Swift API
引入了许多新功能


232
00:13:11,458 --> 00:13:15,562 line:-2
来让大家在Swift中
更容易和简单地使用vImage


233
00:13:15,629 --> 00:13:17,798 line:-1
我们实现了一个选项集标记


234
00:13:18,232 --> 00:13:20,801 line:-2
vImages
抛出了Swift错误


235
00:13:20,868 --> 00:13:23,370 line:-1
我们隐藏了一些可变性的需求


236
00:13:23,437 --> 00:13:25,806 line:-1
以及处理非托管类型


237
00:13:27,674 --> 00:13:29,810 line:-2
如果你在使用
Core Graphics图片


238
00:13:29,877 --> 00:13:31,011 line:-1
这是一个常见的工作流


239
00:13:31,078 --> 00:13:33,814 line:-2
来将图片数据传入到
一个vImage缓冲中


240
00:13:35,115 --> 00:13:39,453 line:-2
首先 你需要创建一个
CGImagesFormat描述


241
00:13:40,320 --> 00:13:42,823 line:-2
接下
实例化一个vImage缓冲


242
00:13:43,390 --> 00:13:45,425 line:-1
在图片中初始化那个缓冲


243
00:13:45,492 --> 00:13:48,829 line:-2
最后
以非Swift的方式来检查错误


244
00:13:49,129 --> 00:13:52,833 line:-2
对于一个常见的操作
有很多样板代码


245
00:13:54,034 --> 00:13:59,173 line:-2
新的API将所有的那段代码
打包成了一个可抛的初始化器


246
00:14:00,574 --> 00:14:04,344 line:-2
不过 因为我们等会将要使用一个
CGImagesFormat


247
00:14:04,411 --> 00:14:08,849 line:-2
这是一个使用新的API
分两步实现的类似功能


248
00:14:09,349 --> 00:14:13,720 line:-2
我们使用一个CGImage为CGImageFormat
添加了一个新的初始化器


249
00:14:13,787 --> 00:14:16,056 line:-1
和一个额外的缓冲初始化器


250
00:14:16,123 --> 00:14:19,860 line:-2
它接受了一个CGImage
和一段明确形式的描述


251
00:14:21,461 --> 00:14:23,497 line:-1
只要你完成了一个缓冲


252
00:14:23,564 --> 00:14:25,098 line:-1
这是经典的vImage函数


253
00:14:25,165 --> 00:14:28,335 line:-2
用来在缓冲的内容中
创建一个CGImage


254
00:14:28,802 --> 00:14:32,072 line:-2
以及我们的新API
也使用一个新的CGImage方法


255
00:14:32,139 --> 00:14:34,341 line:-1
来简化了那个操作


256
00:14:34,408 --> 00:14:37,277 line:-1
它使用了我们刚从图片生成的形式


257
00:14:38,846 --> 00:14:40,781 line:-1
vImage有一个重要的用例


258
00:14:40,848 --> 00:14:44,585 line:-1
就是在不同的域和形式之间转换


259
00:14:44,651 --> 00:14:46,620 line:-2
vImage
是一个任意到任意的转换器


260
00:14:46,687 --> 00:14:49,289 line:-2
能在Core Video和
Core Graphics间转换


261
00:14:49,656 --> 00:14:52,893 line:-2
且在不同Core Graphics
形式之间转换


262
00:14:53,961 --> 00:14:59,900 line:-2
比如 你可能想要转换一个CMYK
Core Graphics图片至RGB


263
00:15:02,035 --> 00:15:04,204 line:-1
这个已有的API创建了一个转换器


264
00:15:04,271 --> 00:15:07,708 line:-1
接受转换的源和目标格式


265
00:15:07,774 --> 00:15:09,910 line:-1
返回一个非托管转换器


266
00:15:11,044 --> 00:15:13,213 line:-1
你获取到转换器的托管引用


267
00:15:13,280 --> 00:15:15,916 line:-1
传递它给实现转换的函数


268
00:15:17,918 --> 00:15:20,654 line:-2
我们的新API为已有的转换器类型
添加了一个新的静态make函数


269
00:15:20,721 --> 00:15:24,925 line:-1
它会返回一个转换器实例


270
00:15:26,193 --> 00:15:28,395 line:-1
转换由转换器实例的


271
00:15:28,462 --> 00:15:30,330 line:-1
转换方法完成


272
00:15:31,131 --> 00:15:35,502 line:-2
最后 我们来了解使用
Core Video图片格式


273
00:15:35,569 --> 00:15:37,004 line:-1
在一个典型的例子中


274
00:15:37,070 --> 00:15:39,773 line:-2
你可能想要从
一个Core Video


275
00:15:39,840 --> 00:15:44,545 line:-2
像素缓冲中创建一个图片格式描述
和计算它的通道数量


276
00:15:45,445 --> 00:15:48,715 line:-2
这是经典的vImage API
需要从一个像素缓冲中


277
00:15:48,782 --> 00:15:51,618 line:-1
创建一个图片形式描述的代码


278
00:15:51,685 --> 00:15:53,153 line:-1
以及获取它的通道数量


279
00:15:54,421 --> 00:15:56,723 line:-1
新的API用两行代码


280
00:15:56,790 --> 00:15:58,425 line:-1
提供了相同的功能


281
00:15:58,792 --> 00:16:01,428 line:-2
你使用一个新的静态make函数
创建了一个来自一个像素


282
00:16:01,495 --> 00:16:04,965 line:-2
缓冲的Core Video
图片格式的实例


283
00:16:05,532 --> 00:16:08,969 line:-1
很简单的就访问到它的通道数量属性


284
00:16:13,307 --> 00:16:16,777 line:-1
这是新的API一小部分的简略介绍


285
00:16:16,844 --> 00:16:19,146 line:-2
我们现在来看一下
LINPACK基准


286
00:16:19,213 --> 00:16:21,982 line:-1
来看看它和Accelerate比


287
00:16:22,049 --> 00:16:23,517 line:-1
有多快和多节能


288
00:16:24,184 --> 00:16:26,887 line:-2
LINPACK基准
出自于LINPACK库


289
00:16:26,954 --> 00:16:28,622 line:-1
它开始是一组例程


290
00:16:28,689 --> 00:16:31,992 line:-1
来提供快速的计算机线性代数


291
00:16:32,993 --> 00:16:35,829 line:-2
它之后被包含在一个叫做
LApack的库里


292
00:16:35,896 --> 00:16:37,998 line:-1
它代表着线性代数软件包


293
00:16:38,899 --> 00:16:41,835 line:-1
LApack被设计用来在调用


294
00:16:41,902 --> 00:16:43,403 line:-1
缓存时利用好这些新的功能


295
00:16:43,837 --> 00:16:46,974 line:-1
LApack是由许多阻塞算法组成


296
00:16:47,040 --> 00:16:50,043 line:-2
这些算法创建在另一个叫做
BLAS库的顶部


297
00:16:50,110 --> 00:16:53,013 line:-1
它代表着基本的线性代数子例程


298
00:16:53,981 --> 00:16:56,750 line:-2
我们会在之后的演讲中了解
关于BLAS的更多内容


299
00:16:56,817 --> 00:16:59,853 line:-1
现在 请记住LINPACK基准


300
00:16:59,920 --> 00:17:03,023 line:-2
在LApack顶部运行
就是在BLAS的顶部运行


301
00:17:05,959 --> 00:17:08,161 line:-2
LINPACK基准衡量
一个平台多快能解决一个


302
00:17:08,228 --> 00:17:12,132 line:-1
一般线性方程组


303
00:17:12,199 --> 00:17:14,067 line:-1
它包含两个步骤


304
00:17:14,134 --> 00:17:16,036 line:-1
矩阵分解步骤


305
00:17:16,103 --> 00:17:18,038 line:-1
接下来的一步是倒推法


306
00:17:18,472 --> 00:17:19,705 line:-1
通过修正算法


307
00:17:19,772 --> 00:17:22,041 line:-1
我们能看到不同平台


308
00:17:22,108 --> 00:17:23,644 line:-1
运行算法时的效果如何


309
00:17:24,077 --> 00:17:27,513 line:-2
它为我们提供了一个比较
不同平台的方法


310
00:17:27,881 --> 00:17:30,417 line:-2
LINPACK基准随着时间在
不断发展


311
00:17:30,684 --> 00:17:34,021 line:-2
最初 它解决了一个
100x100的系统


312
00:17:34,087 --> 00:17:37,057 line:-1
之后是1000x1000的系统


313
00:17:38,125 --> 00:17:42,062 line:-2
现在最经常使用的变量
是无拘束变量


314
00:17:42,296 --> 00:17:45,065 line:-1
问题的尺寸可以是你想要的任何大小


315
00:17:45,432 --> 00:17:48,068 line:-1
这是我们今天会运行的变量


316
00:17:49,770 --> 00:17:54,074 line:-2
我们将在一部iPhone 10S
上比较LINPACK的性能表现


317
00:17:54,141 --> 00:17:55,709 line:-1
最上面 橘色的那个


318
00:17:55,776 --> 00:17:58,545 line:-2
我们将会运行一个未经优化
的LINPACK


319
00:17:59,046 --> 00:18:00,247 line:-1
这个Linpack基准


320
00:18:00,314 --> 00:18:02,683 line:-1
没有使用accelerate框架


321
00:18:02,983 --> 00:18:07,087 line:-2
它依赖没有优化正在运行
的进程的软件


322
00:18:07,154 --> 00:18:09,089 line:-1
我们来看看它是怎样的


323
00:18:11,058 --> 00:18:14,361 line:-2
我们会将它和使用
Accelerate框架做对比


324
00:18:14,428 --> 00:18:18,732 line:-2
也就是说 我们将会在相同的
平台运行相同的基准


325
00:18:18,799 --> 00:18:22,836 line:-2
但使用Accelerate框架
它会调整平台


326
00:18:25,906 --> 00:18:28,775 line:-2
我们能看到使用了
Accelerate框架的那个


327
00:18:28,842 --> 00:18:31,478 line:-1
快了超过24倍


328
00:18:31,879 --> 00:18:33,614 line:-1
这不仅会节约时间


329
00:18:33,680 --> 00:18:36,550 line:-1
也节能 它会延长电池使用寿命


330
00:18:36,984 --> 00:18:38,385 line:-1
我们现在来改变方式


331
00:18:38,452 --> 00:18:40,621 line:-1
来看一下LINPACK基准


332
00:18:40,687 --> 00:18:43,123 line:-1
GEMM的主要使用日常


333
00:18:45,092 --> 00:18:48,729 line:-2
如我所说 LINPACK
在LApack上运行


334
00:18:48,795 --> 00:18:50,631 line:-1
创建在BLAS上面


335
00:18:51,131 --> 00:18:53,200 line:-2
BLAS里的一个叫做
GEMM的例程


336
00:18:53,267 --> 00:18:56,136 line:-1
它代表着一般的矩阵乘法器


337
00:18:56,937 --> 00:19:01,208 line:-2
这个例程被用来实现BLAS
中的一些其他阻塞例程


338
00:19:01,275 --> 00:19:04,611 line:-2
它们在LApack的
阻塞算法中被使用


339
00:19:04,678 --> 00:19:08,715 line:-1
最显著的是矩阵分解和解算器例程


340
00:19:09,616 --> 00:19:10,584 line:-1
因此


341
00:19:10,651 --> 00:19:13,754 line:-2
GEMM有时被用来
作为性能表现的一个代理


342
00:19:14,021 --> 00:19:15,022 line:-1
为了本次演讲


343
00:19:15,088 --> 00:19:19,159 line:-2
我们要特别地来看一下GEMM
的单精度变量


344
00:19:20,527 --> 00:19:23,530 line:-1
这里 我们将要比较Eigen库


345
00:19:23,597 --> 00:19:25,165 line:-1
和Accelerate的性能表现


346
00:19:25,465 --> 00:19:28,335 line:-2
Eigen库
和Accelerate框架都


347
00:19:28,402 --> 00:19:30,704 line:-2
会在一部
iPhone 10S上面运行


348
00:19:30,971 --> 00:19:34,174 line:-2
它们都会运行一个单精度
的矩阵乘法器


349
00:19:34,641 --> 00:19:36,844 line:-1
我们来看看Eigen的表现


350
00:19:38,512 --> 00:19:41,315 line:-2
Eigen的最高速度约为510
亿次浮点运算/秒


351
00:19:41,381 --> 00:19:44,184 line:-2
现在我们来看一下
Accelerate的表现


352
00:19:46,153 --> 00:19:49,957 line:-2
可以看到Accelerate框架
在相同的平台


353
00:19:50,023 --> 00:19:52,192 line:-1
大概比Eigen快了2.5倍


354
00:19:52,659 --> 00:19:56,663 line:-2
这是因为Accelerate
框架对平台进行了手动调整


355
00:19:56,730 --> 00:20:00,200 line:-2
它允许我们能完全利用好平台
能提供的优势


356
00:20:01,101 --> 00:20:03,270 line:-1
那么 如果你是一个开发者


357
00:20:03,337 --> 00:20:06,473 line:-2
在app中用Accelerate
会提供更好的性能表现


358
00:20:06,540 --> 00:20:08,876 line:-1
这个性能表现更节能


359
00:20:08,942 --> 00:20:10,644 line:-1
它意味着更长的电池寿命


360
00:20:10,711 --> 00:20:14,214 line:-1
和一个对用户整体更好的体验


361
00:20:15,616 --> 00:20:16,817 line:-1
总结


362
00:20:16,884 --> 00:20:18,385 line:-1
Accelerat提供了


363
00:20:18,452 --> 00:20:21,655 line:-1
大规模的数学计算的功能


364
00:20:21,722 --> 00:20:25,225 line:-1
更快和节能的图像点运算


365
00:20:25,692 --> 00:20:28,695 line:-2
现在我们加入了一个
Swift友好的API


366
00:20:28,762 --> 00:20:31,365 line:-1
它让Accelerate库更易用


367
00:20:31,431 --> 00:20:35,669 line:-2
这样你的用户会从
性能表现和节能中受益


368
00:20:36,570 --> 00:20:39,373 line:-2
请访问我们的网站
我们提供了示例 文章


369
00:20:39,439 --> 00:20:41,341 line:-1
和广泛覆盖了整个


370
00:20:41,408 --> 00:20:44,244 line:-2
Accelerate框架的
参考材料


371
00:20:44,311 --> 00:20:45,879 line:-1
非常感谢大家

