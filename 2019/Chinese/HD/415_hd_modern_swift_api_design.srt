1
00:00:00,516 --> 00:00:05,000
[音乐]


2
00:00:07,516 --> 00:00:11,500
[掌声]


3
00:00:12,786 --> 00:00:13,366
>> 大家好


4
00:00:14,736 --> 00:00:15,946
我是 Ben 跟我一起的


5
00:00:15,946 --> 00:00:17,066
是我的同事 Doug


6
00:00:17,066 --> 00:00:19,496
我们将要跟你们讲讲 Swift 里的 API 设计


7
00:00:20,326 --> 00:00:21,786
那么 在有了关于


8
00:00:21,786 --> 00:00:24,136
二进制和模块稳定性的介绍后


9
00:00:24,536 --> 00:00:26,096
我们感到非常兴奋


10
00:00:26,096 --> 00:00:27,746
这是我们第一次能够介绍框架


11
00:00:28,126 --> 00:00:29,586
这个框架很好地利用


12
00:00:29,586 --> 00:00:31,176
Swift 来提供丰富


13
00:00:31,436 --> 00:00:33,406
有效且便于使用的 API


14
00:00:33,406 --> 00:00:36,006
作为 Apple SDK 的一部分


15
00:00:36,556 --> 00:00:37,956
现在 我们已经知道了


16
00:00:38,076 --> 00:00:39,566
设计这些 API 的一部分内容


17
00:00:39,566 --> 00:00:40,986
也就是我们今天要跟你们聊的


18
00:00:40,986 --> 00:00:43,116
那么 我们将要涉及到


19
00:00:43,116 --> 00:00:44,746
一些基本的概念


20
00:00:45,606 --> 00:00:47,396
并且理解它们是如何影响


21
00:00:47,396 --> 00:00:48,306
你的 API 设计的


22
00:00:48,746 --> 00:00:49,516
然后我们需要


23
00:00:49,516 --> 00:00:51,066
深入了解一些


24
00:00:51,066 --> 00:00:53,516
Swift 5.1 的新功能


25
00:00:53,516 --> 00:00:54,996
来看看它们是如何提供帮助


26
00:00:54,996 --> 00:00:56,476
使你的 API 表现更出色


27
00:00:57,406 --> 00:00:58,246
同时我们也将向


28
00:00:58,246 --> 00:00:59,976
你们展示一些例子


29
00:00:59,976 --> 00:01:01,486
源自我们最新的 Swift 框架


30
00:01:01,756 --> 00:01:04,686
包括 SwiftUI 以及 RealityKit


31
00:01:06,496 --> 00:01:08,926
那么 我们之前已经讲过了 API 设计


32
00:01:09,116 --> 00:01:11,096
尤其在 2016 年我们


33
00:01:11,096 --> 00:01:13,856
介绍了 Swift API 设计指南


34
00:01:14,546 --> 00:01:15,926
你们现在仍可以在


35
00:01:15,926 --> 00:01:17,106
Swift.org 网站对这些进行查看


36
00:01:17,466 --> 00:01:18,626
它们包含了一些


37
00:01:18,626 --> 00:01:21,076
很有用的建议 围绕着如何命名


38
00:01:21,166 --> 00:01:22,046
以及为你的 API 写文档


39
00:01:22,086 --> 00:01:24,256
但是我现在不会重复这些


40
00:01:24,786 --> 00:01:26,186
但是有一点


41
00:01:26,186 --> 00:01:27,306
我们今天需要去解决


42
00:01:27,306 --> 00:01:30,466
这就是


43
00:01:30,466 --> 00:01:32,406
使用时的清晰明确


44
00:01:32,406 --> 00:01:34,606
是作为 API 设计师的最大目标


45
00:01:35,166 --> 00:01:37,096
你想要做到这一点 这样一来


46
00:01:37,096 --> 00:01:39,116
在阅读使用你的 API 的代码时


47
00:01:39,736 --> 00:01:40,886
它所做的就会一目了然


48
00:01:41,756 --> 00:01:43,506
同时 你想要做到这一点


49
00:01:43,626 --> 00:01:45,146
使你的 API 可以得到正确使用


50
00:01:46,136 --> 00:01:48,696
好的命名和可读性


51
00:01:48,696 --> 00:01:50,016
对此至关重要


52
00:01:50,756 --> 00:01:53,036
还有一个新的东西


53
00:01:53,036 --> 00:01:53,886
是关于命名的


54
00:01:53,886 --> 00:01:55,366
就是接下来


55
00:01:55,366 --> 00:01:57,146
我们将不在


56
00:01:57,146 --> 00:01:59,366
我们仅限 Swift 使用的 API


57
00:01:59,366 --> 00:02:00,986
中使用 Swift 类型的前缀


58
00:02:00,986 --> 00:02:04,136
现在 这会为


59
00:02:04,266 --> 00:02:06,956
这些 API 带来更整洁


60
00:02:07,016 --> 00:02:07,766
更可读的体验


61
00:02:07,766 --> 00:02:11,756
目前 在 C 和 Objective-C 语言中我们


62
00:02:11,756 --> 00:02:13,866
不得不使用前缀 因为


63
00:02:14,026 --> 00:02:15,816
每个符号都处在全球


64
00:02:15,816 --> 00:02:17,546
命名空间里 没有一个好的方法


65
00:02:17,546 --> 00:02:18,346
来消除歧义


66
00:02:19,376 --> 00:02:20,766
基于这一原因 Apple


67
00:02:21,036 --> 00:02:22,966
和开发人员必须遵循一套


68
00:02:22,966 --> 00:02:24,946
非常严格的前缀惯例


69
00:02:25,736 --> 00:02:27,386
为了统一 我们将


70
00:02:27,386 --> 00:02:29,406
继续使用前缀


71
00:02:29,406 --> 00:02:31,536
在那些 Swift 版本的 API 同时


72
00:02:31,536 --> 00:02:33,446
在 Objective-C 语言有对应的情况下


73
00:02:35,516 --> 00:02:37,626
但是 Swift 的模块系统


74
00:02:37,626 --> 00:02:40,106
可以消除歧义 通过


75
00:02:40,106 --> 00:02:41,556
在类型前面加上


76
00:02:41,556 --> 00:02:42,256
模块名称


77
00:02:42,256 --> 00:02:44,046
由于这个原因


78
00:02:44,046 --> 00:02:46,076
标准库也从来没有前缀


79
00:02:46,356 --> 00:02:47,816
你们中的很多人已经发现了


80
00:02:47,876 --> 00:02:48,986
你们也可以将其从你们的


81
00:02:48,986 --> 00:02:49,926
Swift 框架上去除


82
00:02:50,496 --> 00:02:53,886
但是请记住


83
00:02:53,886 --> 00:02:55,326
即便如此 你们也需要


84
00:02:55,326 --> 00:02:56,986
小心谨慎一点


85
00:02:57,996 --> 00:02:59,966
一个非常笼统的名称会让


86
00:02:59,966 --> 00:03:01,776
你的用户必须手动


87
00:03:01,776 --> 00:03:03,336
区分产生歧义的状况


88
00:03:03,336 --> 00:03:04,046
一旦有冲突的话


89
00:03:04,926 --> 00:03:06,846
而且请始终记住


90
00:03:06,846 --> 00:03:07,776
使用时的清晰明确


91
00:03:08,736 --> 00:03:10,266
某个特定框架的一个笼统名称


92
00:03:10,266 --> 00:03:11,856
可能看上去会有点儿


93
00:03:11,856 --> 00:03:13,496
让人困惑


94
00:03:13,536 --> 00:03:14,166
当你没有上下文的时候


95
00:03:14,626 --> 00:03:17,686
现在 我们要讲几个主题


96
00:03:17,686 --> 00:03:19,116
值 引用


97
00:03:19,116 --> 00:03:21,476
协议和泛型


98
00:03:21,926 --> 00:03:23,216
这之后我们将要讲到


99
00:03:23,216 --> 00:03:24,656
我们的两个新功能


100
00:03:24,656 --> 00:03:27,126
关键路径成员查找和属性包装器


101
00:03:28,096 --> 00:03:29,356
那么 让我们先来讲一下


102
00:03:29,356 --> 00:03:30,896
值和引用


103
00:03:31,016 --> 00:03:32,416
首先快速回顾一下


104
00:03:32,666 --> 00:03:34,616
Swift 有三个创建类型的基本概念


105
00:03:34,616 --> 00:03:38,426
类 结构和枚举


106
00:03:39,776 --> 00:03:41,456
类是引用类型


107
00:03:41,456 --> 00:03:42,236
那代表着当你有一个变量


108
00:03:42,236 --> 00:03:44,076
它就指向


109
00:03:44,076 --> 00:03:46,006
有着实际值的对象


110
00:03:46,796 --> 00:03:48,266
当你对它进行复制


111
00:03:48,266 --> 00:03:50,006
就是在复制引用


112
00:03:50,466 --> 00:03:51,726
那代表着当你


113
00:03:51,726 --> 00:03:53,066
通过引用改变一个值


114
00:03:53,066 --> 00:03:55,416
你实际上在改变


115
00:03:55,416 --> 00:03:57,086
同一个对象


116
00:03:57,086 --> 00:03:57,976
而两个变量都指向这个对象


117
00:03:59,436 --> 00:04:00,756
所以它们都能看到变化


118
00:04:01,296 --> 00:04:04,926
在另一方面 结构和枚举


119
00:04:04,926 --> 00:04:06,446
是值类型


120
00:04:06,446 --> 00:04:07,356
当你复制它们


121
00:04:07,476 --> 00:04:09,556
就会复制其所有内容


122
00:04:09,946 --> 00:04:11,196
那代表着当你


123
00:04:11,196 --> 00:04:12,626
做出一个改变 你只是在


124
00:04:12,626 --> 00:04:14,036
改变那一个拷贝


125
00:04:15,086 --> 00:04:16,866
现在 在你的 API 里使用值类型


126
00:04:16,866 --> 00:04:18,416
能带来很多好处


127
00:04:18,486 --> 00:04:20,555
在使用的清晰明确方面


128
00:04:20,995 --> 00:04:21,846
如果你知道你每次都在


129
00:04:21,846 --> 00:04:24,166
获得一个全新的 独一无二的拷贝


130
00:04:24,556 --> 00:04:25,746
那么你就不需要担心


131
00:04:25,746 --> 00:04:27,206
值来自哪里


132
00:04:27,436 --> 00:04:29,006
是否有人对其设有引用


133
00:04:29,006 --> 00:04:30,126
或者是在


134
00:04:30,126 --> 00:04:31,556
你不知情的情况下


135
00:04:31,246 --> 00:04:31,556
进行修改


136
00:04:32,426 --> 00:04:34,426
你不需要 比如


137
00:04:34,426 --> 00:04:36,346
做一个防御性的拷贝


138
00:04:36,346 --> 00:04:37,686
现在 有了这个


139
00:04:37,686 --> 00:04:38,866
出现了一个常见问题 就是


140
00:04:39,066 --> 00:04:40,966
我是否应该将引用或者


141
00:04:40,966 --> 00:04:43,336
一个值的类型用于我某一段


142
00:04:43,336 --> 00:04:43,956
特定的代码


143
00:04:44,276 --> 00:04:45,986
而每种使用情况是不同的


144
00:04:45,986 --> 00:04:47,646
所以没有一个硬性规定


145
00:04:48,036 --> 00:04:49,006
但是有一些笼统的指南


146
00:04:49,006 --> 00:04:50,686
也就是总的来说


147
00:04:50,686 --> 00:04:52,856
你应该倾向使用


148
00:04:52,856 --> 00:04:54,716
结构而不是类 除非你


149
00:04:54,716 --> 00:04:56,496
有一个使用类的很好的理由


150
00:04:57,216 --> 00:04:58,736
如果你默认使用一个类


151
00:04:58,736 --> 00:04:59,996
当每次在创建类型时


152
00:04:59,996 --> 00:05:01,086
试着将这一默认从你


153
00:05:01,086 --> 00:05:02,386
运行的代码中移开


154
00:05:02,386 --> 00:05:02,886
看看会怎么样


155
00:05:03,956 --> 00:05:05,496
目前 类


156
00:05:05,496 --> 00:05:06,896
在 Swift 中还很重要


157
00:05:07,426 --> 00:05:08,956
它们很关键 如果你需要


158
00:05:09,076 --> 00:05:10,786
通过引用计数


159
00:05:10,786 --> 00:05:11,656
管理资源


160
00:05:12,146 --> 00:05:13,316
虽然 你可能常常想要将


161
00:05:13,536 --> 00:05:14,976
那个类包含在一个结构里


162
00:05:14,976 --> 00:05:15,706
像我们马上会看到的那样


163
00:05:16,896 --> 00:05:18,816
它们也是有用的结构体


164
00:05:18,816 --> 00:05:20,316
如果有东西需要被基础性地


165
00:05:20,316 --> 00:05:22,046
存储和分享


166
00:05:22,836 --> 00:05:24,826
很重要的一点 如果你的类型


167
00:05:24,826 --> 00:05:26,046
具有标识


168
00:05:26,196 --> 00:05:28,316
标识的概念


169
00:05:28,316 --> 00:05:29,656
与值分离


170
00:05:30,386 --> 00:05:32,106
这通常标记着某个类


171
00:05:32,106 --> 00:05:33,566
是合理的


172
00:05:34,766 --> 00:05:36,796
现在 有时我们


173
00:05:36,796 --> 00:05:38,806
必须进行判断


174
00:05:38,876 --> 00:05:39,646
那就是在 RealityKit


175
00:05:40,526 --> 00:05:42,506
RealityKit 的 API 围绕着


176
00:05:42,506 --> 00:05:44,016
这些称为实体的东西


177
00:05:44,636 --> 00:05:46,896
这些代表着


178
00:05:46,896 --> 00:05:48,276
出现在场景的对象


179
00:05:48,686 --> 00:05:50,656
它们被存储在


180
00:05:50,656 --> 00:05:52,156
RealityKit 引擎的中心


181
00:05:52,156 --> 00:05:53,356
它们具有标识


182
00:05:54,086 --> 00:05:55,776
当你需要操控一个场景


183
00:05:55,836 --> 00:05:57,956
通过改变对象的


184
00:05:57,956 --> 00:06:00,336
外表或者将它们移动


185
00:06:00,336 --> 00:06:01,946
然后你就直接


186
00:06:01,946 --> 00:06:04,126
在那个引擎里操控对象了


187
00:06:04,546 --> 00:06:05,666
你可以把引用类型看作是


188
00:06:05,666 --> 00:06:08,706
把手


189
00:06:08,706 --> 00:06:11,076
可以处理 RealityKit 中的实际对象


190
00:06:11,556 --> 00:06:13,106
所以这对于引用类型来说


191
00:06:13,106 --> 00:06:13,846
有着完美用途


192
00:06:14,536 --> 00:06:17,446
但是 这些实体的属性


193
00:06:17,446 --> 00:06:19,546
比如它们的定位


194
00:06:19,546 --> 00:06:21,676
或综合某一场景中的方向


195
00:06:21,676 --> 00:06:23,636
被建模成为值的类型


196
00:06:24,396 --> 00:06:25,276
现在 让我们来看看它们


197
00:06:25,276 --> 00:06:26,096
在代码里看上去如何


198
00:06:26,896 --> 00:06:28,416
假设我们想在


199
00:06:28,776 --> 00:06:30,546
这里创建场景


200
00:06:31,146 --> 00:06:33,646
那么我们首先要创建一个


201
00:06:33,646 --> 00:06:34,406
material 类型


202
00:06:34,916 --> 00:06:36,906
然后我们在外面创建


203
00:06:36,906 --> 00:06:38,286
两个盒子


204
00:06:38,416 --> 00:06:39,576
然后我们需要把它们


205
00:06:39,576 --> 00:06:40,426
固定在场景中


206
00:06:41,196 --> 00:06:42,476
接下来 一旦完成这个


207
00:06:42,576 --> 00:06:43,796
我们就可以操控场景


208
00:06:43,836 --> 00:06:45,896
通过直接使用代码我们可以


209
00:06:46,086 --> 00:06:47,486
将小一点盒子在


210
00:06:47,486 --> 00:06:48,286
Y 轴上移动


211
00:06:48,336 --> 00:06:51,426
或者将大一点的盒子旋转 45 度


212
00:06:51,836 --> 00:06:53,096
当我们在


213
00:06:53,096 --> 00:06:54,776
这些引用类型上进行这些操作时


214
00:06:54,776 --> 00:06:56,096
我们正在直接


215
00:06:56,096 --> 00:06:57,296
操控场景


216
00:06:57,296 --> 00:06:59,056
这是很直观的


217
00:07:00,376 --> 00:07:02,676
现在 假设我们想要


218
00:07:02,676 --> 00:07:03,786
像这里一样 也就是


219
00:07:03,786 --> 00:07:04,616
使得每个盒子都是


220
00:07:04,616 --> 00:07:05,276
不同的颜色


221
00:07:05,816 --> 00:07:07,006
我们会使用的一种方法也许是


222
00:07:07,046 --> 00:07:10,526
是将 material.tintColor 


223
00:07:10,526 --> 00:07:11,066
设置成红色


224
00:07:11,886 --> 00:07:14,576
现在 我会期待什么结果呢


225
00:07:14,576 --> 00:07:16,056
这个 API 的用户在这个时候


226
00:07:16,056 --> 00:07:16,366
会发生什么呢


227
00:07:17,206 --> 00:07:19,556
这两个盒子都要变吗


228
00:07:19,776 --> 00:07:21,026
因为我改变了同时


229
00:07:21,026 --> 00:07:22,186
创建出这两个的变量


230
00:07:23,066 --> 00:07:24,516
或者只要


231
00:07:24,516 --> 00:07:26,706
后创建的盒子会适用


232
00:07:26,706 --> 00:07:27,396
这一新变化


233
00:07:27,796 --> 00:07:29,526
也就是说 material 应该


234
00:07:29,836 --> 00:07:32,446
作为引用类型还是值类型


235
00:07:33,216 --> 00:07:35,666
这两个中的任一模型都有可能


236
00:07:35,736 --> 00:07:37,166
成为一个 API 的合理设计


237
00:07:37,166 --> 00:07:39,636
虽然 在这里使用


238
00:07:39,636 --> 00:07:40,766
值类型的好处在于 如果


239
00:07:40,766 --> 00:07:41,966
在你的代码里有一段很长的距离


240
00:07:42,036 --> 00:07:43,776
在你一开始


241
00:07:43,776 --> 00:07:45,176
创建和使用 material


242
00:07:45,176 --> 00:07:46,666
类型并进行更改之间


243
00:07:47,226 --> 00:07:48,536
然后你忘记自己


244
00:07:48,536 --> 00:07:49,526
之前使用过它


245
00:07:49,526 --> 00:07:50,976
最后你可能更改了


246
00:07:50,976 --> 00:07:51,816
一部分场景


247
00:07:51,816 --> 00:07:52,766
而你并不想这么做


248
00:07:53,596 --> 00:07:54,726
基于这一理由


249
00:07:54,726 --> 00:07:56,086
RealityKit 选择将


250
00:07:56,116 --> 00:07:57,946
material 作为一个值类型


251
00:07:58,926 --> 00:08:00,316
但是引用语义


252
00:08:00,316 --> 00:08:01,956
对于其他 API 来说也合理


253
00:08:01,956 --> 00:08:03,246
就如我们在实体中看到的一样


254
00:08:04,236 --> 00:08:06,666
重要的一点在于你的


255
00:08:06,666 --> 00:08:09,906
API 有一个容易解释的模型


256
00:08:10,066 --> 00:08:12,536
解释事物如何以及为何运作


257
00:08:13,246 --> 00:08:16,006
最重要的一点是 


258
00:08:16,006 --> 00:08:17,636
那一行为如何运作不应该


259
00:08:17,636 --> 00:08:19,676
被类型的偶发


260
00:08:19,676 --> 00:08:22,056
执行细节所驱动


261
00:08:22,296 --> 00:08:22,896
相反 应该是一个


262
00:08:22,896 --> 00:08:25,296
有意识的选择 是基于用例的


263
00:08:26,626 --> 00:08:27,736
那么 我说的


264
00:08:27,736 --> 00:08:28,896
偶发执行细节


265
00:08:28,896 --> 00:08:29,236
是指什么呢


266
00:08:29,236 --> 00:08:30,966
好吧 让我们来看一个


267
00:08:30,966 --> 00:08:32,096
示例类型


268
00:08:32,426 --> 00:08:33,765
比如一个 material 类型


269
00:08:33,996 --> 00:08:36,836
我希望它像一个值


270
00:08:36,836 --> 00:08:38,296
所以我将它设置成一个结构


271
00:08:38,506 --> 00:08:39,635
我赋予它一些简单的属性


272
00:08:39,635 --> 00:08:41,106
比如 roughness


273
00:08:41,106 --> 00:08:43,476
然后我给它一个 textture 属性


274
00:08:43,856 --> 00:08:45,376
让我们假设纹 texture


275
00:08:45,376 --> 00:08:46,536
属性需要去通过


276
00:08:46,536 --> 00:08:48,486
引用计数来管理资源


277
00:08:48,486 --> 00:08:50,816
所以我决定将它设置成一个类


278
00:08:52,106 --> 00:08:53,906
现在 我们之前说过


279
00:08:53,906 --> 00:08:55,246
当你对一个值类型进行复制


280
00:08:55,246 --> 00:08:56,936
你将会复制其所有存储


281
00:08:56,936 --> 00:08:57,426
的属性


282
00:08:58,086 --> 00:08:59,196
但是当你复制一个


283
00:08:59,196 --> 00:09:00,926
引用类型时 你只是在


284
00:09:00,926 --> 00:09:02,376
复制那一个引用


285
00:09:03,226 --> 00:09:04,936
所以当你在复制


286
00:09:04,936 --> 00:09:06,776
这个 material 类型时 


287
00:09:06,776 --> 00:09:08,296
最后会发生的情况就是


288
00:09:08,296 --> 00:09:09,656
创建了引用副本


289
00:09:09,686 --> 00:09:10,996
所以两个类型最后


290
00:09:11,226 --> 00:09:13,186
共享了同一个纹理对象


291
00:09:14,576 --> 00:09:16,096
现在 是否可以


292
00:09:16,626 --> 00:09:17,356
实际上取决于


293
00:09:17,356 --> 00:09:18,726
纹理的实现


294
00:09:19,106 --> 00:09:21,016
如果纹理不可变 那么


295
00:09:21,016 --> 00:09:21,966
就非常完美


296
00:09:21,966 --> 00:09:23,576
事实上 这是很理想的


297
00:09:23,576 --> 00:09:24,696
从一个共享的角度考虑


298
00:09:26,066 --> 00:09:27,326
但是如果纹理


299
00:09:27,326 --> 00:09:28,996
在根本上是易变类型


300
00:09:29,806 --> 00:09:30,876
那么我这里所创建的


301
00:09:30,876 --> 00:09:32,116
实际上就有点奇怪了


302
00:09:32,116 --> 00:09:33,256
它的运作既不像


303
00:09:33,256 --> 00:09:35,016
一个引用 也不像一个值


304
00:09:35,426 --> 00:09:37,076
我可以对结构上的属性


305
00:09:37,236 --> 00:09:37,886
做出改变


306
00:09:38,936 --> 00:09:40,826
而且它只影响其中一个变量


307
00:09:40,856 --> 00:09:43,086
但是如果我作出更改


308
00:09:43,086 --> 00:09:46,286
从纹理引用到


309
00:09:46,286 --> 00:09:48,846
对象 那么它将影响两个变量


310
00:09:49,066 --> 00:09:49,936
而这是非常令人惊奇的


311
00:09:49,936 --> 00:09:51,736
对于你 API 的用户来说


312
00:09:51,736 --> 00:09:53,336
也许甚至比


313
00:09:53,336 --> 00:09:54,296
你一直受困于


314
00:09:54,356 --> 00:09:56,356
引用语义还要让人困惑


315
00:09:56,936 --> 00:09:59,466
所以在这儿我们需要做一个


316
00:09:59,466 --> 00:10:01,896
真正的关键区分


317
00:10:01,896 --> 00:10:03,906
在值和引用类型之间


318
00:10:04,306 --> 00:10:06,856
结构与类相比


319
00:10:06,856 --> 00:10:08,836
以及值和引用语义


320
00:10:09,116 --> 00:10:10,836
和类型的表现


321
00:10:12,376 --> 00:10:13,916
仅仅因为一些东西是


322
00:10:13,916 --> 00:10:15,146
值类型 比如结构


323
00:10:15,286 --> 00:10:16,856
未必代表着


324
00:10:16,856 --> 00:10:18,826
你会自动从中获得


325
00:10:18,826 --> 00:10:20,266
值操作


326
00:10:20,496 --> 00:10:22,006
有一种方式 不是


327
00:10:22,006 --> 00:10:23,386
唯一的方式 但是普遍的方式


328
00:10:23,866 --> 00:10:25,966
就是当你将一个可变


329
00:10:26,376 --> 00:10:27,826
的引用类型作为


330
00:10:27,866 --> 00:10:28,616
公共 API 的一部分


331
00:10:28,616 --> 00:10:31,086
所以第一个问题 如果你


332
00:10:31,086 --> 00:10:32,176
想让一些东西表现的像一个值


333
00:10:32,176 --> 00:10:33,456
那么任何


334
00:10:33,456 --> 00:10:35,486
它显示的引用是可变的吗


335
00:10:36,686 --> 00:10:38,416
请记住 这并不


336
00:10:38,416 --> 00:10:39,466
总是很明显


337
00:10:40,056 --> 00:10:41,446
如果我们在处理一个


338
00:10:41,446 --> 00:10:43,696
非最终类 那么你


339
00:10:43,696 --> 00:10:47,036
实际上可能得到的可能是一个可变的子类


340
00:10:47,436 --> 00:10:49,536
幸运的是 我们


341
00:10:49,536 --> 00:10:51,436
有很多技术来避免


342
00:10:51,436 --> 00:10:52,496
类似这样的问题


343
00:10:53,616 --> 00:10:55,986
所以最早的一个就是去做


344
00:10:55,986 --> 00:10:56,946
我们经常针对引用类型


345
00:10:56,946 --> 00:10:58,956
所做的 也就是做一个防御性拷贝


346
00:10:59,316 --> 00:11:00,846
这样我们就可以将 texture


347
00:11:00,846 --> 00:11:02,396
存储属性转为 private


348
00:11:03,476 --> 00:11:05,966
然后创建一个计算后的属性


349
00:11:06,296 --> 00:11:08,816
在设置中


350
00:11:08,816 --> 00:11:10,726
我们复制 texture 对象


351
00:11:11,286 --> 00:11:12,996
这就避免了可变的


352
00:11:12,996 --> 00:11:14,226
子类问题


353
00:11:15,176 --> 00:11:16,396
但是 问题没有解决


354
00:11:16,396 --> 00:11:17,566
如果纹理在


355
00:11:17,566 --> 00:11:19,506
根本上是可变类型


356
00:11:20,036 --> 00:11:21,366
因为你仍然可以改变它


357
00:11:21,366 --> 00:11:22,916
只需要通过 get 方法


358
00:11:22,976 --> 00:11:24,166
这就是引用的工作原理


359
00:11:25,036 --> 00:11:26,806
那么让我们来考虑一下


360
00:11:26,806 --> 00:11:29,886
另一种方式


361
00:11:29,886 --> 00:11:31,436
完全不显示引用类型


362
00:11:31,766 --> 00:11:34,326
相反 只是显示了


363
00:11:34,326 --> 00:11:36,346
我们希望反应在对象上的属性


364
00:11:36,866 --> 00:11:38,526
作为计算生成的属性在我们的


365
00:11:38,526 --> 00:11:40,046
material 值类型上


366
00:11:41,006 --> 00:11:42,676
所以我们可以创建一个通过计算


367
00:11:42,676 --> 00:11:43,156
产生的属性


368
00:11:43,156 --> 00:11:44,496
在 get 方法中


369
00:11:44,496 --> 00:11:45,916
转到相关的


370
00:11:45,916 --> 00:11:46,846
对象的属性


371
00:11:47,486 --> 00:11:50,196
但是在 set 方法中


372
00:11:50,196 --> 00:11:53,106
首先检查对象是否被


373
00:11:53,106 --> 00:11:54,226
唯一引用


374
00:11:54,476 --> 00:11:56,836
如果不是 那么这个时候


375
00:11:57,006 --> 00:11:59,026
我们可以在继续之前


376
00:11:59,026 --> 00:12:01,226
完全复制 texture 对象


377
00:12:01,226 --> 00:12:02,446
并作出更改


378
00:12:03,556 --> 00:12:05,516
通过添加这一行来检查


379
00:12:05,516 --> 00:12:06,756
唯一性 我们已经


380
00:12:06,756 --> 00:12:09,216
执行了完整的写时复制


381
00:12:09,396 --> 00:12:10,906
语义


382
00:12:10,906 --> 00:12:12,276
同时仍显示我们希望出现


383
00:12:12,566 --> 00:12:14,326
在我们的引用类型上的属性


384
00:12:16,556 --> 00:12:17,996
那么接下来 我们来讲讲


385
00:12:17,996 --> 00:12:19,546
协议和泛型


386
00:12:20,276 --> 00:12:21,976
那么 我们已经看过了值类型是如何


387
00:12:22,166 --> 00:12:24,676
使用户清晰明确的


388
00:12:24,676 --> 00:12:25,856
使用你的 API


389
00:12:26,686 --> 00:12:28,356
但是 值类型并不是一个新东西


390
00:12:28,356 --> 00:12:30,306
我们在 Objective-C 语言中一直有


391
00:12:30,376 --> 00:12:32,366
CGPoint 或 CGrect 之类的


392
00:12:33,036 --> 00:12:33,786
那么区别是什么呢


393
00:12:33,836 --> 00:12:35,646
Swift 中的区别


394
00:12:36,036 --> 00:12:37,236
在于可以向


395
00:12:37,436 --> 00:12:39,896
结构和枚举添加协议


396
00:12:40,506 --> 00:12:41,966
同样也包括类


397
00:12:42,506 --> 00:12:43,976
这意味着你可以共享代码


398
00:12:43,976 --> 00:12:45,726
通过使用泛型可以


399
00:12:46,036 --> 00:12:47,016
跨越很多值类型


400
00:12:47,816 --> 00:12:49,376
所以当你觉得你需要


401
00:12:49,376 --> 00:12:50,406
共享一些


402
00:12:50,406 --> 00:12:51,586
不同类型的代码


403
00:12:51,586 --> 00:12:53,576
并不是一定要创建类继承关系


404
00:12:53,576 --> 00:12:55,466
使其中的父类


405
00:12:55,466 --> 00:12:57,106
有共享功能


406
00:12:58,286 --> 00:13:00,756
而是 就像老话说的那样


407
00:13:00,756 --> 00:13:02,876
在 Swift 中 一切从协议开始


408
00:13:04,176 --> 00:13:06,906
但是 那并不意味着当


409
00:13:06,906 --> 00:13:08,596
你打开 XCode 时你会得到


410
00:13:08,596 --> 00:13:09,816
一个空的源文件 你要做的


411
00:13:09,816 --> 00:13:12,356
第一件事是用键盘输入协议


412
00:13:12,986 --> 00:13:14,766
在 Swift API 设计中


413
00:13:14,766 --> 00:13:16,606
就像任何的 Swift 设计一样


414
00:13:16,606 --> 00:13:18,546
首先通过具体的类型探索用例


415
00:13:18,546 --> 00:13:20,376
并且理解


416
00:13:20,376 --> 00:13:21,466
你想要共享的代码是什么


417
00:13:21,466 --> 00:13:23,686
当你发现自己在不同类型上


418
00:13:23,686 --> 00:13:25,086
重复多个功能时


419
00:13:25,706 --> 00:13:27,516
然后通过泛型将代码


420
00:13:27,516 --> 00:13:29,196
共享出去


421
00:13:30,106 --> 00:13:32,906
那么 那可能意味着创建新的协议


422
00:13:33,336 --> 00:13:35,616
但是首先 想一想


423
00:13:35,616 --> 00:13:37,516
通过现存的协议组成


424
00:13:37,516 --> 00:13:38,186
你需要的东西


425
00:13:38,296 --> 00:13:39,096
而且当你在设计


426
00:13:39,096 --> 00:13:40,446
协议时 请确保它们是


427
00:13:40,446 --> 00:13:41,426
可组合的


428
00:13:42,106 --> 00:13:44,876
作为创建协议的


429
00:13:44,876 --> 00:13:46,866
一种替代 你可以考虑


430
00:13:47,376 --> 00:13:49,506
创建一个泛型


431
00:13:50,456 --> 00:13:51,896
那么 让我们来看一些例子


432
00:13:51,896 --> 00:13:53,256
这些例子展示了刚刚提到的


433
00:13:53,256 --> 00:13:53,816
不同的东西


434
00:13:54,466 --> 00:13:56,316
那么 假设我想要创建


435
00:13:56,316 --> 00:13:57,236
一个几何 API


436
00:13:57,546 --> 00:13:59,206
作为其中的一部分 我想要


437
00:13:59,206 --> 00:14:02,036
创建几何向量上的操作


438
00:14:02,036 --> 00:14:05,186
我可能会从为一个


439
00:14:05,186 --> 00:14:06,706
GeometricVector 创建协议开始


440
00:14:07,086 --> 00:14:08,096
我可以赋予其


441
00:14:08,096 --> 00:14:09,156
我想要定义的操作


442
00:14:09,156 --> 00:14:11,816
比如坐标或者


443
00:14:11,816 --> 00:14:13,356
向量间的距离


444
00:14:15,726 --> 00:14:17,556
现在 我需要存储


445
00:14:17,556 --> 00:14:18,636
向量的维度


446
00:14:18,636 --> 00:14:21,176
那么我可能会使我的几何


447
00:14:21,176 --> 00:14:23,656
向量继承自 SIMD 协议


448
00:14:23,956 --> 00:14:25,226
如果你还不熟悉


449
00:14:25,226 --> 00:14:26,326
SIMD 类型 它们


450
00:14:26,326 --> 00:14:27,466
基本上有点像


451
00:14:27,466 --> 00:14:28,616
同质元组


452
00:14:28,616 --> 00:14:30,016
能够很有效地


453
00:14:30,016 --> 00:14:32,256
一次性在每个元素上


454
00:14:32,256 --> 00:14:32,816
执行计算


455
00:14:33,656 --> 00:14:34,836
而且它们还在


456
00:14:34,836 --> 00:14:36,246
Swift 5.1 中有很多了不起的新功能


457
00:14:36,676 --> 00:14:38,186
它们完美地适用于


458
00:14:38,276 --> 00:14:39,346
几何运算


459
00:14:39,776 --> 00:14:40,696
那么 我们要将我们的维度


460
00:14:40,696 --> 00:14:42,656
存储在基础 SIMD 类型中


461
00:14:42,656 --> 00:14:44,086
而且我们还想要对它进行限制


462
00:14:44,086 --> 00:14:46,636
使它只能在标量 SIMD 上工作


463
00:14:46,896 --> 00:14:47,526
这样一来我们就可以


464
00:14:47,526 --> 00:14:49,716
进行我们想要的计算


465
00:14:49,926 --> 00:14:50,896
现在 一旦我们定义了这个协议


466
00:14:50,896 --> 00:14:52,476
我们就可以继续


467
00:14:52,476 --> 00:14:53,396
进行默认的


468
00:14:53,396 --> 00:14:55,066
执行操作 进行所有


469
00:14:55,066 --> 00:14:56,816
我们想在向量上进行的操作


470
00:14:57,706 --> 00:14:59,796
然后我们希望给予


471
00:14:59,796 --> 00:15:02,716
这个协议一致性


472
00:15:02,946 --> 00:15:04,046
针对每一个我们想要其获得


473
00:15:04,046 --> 00:15:05,616
这些新功能的类型


474
00:15:06,286 --> 00:15:08,586
这个三步


475
00:15:08,826 --> 00:15:10,666
定义协议的过程


476
00:15:10,666 --> 00:15:12,346
赋予了它一个默认的执行 


477
00:15:12,346 --> 00:15:13,696
然后为多种类型增添了一致性


478
00:15:13,696 --> 00:15:15,906
事实上这有点乏味


479
00:15:16,316 --> 00:15:17,436
我们有必要后退


480
00:15:17,436 --> 00:15:18,516
一步想一想


481
00:15:19,076 --> 00:15:21,296
协议真的是必要的吗


482
00:15:22,136 --> 00:15:23,756
事实上


483
00:15:23,756 --> 00:15:25,276
这些一致性实际上没有它们的


484
00:15:25,276 --> 00:15:27,476
自定义执行


485
00:15:27,476 --> 00:15:28,986
这实际上是一个警告的信号


486
00:15:29,086 --> 00:15:30,786
说明协议是没用的


487
00:15:30,966 --> 00:15:31,946
不是每个类型


488
00:15:31,976 --> 00:15:33,186
都有自定义


489
00:15:33,586 --> 00:15:34,916
而且实际上 这一操作


490
00:15:34,916 --> 00:15:36,456
在每个不同种类的


491
00:15:36,456 --> 00:15:37,136
SIMD 类型上都存在


492
00:15:38,156 --> 00:15:39,906
那么 协议真的有在


493
00:15:39,906 --> 00:15:40,696
带给我们什么东西吗


494
00:15:42,146 --> 00:15:43,506
如果我们退一步


495
00:15:43,506 --> 00:15:45,116
不在我们的新协议上


496
00:15:45,116 --> 00:15:46,116
编写默认执行


497
00:15:46,116 --> 00:15:48,856
相反 我们只是将其编写成


498
00:15:48,856 --> 00:15:51,296
直接在 SIMD 协议上的扩展


499
00:15:51,296 --> 00:15:52,136
有着相同的限制


500
00:15:52,136 --> 00:15:54,316
这样我们就完成了


501
00:15:54,366 --> 00:15:55,836
在这个单页的代码中


502
00:15:56,056 --> 00:15:57,746
我们已经自动将所有


503
00:15:57,746 --> 00:15:59,776
我们需要的功能赋给所有的


504
00:15:59,776 --> 00:16:01,616
包含浮点数的 SIMD 类型 


505
00:16:03,406 --> 00:16:04,846
要创建这个协议的


506
00:16:04,846 --> 00:16:06,236
继承式关系


507
00:16:06,236 --> 00:16:08,046
并且将不同类型


508
00:16:08,046 --> 00:16:09,796
划分进继承关系


509
00:16:09,866 --> 00:16:10,916
听上去很吸引人


510
00:16:11,416 --> 00:16:12,986
但是这有点太过于形式


511
00:16:12,986 --> 00:16:14,536
就是让人感觉很满意


512
00:16:14,536 --> 00:16:16,106
但并不总是必要


513
00:16:17,186 --> 00:16:19,226
而且这里总是会涉及到


514
00:16:19,226 --> 00:16:20,076
一个现实的问题


515
00:16:20,706 --> 00:16:22,646
这个没有协议的 更简单的


516
00:16:22,646 --> 00:16:24,246
基于扩展的方式


517
00:16:24,246 --> 00:16:26,566
让编译过程简单很多


518
00:16:27,186 --> 00:16:28,276
如果没有这一串


519
00:16:28,276 --> 00:16:29,486
不必要的协议见证表


520
00:16:29,486 --> 00:16:31,436
你的二进制文件会小很多


521
00:16:32,746 --> 00:16:34,056
事实上 我们发现在


522
00:16:34,146 --> 00:16:36,006
很大的项目上


523
00:16:36,006 --> 00:16:38,186
有着大量的复杂协议类型


524
00:16:38,186 --> 00:16:40,686
通过这个


525
00:16:40,686 --> 00:16:42,296
简化方式并减少


526
00:16:42,296 --> 00:16:45,306
协议的数量


527
00:16:45,306 --> 00:16:46,636
我们可以极大地缩短


528
00:16:46,636 --> 00:16:48,056
编译这些 App 的时间


529
00:16:50,186 --> 00:16:52,856
目前 这个方式


530
00:16:52,856 --> 00:16:54,576
对一小部分项目有用


531
00:16:54,946 --> 00:16:56,296
但是当你在设计


532
00:16:56,296 --> 00:16:57,596
一个更完全的 API 时 就涉及


533
00:16:57,596 --> 00:16:58,416
一个可扩展问题


534
00:16:58,416 --> 00:17:01,516
早些时候 我们想着


535
00:17:01,516 --> 00:17:03,676
创建一个协议


536
00:17:03,676 --> 00:17:05,636
我们说了我们要定义几何向量


537
00:17:05,636 --> 00:17:07,836
并用它继承 SIMD


538
00:17:08,136 --> 00:17:09,636
用于我们的存储


539
00:17:10,455 --> 00:17:11,846
但是这真的是正确的吗


540
00:17:11,976 --> 00:17:14,336
这是一种承继关系吗


541
00:17:14,336 --> 00:17:16,046
我们真的可以说几何


542
00:17:16,046 --> 00:17:18,415
向量是 SIMD 类型吗


543
00:17:18,415 --> 00:17:21,096
我的意思是说 一些操作是合理的


544
00:17:21,096 --> 00:17:23,326
你可以添加或者移除向量


545
00:17:23,965 --> 00:17:24,776
但是有一些不行


546
00:17:24,776 --> 00:17:26,546
你不能将两个


547
00:17:26,546 --> 00:17:27,296
向量相互乘起来


548
00:17:27,296 --> 00:17:29,826
或者将数字 1 添加至向量


549
00:17:29,826 --> 00:17:31,886
但是这些操作在


550
00:17:31,886 --> 00:17:33,736
所有的 SIMD 类型都是可行的


551
00:17:33,946 --> 00:17:35,266
在其他的条件下要有


552
00:17:35,266 --> 00:17:37,276
其他合理的定义


553
00:17:37,276 --> 00:17:39,206
只是不是在几何的情况下


554
00:17:40,326 --> 00:17:41,986
如果我们正在设计一个


555
00:17:41,986 --> 00:17:43,856
便于使用的 API


556
00:17:44,126 --> 00:17:45,316
那么我们也许应该考虑另一个选项


557
00:17:45,316 --> 00:17:48,906
这个选项不是承继关系


558
00:17:48,906 --> 00:17:50,366
而是执行一种组合关系


559
00:17:50,856 --> 00:17:53,236
就是将一个 SIMD 值包含在


560
00:17:53,676 --> 00:17:55,256
一个泛型结构里


561
00:17:55,866 --> 00:17:57,666
这样我们就可以创建一个


562
00:17:57,666 --> 00:17:59,506
几何向量的结构


563
00:17:59,786 --> 00:18:02,096
而且我们将其设定为


564
00:18:02,096 --> 00:18:03,936
SIMD 存储类型的泛型


565
00:18:03,936 --> 00:18:05,816
这样它就可以处理浮点类型


566
00:18:06,086 --> 00:18:07,736
以及任何不同数量的维度


567
00:18:08,366 --> 00:18:11,166
然后 一旦我们完成了这个操作


568
00:18:11,166 --> 00:18:13,086
对于在我们的


569
00:18:13,086 --> 00:18:15,116
新类型上显示什么 API 就有了


570
00:18:15,116 --> 00:18:16,586
更精细的控制


571
00:18:17,566 --> 00:18:19,956
所以我们就可以定义两个


572
00:18:19,956 --> 00:18:20,926
向量的相加


573
00:18:21,296 --> 00:18:23,096
而不是某一向量


574
00:18:23,096 --> 00:18:24,126
单个数字的相加


575
00:18:24,416 --> 00:18:26,556
又或者 我们可以依照标量


576
00:18:27,056 --> 00:18:29,156
定义向量的相乘


577
00:18:29,156 --> 00:18:31,386
而不是两个向量


578
00:18:31,386 --> 00:18:33,196
彼此相乘


579
00:18:35,286 --> 00:18:37,546
而且我们仍然可以使用泛型扩展


580
00:18:37,546 --> 00:18:39,376
这样一来 我们执行的


581
00:18:39,426 --> 00:18:41,226
坐标和距离


582
00:18:41,226 --> 00:18:42,676
就和它们之前的是一样的


583
00:18:43,306 --> 00:18:45,876
现在 我们已经在


584
00:18:45,876 --> 00:18:47,796
标准库使用了这一技术


585
00:18:47,796 --> 00:18:49,906
例如 我们就有了一个


586
00:18:49,906 --> 00:18:50,966
SIMD 协议


587
00:18:51,166 --> 00:18:53,406
而且然后我们有了


588
00:18:53,406 --> 00:18:54,766
泛型结构 其代表了


589
00:18:54,766 --> 00:18:56,996
不同尺寸的 SIMD 类型


590
00:18:57,466 --> 00:19:00,676
请注意 这里并没有 SIMD2 或者


591
00:19:00,716 --> 00:19:02,016
SIMD3 协议


592
00:19:02,016 --> 00:19:03,616
它们不必添加很多值


593
00:19:04,626 --> 00:19:06,166
用户仍可以通过


594
00:19:06,166 --> 00:19:08,216
扩展来为特定尺寸的 SIMD


595
00:19:08,756 --> 00:19:11,136
编写泛型代码 比如


596
00:19:11,136 --> 00:19:12,846
对于一个跨产品操作的 SIMD3 类型


597
00:19:12,846 --> 00:19:14,146
你仅仅想要


598
00:19:14,146 --> 00:19:17,176
定义一个三维的 SIMD 类型


599
00:19:17,856 --> 00:19:19,486
希望这些能让你知道


600
00:19:19,486 --> 00:19:21,376
泛型是如何


601
00:19:21,376 --> 00:19:22,966
像协议一样


602
00:19:22,966 --> 00:19:25,096
强大又具扩展性


603
00:19:25,906 --> 00:19:27,236
现在 我们在这里还是在


604
00:19:27,236 --> 00:19:28,006
借助协议的力量


605
00:19:28,976 --> 00:19:30,106
我们在泛型 SIMD 上


606
00:19:30,106 --> 00:19:31,896
有限制标量类型的浮点


607
00:19:31,896 --> 00:19:33,666
它为我们


608
00:19:33,666 --> 00:19:34,776
提供了基本代码块


609
00:19:34,776 --> 00:19:38,726
可以用于写代码


610
00:19:39,276 --> 00:19:40,796
现在 在我们的


611
00:19:40,796 --> 00:19:42,656
GeometricVector 类型上 我们可以


612
00:19:42,656 --> 00:19:43,856
编写同样的跨产品操作


613
00:19:44,426 --> 00:19:45,706
但是当我们这样做


614
00:19:45,706 --> 00:19:47,276
执行操作看上去


615
00:19:47,276 --> 00:19:48,116
会有点丑陋


616
00:19:48,606 --> 00:19:49,486
因为我们必须保持


617
00:19:49,536 --> 00:19:51,006
间接通过值存储


618
00:19:51,006 --> 00:19:52,356
来获取


619
00:19:52,356 --> 00:19:54,156
X Y 和 Z 坐标


620
00:19:54,496 --> 00:19:56,046
所以 如果我们可以


621
00:19:56,046 --> 00:19:56,806
解决这个问题 会很棒


622
00:19:57,246 --> 00:19:58,616
现在 很显然我们可以


623
00:19:58,616 --> 00:19:59,946
的向量类型上为


624
00:19:59,946 --> 00:20:01,516
X Y 和 Z 编写计算出的属性


625
00:20:01,576 --> 00:20:02,896
但是实际上在


626
00:20:02,896 --> 00:20:05,846
Swift 5.1 有一个新功能叫做


627
00:20:05,846 --> 00:20:07,876
关键路径成员查找 


628
00:20:07,876 --> 00:20:09,696
你可以编写单个下标操作


629
00:20:09,696 --> 00:20:11,446
同时显示


630
00:20:11,636 --> 00:20:13,766
一个类型中的多个


631
00:20:13,766 --> 00:20:15,286
不同的计算属性


632
00:20:15,286 --> 00:20:18,096
这样一来 我们就可以根据选择


633
00:20:18,096 --> 00:20:20,426
来使用它 如果可行


634
00:20:20,426 --> 00:20:22,256
就一次性将


635
00:20:22,256 --> 00:20:25,266
SIMD 上的所有属性显示在


636
00:20:25,266 --> 00:20:25,836
我们的几何向量上


637
00:20:26,396 --> 00:20:27,536
让我们来看看我们是如何做的


638
00:20:28,506 --> 00:20:31,296
那么首先 我们将我们的 GeometricVector


639
00:20:31,296 --> 00:20:33,886
标记为 dynamicMemberLookup 属性


640
00:20:34,686 --> 00:20:37,936
紧接着 编译器


641
00:20:37,936 --> 00:20:39,146
会提醒我们写一个特殊的


642
00:20:39,236 --> 00:20:40,546
动态成员下标


643
00:20:41,136 --> 00:20:44,966
这个下标采取关键路径


644
00:20:44,966 --> 00:20:46,206
执行这一下标


645
00:20:46,206 --> 00:20:47,746
的影响是任何


646
00:20:47,806 --> 00:20:49,606
可通过该关键路径


647
00:20:49,606 --> 00:20:52,096
自动访问的属性


648
00:20:52,096 --> 00:20:53,826
都会在我们的 GeometricVector 类型上


649
00:20:54,256 --> 00:20:56,436
显示为计算属性


650
00:20:56,946 --> 00:20:58,336
在这个例子中 我们想要


651
00:20:58,386 --> 00:21:00,556
关键路径是进入 SIMD 存储类型


652
00:21:00,556 --> 00:21:02,496
并返回一个标量


653
00:21:02,956 --> 00:21:04,336
然后我们使用那个关键路径


654
00:21:04,336 --> 00:21:05,766
继续并获取


655
00:21:05,766 --> 00:21:08,516
来自值存储的值并返回


656
00:21:08,516 --> 00:21:11,076
一旦我们完成了这些


657
00:21:11,156 --> 00:21:12,946
我们的几何向量


658
00:21:12,946 --> 00:21:13,826
就会自动获得所有


659
00:21:13,826 --> 00:21:15,216
SIMD 拥有的属性


660
00:21:16,036 --> 00:21:17,806
举个例子


661
00:21:17,806 --> 00:21:18,816
可以获取 X Y 和 Z 坐标


662
00:21:18,996 --> 00:21:20,036
而且它们甚至出现在


663
00:21:20,036 --> 00:21:21,646
Xcode 的自动补全里


664
00:21:22,646 --> 00:21:24,386
如果你想在 Swift 5 里尝试这一功能


665
00:21:24,386 --> 00:21:25,446
当它是基于字符串时


666
00:21:25,446 --> 00:21:27,066
这里的区别在于


667
00:21:27,066 --> 00:21:28,526
这个版本是


668
00:21:28,526 --> 00:21:29,876
完全类型安全的


669
00:21:30,556 --> 00:21:31,586
而且更多的东西是在


670
00:21:31,586 --> 00:21:34,806
编译时完成


671
00:21:35,046 --> 00:21:36,016
既然我们可以访问


672
00:21:36,016 --> 00:21:37,306
X Y 和 Z 属性 那么


673
00:21:37,306 --> 00:21:38,916
我们就可以很大程度上


674
00:21:39,346 --> 00:21:41,936
简化我们的跨产品操作了


675
00:21:42,436 --> 00:21:44,466
就是这样 看上去好多了


676
00:21:44,756 --> 00:21:45,996
目前 这个动态成员


677
00:21:46,296 --> 00:21:48,266
的功能不仅对于


678
00:21:48,266 --> 00:21:49,606
发送属性有用


679
00:21:49,606 --> 00:21:52,436
你还可以将复杂的逻辑放进下标


680
00:21:52,436 --> 00:21:54,376
那么我们再来看一个例子


681
00:21:54,986 --> 00:21:57,536
让我们回到早前的例子


682
00:21:57,536 --> 00:21:59,576
在这个例子中 我们


683
00:21:59,576 --> 00:22:01,296
通过写时复制语义


684
00:22:01,636 --> 00:22:03,616
显示了 texture 的特定属性


685
00:22:04,146 --> 00:22:05,746
这对于一个属性是有效的


686
00:22:05,746 --> 00:22:07,106
但是会很不幸


687
00:22:07,106 --> 00:22:08,646
如果我们需要每次都编写


688
00:22:08,646 --> 00:22:09,566
相同的代码


689
00:22:10,606 --> 00:22:11,846
如果它想要将


690
00:22:11,846 --> 00:22:13,726
texture 上的所有属性


691
00:22:13,926 --> 00:22:15,476
使用写时复制语义属性


692
00:22:15,786 --> 00:22:16,996
作为 material 类型的属性怎么办


693
00:22:16,996 --> 00:22:18,296
那么 我们可以通过动态


694
00:22:18,296 --> 00:22:18,896
成员查找来实现


695
00:22:19,766 --> 00:22:21,696
那么首先 我们要将


696
00:22:21,696 --> 00:22:23,456
dynamicMemberLookup 添加至我们的类型


697
00:22:24,986 --> 00:22:26,926
然后我们执行


698
00:22:26,926 --> 00:22:27,946
下标操作


699
00:22:27,946 --> 00:22:29,496
而且我们要使它采取


700
00:22:29,666 --> 00:22:30,926
一个可写的关键路径


701
00:22:30,926 --> 00:22:32,846
因为我们希望可以同时获取


702
00:22:32,846 --> 00:22:33,856
并设定属性


703
00:22:34,816 --> 00:22:37,346
再将泛型作为返回值


704
00:22:37,616 --> 00:22:38,636
因为我们想要在 texture 中


705
00:22:38,636 --> 00:22:40,806
获取不同的类型


706
00:22:41,376 --> 00:22:44,526
然后我们执行 get 和 set 方法


707
00:22:44,666 --> 00:22:45,896
在 get 方法中我们只需要


708
00:22:45,896 --> 00:22:46,956
进行之前的操作


709
00:22:47,576 --> 00:22:49,506
但是在 set 方法中 在我们做出


710
00:22:49,506 --> 00:22:51,696
更改前 我们要添加唯一


711
00:22:51,696 --> 00:22:54,256
引用检查和 texture 的完整拷贝


712
00:22:55,036 --> 00:22:57,056
通过这样的做法


713
00:22:57,056 --> 00:22:58,606
在这个简洁的下标中


714
00:22:58,606 --> 00:23:00,416
我们显示了


715
00:23:00,416 --> 00:23:02,726
texture 上的每一个属性


716
00:23:02,726 --> 00:23:04,606
同时在我们的 texture 类型上有


717
00:23:04,606 --> 00:23:05,416
写时复制语义


718
00:23:06,036 --> 00:23:07,526
这是一个非常有用的方式


719
00:23:07,526 --> 00:23:09,996
以此来从你的类型中获取值语义


720
00:23:11,916 --> 00:23:14,286
这个新的功能有很多


721
00:23:14,286 --> 00:23:15,126
不同的应用


722
00:23:15,126 --> 00:23:16,616
事实上它和 5.1 中的


723
00:23:16,616 --> 00:23:18,856
一个新功能很好地组合在了一起


724
00:23:19,126 --> 00:23:20,436
那就是属性包装器


725
00:23:20,436 --> 00:23:21,826
接下来 Doug 会聊一聊这个话题


726
00:23:22,366 --> 00:23:30,356
Doug [掌声]


727
00:23:30,856 --> 00:23:31,446
>> 谢谢你 Ben


728
00:23:32,926 --> 00:23:36,416
那么 Swift 是为了清晰


729
00:23:36,416 --> 00:23:38,566
简洁的代码设计的


730
00:23:38,566 --> 00:23:40,846
也是为了构建表现力优异的 API 对吗


731
00:23:40,886 --> 00:23:42,066
也是为了代码的重新利用


732
00:23:42,066 --> 00:23:42,826
我们已经谈过了


733
00:23:42,896 --> 00:23:44,956
泛型和协议


734
00:23:44,956 --> 00:23:46,106
有了它们你才可以


735
00:23:46,406 --> 00:23:48,766
创建泛型代码


736
00:23:48,766 --> 00:23:50,636
所以为了你的功能和类型


737
00:23:50,636 --> 00:23:51,476
那是可以被再利用的


738
00:23:51,866 --> 00:23:54,026
所以属性包装器


739
00:23:54,026 --> 00:23:55,766
是 Swift 5.1 的新功能


740
00:23:56,486 --> 00:23:58,066
属性包装器背后的想法


741
00:23:58,066 --> 00:23:59,796
是有效地从你编写的


742
00:23:59,796 --> 00:24:01,566
计算属性中获取


743
00:24:01,566 --> 00:24:02,456
代码的重新利用


744
00:24:03,456 --> 00:24:06,376
像这样 这儿有一堆代码


745
00:24:07,486 --> 00:24:10,266
那么这里发生了什么呢


746
00:24:10,266 --> 00:24:12,936
所以 我们尝试去做的就是


747
00:24:13,356 --> 00:24:15,526
显示一个 public 属性 对吗


748
00:24:16,276 --> 00:24:16,946
然后我们得到了这个


749
00:24:16,946 --> 00:24:17,976
我们只是想要一个 image 属性


750
00:24:17,976 --> 00:24:18,526
并且是 public


751
00:24:18,916 --> 00:24:20,256
但是我们并不希望


752
00:24:20,606 --> 00:24:22,236
所有的用户 我们的客户


753
00:24:22,236 --> 00:24:23,966
可以那里编写任意值


754
00:24:24,226 --> 00:24:25,676
我们想要描述一些策略


755
00:24:25,746 --> 00:24:27,016
那么这就变成计算过的属性


756
00:24:27,326 --> 00:24:29,616
我们实际的存储回到


757
00:24:29,616 --> 00:24:31,116
这里 在内部的


758
00:24:31,116 --> 00:24:32,056
imageStorage 属性中


759
00:24:32,646 --> 00:24:34,106
所以通向那存储的访问权限


760
00:24:34,366 --> 00:24:36,926
都是通过 get 和 set 方法建立的


761
00:24:37,636 --> 00:24:39,566
这有很多代码


762
00:24:39,706 --> 00:24:40,926
你们可以先看一看


763
00:24:41,396 --> 00:24:42,256
你们中的一些人也许


764
00:24:42,256 --> 00:24:43,556
认出了这是什么


765
00:24:44,446 --> 00:24:45,966
它真的是一种很冗长的方式


766
00:24:45,966 --> 00:24:49,176
来描述这只是一个惰性变量 image


767
00:24:50,616 --> 00:24:52,446
现在这样就好多了


768
00:24:53,696 --> 00:24:55,216
这是一行代码而不是


769
00:24:55,276 --> 00:24:57,316
有着杂乱访问策略逻辑的


770
00:24:57,456 --> 00:24:59,436
两个属性


771
00:24:59,936 --> 00:25:02,256
我们有这个很好的修饰语


772
00:25:02,376 --> 00:25:04,626
lazy 来告诉你


773
00:25:04,626 --> 00:25:06,146
这里真实的语义是什么


774
00:25:07,266 --> 00:25:07,996
这很重要


775
00:25:07,996 --> 00:25:08,936
能更好的写文档


776
00:25:08,936 --> 00:25:09,866
也更便于阅读


777
00:25:10,776 --> 00:25:11,826
这就是为什么 lazy


778
00:25:11,826 --> 00:25:13,376
自 Swift 1 就在语言中存在了


779
00:25:14,136 --> 00:25:18,856
现在问题是


780
00:25:19,256 --> 00:25:21,226
这是一个更笼统问题的例子


781
00:25:21,346 --> 00:25:23,306
那么 让我们来看看这里的


782
00:25:23,306 --> 00:25:24,996
另一个例子 也就是代码结构


783
00:25:25,716 --> 00:25:26,856
基本上是相似的


784
00:25:28,006 --> 00:25:29,746
但是策略以及实际


785
00:25:29,746 --> 00:25:30,986
在 get 和 set 中


786
00:25:30,986 --> 00:25:32,556
的执行不一样


787
00:25:32,856 --> 00:25:33,956
那么如果你在看


788
00:25:33,956 --> 00:25:35,646
这里的逻辑


789
00:25:35,646 --> 00:25:37,836
你看到这是一个延迟初始化模式


790
00:25:37,836 --> 00:25:39,476
你必须设置过这个


791
00:25:40,236 --> 00:25:41,956
或者在你可以读取之前


792
00:25:41,956 --> 00:25:42,436
曾初始化过


793
00:25:42,436 --> 00:25:43,456
否则你就会失败


794
00:25:43,456 --> 00:25:45,006
这是非常常见的事情


795
00:25:46,206 --> 00:25:47,196
这类的代码出现在


796
00:25:47,196 --> 00:25:47,916
很多地方


797
00:25:48,456 --> 00:25:50,816
我们不会通过


798
00:25:50,816 --> 00:25:52,676
为 Swift 提供另一种语言的扩展


799
00:25:53,226 --> 00:25:55,296
来解决这个问题


800
00:25:56,266 --> 00:25:57,326
但是事实上 我们想要


801
00:25:57,326 --> 00:25:58,476
更宏观地解决这个


802
00:25:58,476 --> 00:25:59,606
因为我们希望人们可以构建


803
00:25:59,606 --> 00:26:00,906
这些东西的库


804
00:26:00,906 --> 00:26:02,026
在这个库中


805
00:26:02,026 --> 00:26:03,476
他们能够分离出


806
00:26:03,476 --> 00:26:05,356
访问单个值的策略


807
00:26:05,986 --> 00:26:07,716
所以这就是


808
00:26:07,716 --> 00:26:09,076
属性包装器背后的想法


809
00:26:09,076 --> 00:26:10,936
就是去消除这种样板


810
00:26:10,936 --> 00:26:12,356
并获得表现更加优异的 API


811
00:26:13,556 --> 00:26:15,006
那么 它们看上去有点像这样


812
00:26:15,716 --> 00:26:17,706
这里的想法就是我们希望


813
00:26:17,706 --> 00:26:19,296
当你在声明一个属性时能


814
00:26:19,296 --> 00:26:20,206
使用标记


815
00:26:20,206 --> 00:26:22,236
所以在这里它就是 public 文本变量


816
00:26:22,236 --> 00:26:26,316
并运用延迟


817
00:26:26,316 --> 00:26:28,136
初始化属性包装器来


818
00:26:28,136 --> 00:26:29,876
给予它特别的语义


819
00:26:29,876 --> 00:26:30,936
来给予它


820
00:26:30,936 --> 00:26:32,176
特别的策略


821
00:26:33,696 --> 00:26:35,266
现在这个 @LateInitialized


822
00:26:35,266 --> 00:26:36,686
这是一个自定义属性


823
00:26:36,686 --> 00:26:37,906
这是一个新的标记


824
00:26:37,906 --> 00:26:38,986
我们在 Swift 中会稍微用到


825
00:26:39,406 --> 00:26:41,496
最根本的 它就是在说


826
00:26:41,686 --> 00:26:42,836
应用这个延迟初始化模式


827
00:26:42,836 --> 00:26:43,686
无论它是什么


828
00:26:43,686 --> 00:26:44,876
我们之后会回到这个来


829
00:26:45,516 --> 00:26:47,316
但是仅仅从代码角度看


830
00:26:47,316 --> 00:26:49,726
这整个都像是惰性的


831
00:26:49,726 --> 00:26:51,046
它为我们带来的好处和


832
00:26:51,106 --> 00:26:52,166
惰性是完全一样的


833
00:26:52,736 --> 00:26:54,506
我们已经完全摆脱了样板文件


834
00:26:55,516 --> 00:26:57,796
但是同时 我们也在


835
00:26:57,886 --> 00:26:58,866
声明的位置就说明了


836
00:26:58,866 --> 00:27:00,426
实际上的语义


837
00:27:00,426 --> 00:27:01,996
比起那些混乱的代码


838
00:27:01,996 --> 00:27:04,406
这更容易阅读和理解


839
00:27:05,386 --> 00:27:07,626
好的 关于这一行小小的代码


840
00:27:07,626 --> 00:27:08,466
已经讲得够多了


841
00:27:08,636 --> 00:27:09,916
让我们来看看那延迟初始化


842
00:27:09,916 --> 00:27:10,866
实际上看起来是怎么样的


843
00:27:11,776 --> 00:27:13,206
你在这里将会看到


844
00:27:13,206 --> 00:27:13,816
它是一些代码


845
00:27:13,816 --> 00:27:15,976
但是就跟我们刚刚看到的代码一样


846
00:27:15,976 --> 00:27:17,936
延迟初始化背后的


847
00:27:18,276 --> 00:27:20,076
策略模版是一样的


848
00:27:21,136 --> 00:27:22,776
在这里你有 get 和 set


849
00:27:22,956 --> 00:27:24,846
set 是更新存储


850
00:27:24,876 --> 00:27:25,876
get 是检查以确保


851
00:27:25,876 --> 00:27:27,376
至少将其设置过一次


852
00:27:27,376 --> 00:27:28,276
并且当我们有设置时


853
00:27:28,276 --> 00:27:30,416
返回值 这非常直接


854
00:27:31,176 --> 00:27:33,476
现在使这个简单的


855
00:27:33,476 --> 00:27:35,716
泛型变得有意思的点在于


856
00:27:35,756 --> 00:27:37,216
它是一个属性包装器


857
00:27:37,686 --> 00:27:39,196
它由这里


858
00:27:39,306 --> 00:27:40,786
顶部的 propertyWrapper 属性


859
00:27:40,786 --> 00:27:41,256
指出是什么样


860
00:27:42,376 --> 00:27:43,606
那么 它所做的就是


861
00:27:43,606 --> 00:27:45,396
允许自定义属性句法


862
00:27:45,396 --> 00:27:47,086
也就是说我们能将这个东西


863
00:27:47,086 --> 00:27:49,086
运用到其他一些属性上


864
00:27:49,936 --> 00:27:50,986
现在 有了 propertyWrapper 属性


865
00:27:50,986 --> 00:27:52,936
就出现了一些要求


866
00:27:53,096 --> 00:27:55,036
主要的一个问题要有


867
00:27:55,286 --> 00:27:56,406
value 属性


868
00:27:57,056 --> 00:27:59,336
这是所有策略执行的地方


869
00:27:59,386 --> 00:28:01,146
所以所有访问


870
00:28:01,146 --> 00:28:02,686
延迟初始化属性的权限都经过这里


871
00:28:03,876 --> 00:28:05,386
而且我们看到实际的


872
00:28:05,386 --> 00:28:06,836
标记是找到一些


873
00:28:06,836 --> 00:28:08,356
提取的概念关于什么是


874
00:28:08,356 --> 00:28:09,416
延迟初始化


875
00:28:10,156 --> 00:28:11,166
在这个特殊的例子中


876
00:28:11,166 --> 00:28:12,756
另一个有趣的事情是


877
00:28:12,756 --> 00:28:14,706
我们已经声明了一个


878
00:28:14,706 --> 00:28:15,956
没有参数的初始化


879
00:28:17,716 --> 00:28:19,016
现在 在属性包装器里


880
00:28:19,016 --> 00:28:19,756
这是可选的


881
00:28:19,906 --> 00:28:21,506
但是当你使用时


882
00:28:21,506 --> 00:28:22,756
它想说明的就是


883
00:28:22,756 --> 00:28:24,516
应用该包装器属性


884
00:28:25,036 --> 00:28:26,806
免费获得了


885
00:28:26,806 --> 00:28:28,056
隐式初始化


886
00:28:28,056 --> 00:28:29,136
在这个特殊的初始化中


887
00:28:32,076 --> 00:28:32,166
>> 好的


888
00:28:33,986 --> 00:28:35,116
让我们来实际运用这个东西


889
00:28:35,426 --> 00:28:37,006
所以 当你通过将其


890
00:28:37,006 --> 00:28:38,176
应用至一个特定的属性


891
00:28:38,176 --> 00:28:39,886
来使用属性包装器时


892
00:28:39,886 --> 00:28:41,546
编译器要将


893
00:28:41,546 --> 00:28:44,856
那个代码翻译成两个分开的属性


894
00:28:44,856 --> 00:28:46,876
基本上 我们正在


895
00:28:46,876 --> 00:28:48,076
扩展成为我们一开始


896
00:28:48,076 --> 00:28:48,716
看到的模式


897
00:28:49,426 --> 00:28:51,416
所以你有一个带 $ 前缀的


898
00:28:51,416 --> 00:28:53,346
备份存储属性


899
00:28:53,346 --> 00:28:55,826
所以 $text 的类型


900
00:28:56,116 --> 00:28:58,396
是属性包装器类型的一个实例


901
00:28:58,456 --> 00:28:59,276
所以我们现在有一个


902
00:28:59,276 --> 00:29:00,806
LateInitialized 字符串


903
00:29:01,826 --> 00:29:03,246
它提供存储


904
00:29:04,616 --> 00:29:05,976
通过调用无参数初始化


905
00:29:06,256 --> 00:29:09,646
它将由编译器进行隐式初始化


906
00:29:09,646 --> 00:29:11,256
就是我们刚刚提到的


907
00:29:11,586 --> 00:29:12,836
因为它在那儿 现在我们


908
00:29:12,836 --> 00:29:13,996
获得了隐式初始化


909
00:29:14,546 --> 00:29:16,586
而延迟初始化随时可以进行


910
00:29:16,866 --> 00:29:18,706
你也许能想起来


911
00:29:18,706 --> 00:29:19,666
存储被设成了 nil


912
00:29:21,136 --> 00:29:21,966
编译器在这里


913
00:29:21,966 --> 00:29:23,596
还做了一件事 就是


914
00:29:23,596 --> 00:29:26,526
将文本翻译成计算属性


915
00:29:27,286 --> 00:29:28,706
所以 get 要


916
00:29:28,706 --> 00:29:31,066
创建一个对 $text 的访问


917
00:29:31,506 --> 00:29:33,776
然后通过


918
00:29:33,776 --> 00:29:36,056
调用 get 值来获取


919
00:29:36,056 --> 00:29:36,926
$text 的值


920
00:29:36,976 --> 00:29:39,346
在 set 里我们也进行同样的操作


921
00:29:39,346 --> 00:29:42,686
在 $text.value 中写下新的值


922
00:29:43,026 --> 00:29:44,756
所以就是这个


923
00:29:44,756 --> 00:29:46,356
属性包装器能有


924
00:29:46,356 --> 00:29:47,496
其自己的存储


925
00:29:47,496 --> 00:29:48,296
无论它想要怎么存储


926
00:29:48,296 --> 00:29:49,416
无论是本地或者其他地方


927
00:29:49,986 --> 00:29:52,796
然后无论执行什么


928
00:29:52,796 --> 00:29:54,886
你指定的策略


929
00:29:54,886 --> 00:29:57,386
通过 get 和 set 访问数据


930
00:29:58,756 --> 00:30:00,656
所以总的来说 这是很好的


931
00:30:00,656 --> 00:30:02,576
我们已经将策略和它的应用分离


932
00:30:02,736 --> 00:30:04,236
将其放在


933
00:30:04,236 --> 00:30:07,736
延迟初始化包装器中


934
00:30:07,966 --> 00:30:10,156
无论我们想要什么类型


935
00:30:10,156 --> 00:30:11,466
我们都可以对任意数量的


936
00:30:11,466 --> 00:30:14,006
不同属性进行操作


937
00:30:14,006 --> 00:30:15,506
在简单很多同时有更少的样板文件


938
00:30:17,196 --> 00:30:19,316
那么 让我们来看看另一个例子


939
00:30:20,236 --> 00:30:21,546
Ben 有提到过关于


940
00:30:21,546 --> 00:30:23,276
值和引用语义的东西


941
00:30:23,866 --> 00:30:24,606
现在 当你在处理


942
00:30:24,606 --> 00:30:26,196
引用语义和可变状态时


943
00:30:26,196 --> 00:30:27,516
你会发现在


944
00:30:27,516 --> 00:30:28,866
在某些时候进行着


945
00:30:28,866 --> 00:30:29,436
防御性拷贝


946
00:30:30,046 --> 00:30:31,486
当然 我们可以手动在任何


947
00:30:31,486 --> 00:30:32,866
需要的地方做这件事


948
00:30:32,866 --> 00:30:34,086
但是为什么不为此


949
00:30:34,086 --> 00:30:35,036
构建一个属性包装器呢


950
00:30:35,506 --> 00:30:38,506
所以 这就是属性包装器


951
00:30:38,506 --> 00:30:40,146
它的样子基本上


952
00:30:40,146 --> 00:30:41,526
和我们之前看到的一样


953
00:30:41,526 --> 00:30:42,546
它有存储能力


954
00:30:42,546 --> 00:30:43,786
它有一个值属性


955
00:30:44,306 --> 00:30:45,636
这个属性包装器的


956
00:30:45,676 --> 00:30:48,276
所有策略都在 set里


957
00:30:48,536 --> 00:30:49,766
当我们有了一个新的值


958
00:30:49,766 --> 00:30:50,836
继续并复制这个值


959
00:30:51,216 --> 00:30:52,876
而且由于我们正在使用 NSCopying


960
00:30:52,876 --> 00:30:54,906
来进行复制


961
00:30:54,906 --> 00:30:56,436
它就会继续并调用复制方法


962
00:30:56,436 --> 00:30:57,166
然后进行投射


963
00:30:58,516 --> 00:30:59,736
关于防御性拷贝的


964
00:30:59,736 --> 00:31:02,246
另一件有趣的事情在于


965
00:31:02,246 --> 00:31:04,196
它提供一个初始值的初始化


966
00:31:04,816 --> 00:31:06,746
这就像那个没有参数的初始化


967
00:31:06,746 --> 00:31:08,086
在你的属性包装器里


968
00:31:08,086 --> 00:31:08,996
它并不是必须的


969
00:31:09,436 --> 00:31:11,546
但是如果它在那里


970
00:31:11,546 --> 00:31:13,976
就会让你在属性包装其中的


971
00:31:13,976 --> 00:31:15,076
所有属性


972
00:31:15,076 --> 00:31:15,926
都被赋为默认值


973
00:31:16,336 --> 00:31:18,776
那个默认值会被填入这个初始化


974
00:31:19,106 --> 00:31:20,406
我们可以在


975
00:31:20,406 --> 00:31:21,376
初始化上实行任何我们


976
00:31:21,376 --> 00:31:22,206
希望的策略


977
00:31:22,826 --> 00:31:24,116
在我们的这个例子中


978
00:31:24,116 --> 00:31:25,076
就跟 set 策略一样


979
00:31:25,356 --> 00:31:27,766
我们想要继续并创建一个


980
00:31:27,766 --> 00:31:30,926
防御性拷贝


981
00:31:33,296 --> 00:31:34,376
之后为它分配一个结果


982
00:31:35,206 --> 00:31:35,946
让我们来看一下


983
00:31:36,436 --> 00:31:38,636
那么 如果我们要定义一些


984
00:31:38,636 --> 00:31:40,116
防御性拷贝 UIBezierPath


985
00:31:40,956 --> 00:31:41,716
会发生什么呢


986
00:31:41,716 --> 00:31:43,036
好吧 编译器会


987
00:31:43,306 --> 00:31:44,956
将其编译成两个


988
00:31:44,956 --> 00:31:45,896
不同的定义


989
00:31:46,256 --> 00:31:46,976
首先 在这里我们将会


990
00:31:46,976 --> 00:31:48,756
有一个初始化


991
00:31:49,386 --> 00:31:51,256
所以这里 无论何时我们创建这个路径


992
00:31:51,256 --> 00:31:53,006
它有一个默认的


993
00:31:53,006 --> 00:31:54,366
UIBezierPath


994
00:31:54,886 --> 00:31:56,536
只是创建了空白的实例


995
00:31:56,956 --> 00:31:58,366
然后当我们继续并


996
00:31:58,366 --> 00:32:00,056
将其变成多个属性时


997
00:32:00,056 --> 00:32:01,826
就有了备份


998
00:32:01,826 --> 00:32:03,186
存储属性 $path


999
00:32:03,856 --> 00:32:05,326
请注意我们是如何将它初始化的


1000
00:32:05,406 --> 00:32:06,936
我们将用户提供的


1001
00:32:06,936 --> 00:32:09,026
初始值传输至


1002
00:32:09,026 --> 00:32:11,576
初始值初始化 这样它


1003
00:32:11,576 --> 00:32:12,756
就可以被防御性复制了


1004
00:32:13,566 --> 00:32:14,556
get 和 set 方法


1005
00:32:14,556 --> 00:32:15,376
看上去完全一样


1006
00:32:15,376 --> 00:32:16,376
get 和 set


1007
00:32:16,376 --> 00:32:18,686
都需要 $path.value


1008
00:32:19,836 --> 00:32:21,666
现在 当然在默认情况下


1009
00:32:21,666 --> 00:32:22,616
是正确的语义


1010
00:32:22,616 --> 00:32:24,106
防御性拷贝应该


1011
00:32:24,106 --> 00:32:24,846
继续并进行复制


1012
00:32:25,486 --> 00:32:26,786
在这个例子中我们了解了


1013
00:32:26,786 --> 00:32:28,356
有关默认值的知识


1014
00:32:28,516 --> 00:32:29,546
就是创建一个新的对象


1015
00:32:29,716 --> 00:32:31,086
为什么我们要操作并复制呢


1016
00:32:31,486 --> 00:32:33,606
所以 让我们来稍微优化一下


1017
00:32:33,606 --> 00:32:34,766
因为我们可以做到


1018
00:32:35,796 --> 00:32:37,286
所以我们能够扩展防御拷贝


1019
00:32:37,326 --> 00:32:37,956
它只是一个类型


1020
00:32:38,046 --> 00:32:39,066
关于这个类型


1021
00:32:39,066 --> 00:32:39,966
没有什么神奇的


1022
00:32:39,966 --> 00:32:40,906
除了在使用时它表现得像


1023
00:32:40,906 --> 00:32:42,466
一个属性包装器


1024
00:32:42,946 --> 00:32:44,176
而且我们可以添加


1025
00:32:44,246 --> 00:32:45,686
withoutCopying 初始化


1026
00:32:46,286 --> 00:32:49,516
当我们这么使用时 


1027
00:32:49,516 --> 00:32:50,936
我们可以进行并为我们的类型


1028
00:32:50,936 --> 00:32:52,246
编写一个初始化程序


1029
00:32:53,256 --> 00:32:54,796
在这里我们在做的就是


1030
00:32:54,796 --> 00:32:57,666
我们正在为 $path 赋值


1031
00:32:57,666 --> 00:32:59,586
让它调用防御性 withoutCopying


1032
00:32:59,586 --> 00:33:01,416
初始化程序 这样我们就可以避免


1033
00:33:01,416 --> 00:33:02,056
出现多余的拷贝


1034
00:33:03,146 --> 00:33:04,256
所以这里没有更多


1035
00:33:04,256 --> 00:33:06,076
神奇的事情了


1036
00:33:06,266 --> 00:33:08,206
$path 只是一个存储属性


1037
00:33:08,256 --> 00:33:09,516
它唯一神奇的点在于


1038
00:33:09,516 --> 00:33:11,136
它是编译器作为将其应用到


1039
00:33:11,246 --> 00:33:13,586
属性包装器模式的一部分


1040
00:33:13,586 --> 00:33:14,896
而生成的


1041
00:33:15,456 --> 00:33:16,766
但是你可以


1042
00:33:16,766 --> 00:33:18,766
将它作为一个普通变量对待


1043
00:33:18,766 --> 00:33:20,436
包括设定


1044
00:33:20,436 --> 00:33:21,256
自己的初始化


1045
00:33:21,866 --> 00:33:24,056
现在 这还是


1046
00:33:24,256 --> 00:33:25,396
有点像样板文件


1047
00:33:25,396 --> 00:33:26,476
很不幸的是 我们不得不


1048
00:33:26,476 --> 00:33:27,446
编写那个初始化程序


1049
00:33:27,516 --> 00:33:28,256
所以你要看到


1050
00:33:28,256 --> 00:33:29,816
其他的初始化格式了


1051
00:33:30,546 --> 00:33:32,786
当你在


1052
00:33:32,786 --> 00:33:34,926
声明自定义属性时


1053
00:33:34,926 --> 00:33:36,446
使用 @DefensiveCopying


1054
00:33:36,446 --> 00:33:37,826
你可以就在属性声明里


1055
00:33:37,826 --> 00:33:39,056
进行初始化


1056
00:33:39,206 --> 00:33:40,266
按照你的想法来


1057
00:33:40,686 --> 00:33:42,636
所以这里我们就可以继续并调用


1058
00:33:42,636 --> 00:33:44,186
withoutCopying 初始化程序


1059
00:33:44,186 --> 00:33:45,446
来用我们想要的值


1060
00:33:45,446 --> 00:33:47,606
初始化备份存储属性


1061
00:33:47,966 --> 00:33:49,536
这个一个很好的小声明


1062
00:33:49,936 --> 00:33:51,236
而你还是获得了在


1063
00:33:51,236 --> 00:33:52,386
记忆初始化


1064
00:33:52,386 --> 00:33:54,326
获取默认设定的好处


1065
00:33:56,436 --> 00:34:00,016
好吧 所以 属性包装器事实上


1066
00:34:00,016 --> 00:34:01,576
还是很强大的


1067
00:34:01,836 --> 00:34:03,756
它们将访问数据的


1068
00:34:03,756 --> 00:34:06,326
这个策略概念抽象化了


1069
00:34:06,536 --> 00:34:08,416
所以你可以决定如何存储你的数据


1070
00:34:08,656 --> 00:34:10,626
而且你也可以决定如何访问你的数据


1071
00:34:11,106 --> 00:34:12,766
针对你的属性包装器 


1072
00:34:12,766 --> 00:34:14,016
你的用户要做的就是


1073
00:34:14,156 --> 00:34:15,846
使用那个自定义属性句法


1074
00:34:16,266 --> 00:34:17,366
来联系进你的系统


1075
00:34:17,616 --> 00:34:19,616
所以在我们开发


1076
00:34:19,616 --> 00:34:20,906
属性包装器时 我们发现了


1077
00:34:20,906 --> 00:34:22,755
针对它们的很多不同使用


1078
00:34:23,335 --> 00:34:24,716
都是围绕这类数据访问


1079
00:34:24,716 --> 00:34:26,496
的大致概念的


1080
00:34:27,246 --> 00:34:28,525
所以举个例子 你也许已经


1081
00:34:28,525 --> 00:34:29,886
看到用户默认示例


1082
00:34:30,306 --> 00:34:31,525
这里就是我们


1083
00:34:31,525 --> 00:34:32,626
建立的一个关系 这个关系在


1084
00:34:32,626 --> 00:34:34,246
你刚刚作为 Bool 引用的


1085
00:34:34,246 --> 00:34:35,795
Swift 中类型良好的属性


1086
00:34:35,795 --> 00:34:37,466
和一些字符串


1087
00:34:37,466 --> 00:34:38,726
类型实体之间


1088
00:34:39,045 --> 00:34:40,085
所以我们在结构参数中


1089
00:34:40,085 --> 00:34:41,636
明确描述了


1090
00:34:41,815 --> 00:34:43,815
如何继续并获取数据


1091
00:34:44,246 --> 00:34:46,255
处理用户默认的


1092
00:34:46,255 --> 00:34:47,926
所有逻辑 就在这个


1093
00:34:47,926 --> 00:34:50,136
用户默认属性包装器中完成了


1094
00:34:51,076 --> 00:34:53,196
所以我们构建 @ThreadSpecific


1095
00:34:53,196 --> 00:34:54,446
如果你想要以本地线程存储


1096
00:34:55,356 --> 00:34:55,966
你可以应用


1097
00:34:55,966 --> 00:34:57,206
ThreadSpecific 属性包装器


1098
00:34:57,296 --> 00:34:58,426
处理系统的线程相关


1099
00:34:58,426 --> 00:35:00,176
存储的所有细节


1100
00:35:00,176 --> 00:35:02,376
就都在属性包装器里面


1101
00:35:02,556 --> 00:35:03,796
你可以就把这个东西想成


1102
00:35:03,906 --> 00:35:05,766
一个本地的记忆池


1103
00:35:06,756 --> 00:35:08,326
还有 在 Swift 社区


1104
00:35:08,326 --> 00:35:09,106
正如我们已经


1105
00:35:09,106 --> 00:35:10,636
构建的这个功能 我们发现


1106
00:35:11,376 --> 00:35:13,026
在描述命令行参数时


1107
00:35:13,026 --> 00:35:14,696
它实现得非常好


1108
00:35:14,696 --> 00:35:15,496
如果你通过一个


1109
00:35:15,496 --> 00:35:17,376
库构建了一个命令行工具


1110
00:35:17,376 --> 00:35:18,906
用于记录


1111
00:35:19,256 --> 00:35:20,476
简写语法


1112
00:35:20,476 --> 00:35:21,926
意思是我想要 Minimum value


1113
00:35:22,106 --> 00:35:23,426
这就是 @Option 的描述


1114
00:35:24,156 --> 00:35:25,276
这就是用户传递的


1115
00:35:25,276 --> 00:35:26,406
缩写字符串


1116
00:35:26,406 --> 00:35:27,516
以及含义是什么


1117
00:35:27,596 --> 00:35:28,776
以及所有其他的东西


1118
00:35:28,776 --> 00:35:31,026
你需要非常非常简洁地


1119
00:35:31,026 --> 00:35:32,936
说明你的命令行选项


1120
00:35:33,636 --> 00:35:34,666
有很多真的非常酷


1121
00:35:34,666 --> 00:35:35,916
的东西我们可以通过


1122
00:35:35,916 --> 00:35:37,046
属性包装器完成


1123
00:35:37,046 --> 00:35:38,756
因为这个良好 干净的句法


1124
00:35:38,756 --> 00:35:39,616
可以生产一些东西


1125
00:35:40,816 --> 00:35:42,456
也许你在


1126
00:35:42,456 --> 00:35:44,386
另一场会议中已经了解了


1127
00:35:44,386 --> 00:35:46,086
我们在 SwiftUI 中广泛地


1128
00:35:46,386 --> 00:35:48,636
使用了属性包装器来描述


1129
00:35:48,636 --> 00:35:50,906
视图的数据依赖


1130
00:35:52,016 --> 00:35:54,116
在 Swift UI 中


1131
00:35:54,116 --> 00:35:55,326
有几个不同的


1132
00:35:55,326 --> 00:35:56,896
属性包装器存在


1133
00:35:57,036 --> 00:35:58,556
那么这里我们有一个 @State


1134
00:35:58,556 --> 00:35:59,806
来引入查看本地状态


1135
00:36:00,186 --> 00:36:01,716
对于一些高级引用


1136
00:36:01,716 --> 00:36:02,986
我们有 @Binding 来


1137
00:36:02,986 --> 00:36:04,236
声明它是来自其他地方的


1138
00:36:04,516 --> 00:36:05,036
你也许已经看到了


1139
00:36:05,036 --> 00:36:06,586
@Environment 一个环境对象


1140
00:36:07,676 --> 00:36:09,206
所有的这些都是属性包装器


1141
00:36:09,206 --> 00:36:10,636
在 Swift 中以那种方式


1142
00:36:10,636 --> 00:36:12,196
描述它们的一个好处在于


1143
00:36:12,196 --> 00:36:15,216
你在明确你的策略


1144
00:36:15,216 --> 00:36:17,216
数据在哪里


1145
00:36:17,216 --> 00:36:19,326
它是如何被访问的


1146
00:36:19,326 --> 00:36:20,506
都可以在声明中给出


1147
00:36:21,106 --> 00:36:22,306
但是当你继续并构建你的视图时


1148
00:36:22,306 --> 00:36:24,586
你并不在意那个


1149
00:36:24,716 --> 00:36:26,386
你不在乎数据在哪里


1150
00:36:26,556 --> 00:36:28,136
系统为你管理好了


1151
00:36:28,926 --> 00:36:30,536
你就可以查看


1152
00:36:30,536 --> 00:36:32,216
Keynote 讲演的


1153
00:36:32,216 --> 00:36:32,806
特定的一页


1154
00:36:33,536 --> 00:36:34,266
输入数字


1155
00:36:34,716 --> 00:36:35,696
如果你想要继续并编辑


1156
00:36:35,696 --> 00:36:38,426
一些东西 那么你可以使


1157
00:36:39,376 --> 00:36:41,726
找到实际捆绑的幻灯片


1158
00:36:42,776 --> 00:36:45,996
所以 处理数据的


1159
00:36:45,996 --> 00:36:47,736
所有逻辑 以及观察


1160
00:36:47,776 --> 00:36:49,096
变化更新 或者甚至是


1161
00:36:49,096 --> 00:36:50,256
在存储数据


1162
00:36:50,476 --> 00:36:51,946
在属性包装器类型中


1163
00:36:51,946 --> 00:36:53,696
的策略里都解决了


1164
00:36:53,976 --> 00:36:55,116
你不需要考虑


1165
00:36:55,336 --> 00:36:56,766
你只需要考虑处理


1166
00:36:56,766 --> 00:36:57,626
你实际的数据


1167
00:36:58,306 --> 00:37:00,136
现在 在这页幻灯片上


1168
00:37:00,136 --> 00:37:01,796
有一个东西有点意思


1169
00:37:02,436 --> 00:37:04,906
那么这是 $slide.title


1170
00:37:05,546 --> 00:37:06,736
我们将其传递 这样就可以


1171
00:37:06,876 --> 00:37:08,506
在文本框编辑页标题


1172
00:37:09,986 --> 00:37:12,566
$slide 我们之前已经看到过了


1173
00:37:12,646 --> 00:37:14,486
那是备份存储属性


1174
00:37:14,486 --> 00:37:15,356
那就是编译器


1175
00:37:15,356 --> 00:37:16,836
为我们进行合成


1176
00:37:17,176 --> 00:37:19,546
因为我们在这里应用了


1177
00:37:19,546 --> 00:37:20,436
Binding 属性包装器


1178
00:37:21,826 --> 00:37:23,236
但在 Binding 中


1179
00:37:23,686 --> 00:37:24,676
是没有标题的


1180
00:37:26,066 --> 00:37:28,096
标题是我的数据模型的一部分


1181
00:37:28,096 --> 00:37:29,096
我一个幻灯片的数据模型


1182
00:37:29,186 --> 00:37:29,646
那么这给了我们什么呢


1183
00:37:30,086 --> 00:37:32,426
所以 实际上这是一个


1184
00:37:32,426 --> 00:37:34,446
属性包装器和


1185
00:37:34,446 --> 00:37:36,716
先前 Ben 讲到的关键路径成员


1186
00:37:36,716 --> 00:37:39,226
查找功能的结合


1187
00:37:39,806 --> 00:37:42,256
那么这样的话 让我们实际来


1188
00:37:42,306 --> 00:37:43,896
关注 @Binding


1189
00:37:43,896 --> 00:37:45,526
也就是在 Swift UI 里的东西 并且提供了


1190
00:37:45,526 --> 00:37:46,816
这个高级引用


1191
00:37:47,136 --> 00:37:49,646
首先也是最重要的 Binding


1192
00:37:49,646 --> 00:37:50,416
是一个属性包装器


1193
00:37:50,946 --> 00:37:53,736
所以它有 value


1194
00:37:53,736 --> 00:37:55,166
可以以任何类型的参数存在


1195
00:37:55,166 --> 00:37:56,786
因为你可以对任何东西进行捆绑


1196
00:37:57,096 --> 00:37:59,416
它有着任何样式的访问权限


1197
00:37:59,416 --> 00:38:00,106
这并不重要


1198
00:38:00,276 --> 00:38:02,456
我们并不知道这是什么


1199
00:38:02,456 --> 00:38:04,426
因为是由框架为我们处理的


1200
00:38:04,536 --> 00:38:07,646
通过泛型下标


1201
00:38:07,646 --> 00:38:09,306
捆绑也是支持关键


1202
00:38:09,346 --> 00:38:12,716
路径成员查找的泛型下标


1203
00:38:12,766 --> 00:38:13,506
有点儿拗口


1204
00:38:13,566 --> 00:38:14,486
我们不需要知道


1205
00:38:14,486 --> 00:38:15,756
是怎么实现的


1206
00:38:15,756 --> 00:38:16,466
但是我们应该更加仔细地


1207
00:38:16,466 --> 00:38:17,606
看一看类型签名


1208
00:38:17,606 --> 00:38:18,676
因为它很有趣


1209
00:38:19,096 --> 00:38:21,476
那么 我们已经讲过了关键路径


1210
00:38:21,986 --> 00:38:24,966
它与特定的值类型紧密联系


1211
00:38:24,966 --> 00:38:26,766
所以我们在进行捆绑的东西


1212
00:38:27,006 --> 00:38:30,656
比如幻灯片页


1213
00:38:30,656 --> 00:38:33,466
以及在那个特定实体里访问任何属性


1214
00:38:34,186 --> 00:38:36,076
这里返回的不是一个值


1215
00:38:36,076 --> 00:38:39,146
不是引用一些东西


1216
00:38:39,396 --> 00:38:41,256
我们返回的是一个新的捆绑


1217
00:38:41,666 --> 00:38:43,426
它的焦点在于外部捆绑的


1218
00:38:43,426 --> 00:38:45,976
某一个特定的属性


1219
00:38:45,976 --> 00:38:48,936
仍然保持着数据依赖


1220
00:38:52,806 --> 00:38:54,356
那么 在实际操作中这是怎么样的呢


1221
00:38:54,356 --> 00:38:56,556
好吧 我们有 slide


1222
00:38:56,556 --> 00:38:58,206
捆绑在我们的 Slide 类型上


1223
00:38:58,916 --> 00:39:00,696
基本上 我们将其


1224
00:39:00,696 --> 00:39:01,526
视作是一个值


1225
00:39:01,526 --> 00:39:02,636
所以我们可以引用 slide


1226
00:39:02,636 --> 00:39:03,496
我们得到了一个 slide 实例


1227
00:39:03,496 --> 00:39:04,986
我们可以引用 slide.title 并且


1228
00:39:04,986 --> 00:39:06,406
获得那个字符串的实例


1229
00:39:06,676 --> 00:39:07,626
同时在后台


1230
00:39:08,186 --> 00:39:10,176
追踪所有修改


1231
00:39:10,756 --> 00:39:13,376
如果我们输入 $Slide 好的


1232
00:39:13,436 --> 00:39:15,336
我们将那个捆绑的实例放到了 slide 中


1233
00:39:15,946 --> 00:39:19,506
当我们输入 $slide.title 好的


1234
00:39:19,506 --> 00:39:20,626
现在我们在查找一个属性


1235
00:39:20,626 --> 00:39:22,316
它并不在捆绑中


1236
00:39:22,316 --> 00:39:24,056
所以编译器将其进行了重写


1237
00:39:24,126 --> 00:39:26,266
将其变成使用动态数字下标


1238
00:39:26,266 --> 00:39:28,696
将一个关键路径


1239
00:39:29,216 --> 00:39:30,276
放进 slide.title


1240
00:39:31,536 --> 00:39:33,126
这解析的方式是


1241
00:39:33,126 --> 00:39:34,586
将一个焦点捆绑点


1242
00:39:34,866 --> 00:39:37,846
变成字符串属性


1243
00:39:37,956 --> 00:39:39,776
它位于之前的捆绑中


1244
00:39:39,806 --> 00:39:40,826
并且遵循所有的


1245
00:39:40,826 --> 00:39:41,706
数据依赖


1246
00:39:42,656 --> 00:39:44,946
那么 如果我们抛开


1247
00:39:44,946 --> 00:39:46,246
之前我们一直在关注的


1248
00:39:46,246 --> 00:39:48,136
语言机制然后


1249
00:39:48,136 --> 00:39:49,286
看一看我们在这里进行的


1250
00:39:49,286 --> 00:39:51,246
高级代码 会非常好


1251
00:39:51,246 --> 00:39:52,416
在属性包装器里


1252
00:39:52,416 --> 00:39:54,096
使用这个自定义属性


1253
00:39:54,096 --> 00:39:55,216
我们建立了数据依赖


1254
00:39:55,976 --> 00:39:57,086
我们有访问我们数据的


1255
00:39:57,086 --> 00:39:59,276
基础权限 很容易读取


1256
00:39:59,276 --> 00:39:59,906
或者进行修改


1257
00:39:59,906 --> 00:40:01,546
如果我们想要通过


1258
00:40:01,546 --> 00:40:02,536
我们的捆绑传递一个


1259
00:40:02,536 --> 00:40:04,506
高级引用 我们把这个前缀 $


1260
00:40:04,506 --> 00:40:05,796
放在它的前面


1261
00:40:05,876 --> 00:40:06,806
我们获得的影响是


1262
00:40:06,806 --> 00:40:07,836
我们总是可以向


1263
00:40:07,836 --> 00:40:09,886
一些其他视图传递一个捆绑


1264
00:40:11,616 --> 00:40:15,416
那么 我们已经讲到了一些


1265
00:40:15,416 --> 00:40:16,146
不同的主题


1266
00:40:16,146 --> 00:40:17,586
我们讲到了值语义


1267
00:40:17,646 --> 00:40:19,556
和引用语义


1268
00:40:19,556 --> 00:40:21,096
何时去使用两者以及如何


1269
00:40:21,096 --> 00:40:21,936
让它们协作运行


1270
00:40:23,076 --> 00:40:24,116
我们也谈到了


1271
00:40:24,116 --> 00:40:25,596
泛型和协议的使用


1272
00:40:26,336 --> 00:40:28,476
请记住 协议是极其强大的


1273
00:40:28,596 --> 00:40:30,686
但是用它们来进行代码重用


1274
00:40:30,686 --> 00:40:31,716
这就是它们的作用


1275
00:40:32,086 --> 00:40:33,606
而不是用来分类或者


1276
00:40:33,606 --> 00:40:34,966
构建庞大的继承结构


1277
00:40:34,966 --> 00:40:35,906
因为它们会阻碍你


1278
00:40:35,986 --> 00:40:37,706
你不需要这么做


1279
00:40:37,996 --> 00:40:41,326
最后 我们深入讲了讲


1280
00:40:41,326 --> 00:40:43,526
属性包装器语言功能


1281
00:40:43,526 --> 00:40:45,746
以及如何用它来


1282
00:40:45,796 --> 00:40:47,186
抽象访问数据


1283
00:40:48,476 --> 00:40:48,776
好的


1284
00:40:48,876 --> 00:40:49,846
非常感谢你们


1285
00:40:50,416 --> 00:40:51,816
如果你想要就任何这些话题进行讨论


1286
00:40:51,816 --> 00:40:53,466
欢迎来我们的实验室


1287
00:40:54,516 --> 00:40:59,500
[掌声]

