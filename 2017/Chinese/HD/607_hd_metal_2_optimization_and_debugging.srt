1
00:00:07,516 --> 00:00:21,516
谈话声


2
00:00:22,516 --> 00:00:27,556
[掌声]


3
00:00:28,056 --> 00:00:29,076
>> 大家下午好


4
00:00:29,076 --> 00:00:30,446
欢迎来到


5
00:00:30,446 --> 00:00:31,796
Metal 2 优化和调试


6
00:00:31,796 --> 00:00:34,716
你们已经知道 我们今年


7
00:00:34,716 --> 00:00:35,856
有很多关于 Metal 2 的内容


8
00:00:35,856 --> 00:00:37,116
在一些平台上实现了


9
00:00:37,116 --> 00:00:39,106
一些很好的提升 


10
00:00:39,106 --> 00:00:40,966
包括 GP 驱动渲染 机器学习加速 


11
00:00:40,966 --> 00:00:43,936
macOS VR 和


12
00:00:43,936 --> 00:00:45,716
外部 GPU 支持


13
00:00:47,106 --> 00:00:48,466
别忘了还有


14
00:00:48,466 --> 00:00:49,636
高级优化工具


15
00:00:50,186 --> 00:00:52,886
所以 今天下午我们


16
00:00:52,886 --> 00:00:54,536
将会讨论一下当前的


17
00:00:54,666 --> 00:00:56,076
Metal 工具


18
00:00:56,376 --> 00:00:57,906
简要概括一下它们


19
00:00:57,906 --> 00:00:59,536
并介绍一些很棒的


20
00:00:59,536 --> 00:01:01,356
针对 Metal 帧调试工具的提升


21
00:01:01,356 --> 00:01:03,136
最后讨论一些


22
00:01:03,136 --> 00:01:04,016
关于 GPU 配置的内容 


23
00:01:04,676 --> 00:01:08,016
首先 我们来看看 帧调试工具


24
00:01:10,226 --> 00:01:12,056
我希望你们都


25
00:01:12,056 --> 00:01:12,776
熟悉这个工具


26
00:01:14,076 --> 00:01:15,376
帧调试工具集成在 Xcode 中


27
00:01:15,376 --> 00:01:17,246
功能齐全


28
00:01:17,246 --> 00:01:20,106
让你可以处理你的


29
00:01:20,106 --> 00:01:22,586
Metal 2 作品


30
00:01:22,966 --> 00:01:24,126
让它成为计算机图形


31
00:01:24,126 --> 00:01:25,086
并且可以进一步检查


32
00:01:25,086 --> 00:01:27,086
状态和资源


33
00:01:27,476 --> 00:01:28,186
让你能够调试和优化


34
00:01:29,076 --> 00:01:33,216
提升帧调试


35
00:01:33,216 --> 00:01:34,006
工具的性能


36
00:01:34,006 --> 00:01:34,886
是我们最近几年


37
00:01:34,886 --> 00:01:36,676
的工作中心之一


38
00:01:36,676 --> 00:01:38,316
我们尤其


39
00:01:38,316 --> 00:01:39,386
注意提升


40
00:01:39,676 --> 00:01:40,346
捕获速度


41
00:01:40,346 --> 00:01:43,096
我很开心告诉大家


42
00:01:43,096 --> 00:01:46,436
与 Xcode 8 相比


43
00:01:46,436 --> 00:01:48,586
Xcode 9 现在的捕获速度


44
00:01:49,106 --> 00:01:50,116
可以达到原来的 10 倍


45
00:01:50,116 --> 00:01:51,556
让你从点按 Capture 按钮


46
00:01:51,556 --> 00:01:52,946
到打开调试工具的时间


47
00:01:52,946 --> 00:01:53,256
大大缩短


48
00:01:56,036 --> 00:01:58,466
如你期待的那样


49
00:01:58,466 --> 00:02:00,036
我们全面支持了 Metal 2 的 API


50
00:02:00,036 --> 00:02:02,006
包括光栅顺序组


51
00:02:02,006 --> 00:02:04,346
采样数组  Viewport 数组


52
00:02:04,346 --> 00:02:06,146
以及全新的像素和


53
00:02:06,146 --> 00:02:07,356
顶点数组格式


54
00:02:07,876 --> 00:02:10,856
在 Metal 2 中


55
00:02:10,856 --> 00:02:12,406
我们花了很大精力


56
00:02:12,406 --> 00:02:14,116
来支持全新的


57
00:02:14,116 --> 00:02:15,296
参数缓冲器


58
00:02:15,936 --> 00:02:17,376
有了它 在缓冲查看器中


59
00:02:17,626 --> 00:02:19,386
你可以看到所有的


60
00:02:19,386 --> 00:02:20,546
参数 缓冲参数


61
00:02:20,646 --> 00:02:22,196
都一行行显示出来


62
00:02:22,196 --> 00:02:23,856
你可以点按它们选择是否要


63
00:02:23,856 --> 00:02:26,516
附上你的采样器 缓冲器


64
00:02:26,516 --> 00:02:32,686
或者其他参数缓冲器


65
00:02:32,686 --> 00:02:33,956
此外 随着对 SteamVR 的自动支持


66
00:02:33,956 --> 00:02:35,196
我们今年开始支持


67
00:02:35,196 --> 00:02:36,456
VR 捕获


68
00:02:36,456 --> 00:02:38,316
我们也为你们提供了


69
00:02:38,316 --> 00:02:40,216
让你们可以以立体的形式


70
00:02:40,216 --> 00:02:40,966
查看你们上传的界面的支持


71
00:02:41,446 --> 00:02:43,526
当你们发送 提交


72
00:02:43,526 --> 00:02:44,576
指令的时候 你将会向


73
00:02:44,576 --> 00:02:46,116
VR 混合器发送你的界面


74
00:02:46,406 --> 00:02:47,786
你会同时看到


75
00:02:47,786 --> 00:02:49,556
左右眼的视图


76
00:02:49,556 --> 00:02:51,106
可以帮助你发现其中的差异


77
00:02:51,676 --> 00:02:56,496
今年的另一个工作重心是


78
00:02:56,716 --> 00:02:58,006
为了要针对更复杂的计算任务


79
00:02:58,006 --> 00:02:59,456
进行捕获  


80
00:02:59,456 --> 00:03:00,416
我们改进了捕获工作流


81
00:03:00,826 --> 00:03:01,836
所以如果你现在


82
00:03:01,896 --> 00:03:04,036
只在 Metal 里做纯计算任务


83
00:03:04,036 --> 00:03:05,396
或者如果你同时有多个


84
00:03:05,396 --> 00:03:07,516
Metal 命令队列  现在我们就可以


85
00:03:07,516 --> 00:03:08,846
更轻松地  准确捕获到你想要


86
00:03:08,846 --> 00:03:09,396
的那部分内容


87
00:03:10,446 --> 00:03:11,526
我们还添加了轻便型


88
00:03:11,526 --> 00:03:13,576
捕获 API  其中内置了一些新的 Metal


89
00:03:13,576 --> 00:03:15,406
捕获作用域对象  我们可以在新建


90
00:03:15,406 --> 00:03:17,416
项目时创建这些对象  然后后期在


91
00:03:17,416 --> 00:03:19,276
每一帧都可以重复利用  可以用来


92
00:03:19,276 --> 00:03:20,136
包裹住之后想捕获的部分


93
00:03:20,546 --> 00:03:21,656
我们稍后会看到这项的演示


94
00:03:21,656 --> 00:03:22,746
这给我们带来了新的可能性


95
00:03:22,746 --> 00:03:25,346
比如说  现在可以把我们所有的


96
00:03:25,626 --> 00:03:28,006
正常渲染任务都包在一个作用域里


97
00:03:28,006 --> 00:03:29,666
把其他那些异步任务  比如说


98
00:03:29,916 --> 00:03:31,126
重新生成我们的密铺因子缓冲区


99
00:03:31,126 --> 00:03:32,866
这一类的任务  归到另一个


100
00:03:32,866 --> 00:03:33,956
作用域里  这样等我们开始捕获的时候


101
00:03:33,956 --> 00:03:35,456
就可以精准地制定区域  获得想要的


102
00:03:35,456 --> 00:03:35,866
结果


103
00:03:37,416 --> 00:03:38,576
我们现在还支持


104
00:03:38,576 --> 00:03:39,266
在我们的应用程序中


105
00:03:39,266 --> 00:03:40,766
用编程方式触发捕获过程


106
00:03:41,316 --> 00:03:43,026
其实我们在自己的测试应用程序里


107
00:03:43,026 --> 00:03:44,256
也经常使用这一功能  用上之后


108
00:03:44,256 --> 00:03:45,436
比如我们可以立马在设备上做一个


109
00:03:45,436 --> 00:03:46,826
什么手势  然后就可以自动触发


110
00:03:47,216 --> 00:03:48,476
帧捕获  我们就不用再


111
00:03:48,476 --> 00:03:53,046
费力切换回 Xcode 去实现这个功能了


112
00:03:53,546 --> 00:03:55,076
今年要宣布的另一个新功能


113
00:03:55,076 --> 00:03:56,676
是 Xcode 的快速预览(Quick Looks)


114
00:03:57,046 --> 00:03:57,606
功能


115
00:03:58,826 --> 00:04:00,766
现在在 CPU 调试工具里


116
00:04:00,766 --> 00:04:02,286
有了新的轻便型 Metal


117
00:04:02,286 --> 00:04:02,856
调试功能


118
00:04:03,116 --> 00:04:05,276
假设我们现在再遇到断点


119
00:04:05,276 --> 00:04:07,316
如果包含有 Metal 纹理


120
00:04:07,796 --> 00:04:09,206
快速预览就会从 GPU 里


121
00:04:09,206 --> 00:04:11,426
自动提取 Metal 纹理数据


122
00:04:11,426 --> 00:04:12,716
然后给大家提供实时预览


123
00:04:12,916 --> 00:04:14,106
同样的功能  也支持预览缓冲区


124
00:04:14,106 --> 00:04:14,586
和采样器


125
00:04:15,486 --> 00:04:17,375
对于有些不太方便


126
00:04:17,375 --> 00:04:19,796
做完整帧捕获的项目  这个功能


127
00:04:19,796 --> 00:04:21,736
非常有用  举个例子来说


128
00:04:21,736 --> 00:04:22,786
如果我们要调试的是


129
00:04:22,786 --> 00:04:24,156
资源载入  或者一些设置代码


130
00:04:24,156 --> 00:04:24,546
这一类


131
00:04:24,546 --> 00:04:27,506
另外  如果我们要调试一些


132
00:04:27,506 --> 00:04:28,916
计算任务  用这个断点预览


133
00:04:28,916 --> 00:04:32,606
也会非常方便


134
00:04:33,026 --> 00:04:35,156
去年我们介绍了


135
00:04:35,416 --> 00:04:37,056
在帧调试工具里


136
00:04:37,266 --> 00:04:38,606
全局可用的  丰富的过滤功能


137
00:04:38,686 --> 00:04:41,526
我们可以同时过滤


138
00:04:41,526 --> 00:04:42,946
比如  资源属性  这一类东西


139
00:04:43,426 --> 00:04:44,356
但同时  在帧


140
00:04:44,356 --> 00:04:47,156
导航栏里  我们也可以依据


141
00:04:47,156 --> 00:04:49,606
上下文数据进行过滤  这样如果


142
00:04:49,936 --> 00:04:51,146
我们的过滤条件是一个特定绘制指令


143
00:04:51,146 --> 00:04:52,506
所用的资源  过滤结果就会输出


144
00:04:52,506 --> 00:04:53,566
那个特定的绘制指令


145
00:04:53,756 --> 00:04:55,196
我们今年把这一功能进行了改进


146
00:04:55,196 --> 00:04:56,626
能达到的功能更上一层楼了


147
00:04:56,626 --> 00:04:58,136
现在我们还可以支持在整个


148
00:04:58,136 --> 00:04:59,476
捕获帧内进行数据挖掘


149
00:05:00,156 --> 00:05:01,716
所以现在我们一边输入  程序


150
00:05:01,716 --> 00:05:03,626
就会一边自动返回上下文相关的


151
00:05:03,626 --> 00:05:04,866
自动补全建议


152
00:05:05,706 --> 00:05:07,886
而且我们现在还支持复合术语


153
00:05:08,326 --> 00:05:10,236
所以如果现在先限定某个特定的


154
00:05:10,236 --> 00:05:12,506
编码器  然后再限定某个


155
00:05:12,506 --> 00:05:14,696
纹理  我们现在给你显示


156
00:05:14,696 --> 00:05:15,806
出的的自动补全建议  就会是


157
00:05:15,806 --> 00:05:17,026
那个特定编码器里


158
00:05:17,026 --> 00:05:22,346
实际用到的纹理


159
00:05:22,946 --> 00:05:24,386
这几年来  我们收到


160
00:05:24,386 --> 00:05:25,806
请求最多的一项功能就是


161
00:05:25,806 --> 00:05:27,106
像素审查 (Pixel Inspection) 功能


162
00:05:28,386 --> 00:05:29,496
我们现在终于满足了这一需求


163
00:05:30,386 --> 00:05:32,186
所以现在我们可以针对


164
00:05:32,186 --> 00:05:34,886
每一个独立像素  做详细的审查


165
00:05:35,196 --> 00:05:36,706
不管是在纹理  还是


166
00:05:36,706 --> 00:05:37,486
在渲染目标中


167
00:05:38,046 --> 00:05:39,366
而如果你的渲染


168
00:05:39,366 --> 00:05:40,196
目标中  包含有多个附件


169
00:05:40,196 --> 00:05:41,606
我们还会在同一时间


170
00:05:41,656 --> 00:05:43,366
给你显示出每个


171
00:05:43,366 --> 00:05:45,206
附件内部同等位置处的


172
00:05:45,206 --> 00:05:45,866
像素值


173
00:05:45,976 --> 00:05:47,146
所以如果我们要看着附件调试


174
00:05:47,146 --> 00:05:48,836
颜色值啊  同时还要调试


175
00:05:48,836 --> 00:05:50,136
模版啊之类的东西


176
00:05:50,136 --> 00:05:51,036
就会非常方便


177
00:05:51,346 --> 00:05:52,916
这个功能在调试计算任务


178
00:05:52,916 --> 00:05:54,516
的时候  也非常有用


179
00:05:54,516 --> 00:05:55,746
比如你正在处理图片


180
00:05:55,746 --> 00:05:56,996
假设我们的


181
00:05:56,996 --> 00:05:58,236
CNN 正做到一半  但是想测试一下


182
00:05:58,236 --> 00:05:59,686
看看各个缓冲区里面的实际


183
00:05:59,686 --> 00:06:01,036
数值都是多少  就可以用这个来


184
00:06:01,036 --> 00:06:01,306
审查


185
00:06:03,516 --> 00:06:07,546
[掌声]


186
00:06:08,046 --> 00:06:09,026
我们去年介绍的


187
00:06:09,026 --> 00:06:10,556
另一个新功能  就是


188
00:06:10,556 --> 00:06:12,436
顶点属性观察器  在这里


189
00:06:12,436 --> 00:06:14,336
我们可以看到  所有在传入我们的


190
00:06:14,486 --> 00:06:16,376
顶点着色引擎的顶点数据


191
00:06:16,376 --> 00:06:18,246
数据按照每个顶点分开


192
00:06:18,246 --> 00:06:19,856
显示


193
00:06:20,496 --> 00:06:21,446
好了  今年  我们又添加


194
00:06:21,446 --> 00:06:23,626
了新的功能  现在我们也可以看到


195
00:06:23,626 --> 00:06:25,556
顶点着色引擎输出的顶点数据了


196
00:06:25,696 --> 00:06:27,766
我们还会把这个内联


197
00:06:28,076 --> 00:06:29,776
和之前支持的输入时的数据并列显示


198
00:06:30,146 --> 00:06:31,476
所以在这个例子里  我们可以看到


199
00:06:31,476 --> 00:06:33,306
输入的顶点位置数据  和输出的


200
00:06:33,306 --> 00:06:34,596
顶点位置数据  同时显示在


201
00:06:34,596 --> 00:06:35,000
一起


202
00:06:38,046 --> 00:06:38,866
好了  现在该给大家实际


203
00:06:38,866 --> 00:06:40,076
演示一下我说过的这些新功能了


204
00:06:40,076 --> 00:06:41,256
请允许我邀请我的同事


205
00:06:41,486 --> 00:06:42,686
Max 上台  他将会给大家


206
00:06:42,686 --> 00:06:44,106
演示刚刚说过的这些精彩的


207
00:06:44,106 --> 00:06:45,076
新功能


208
00:06:46,516 --> 00:06:49,556
[掌声]


209
00:06:50,056 --> 00:06:51,956
大家好  很高兴今天在这里见到


210
00:06:51,956 --> 00:06:52,386
大家


211
00:06:52,526 --> 00:06:57,706
我希望大家手头工作进展都不错


212
00:06:57,706 --> 00:06:59,776
而你们都和我们一样  对 Metal 充满


213
00:06:59,776 --> 00:07:00,236
激情


214
00:07:00,636 --> 00:07:02,616
Xcode 的 GPU 调试工具可以帮我们


215
00:07:02,616 --> 00:07:04,456
调试我们的 GPU 和 Metal 占用


216
00:07:04,456 --> 00:07:05,146
情况


217
00:07:05,616 --> 00:07:07,356
我叫作 Max  今天我会帮大家


218
00:07:07,356 --> 00:07:08,496
最优化 (maximize) 你们的调试


219
00:07:08,496 --> 00:07:09,886
体验  给大家演示下新的


220
00:07:09,886 --> 00:07:10,246
功能


221
00:07:11,516 --> 00:07:14,696
[掌声]


222
00:07:15,196 --> 00:07:17,106
让我运行一下我的示例程序


223
00:07:19,576 --> 00:07:21,676
这里渲染出来的  是一幅美丽的


224
00:07:21,676 --> 00:07:24,056
风景  显示出来  雪中


225
00:07:24,056 --> 00:07:26,266
的山脉啦  在风中飘动


226
00:07:26,266 --> 00:07:27,936
的草啦  然后为了让效果


227
00:07:27,936 --> 00:07:29,986
看起来更好  我还添加了一些


228
00:07:29,986 --> 00:07:31,846
颗粒  并让它们在空中闪闪


229
00:07:32,606 --> 00:07:33,176
发光


230
00:07:33,216 --> 00:07:35,636
但就像大家看到的那样


231
00:07:35,636 --> 00:07:37,826
草上面的这些颗粒  看起来


232
00:07:37,826 --> 00:07:39,316
渲染得有点问题


233
00:07:39,546 --> 00:07:41,196
所以让我们看看怎么解决一下


234
00:07:41,756 --> 00:07:46,296
作为调试的第一步  让我们先看看


235
00:07:46,296 --> 00:07:47,336
纹理设置对了没有


236
00:07:47,906 --> 00:07:49,436
我们在渲染循环里设置


237
00:07:49,436 --> 00:07:50,656
一个断点  设置在正要


238
00:07:50,716 --> 00:07:52,116
使用这个纹理的时候


239
00:07:53,216 --> 00:07:54,846
把鼠标悬停在一个变量上


240
00:07:54,846 --> 00:07:57,226
我们就可以看到 Xcode 的数据提示


241
00:07:57,566 --> 00:07:59,446
可通过 Xcode 这个提示快速查看该变量的


242
00:07:59,446 --> 00:08:00,196
纹理数据


243
00:08:00,726 --> 00:08:02,296
这个纹理数据  是实时从 GPU


244
00:08:02,296 --> 00:08:03,996
抓取的  可以帮助我们


245
00:08:03,996 --> 00:08:05,576
快速确认  是否绑定上了正确


246
00:08:05,576 --> 00:08:07,466
的资源  当然  这个功能对于


247
00:08:07,466 --> 00:08:09,136
所有的 Metal 资源都可用


248
00:08:09,856 --> 00:08:12,196
我们目前这个变量的纹理看起来


249
00:08:12,196 --> 00:08:12,916
没有错


250
00:08:13,406 --> 00:08:20,006
那么我们还有什么可以检查的


251
00:08:20,276 --> 00:08:21,786
我们下一步  就可以开始捕获帧


252
00:08:21,786 --> 00:08:22,226
了


253
00:08:22,686 --> 00:08:25,336
只需点击调试栏里的这个


254
00:08:25,336 --> 00:08:27,366
小照相机图标  我们就可以捕获


255
00:08:27,366 --> 00:08:29,866
一帧  但如果我们长按这个图标


256
00:08:30,146 --> 00:08:31,556
就会显示出菜单  可以选择捕获


257
00:08:31,556 --> 00:08:33,596
作用域  或者命令队列


258
00:08:33,876 --> 00:08:36,106
捕获作用域是通过渲染通道


259
00:08:36,306 --> 00:08:37,596
完成


260
00:08:37,846 --> 00:08:39,035
就像我的环境图  这个


261
00:08:39,035 --> 00:08:40,395
我每几帧  才更新


262
00:08:40,395 --> 00:08:41,066
一次


263
00:08:41,826 --> 00:08:43,366
但这个例子里  我们想要


264
00:08:43,366 --> 00:08:44,596
捕获的是渲染过程  因为这个


265
00:08:44,596 --> 00:08:45,636
过程里才会真正开始绘制颗粒


266
00:08:46,866 --> 00:08:49,836
所以我们点击  捕获一下


267
00:08:50,046 --> 00:08:50,946
这就捕获好了


268
00:08:51,476 --> 00:08:54,096
对于那些不太熟悉我们的工具


269
00:08:54,096 --> 00:08:55,956
界面的人  我先给大家


270
00:08:55,956 --> 00:08:56,986
快速讲解一下在这个


271
00:08:56,986 --> 00:08:58,186
界面上  都有些什么东西


272
00:08:58,186 --> 00:09:01,726
在界面左侧  我们可以看到


273
00:09:01,726 --> 00:09:02,716
调试工具导航栏


274
00:09:03,186 --> 00:09:04,276
在这里按等级


275
00:09:04,276 --> 00:09:06,396
显示了我们的帧  为了更加


276
00:09:06,396 --> 00:09:08,016
方便大家调试使用  自动


277
00:09:08,016 --> 00:09:10,316
进行了分组  分开了命令缓冲区


278
00:09:10,316 --> 00:09:11,376
和命令编码器


279
00:09:12,346 --> 00:09:13,926
我们的调试组


280
00:09:13,926 --> 00:09:15,936
也显示在这里了  让我们在


281
00:09:15,936 --> 00:09:17,566
微小的层面上也可以掌控调整帧


282
00:09:17,906 --> 00:09:19,856
我们可以选择绘制指令


283
00:09:19,856 --> 00:09:21,526
或者任何其他的 Metal 指令  来审查


284
00:09:21,526 --> 00:09:22,346
其更多细节


285
00:09:23,136 --> 00:09:27,406
位于界面中央的编辑器


286
00:09:27,406 --> 00:09:29,106
向我们展示了绑定的资源


287
00:09:29,496 --> 00:09:30,846
展示了选中的 API 指令中


288
00:09:30,846 --> 00:09:32,986
我们所用到的所有的 Metal 对象


289
00:09:33,986 --> 00:09:35,976
在这里我们也可以看到  为我们的对象


290
00:09:35,976 --> 00:09:37,726
添加标签  可以有效提高调试时的


291
00:09:37,726 --> 00:09:38,536
可读性


292
00:09:38,926 --> 00:09:41,306
我建议大家都养成这个习惯


293
00:09:42,956 --> 00:09:45,026
界面右侧的编辑器


294
00:09:45,026 --> 00:09:46,556
显示的是附件  是最近


295
00:09:46,556 --> 00:09:48,556
一次绘制指令的输出结果


296
00:09:49,136 --> 00:09:50,066
所以不管你什么时候


297
00:09:50,066 --> 00:09:51,416
不管在帧的哪里


298
00:09:51,606 --> 00:09:53,106
都可以马上看到自己在哪一步


299
00:09:53,936 --> 00:09:56,346
在界面最下方  我们有


300
00:09:56,346 --> 00:09:58,166
变量观察器  可以让我们


301
00:09:58,166 --> 00:10:00,156
方便地查看每个 Metal 对象的


302
00:10:00,156 --> 00:10:01,026
状态


303
00:10:01,506 --> 00:10:03,296
好了  我们回到刚刚颗粒的


304
00:10:03,296 --> 00:10:04,366
问题上


305
00:10:04,786 --> 00:10:06,216
现在我们就可以试验一下超强的


306
00:10:06,216 --> 00:10:07,756
过滤功能


307
00:10:08,496 --> 00:10:11,226
好了  现在我知道  那些颗粒


308
00:10:11,226 --> 00:10:12,666
是在正向渲染过程中某处绘制的


309
00:10:13,316 --> 00:10:15,556
所以让我们试着过滤一下


310
00:10:15,866 --> 00:10:17,576
如果对命令编码器进行过滤


311
00:10:17,976 --> 00:10:20,786
那么结果只会显示这个命令编码器


312
00:10:20,786 --> 00:10:21,926
里的 API 指令


313
00:10:21,926 --> 00:10:22,846
比如像这样


314
00:10:23,446 --> 00:10:25,486
但结果还是太多了


315
00:10:26,646 --> 00:10:28,386
所以我们再添加一个额外的过滤


316
00:10:28,386 --> 00:10:28,736
条件


317
00:10:29,086 --> 00:10:30,616
我们知道会用到颗粒


318
00:10:30,616 --> 00:10:31,066
纹理


319
00:10:34,556 --> 00:10:37,186
如果对纹理进行过滤  那么结果


320
00:10:37,186 --> 00:10:39,476
只会显示使用了此纹理的绘制


321
00:10:39,476 --> 00:10:39,896
指令


322
00:10:40,576 --> 00:10:43,656
这就好了  这两个过滤条件


323
00:10:43,656 --> 00:10:46,046
叠加  就能过滤出唯一的 API 指令


324
00:10:46,046 --> 00:10:47,986
而这一指令正是我们希望进一步研究的


325
00:10:48,726 --> 00:10:49,536
我们来看一下


326
00:10:50,016 --> 00:10:53,296
我们先看一下这个指令绑定的


327
00:10:53,296 --> 00:10:54,166
资源


328
00:10:55,046 --> 00:10:57,026
这里  顶点属性中包含了


329
00:10:57,026 --> 00:10:58,456
输入顶点函数的数据  也包含了


330
00:10:58,456 --> 00:11:01,026
离开顶点函数的数据


331
00:11:01,296 --> 00:11:02,616
也许我们就是在这里搞错了


332
00:11:02,616 --> 00:11:05,106
一些几何特征的设定


333
00:11:05,106 --> 00:11:06,196
所以我们看一下  双击


334
00:11:06,196 --> 00:11:06,616
打开


335
00:11:07,626 --> 00:11:09,696
让我们先把这边的附件


336
00:11:09,696 --> 00:11:10,406
隐藏一下


337
00:11:11,626 --> 00:11:13,036
去年  我们给大家展示了


338
00:11:13,036 --> 00:11:14,436
缓冲区一种更好的布局


339
00:11:16,516 --> 00:11:17,836
今年我们还新添加了一些别的东西


340
00:11:18,986 --> 00:11:20,316
在界面眉头  我们可以看到


341
00:11:20,316 --> 00:11:21,746
下方显示的数据是输入还是


342
00:11:21,746 --> 00:11:22,306
输出


343
00:11:23,266 --> 00:11:28,336
如果我们看一下  这边


344
00:11:28,336 --> 00:11:29,626
就是输出的数据  是离开


345
00:11:29,626 --> 00:11:31,106
顶点函数的数据


346
00:11:31,376 --> 00:11:32,966
这些显示了全部颗粒顶点


347
00:11:33,106 --> 00:11:35,776
输出时的位置  我们在这里


348
00:11:35,776 --> 00:11:37,336
可以看到  没有


349
00:11:37,376 --> 00:11:39,286
什么很明显的错误  比如哪个数据


350
00:11:39,286 --> 00:11:41,166
数值过大之类的问题  所以我先


351
00:11:41,166 --> 00:11:42,706
假设这些数据都是正确的


352
00:11:43,446 --> 00:11:45,336
那么我们还可以检查哪里


353
00:11:46,036 --> 00:11:50,386
调试工具导航栏现在还可以让


354
00:11:50,386 --> 00:11:51,836
我们快速定位并进入到当前


355
00:11:51,836 --> 00:11:53,596
绘制指令所相关的所有视图


356
00:11:53,926 --> 00:11:54,846
让我们再切换回


357
00:11:54,846 --> 00:11:55,746
附件看看


358
00:11:56,256 --> 00:12:01,306
我们现在显示了


359
00:12:01,306 --> 00:12:01,506
两种渲染目标


360
00:12:02,436 --> 00:12:04,566
颜色  和深度


361
00:12:05,076 --> 00:12:06,796
让我们再审查一些


362
00:12:06,796 --> 00:12:07,376
像素值吧


363
00:12:07,876 --> 00:12:11,586
我们可以使用位于界面右下方的


364
00:12:11,586 --> 00:12:13,156
审查像素按钮  这就可以


365
00:12:13,226 --> 00:12:16,456
唤出一个新工具


366
00:12:16,556 --> 00:12:20,386
一个环形  这个圆环里显示的


367
00:12:20,386 --> 00:12:22,106
数据  和片元函数输出的


368
00:12:22,106 --> 00:12:23,296
数据完全一致


369
00:12:24,246 --> 00:12:26,256
我们可以用鼠标在渲染目标上


370
00:12:26,256 --> 00:12:27,506
随意移动这个圆环


371
00:12:28,386 --> 00:12:29,796
但我们也可以通过方向键


372
00:12:29,796 --> 00:12:31,796
进行精准到像素级别的控制移动


373
00:12:31,796 --> 00:12:33,186
移动之前甚至都不用放大


374
00:12:34,396 --> 00:12:36,566
我们还可以注意到  在所有的


375
00:12:36,566 --> 00:12:37,806
渲染目标上  圆环的移动都是


376
00:12:37,806 --> 00:12:38,956
完全同步的


377
00:12:39,246 --> 00:12:40,976
可让我们同时查看两边的数值


378
00:12:41,256 --> 00:12:43,306
我们现在就找一个


379
00:12:45,056 --> 00:12:45,136
有趣的像素来看一下


380
00:12:45,356 --> 00:12:46,426
我们长按  就可以


381
00:12:46,426 --> 00:12:47,666
立即移动光标


382
00:12:48,286 --> 00:12:51,686
在这个点上  我们可以看出有些


383
00:12:51,686 --> 00:12:52,576
奇怪


384
00:12:53,466 --> 00:12:55,676
这个颗粒的内部和外部


385
00:12:55,676 --> 00:12:57,586
深度数值不一样


386
00:12:58,076 --> 00:12:59,796
这很奇怪  正常情况下


387
00:12:59,796 --> 00:13:00,946
我们的颗粒不应该写入


388
00:13:00,946 --> 00:13:01,896
深度缓冲区


389
00:13:02,526 --> 00:13:03,896
把这里修好应该很简单


390
00:13:04,316 --> 00:13:05,976
我相信  我们新的 GPU


391
00:13:05,976 --> 00:13:07,536
调试工具也可以帮大家快速地


392
00:13:07,536 --> 00:13:08,886
修好你们 GPU 里的问题


393
00:13:09,906 --> 00:13:11,346
我希望明天早上可以在实验室里


394
00:13:11,346 --> 00:13:13,326
或是在今天的晚些时候


395
00:13:13,326 --> 00:13:14,226
再次看到大家


396
00:13:14,936 --> 00:13:16,296
下面还有请我的同事 Seth


397
00:13:17,516 --> 00:13:23,256
[掌声]


398
00:13:23,756 --> 00:13:26,276
好了  下面我们讲 GPU 性能分析


399
00:13:27,896 --> 00:13:29,796
我们都知道   对于游戏和其他


400
00:13:29,796 --> 00:13:30,896
一些图形应用程序


401
00:13:30,896 --> 00:13:32,596
运行性能至关重要


402
00:13:32,596 --> 00:13:33,966
我们经常需要能够保持


403
00:13:33,966 --> 00:13:35,316
持续稳定的高帧率


404
00:13:36,106 --> 00:13:37,216
但另一方面  我们也


405
00:13:37,216 --> 00:13:38,616
希望能充分利用 GPU


406
00:13:38,616 --> 00:13:40,066
产出图形效果最好的游戏


407
00:13:40,066 --> 00:13:41,756
而同时希望能够提高效率


408
00:13:41,756 --> 00:13:43,106
延长高质量的游戏体验


409
00:13:43,106 --> 00:13:43,846
时间


410
00:13:44,556 --> 00:13:45,726
为了做到以上这些  我们就需要


411
00:13:45,726 --> 00:13:47,206
使用 GPU 性能分析 (Profiling) 工具


412
00:13:47,656 --> 00:13:53,046
我想讲的第一个工具叫作


413
00:13:53,046 --> 00:13:54,546
Metal 系统跟踪 (Metal System Trace)


414
00:13:55,396 --> 00:13:56,236
这个工具可以


415
00:13:56,236 --> 00:13:58,446
用来审查计时问题


416
00:13:58,446 --> 00:14:00,136
我的意思是说  可以审查一些场景


417
00:14:00,136 --> 00:14:02,446
比如有时 CPU 和 GPU 可能


418
00:14:02,446 --> 00:14:04,656
没有在并行运行


419
00:14:04,656 --> 00:14:06,286
而是因为我们错误地


420
00:14:06,286 --> 00:14:07,836
做了一些同步运行  使得


421
00:14:07,836 --> 00:14:08,726
CPU GPU 被迫无法并行 


422
00:14:08,726 --> 00:14:09,116
转而连续运行


423
00:14:09,796 --> 00:14:10,586
这个工具还可以


424
00:14:10,586 --> 00:14:12,166
用来审查一些场景  比如


425
00:14:12,396 --> 00:14:13,586
我们大部分的帧都是


426
00:14:13,586 --> 00:14:14,676
我们想要的样子


427
00:14:14,676 --> 00:14:15,976
但偶尔会有卡顿


428
00:14:16,246 --> 00:14:17,126
然后我们需要去搞明白


429
00:14:17,126 --> 00:14:18,306
好了  就在卡顿的那里底


430
00:14:18,306 --> 00:14:19,226
到有什么问题


431
00:14:20,106 --> 00:14:21,676
这个工具可以让我们


432
00:14:21,676 --> 00:14:22,966
沿着系统跟踪 Metal 任务


433
00:14:23,046 --> 00:14:25,436
从 CPU 到 GPU 到显示


434
00:14:27,436 --> 00:14:29,606
今年  我们还增加了对 VR


435
00:14:29,606 --> 00:14:31,296
应用程序的支持


436
00:14:31,296 --> 00:14:33,056
包含具体的 VR 跟踪点


437
00:14:33,056 --> 00:14:35,836
可针对的活动有比如  当我们向


438
00:14:35,836 --> 00:14:38,916
虚拟现实头盔查询数据时


439
00:14:38,916 --> 00:14:40,516
向 VR Compositor 提交面层


440
00:14:40,516 --> 00:14:43,086
的时候  当 Compositor 进行


441
00:14:43,086 --> 00:14:45,196
排版生成的时候  还有


442
00:14:45,196 --> 00:14:46,946
最后显示在头戴设备的


443
00:14:47,106 --> 00:14:48,506
屏幕上的时候


444
00:14:49,576 --> 00:14:51,406
事实上  从运动到图像显示


445
00:14:51,406 --> 00:14:53,366
整个过程我们都可以追踪


446
00:14:55,976 --> 00:14:58,266
我们今年还添加了


447
00:14:58,266 --> 00:14:59,566
对 ProMotion 显示


448
00:14:59,566 --> 00:15:02,076
的支持  大家可以在新


449
00:15:02,076 --> 00:15:04,096
iPad 上找到  就是这周早些时候


450
00:15:04,096 --> 00:15:06,066
发布的新 iPad Pro  我们还在


451
00:15:06,066 --> 00:15:08,046
macOS 上新增了对外部 GPU 的


452
00:15:08,046 --> 00:15:08,666
支持


453
00:15:09,476 --> 00:15:10,776
另外值得注意的  还有


454
00:15:10,776 --> 00:15:11,906
我们对工具集也新做了很多


455
00:15:11,906 --> 00:15:13,846
很棒的改进  让我们可以更加


456
00:15:13,846 --> 00:15:15,616
便捷地查看其他工具集


457
00:15:15,786 --> 00:15:17,646
和 Metal 系统跟踪一起


458
00:15:17,646 --> 00:15:20,386
比以前整合程度更高了


459
00:15:20,816 --> 00:15:22,776
我们另一个性能分析的工具叫作


460
00:15:22,776 --> 00:15:23,806
GPU 着色器分析器 (GPU Shader Profiler)


461
00:15:24,306 --> 00:15:25,726
是分析着色器性能的


462
00:15:25,726 --> 00:15:26,326
不二选择


463
00:15:27,076 --> 00:15:28,316
我们把这个工具整合进了


464
00:15:28,316 --> 00:15:29,626
帧调试工具里  可以让我们


465
00:15:29,626 --> 00:15:31,466
针对每个绘制指令  每个管道


466
00:15:31,466 --> 00:15:33,116
分别查看着色时间


467
00:15:33,686 --> 00:15:37,416
而且  如果在 iOS 或者 Apple tvOS 上


468
00:15:37,416 --> 00:15:39,236
这个工具还可以让我们分


469
00:15:39,236 --> 00:15:39,956
条查看


470
00:15:41,696 --> 00:15:43,136
我们今年第一个全新的工具


471
00:15:43,136 --> 00:15:44,816
专门为了与 GPU 着色分析器


472
00:15:44,816 --> 00:15:46,006
协同工作而


473
00:15:46,006 --> 00:15:46,496
设计


474
00:15:48,636 --> 00:15:50,296
我们管这个工具叫作 Metal 管道


475
00:15:50,296 --> 00:15:51,046
统计工具 (Metal Pipeline Statistics)


476
00:15:53,036 --> 00:15:55,436
Metal 管道统计工具让我们


477
00:15:55,436 --> 00:15:57,456
可以直连 GPU 编译器


478
00:15:57,456 --> 00:15:59,306
编译器根据我们的着色器


479
00:15:59,306 --> 00:16:00,916
生成机器代码  而这个工具可以


480
00:16:00,916 --> 00:16:02,946
让我们查看这些机器代码的质量


481
00:16:03,016 --> 00:16:03,316
优劣


482
00:16:04,066 --> 00:16:05,176
这个工具会输出一系列


483
00:16:05,176 --> 00:16:06,606
丰富的统计数据  比如


484
00:16:06,756 --> 00:16:08,366
指令数啦  指令混合啦


485
00:16:08,366 --> 00:16:10,236
也就是说  统计


486
00:16:10,236 --> 00:16:11,796
像比如 ALU 内存  或者控制流


487
00:16:11,796 --> 00:16:13,396
这类操作所占的相对比例


488
00:16:13,396 --> 00:16:15,826
而在那些相关的


489
00:16:15,826 --> 00:16:17,216
GPU 上  分析输出结果还会


490
00:16:17,216 --> 00:16:18,866
显示寄存器使用和占用情况


491
00:16:19,306 --> 00:16:21,986
对于这部分 GPU 这些


492
00:16:22,016 --> 00:16:23,436
统计信息至关重要


493
00:16:23,436 --> 00:16:25,306
可以帮助我们理解


494
00:16:25,306 --> 00:16:27,766
同时多少个着色器工作的


495
00:16:27,766 --> 00:16:29,496
限制条件都是什么


496
00:16:30,176 --> 00:16:32,486
也就是说同时可以排


497
00:16:32,646 --> 00:16:33,646
多少个着色场景


498
00:16:34,876 --> 00:16:37,976
但更好用的  是新的


499
00:16:37,976 --> 00:16:39,066
编译器评论功能


500
00:16:39,736 --> 00:16:41,636
有个这个  GPU 编译器就可以


501
00:16:41,636 --> 00:16:43,446
针对你着色器的运行性能


502
00:16:43,666 --> 00:16:44,786
给你反馈出直接的  可操作


503
00:16:44,786 --> 00:16:46,506
的指导  还可以告诉我们具体该改进


504
00:16:46,506 --> 00:16:48,556
哪里  可以避免性能迟缓


505
00:16:48,556 --> 00:16:49,956
从比如慢计算使用情况


506
00:16:50,256 --> 00:16:51,776
寄存器溢出  和堆栈使用


507
00:16:51,776 --> 00:16:52,216
情况


508
00:16:52,796 --> 00:16:56,906
这就好像每个 Xcode 都自带了


509
00:16:56,906 --> 00:16:59,636
一位 GPU 编译器工程师


510
00:17:00,736 --> 00:17:02,806
对于每条评论  下面都会展开解释


511
00:17:02,946 --> 00:17:06,246
到底什么意思  我们可以做什么来


512
00:17:06,316 --> 00:17:08,796
提升性能  还会给我们提供一个链接


513
00:17:08,796 --> 00:17:11,006
点击就可以直接定位到需要修改的


514
00:17:11,076 --> 00:17:11,536
地方


515
00:17:12,695 --> 00:17:13,955
好了  为了给大家演示这个新功能


516
00:17:13,955 --> 00:17:15,036
我想请我的同事 Jose


517
00:17:15,256 --> 00:17:16,935
上台  给大家演示一下


518
00:17:16,935 --> 00:17:18,465
Metal 通道


519
00:17:18,465 --> 00:17:19,086
统计工具


520
00:17:20,516 --> 00:17:22,546
[掌声]


521
00:17:23,046 --> 00:17:23,536
>> 大家好


522
00:17:23,685 --> 00:17:24,526
我是 Jose Enrique


523
00:17:24,606 --> 00:17:26,006
我要为大家展示一个新特性


524
00:17:26,006 --> 00:17:27,556
那就是我们的对 GPU 友好的


525
00:17:27,556 --> 00:17:28,946
调试器 它会助你


526
00:17:29,296 --> 00:17:30,466
产出高质量的产品


527
00:17:30,836 --> 00:17:32,416
大家可以看到 我们


528
00:17:32,526 --> 00:17:33,786
正在重放一个在 iOS 上的


529
00:17:33,976 --> 00:17:35,166
捕捉 Metal 的演示


530
00:17:35,996 --> 00:17:37,956
我要做的第一件事


531
00:17:37,956 --> 00:17:39,286
就是把调试导航视图


532
00:17:39,286 --> 00:17:41,196
从按调用检视帧 (view frame


533
00:17:41,196 --> 00:17:42,766
by call） 改成按性能检视帧 (view frame by


534
00:17:42,766 --> 00:17:43,496
performance)


535
00:17:44,026 --> 00:17:46,916
这会给出 这个视图


536
00:17:46,916 --> 00:17:50,216
会给出你所捕捉的所有


537
00:17:50,216 --> 00:17:53,956
通道 按时间分类的


538
00:17:54,146 --> 00:17:56,066
记住 在 Metal 里 


539
00:17:56,066 --> 00:17:57,156
着色器永远连接到通道上


540
00:17:57,556 --> 00:17:59,556
因此 这是一个列表


541
00:17:59,556 --> 00:18:00,656
上面是所有


542
00:18:00,656 --> 00:18:01,126
捕捉中可以得到的


543
00:18:01,126 --> 00:18:01,466
发起程序组合


544
00:18:02,486 --> 00:18:04,506
我要看一下


545
00:18:04,506 --> 00:18:05,296
最昂贵的通道


546
00:18:05,296 --> 00:18:06,836
去看看我们是否


547
00:18:06,836 --> 00:18:07,866
能改进着色器


548
00:18:08,436 --> 00:18:12,726
我们可以看到这个视图


549
00:18:12,726 --> 00:18:13,586
有三个部分


550
00:18:13,956 --> 00:18:15,686
最上面的是评价 (remarks)


551
00:18:16,296 --> 00:18:17,626
评价是改进


552
00:18:17,626 --> 00:18:19,246
编译器着色器质量的好办法


553
00:18:19,616 --> 00:18:21,576
它会报告最终编译器


554
00:18:22,116 --> 00:18:23,486
合成时产生的问题


555
00:18:24,646 --> 00:18:26,326
要记住 GPU 会


556
00:18:26,326 --> 00:18:28,206
在每一帧中运行着色器上百万次


557
00:18:28,206 --> 00:18:30,046
因此 


558
00:18:30,046 --> 00:18:31,446
你合成的越好


559
00:18:31,446 --> 00:18:33,746
它的性能就会越好


560
00:18:35,096 --> 00:18:36,406
评价还按相关度分类


561
00:18:36,406 --> 00:18:38,766
如果扩张了


562
00:18:38,766 --> 00:18:41,106
它还会告诉你


563
00:18:41,106 --> 00:18:42,986
为什么要上报


564
00:18:42,986 --> 00:18:44,556
再给出建议 该如何预防这种情况


565
00:18:45,456 --> 00:18:45,523
发生


566
00:18:46,226 --> 00:18:47,836
在评价下面


567
00:18:47,836 --> 00:18:49,336
是每个着色器的概况


568
00:18:49,336 --> 00:18:50,496
你可以看到编译器是如何


569
00:18:50,576 --> 00:18:52,986
最终组合


570
00:18:52,986 --> 00:18:54,096
指令比 (instruction


571
00:18:54,166 --> 00:18:54,876
ratio)


572
00:18:56,186 --> 00:18:58,046
最后 我们还有


573
00:18:58,106 --> 00:18:59,306
所用使用这个通道的调回的


574
00:18:59,306 --> 00:18:59,756
列表


575
00:19:00,396 --> 00:19:01,626
这会在我们


576
00:19:01,626 --> 00:19:02,776
迭代我们的着色器时


577
00:19:02,776 --> 00:19:03,396
非常方便


578
00:19:04,426 --> 00:19:06,946
下面让我来展示一个例子


579
00:19:06,946 --> 00:19:08,506
是关于工作流剖析数据的


580
00:19:09,376 --> 00:19:10,976
我们来到最上面的评价部分


581
00:19:11,186 --> 00:19:13,036
寄存器溢出 (Register Spill) 我们可以看到


582
00:19:13,036 --> 00:19:14,846
编译器报告了一个很大的


583
00:19:14,846 --> 00:19:16,946
溢出 有 1040 字节


584
00:19:17,786 --> 00:19:19,246
溢出会导致 GPU


585
00:19:19,246 --> 00:19:21,546
访问内存 这会拖延


586
00:19:21,546 --> 00:19:22,486
你的着色执行


587
00:19:23,856 --> 00:19:24,806
如果能够知道编译器


588
00:19:24,806 --> 00:19:26,326
发生了溢出 并修复它


589
00:19:26,326 --> 00:19:27,376
这会极大地提升你的着色器


590
00:19:27,376 --> 00:19:29,636
性能 但是要找到


591
00:19:29,636 --> 00:19:30,886
编译器在哪里发生溢出


592
00:19:31,296 --> 00:19:32,566
及其原因 这是一个很耗费时间的


593
00:19:32,566 --> 00:19:32,876
事情


594
00:19:33,936 --> 00:19:36,596
但要注意的是第二个和第四个


595
00:19:36,596 --> 00:19:37,106
评价


596
00:19:37,586 --> 00:19:39,156
动态栈存储 (Dynamic Stack Store)


597
00:19:39,156 --> 00:19:39,766
和动态栈读取


598
00:19:40,776 --> 00:19:43,056
如果扩展了 它会给出原因


599
00:19:43,226 --> 00:19:45,046
为什么一个昂贵的栈读取


600
00:19:45,046 --> 00:19:46,716
在本地数组中被反射到


601
00:19:46,716 --> 00:19:47,416
动态偏移上


602
00:19:48,256 --> 00:19:51,096
同时还会给出建议


603
00:19:51,096 --> 00:19:52,256
减少栈访问


604
00:19:52,336 --> 00:19:53,786
消除对于本地数组的


605
00:19:53,786 --> 00:19:54,476
动态访问


606
00:19:55,236 --> 00:19:57,026
这等于在说


607
00:19:57,026 --> 00:19:58,586
在我们的着色器代码中


608
00:19:58,586 --> 00:20:00,116
有一个可变数组在


609
00:20:00,116 --> 00:20:01,936
储存栈 而且我们


610
00:20:01,936 --> 00:20:03,416
在用一些别的可变索引访问它


611
00:20:04,296 --> 00:20:05,996
这在支持 CPU 时


612
00:20:05,996 --> 00:20:07,816
是一个非常常见的模式


613
00:20:07,816 --> 00:20:09,286
但 GPU 不同 我们如果依赖栈的使用


614
00:20:09,286 --> 00:20:11,346
就会造成 GPU 的负担


615
00:20:11,966 --> 00:20:14,726
但要注意建议下面的


616
00:20:14,726 --> 00:20:15,376
话


617
00:20:15,426 --> 00:20:16,916
它有一个准确的行数


618
00:20:17,436 --> 00:20:18,676
这意味着我们选择点击它


619
00:20:18,776 --> 00:20:22,086
就会直接跳转到


620
00:20:22,086 --> 00:20:23,426
着色器代码行


621
00:20:23,426 --> 00:20:25,146
在这里编译器在从


622
00:20:25,146 --> 00:20:26,286
栈数组中读取数据


623
00:20:26,776 --> 00:20:27,896
我们找到编译器溢出了


624
00:20:29,366 --> 00:20:30,656
同时这与我们的共享性能数据


625
00:20:30,656 --> 00:20:31,676
协调得非常好


626
00:20:31,676 --> 00:20:33,116
会让我们知道这一行的高代价


627
00:20:33,116 --> 00:20:34,986
现在我们知道


628
00:20:34,986 --> 00:20:35,666
到底为什么了


629
00:20:37,396 --> 00:20:40,326
着色器执行了两个 pass


630
00:20:41,056 --> 00:20:42,836
第一个 pass 是光线计算


631
00:20:44,166 --> 00:20:46,956
第二个 pass 是


632
00:20:46,956 --> 00:20:47,776
光线积累


633
00:20:48,766 --> 00:20:49,766
这是从 GPU 的角度


634
00:20:49,766 --> 00:20:51,076
与编译器共同工作


635
00:20:51,076 --> 00:20:52,186
来解决问题


636
00:20:52,856 --> 00:20:55,056
我要做的第一件事


637
00:20:55,176 --> 00:20:56,686
是移除栈数组


638
00:20:56,686 --> 00:20:59,756
我要移除它


639
00:20:59,756 --> 00:21:02,366
然后我要


640
00:21:02,366 --> 00:21:03,536
第一个循环里


641
00:21:03,536 --> 00:21:04,896
直接计算


642
00:21:04,896 --> 00:21:06,166
光线积累


643
00:21:09,116 --> 00:21:10,736
然后我要移除


644
00:21:10,736 --> 00:21:12,976
第二个循环


645
00:21:13,996 --> 00:21:14,316
不再这样做了


646
00:21:14,316 --> 00:21:15,916
现在我要点击


647
00:21:15,916 --> 00:21:17,396
更新着色器按键 然后


648
00:21:17,396 --> 00:21:17,916
等待结果


649
00:21:18,516 --> 00:21:19,646
这样做会


650
00:21:19,646 --> 00:21:20,966
让编译器进行一次


651
00:21:20,966 --> 00:21:21,776
完整的循环优化


652
00:21:21,776 --> 00:21:24,376
并重新反复使用同样的


653
00:21:24,376 --> 00:21:26,636
减速器而不是去


654
00:21:26,636 --> 00:21:27,596
依赖那个栈


655
00:21:28,906 --> 00:21:30,356
结果出来之后


656
00:21:30,356 --> 00:21:31,786
我们就能看到


657
00:21:31,786 --> 00:21:33,356
前后的合成中的指令比率


658
00:21:33,356 --> 00:21:35,416
已经变小了


659
00:21:35,416 --> 00:21:36,486
同时 这一更改


660
00:21:36,486 --> 00:21:38,006
对通道中用到的每一个绘制调用


661
00:21:38,006 --> 00:21:39,726
的影响也小了


662
00:21:39,726 --> 00:21:41,296
给了我们整个空间性能


663
00:21:41,296 --> 00:21:41,896
的改进


664
00:21:43,046 --> 00:21:44,226
到这里 关于


665
00:21:44,226 --> 00:21:44,986
这个示例


666
00:21:44,986 --> 00:21:46,246
就结束了


667
00:21:46,466 --> 00:21:47,656
交还给我的同事


668
00:21:47,656 --> 00:21:47,926
Seth


669
00:21:49,516 --> 00:21:54,756
[掌声] 


670
00:21:55,256 --> 00:21:56,866
>> 谢谢 Jose


671
00:21:56,966 --> 00:21:59,766
下面讲我们今天要介绍的


672
00:21:59,766 --> 00:22:00,296
最后一样工具


673
00:22:00,726 --> 00:22:02,286
GPU 计数分析 (GPU Counter Profiling)


674
00:22:02,806 --> 00:22:06,196
大家知道 GPU 构建非常复杂


675
00:22:06,196 --> 00:22:08,056
因为有由多个可编程


676
00:22:08,056 --> 00:22:08,986
的固定功能块组成


677
00:22:08,986 --> 00:22:10,366
的通道


678
00:22:10,366 --> 00:22:12,196
在这个通道中


679
00:22:12,196 --> 00:22:13,396
任何地方都可能出现瓶颈


680
00:22:14,216 --> 00:22:15,476
而且常常是


681
00:22:15,546 --> 00:22:16,936
多个地方同时发生


682
00:22:18,386 --> 00:22:20,986
你们作为 Metal 程序员的任务


683
00:22:20,986 --> 00:22:23,026
是让固定功能瓶颈最小化


684
00:22:23,026 --> 00:22:24,366
同时还要有效地


685
00:22:24,366 --> 00:22:25,966
利用可编程块


686
00:22:28,776 --> 00:22:30,586
要实现这一点 我们的


687
00:22:30,586 --> 00:22:33,166
新 GPU 计数分析是个好工具


688
00:22:33,546 --> 00:22:36,106
它不会直接去到


689
00:22:36,106 --> 00:22:38,236
GPU 帧调试器 而是给你


690
00:22:38,236 --> 00:22:40,286
详细的 GPU 硬件


691
00:22:40,286 --> 00:22:42,866
性能数据 在 macOS 上


692
00:22:42,866 --> 00:22:46,496
以每个 draw call 的频率给出


693
00:22:46,496 --> 00:22:49,066
在 iOS 和 Apple tvOS 上以每个编码器的频率给出


694
00:22:50,036 --> 00:22:51,986
它不会给你


695
00:22:51,986 --> 00:22:54,336
一个复杂的计数列表


696
00:22:54,336 --> 00:22:55,906
这种列表为每个 GPU 发生变化


697
00:22:55,906 --> 00:22:57,676
难以理解 常常无法


698
00:22:58,206 --> 00:22:59,216
告诉你你想知道的事


699
00:22:59,216 --> 00:23:01,576
我们定义了一系列


700
00:23:01,576 --> 00:23:03,236
高等级的字符


701
00:23:03,236 --> 00:23:04,936
对每个 GPU 的意义都相同


702
00:23:05,286 --> 00:23:07,296
所以你不需要针对每个 GPU 的


703
00:23:07,296 --> 00:23:08,666
学习曲线了


704
00:23:10,156 --> 00:23:12,606
这就是计数分析


705
00:23:13,146 --> 00:23:16,726
在左边是图像视图


706
00:23:16,726 --> 00:23:19,506
显示出详细的 GPU


707
00:23:19,546 --> 00:23:21,156
计数图 在右边


708
00:23:21,156 --> 00:23:22,886
是细节窗口


709
00:23:23,606 --> 00:23:25,246
我们一样一样说


710
00:23:26,036 --> 00:23:29,866
在图像视图中


711
00:23:30,276 --> 00:23:33,306
显示了每一帧的计数


712
00:23:33,936 --> 00:23:35,706
X 轴代表绘制调用


713
00:23:35,706 --> 00:23:37,836
或者时间上的编码器


714
00:23:39,036 --> 00:23:40,506
在最上面显示的是 GPU 时间


715
00:23:40,826 --> 00:23:43,206
所有的 GPU 计数分析


716
00:23:43,206 --> 00:23:43,996
都有这个


717
00:23:44,746 --> 00:23:45,886
在它下面


718
00:23:45,886 --> 00:23:47,106
是一系列顶级计数


719
00:23:47,106 --> 00:23:48,706
对应 GPU 通道中的每个阶段


720
00:23:48,706 --> 00:23:50,986
以及一些其他的


721
00:23:50,986 --> 00:23:52,386
顶级计数


722
00:23:52,386 --> 00:23:53,996
对应共享执行单元


723
00:23:53,996 --> 00:23:55,816
比如着色器核心


724
00:23:55,816 --> 00:23:56,836
和测试单元


725
00:23:58,616 --> 00:24:00,796
你可以在每一组


726
00:24:00,796 --> 00:24:02,686
深挖到更细节的计数


727
00:24:02,686 --> 00:24:04,726
在每一个阶段中


728
00:24:04,726 --> 00:24:06,966
探索更多数据


729
00:24:06,966 --> 00:24:08,926
这对那些你认为


730
00:24:08,926 --> 00:24:10,616
首当其冲可能是


731
00:24:10,616 --> 00:24:11,816
性能发生问题的


732
00:24:11,976 --> 00:24:13,746
工作流很有用 然后你可以看更多细节


733
00:24:13,746 --> 00:24:14,286
从而发现问题


734
00:24:14,976 --> 00:24:19,586
在细节视图中 


735
00:24:19,586 --> 00:24:20,976
我们会向你展示


736
00:24:20,976 --> 00:24:22,306
和计数图像视图中一样的


737
00:24:22,306 --> 00:24:23,706
计数 但是会展示全部的细节


738
00:24:23,706 --> 00:24:24,226
以数值模拟的方式


739
00:24:25,096 --> 00:24:26,546
为了给它一个背景


740
00:24:26,546 --> 00:24:28,656
我们还会展示出 


741
00:24:28,656 --> 00:24:29,996
这一帧的中值 最大值


742
00:24:29,996 --> 00:24:30,786
以及总数值


743
00:24:31,016 --> 00:24:34,546
图像视图和


744
00:24:34,546 --> 00:24:35,856
细节视图都支持


745
00:24:35,856 --> 00:24:38,136
全面丰富的过滤选项


746
00:24:38,426 --> 00:24:40,036
我们在帧调试器的其他地方也支持


747
00:24:40,036 --> 00:24:42,226
这种选项 所以如果你想同时


748
00:24:42,226 --> 00:24:44,086
查看某个像素数据


749
00:24:44,216 --> 00:24:45,426
和某个内存数据


750
00:24:45,426 --> 00:24:47,336
你可以把搜索项目合并


751
00:24:47,336 --> 00:24:48,776
然后依次查看


752
00:24:48,776 --> 00:24:49,876
你所需要的所有东西


753
00:24:51,406 --> 00:24:54,696
但我要重点指出 


754
00:24:54,696 --> 00:24:56,756
GPU 计数分析是我们


755
00:24:56,756 --> 00:24:58,026
对瓶颈分析的利器


756
00:24:59,016 --> 00:25:00,516
我们用它找出


757
00:25:00,516 --> 00:25:01,896
在每一个绘制调用


758
00:25:01,896 --> 00:25:03,706
或者每一个编码器中


759
00:25:03,706 --> 00:25:05,536
用过的计数 


760
00:25:05,536 --> 00:25:07,696
对它进行全面分析


761
00:25:07,696 --> 00:25:10,446
这种分析是跨平台基础上的


762
00:25:10,446 --> 00:25:12,716
也是以每个 GPU 为基础的


763
00:25:12,716 --> 00:25:14,506
从而找出每个调用中的潜在瓶颈


764
00:25:16,446 --> 00:25:19,546
除了这个 我们还给你


765
00:25:19,546 --> 00:25:21,416
很多数据 让你知道


766
00:25:21,416 --> 00:25:22,636
发生了什么


767
00:25:23,006 --> 00:25:24,306
什么导致的


768
00:25:24,306 --> 00:25:26,266
然后是直接导航到


769
00:25:26,266 --> 00:25:28,716
受影响地区的直观工作流


770
00:25:30,346 --> 00:25:32,136
现在 所有的瓶颈


771
00:25:32,136 --> 00:25:34,356
以及所有的计数


772
00:25:34,486 --> 00:25:36,606
都会在 Xcode 文件里


773
00:25:36,866 --> 00:25:38,826
有丰富的细节记录


774
00:25:39,166 --> 00:25:40,716
详细解释每一个计数的意义


775
00:25:40,716 --> 00:25:43,276
为什么它特别高


776
00:25:43,276 --> 00:25:44,636
或者特别低


777
00:25:44,636 --> 00:25:46,626
以及你能


778
00:25:46,626 --> 00:25:47,846
做些什么


779
00:25:47,846 --> 00:25:49,306
要展示这个


780
00:25:49,516 --> 00:25:51,086
很棒的 GPU 计数分析特性


781
00:25:51,086 --> 00:25:52,556
我想再次请上我的同事 


782
00:25:52,556 --> 00:25:54,476
Jose 来给大家做


783
00:25:54,476 --> 00:25:56,336
实际应用的演示


784
00:25:57,516 --> 00:25:59,676
[掌声] 


785
00:26:00,176 --> 00:26:00,576
>> 谢谢 Seth


786
00:26:01,176 --> 00:26:02,116
我又来了


787
00:26:02,806 --> 00:26:06,066
这次我要展示的是


788
00:26:06,426 --> 00:26:10,266
GPU 计数器 这个工具


789
00:26:10,266 --> 00:26:11,396
会帮助你分析


790
00:26:11,396 --> 00:26:11,996
GPU 的性能


791
00:26:13,036 --> 00:26:14,066
首先 我要再播放一遍


792
00:26:14,066 --> 00:26:15,286
刚才放过的演示


793
00:26:15,286 --> 00:26:17,496
但这次 我们要从性能角度


794
00:26:17,496 --> 00:26:18,636
注意观看


795
00:26:19,766 --> 00:26:21,596
要注意的第一件事是


796
00:26:21,596 --> 00:26:23,656
新的 GPU 测量


797
00:26:23,656 --> 00:26:24,336
就在 FPS 测量下面


798
00:26:25,366 --> 00:26:26,356
点击它 我们就


799
00:26:26,356 --> 00:26:28,796
来到了 GP 计数视图


800
00:26:29,436 --> 00:26:31,316
我们可以看到


801
00:26:31,316 --> 00:26:32,486
这里有很多数据


802
00:26:33,106 --> 00:26:34,306
这在之前是没有过的


803
00:26:34,476 --> 00:26:36,286
有了这个视图 你们就可以


804
00:26:36,356 --> 00:26:38,216
传输文件 在任意捕捉帧中


805
00:26:38,216 --> 00:26:39,316
你所遇到的任何问题


806
00:26:39,316 --> 00:26:40,296
都可以


807
00:26:41,326 --> 00:26:42,796
我来演示一下要怎么


808
00:26:42,796 --> 00:26:43,776
发现性能问题


809
00:26:45,326 --> 00:26:46,696
首先 我们来看图像


810
00:26:46,696 --> 00:26:47,016
视图


811
00:26:50,206 --> 00:26:51,566
我们看到


812
00:26:51,566 --> 00:26:53,076
在一个捕捉的开始


813
00:26:53,076 --> 00:26:54,016
有一个 GPU 时间的高峰


814
00:26:54,526 --> 00:26:56,356
你要做的第一件事


815
00:26:56,356 --> 00:26:58,746
就是放大去看单一的回调


816
00:26:58,826 --> 00:26:59,876
有更多的


817
00:26:59,876 --> 00:27:00,436
offender


818
00:27:00,946 --> 00:27:01,926
要做到这一点 我只需


819
00:27:01,926 --> 00:27:04,596
捏合缩放 这样就


820
00:27:04,596 --> 00:27:04,846
可以了


821
00:27:05,556 --> 00:27:07,216
任何默认系统行为


822
00:27:07,216 --> 00:27:08,356
都会按你的意愿


823
00:27:08,356 --> 00:27:08,696
工作


824
00:27:09,406 --> 00:27:11,546
现在我会看到这里有一个


825
00:27:11,546 --> 00:27:12,266
高峰


826
00:27:12,456 --> 00:27:14,106
你可以通过点击这个


827
00:27:14,106 --> 00:27:15,306
绘制调用


828
00:27:15,436 --> 00:27:17,856
在所有通道中标记这个高峰


829
00:27:17,856 --> 00:27:19,856
在每一行上悬停会给我们


830
00:27:19,856 --> 00:27:21,396
细节信息 让我们知道


831
00:27:21,396 --> 00:27:23,016
它们分别与这个绘制调用


832
00:27:23,016 --> 00:27:23,936
有多大相关


833
00:27:24,856 --> 00:27:26,896
在这个示例中 Vertex Omission


834
00:27:27,026 --> 00:27:28,506
Vertex Shader 和 Primitives


835
00:27:28,936 --> 00:27:30,546
似乎都没有相关的


836
00:27:30,676 --> 00:27:30,876
影响


837
00:27:31,406 --> 00:27:33,096
与之相反 Fragment Shader


838
00:27:33,716 --> 00:27:35,236
和 Pixels Stored 看起来


839
00:27:35,436 --> 00:27:36,316
相当的高


840
00:27:37,106 --> 00:27:38,836
我们先来看一下 Fragment


841
00:27:38,836 --> 00:27:39,436
Shader


842
00:27:40,396 --> 00:27:42,326
如果我们展开这个组


843
00:27:42,326 --> 00:27:43,796
就能够访问大量的


844
00:27:43,796 --> 00:27:45,596
计数数据 这能给我们


845
00:27:45,656 --> 00:27:47,336
细节信息 让我们知道


846
00:27:47,336 --> 00:27:48,806
着色器阶段发生了什么


847
00:27:49,636 --> 00:27:50,646
最后被计数的


848
00:27:50,646 --> 00:27:52,366
我们可以很快看到 


849
00:27:52,616 --> 00:27:54,476
延时时间高得出奇


850
00:27:54,476 --> 00:27:56,786
超过了 76%


851
00:27:57,486 --> 00:27:58,936
这意味着我们花在


852
00:27:58,936 --> 00:28:00,116
Fragment Shader 上的


853
00:28:00,116 --> 00:28:01,586
大多数时间实际上是在等待


854
00:28:01,586 --> 00:28:03,366
一些内存或者数据


855
00:28:04,526 --> 00:28:06,776
这是因为你在


856
00:28:06,776 --> 00:28:08,176
从一个缓冲器


857
00:28:08,176 --> 00:28:10,596
或者从一个纹理中取用


858
00:28:10,596 --> 00:28:11,806
但纹理捕捉应该在这个延迟里


859
00:28:12,406 --> 00:28:14,556
所以让我们去到纹理单元 (Texture


860
00:28:14,556 --> 00:28:16,736
Unit) 看看缓存率


861
00:28:16,736 --> 00:28:16,956
是多少


862
00:28:18,746 --> 00:28:20,526
我们可以立即看到 


863
00:28:20,526 --> 00:28:22,256
纹理缓存率也出奇的高


864
00:28:22,256 --> 00:28:24,586
几乎到了 60%


865
00:28:25,326 --> 00:28:27,246
这意味着超过一半的


866
00:28:27,246 --> 00:28:28,396
纹理样本


867
00:28:28,396 --> 00:28:29,636
都来自视频内存


868
00:28:29,636 --> 00:28:30,766
而不是纹理缓存


869
00:28:31,966 --> 00:28:33,956
现在我们对于当前的问题


870
00:28:33,956 --> 00:28:34,946
有了更好的了解


871
00:28:34,946 --> 00:28:36,966
就来看一看


872
00:28:36,966 --> 00:28:37,636
辅助编辑器吧


873
00:28:38,196 --> 00:28:41,686
我们可以看到 


874
00:28:41,686 --> 00:28:43,406
辅助编辑器提供了


875
00:28:43,506 --> 00:28:45,006
和图像视图一样的


876
00:28:45,006 --> 00:28:46,156
计数信息


877
00:28:46,356 --> 00:28:48,106
这不过这次是以列表视图显示的


878
00:28:48,806 --> 00:28:51,376
但更重要的是 看一下顶部


879
00:28:51,826 --> 00:28:53,286
这是我们的瓶颈访问工具


880
00:28:53,566 --> 00:28:56,406
它会指出我们在


881
00:28:56,406 --> 00:28:58,106
选择的绘制调用内部


882
00:28:58,106 --> 00:29:00,276
分析所有计数时


883
00:29:00,276 --> 00:29:01,736
所考虑到的两个相关问题


884
00:29:01,736 --> 00:29:03,076
并指出了我们认为


885
00:29:03,076 --> 00:29:04,976
值得引起你们注意的


886
00:29:04,976 --> 00:29:05,926
任何相关问题


887
00:29:06,266 --> 00:29:07,356
在这个示例里 


888
00:29:07,356 --> 00:29:09,446
标记同样的问题


889
00:29:09,446 --> 00:29:12,776
也就是我们刚才通过检查图表


890
00:29:12,776 --> 00:29:15,646
手动发现的问题 纹理缓存失误率很高


891
00:29:15,876 --> 00:29:17,686
展开之后 它还


892
00:29:17,686 --> 00:29:18,586
给出了建议 告诉我们应该检查


893
00:29:18,586 --> 00:29:18,866
什么


894
00:29:19,636 --> 00:29:21,436
在这个示例里 检查


895
00:29:21,436 --> 00:29:23,446
样本纹理是否有纹理映射


896
00:29:23,486 --> 00:29:25,406
还有关于这个问题的


897
00:29:25,436 --> 00:29:26,786
相关视图的快速导航名称


898
00:29:28,066 --> 00:29:29,656
比如边界资源 (boundary sources)


899
00:29:30,006 --> 00:29:31,266
我们可以立即看到


900
00:29:31,266 --> 00:29:32,886
现在的问题是什么


901
00:29:32,886 --> 00:29:35,866
我们正在获取一个 4 K 乘 4 K 的 RGBA32


902
00:29:35,926 --> 00:29:37,126
浮点纹理


903
00:29:37,126 --> 00:29:38,576
并且这个浮点纹理在 vertex


904
00:29:39,226 --> 00:29:40,126
和 Fragment Shader 里都没有纹理映射


905
00:29:40,476 --> 00:29:43,336
这是一个 256 MB 的纹理


906
00:29:43,336 --> 00:29:44,866
在整个通道里被获取


907
00:29:45,846 --> 00:29:47,816
难怪缓存都被浪费了


908
00:29:48,826 --> 00:29:50,156
想一想我们刚才


909
00:29:50,156 --> 00:29:50,826
做了什么


910
00:29:51,426 --> 00:29:52,486
这是一个非常详细的


911
00:29:52,486 --> 00:29:54,656
关于 GPU 内部工作的视图


912
00:29:55,616 --> 00:29:56,926
你们终于有了能够证明


913
00:29:56,926 --> 00:29:58,216
从纹理中获取


914
00:29:58,216 --> 00:29:59,746
是昂贵的


915
00:29:59,746 --> 00:30:01,226
这件事的数据


916
00:30:01,226 --> 00:30:02,176
但现在你知道为什么了


917
00:30:03,296 --> 00:30:05,076
访问这个纹理


918
00:30:05,076 --> 00:30:06,216
在 Fragment Shader 上是一个开始


919
00:30:06,216 --> 00:30:08,136
因为它必须从


920
00:30:08,136 --> 00:30:09,196
内置内存中获取数据


921
00:30:09,196 --> 00:30:11,426
这些数据现在在缓存里


922
00:30:12,376 --> 00:30:12,576
已经没有了


923
00:30:12,706 --> 00:30:13,656
这种程度的细节


924
00:30:13,656 --> 00:30:14,716
一般在咨询工具之外


925
00:30:14,716 --> 00:30:15,606
很难见到


926
00:30:16,706 --> 00:30:17,896
解决这个问题现在


927
00:30:17,896 --> 00:30:20,566
取决于平衡 性能


928
00:30:21,006 --> 00:30:22,736
质量和正确率


929
00:30:22,736 --> 00:30:23,926
但你已经展示了


930
00:30:23,926 --> 00:30:25,036
要如何运用 GPU 计数和


931
00:30:25,036 --> 00:30:27,376
GPU 帧调试器 来帮助你


932
00:30:27,376 --> 00:30:30,196
调查 分析 


933
00:30:30,196 --> 00:30:32,016
分辨任何的捕捉信息


934
00:30:32,016 --> 00:30:34,246
任何在你的捕捉里的


935
00:30:34,246 --> 00:30:35,256
性能信息


936
00:30:35,676 --> 00:30:37,056
现在再请我的同事


937
00:30:37,056 --> 00:30:37,586
Seth 回来


938
00:30:38,516 --> 00:30:43,500
[掌声] 


939
00:30:48,386 --> 00:30:48,976
>> 谢谢 Jose


940
00:30:50,696 --> 00:30:52,756
这就是 GPU 计数


941
00:30:52,756 --> 00:30:53,346
分析


942
00:30:53,966 --> 00:30:54,926
和我们今天说过的所有新


943
00:30:54,926 --> 00:30:56,456
特性一样


944
00:30:56,456 --> 00:30:58,676
它是 Xcode Beta 9 里的最大乐趣


945
00:30:59,166 --> 00:31:00,716
它对所有可以使用 Metal 的


946
00:31:00,716 --> 00:31:01,906
GPU 都适用


947
00:31:02,656 --> 00:31:04,356
你们会发现 


948
00:31:04,356 --> 00:31:05,586
越新的 GPU 就有越多的计数可用


949
00:31:05,586 --> 00:31:07,676
因为 GPU 更加现代化了


950
00:31:07,986 --> 00:31:10,086
但所有的 GPU


951
00:31:10,086 --> 00:31:11,976
都会有丰富可用的


952
00:31:11,976 --> 00:31:13,616
计数


953
00:31:14,026 --> 00:31:16,616
尽管如此 我们还是非常


954
00:31:16,616 --> 00:31:17,936
期待你们的反馈


955
00:31:17,936 --> 00:31:18,946
如果你们觉得哪个计数


956
00:31:18,946 --> 00:31:19,696
还没有 它又非常


957
00:31:19,696 --> 00:31:22,156
有价值 那么就请
 
00:31:22,426 --> 00:31:24,606
务必光临实验室


958
00:31:24,606 --> 00:31:26,046
我们会很乐意


959
00:31:26,046 --> 00:31:26,956
进行研究


960
00:31:27,386 --> 00:31:28,986
我们今天说了


961
00:31:28,986 --> 00:31:29,226
什么呢


962
00:31:29,486 --> 00:31:30,586
我们讲到了


963
00:31:30,586 --> 00:31:31,906
Metal 帧调试器的一些很好的改进


964
00:31:31,906 --> 00:31:33,676
包括支持像素检查


965
00:31:33,676 --> 00:31:35,846
检查 Vertex


966
00:31:36,246 --> 00:31:39,256
Shader 输出 丰富的过滤


967
00:31:39,776 --> 00:31:42,186
更好的捕捉支持 


968
00:31:42,186 --> 00:31:44,196
更好的捕捉性能


969
00:31:44,196 --> 00:31:45,696
和 Xcode Metal Quick Look


970
00:31:46,216 --> 00:31:49,206
我们还讲到了


971
00:31:49,206 --> 00:31:50,586
对 Metal 托盘调试器中


972
00:31:50,586 --> 00:31:53,506
VR 应用的调试和分析的支持


973
00:31:53,506 --> 00:31:54,876
以及 Metal 系统托盘


974
00:31:57,356 --> 00:31:59,986
我们讲到了 Metal


975
00:32:00,056 --> 00:32:01,726
通道数据


976
00:32:01,726 --> 00:32:03,236
让你们直接进入


977
00:32:03,236 --> 00:32:04,316
GPU compiler


978
00:32:04,316 --> 00:32:04,916
获取性能信息


979
00:32:06,696 --> 00:32:08,516
我们还介绍了 GPU 计数分析


980
00:32:08,516 --> 00:32:11,586
它让你们能够


981
00:32:11,586 --> 00:32:13,626
访问 Metal 里的


982
00:32:13,626 --> 00:32:17,346
GPU 性能计数数据


983
00:32:17,626 --> 00:32:19,866
更多信息请访问


984
00:32:19,866 --> 00:32:20,486
网站


985
00:32:22,166 --> 00:32:23,846
编号是 607


986
00:32:23,846 --> 00:32:28,276
我还想推荐


987
00:32:28,276 --> 00:32:29,956
其他的一些演讲


988
00:32:30,316 --> 00:32:31,756
如果你们没有赶上


989
00:32:31,756 --> 00:32:33,946
Introducing Metal 2 或者 VR With


990
00:32:33,946 --> 00:32:35,716
Metal 2 这两场本周早些时候的


991
00:32:35,716 --> 00:32:38,186
演讲 它们非常值得


992
00:32:38,186 --> 00:32:39,896
你通过视频来再次观看


993
00:32:39,896 --> 00:32:41,606
就算你们已经去过


994
00:32:41,606 --> 00:32:42,736
也请在视频中再次看看它们


995
00:32:43,066 --> 00:32:45,246
今天下午晚些时候


996
00:32:45,246 --> 00:32:46,446
还有一场很棒的演讲


997
00:32:46,446 --> 00:32:47,706
关于使用 Metal 2 进行计算


998
00:32:47,706 --> 00:32:49,856
在 A 大厅


999
00:32:49,926 --> 00:32:50,866
4 点 10 分开始


1000
00:32:51,386 --> 00:32:52,996
就到这里


1001
00:32:52,996 --> 00:32:54,216
谢谢大家


1002
00:32:54,556 --> 00:32:56,086
祝你们接下来的


1003
00:32:56,146 --> 00:32:58,436
WWDC 17 有所收获


1004
00:32:58,436 --> 00:32:58,776
谢谢大家

