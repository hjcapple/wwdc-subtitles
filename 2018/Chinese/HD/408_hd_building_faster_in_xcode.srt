1
00:00:08,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:25,516 --> 00:00:29,596
[ 掌声 ]


3
00:00:30,096 --> 00:00:31,336
>> 大家好 


4
00:00:31,336 --> 00:00:31,906
早上好


5
00:00:31,906 --> 00:00:32,896
我很高兴


6
00:00:32,896 --> 00:00:33,536
你们今天早上能来


7
00:00:34,026 --> 00:00:35,316
我叫 David Owens


8
00:00:35,446 --> 00:00:37,346
我是 Xcode 团队的一名工程师


9
00:00:37,706 --> 00:00:39,566
今天 我将和 Swift 团队的


10
00:00:39,566 --> 00:00:41,026
工程师 我的同事 Jordan Rose


11
00:00:41,026 --> 00:00:42,556
一起和你们讲讲


12
00:00:42,556 --> 00:00:44,406
如何在 Xcode 中


13
00:00:44,406 --> 00:00:46,136
构建的更快


14
00:00:47,056 --> 00:00:48,626
现在基于你的项目


15
00:00:48,686 --> 00:00:49,826
它们的配置 


16
00:00:49,826 --> 00:00:51,516
它们的复杂性


17
00:00:51,516 --> 00:00:53,646
有很多机会可以让你对其


18
00:00:53,646 --> 00:00:55,396
进行改进


19
00:00:55,536 --> 00:00:57,496
在某些情况下


20
00:00:57,496 --> 00:00:58,936
可以显著地提高你的构建


21
00:00:58,936 --> 00:00:59,736
运行情况


22
00:01:00,996 --> 00:01:02,696
今天我们讨论的是


23
00:01:02,696 --> 00:01:04,036
在 Xcode 中构建更快


24
00:01:04,646 --> 00:01:05,856
我们会从两个不同的角度


25
00:01:05,856 --> 00:01:06,786
来考虑


26
00:01:07,356 --> 00:01:10,166
第一个就是


27
00:01:10,166 --> 00:01:12,636
提升你的整体构建效率


28
00:01:12,636 --> 00:01:15,356
第二个则是


29
00:01:15,356 --> 00:01:16,696
减少你在构建中需要


30
00:01:16,696 --> 00:01:18,306
做的工作


31
00:01:18,306 --> 00:01:19,656
尤其是你的


32
00:01:19,656 --> 00:01:20,116
增量式构建


33
00:01:21,756 --> 00:01:23,556
现在 我将为你们介绍一些


34
00:01:23,556 --> 00:01:25,326
项目级对象 


35
00:01:25,326 --> 00:01:26,626
包括如何并行你的


36
00:01:26,696 --> 00:01:27,296
构建过程


37
00:01:27,846 --> 00:01:29,146
如何宣告并配置你的


38
00:01:29,146 --> 00:01:30,506
运行的脚本阶段


39
00:01:31,256 --> 00:01:32,306
我还会给你们介绍一些


40
00:01:32,606 --> 00:01:34,596
Xcode 10 中的关于测量你的


41
00:01:34,916 --> 00:01:38,386
构建时间的新性能


42
00:01:38,566 --> 00:01:39,446
现在 Jordan 将给我们介绍


43
00:01:39,446 --> 00:01:40,556
一些我们可以


44
00:01:40,626 --> 00:01:41,716
为我们的项目带来的


45
00:01:41,716 --> 00:01:43,056
源级的提升


46
00:01:43,516 --> 00:01:44,636
包括使用 Swift 来


47
00:01:44,636 --> 00:01:45,756
理解我们的依赖性


48
00:01:46,486 --> 00:01:48,486
在 Swift 中处理复杂的表达式


49
00:01:49,436 --> 00:01:50,416
以及如何将


50
00:01:50,416 --> 00:01:52,436
Objective-C 限制到 Swift 界面


51
00:01:54,016 --> 00:01:55,126
现在让我们来讨论一下


52
00:01:55,126 --> 00:01:56,056
并行你的构建


53
00:01:56,676 --> 00:01:58,816
Xcode 通过使用目标


54
00:01:58,816 --> 00:02:00,736
来配置你的项目


55
00:02:01,606 --> 00:02:04,016
目标指定了你想要构建的


56
00:02:04,016 --> 00:02:05,566
产品或者输出


57
00:02:06,226 --> 00:02:07,916
有一些例子是 iOS App


58
00:02:08,756 --> 00:02:10,545
框架和单位测试


59
00:02:11,276 --> 00:02:12,776
还有另一个信息


60
00:02:12,776 --> 00:02:13,846
那就是


61
00:02:13,846 --> 00:02:15,696
目标之间的依赖性


62
00:02:16,226 --> 00:02:17,886
Xcode 为定义我们的依赖性


63
00:02:18,326 --> 00:02:19,526
提供了两种方法


64
00:02:19,816 --> 00:02:21,556
有一种很清楚的方法


65
00:02:21,556 --> 00:02:22,396
就是通过


66
00:02:22,396 --> 00:02:23,436
目标依赖性阶段


67
00:02:24,046 --> 00:02:25,276
还有一种隐含的方法


68
00:02:25,336 --> 00:02:26,586
就是通过函数库阶段的


69
00:02:26,586 --> 00:02:28,526
连接的二进制


70
00:02:28,926 --> 00:02:29,806
一会我们会用一点时间


71
00:02:29,806 --> 00:02:32,696
深入地了解这些


72
00:02:33,426 --> 00:02:34,546
现在 我想用


73
00:02:34,546 --> 00:02:35,956
一个样本项目来


74
00:02:35,956 --> 00:02:36,996
开始我们的讨论


75
00:02:37,686 --> 00:02:38,656
我们将看到


76
00:02:38,656 --> 00:02:40,686
这个项目的依赖性图表


77
00:02:41,706 --> 00:02:43,736
现在 一个依赖性图表


78
00:02:43,796 --> 00:02:46,006
只是一个包含所有目标的名单


79
00:02:46,146 --> 00:02:47,206
在这个例子中


80
00:02:47,206 --> 00:02:48,896
我们将要构建五个目标


81
00:02:50,226 --> 00:02:51,336
在这些目标中间


82
00:02:51,336 --> 00:02:53,466
有依赖性信息


83
00:02:54,376 --> 00:02:55,966
基于这两个信息


84
00:02:55,966 --> 00:02:58,696
Xcode 可以得到我们的


85
00:02:58,696 --> 00:02:59,226
构建次序


86
00:02:59,226 --> 00:03:01,696
现在 让我们看看


87
00:03:01,696 --> 00:03:02,966
它在时间表中是


88
00:03:02,966 --> 00:03:03,246
什么样的


89
00:03:03,306 --> 00:03:08,086
正如我们所见 


90
00:03:08,086 --> 00:03:09,486
每个目标都按顺序构建得


91
00:03:09,486 --> 00:03:10,876
很有秩序


92
00:03:11,396 --> 00:03:12,796
它们都需要等到之前的


93
00:03:12,796 --> 00:03:14,386
目标完成构建


94
00:03:14,786 --> 00:03:16,366
就其本身而言 构建


95
00:03:16,366 --> 00:03:17,946
时间线并没有什么错


96
00:03:18,356 --> 00:03:20,436
但是这代表了对潜在的


97
00:03:20,436 --> 00:03:22,026
硬件资源应用的浪费


98
00:03:22,376 --> 00:03:23,146
尤其是在你有一个


99
00:03:23,146 --> 00:03:24,326
如 iMac Pro 的


100
00:03:24,326 --> 00:03:25,846
多核或微核机器


101
00:03:26,726 --> 00:03:28,356
这对于作为开发者的你来说


102
00:03:28,356 --> 00:03:29,616
就是一种时间的浪费


103
00:03:30,346 --> 00:03:32,416
因此我们要采用


104
00:03:32,416 --> 00:03:34,466
另一种方法


105
00:03:37,476 --> 00:03:37,576
看起来大概是这样


106
00:03:37,786 --> 00:03:38,846
现在 有几件事


107
00:03:38,846 --> 00:03:39,876
或者很少的几件事


108
00:03:39,876 --> 00:03:40,456
我想要提醒大家


109
00:03:40,926 --> 00:03:42,726
首先 我们在构建项目中


110
00:03:42,726 --> 00:03:43,936
所做的工作量


111
00:03:43,936 --> 00:03:45,286
其实并没有变化


112
00:03:46,696 --> 00:03:49,456
但是用来构建的时间 的确减少了


113
00:03:50,126 --> 00:03:51,396
在这种情况下


114
00:03:51,396 --> 00:03:53,486
时间其实大幅度减少了


115
00:03:53,946 --> 00:03:56,196
我们可以通过


116
00:03:56,196 --> 00:03:59,466
更好地利用可用的硬件


117
00:03:59,466 --> 00:04:02,736
来减少构建的时间


118
00:04:02,946 --> 00:04:04,736
如果并行


119
00:04:04,736 --> 00:04:07,366
或者说并行是这么好的一件事


120
00:04:07,366 --> 00:04:09,036
为什么我们不创建一个


121
00:04:09,036 --> 00:04:10,326
和这个很像的构建图表


122
00:04:10,536 --> 00:04:11,796
我们只需要在我们的构建时间表中


123
00:04:11,796 --> 00:04:13,016
从头开始构建


124
00:04:14,156 --> 00:04:16,276
在最好的情况下


125
00:04:16,276 --> 00:04:17,516
你们将遇到确定性的


126
00:04:17,856 --> 00:04:18,875
构建错误


127
00:04:19,096 --> 00:04:20,596
这是因为依赖信息


128
00:04:20,596 --> 00:04:22,076
其实是你们


129
00:04:22,076 --> 00:04:24,136
项目配置的重要部分


130
00:04:24,796 --> 00:04:25,916
当它像这样被设置时


131
00:04:26,636 --> 00:04:28,306
你们将试着在你们构建


132
00:04:28,306 --> 00:04:29,956
依赖性之前


133
00:04:29,956 --> 00:04:31,196
去构建你们的游戏目标


134
00:04:31,456 --> 00:04:32,816
这并不是一个好的状态


135
00:04:34,176 --> 00:04:35,216
所以我们如何做到这样


136
00:04:35,876 --> 00:04:37,906
我们如何从漫长的


137
00:04:37,906 --> 00:04:39,896
系列化的构建时间线


138
00:04:39,896 --> 00:04:43,486
转换成并行的构建时间


139
00:04:44,356 --> 00:04:45,586
首先 你需要确保


140
00:04:45,586 --> 00:04:48,206
Xcode 被设置并配置成


141
00:04:48,206 --> 00:04:49,446
允许我们的目标


142
00:04:49,446 --> 00:04:51,076
被平行构建


143
00:04:51,126 --> 00:04:52,516
我们通过 Scheme Editor (方案编辑器）


144
00:04:52,516 --> 00:04:53,056
完成这个指令


145
00:04:53,796 --> 00:04:54,876
你可以打开 Scheme Chooser（方案选择器）


146
00:04:54,876 --> 00:04:56,226
选择 Edit Scheme (编辑方案）


147
00:04:57,176 --> 00:04:58,366
然后来到 Scheme Editor


148
00:04:58,836 --> 00:05:00,696
明确来说 你需要


149
00:05:00,696 --> 00:05:01,826
看一下 Build Action (构建行为）


150
00:05:02,936 --> 00:05:05,046
在这里是 Build Options (构建选项）


151
00:05:05,366 --> 00:05:06,866
这里有两个已经列出来的


152
00:05:07,196 --> 00:05:08,866
第一个是 Parallelize Build (并行构建选项）


153
00:05:08,986 --> 00:05:10,916
第二个是 Find Implicit Dependencies


154
00:05:10,916 --> 00:05:11,656
（寻找隐含依赖性）


155
00:05:12,426 --> 00:05:14,146
你可能想检查 Parallelize Build


156
00:05:14,706 --> 00:05:16,176
这会允许 Xcode 通过


157
00:05:16,176 --> 00:05:17,656
你的目标来使用


158
00:05:17,656 --> 00:05:19,296
依赖性信息


159
00:05:19,296 --> 00:05:20,846
这样就可以让其尝试着并行


160
00:05:20,846 --> 00:05:21,376
构建你的目标


161
00:05:21,956 --> 00:05:24,646
让我们来看看


162
00:05:24,936 --> 00:05:25,996
如何在 Xcode 内


163
00:05:25,996 --> 00:05:27,116
配置你的依赖性


164
00:05:28,286 --> 00:05:29,406
这是通过 Build Phase Editor (构建阶段


165
00:05:29,406 --> 00:05:30,036
编辑器）实现的


166
00:05:30,586 --> 00:05:31,496
你可以通过你的 Project Navigator


167
00:05:31,496 --> 00:05:33,616
(项目导航器） 选择你的项目


168
00:05:33,616 --> 00:05:35,566
然后来到 Build 


169
00:05:35,566 --> 00:05:36,116
Phase Editor


170
00:05:36,636 --> 00:05:37,806
在这个例子中我们


171
00:05:37,806 --> 00:05:39,556
来看下 Game Target (游戏目标）或者 Game


172
00:05:39,556 --> 00:05:39,916
Project (游戏项目）


173
00:05:40,326 --> 00:05:43,816
接下来点击 Build Phases (构建阶段）


174
00:05:44,916 --> 00:05:46,036
我们来看一下


175
00:05:46,036 --> 00:05:46,626
Game Target


176
00:05:46,866 --> 00:05:47,946
这是针对我们的 Game Target 的


177
00:05:47,946 --> 00:05:48,806
Build Phase Editor 


178
00:05:48,886 --> 00:05:50,156
我们将看看它的依赖性


179
00:05:50,156 --> 00:05:51,536
是如何配置的


180
00:05:52,056 --> 00:05:52,826
首先我希望 你们能注意一下 


181
00:05:52,826 --> 00:05:54,916
Link Binary with Libraries phase


182
00:05:55,186 --> 00:05:57,166
（带函数库阶段的连接二进制）


183
00:05:57,836 --> 00:05:59,446
现在是你定义


184
00:05:59,446 --> 00:06:00,746
所有你想要连接到你目标的


185
00:06:00,746 --> 00:06:03,566
项目的构建过程阶段


186
00:06:04,676 --> 00:06:06,046
这种情况下我有两个项目


187
00:06:06,046 --> 00:06:08,346
分别是物理和实用性


188
00:06:08,716 --> 00:06:11,526
现在这些是在我们的项目中


189
00:06:11,526 --> 00:06:12,856
和我们的工作环境中的目标


190
00:06:13,086 --> 00:06:14,696
Xcode 可以在这些目标中


191
00:06:14,696 --> 00:06:16,716
创建一个隐含的依赖性


192
00:06:17,766 --> 00:06:19,356
如果你在使用如


193
00:06:19,356 --> 00:06:22,156
自动连接或


194
00:06:22,216 --> 00:06:23,756
其他的 LD 构建标志构建设置


195
00:06:23,786 --> 00:06:25,416
这些都不会


196
00:06:25,416 --> 00:06:27,846
暗中地在你这里生效


197
00:06:28,166 --> 00:06:29,236
你要么在这个构建中


198
00:06:29,236 --> 00:06:30,636
或者在目标依赖性构建过程中


199
00:06:30,686 --> 00:06:34,996
生成一个明确的依赖性


200
00:06:35,396 --> 00:06:37,806
我们可以看到在这里


201
00:06:37,806 --> 00:06:38,686
还有一个名为 Shaders (渲染）的


202
00:06:38,686 --> 00:06:39,206
另一个项目


203
00:06:39,616 --> 00:06:42,106
Shaders 并不在连接时候


204
00:06:42,106 --> 00:06:43,926
使用 而是在


205
00:06:43,926 --> 00:06:45,776
我们现有的目标中


206
00:06:45,776 --> 00:06:47,456
被另一个构建过程使用


207
00:06:48,096 --> 00:06:49,316
很重要的一件事就是


208
00:06:49,316 --> 00:06:50,926
我们让 Xcode 知道


209
00:06:50,926 --> 00:06:52,256
这是一个依赖性而且我们需要


210
00:06:52,256 --> 00:06:54,506
等 Shaders 完成编辑


211
00:06:54,566 --> 00:06:57,886
同时 在我们构建现有的目标前


212
00:06:57,886 --> 00:06:58,876
就进行构建


213
00:06:59,406 --> 00:07:02,336
现在 这个目标实际上


214
00:07:02,336 --> 00:07:03,256
存在于不同的项目


215
00:07:03,846 --> 00:07:05,626
如果你想要


216
00:07:05,626 --> 00:07:06,826
对该项目做个参考


217
00:07:06,826 --> 00:07:08,376
你可以拖拽如


218
00:07:08,376 --> 00:07:10,266
你目前正在处理的项目的孩子一样


219
00:07:10,266 --> 00:07:11,526
拖拽该项目


220
00:07:11,526 --> 00:07:13,776
我想再介绍一下


221
00:07:13,776 --> 00:07:15,276
我们项目其余的依赖性


222
00:07:16,576 --> 00:07:17,916
我们的 Shaders 目标


223
00:07:17,916 --> 00:07:19,196
对于我们的实用性目标


224
00:07:19,196 --> 00:07:19,506
有一个依赖性


225
00:07:20,886 --> 00:07:22,196
我们的实用性 目标


226
00:07:22,196 --> 00:07:23,806
在我们的物理目标上


227
00:07:23,806 --> 00:07:24,106
有一个依赖性


228
00:07:25,146 --> 00:07:27,206
最后 我们的测试（Tests)


229
00:07:27,206 --> 00:07:30,516
对我们的 Shaders 和实用性目标


230
00:07:30,516 --> 00:07:31,676
有一个依赖性


231
00:07:32,616 --> 00:07:33,206
现在我们对我们项目的


232
00:07:33,206 --> 00:07:34,296
配置有了


233
00:07:34,296 --> 00:07:35,806
一定的了解


234
00:07:35,806 --> 00:07:37,266
我们来看看


235
00:07:37,266 --> 00:07:38,996
将这个序列化的构建过程


236
00:07:38,996 --> 00:07:41,106
变成并行的


237
00:07:41,446 --> 00:07:43,556
必要步骤


238
00:07:44,136 --> 00:07:45,286
首先我们要看一看


239
00:07:45,286 --> 00:07:46,746
我们的测试依赖性


240
00:07:48,876 --> 00:07:50,566
现在 我将依赖性


241
00:07:50,566 --> 00:07:51,556
分成了三种


242
00:07:51,556 --> 00:07:52,366
不同类型


243
00:07:52,366 --> 00:07:53,896
我想要谈论的依赖性


244
00:07:54,466 --> 00:07:55,866
第一个依赖性


245
00:07:55,866 --> 00:07:57,366
我称之为 “什么都做的”


246
00:07:57,366 --> 00:07:58,646
依赖性


247
00:07:59,316 --> 00:08:00,566
有一点很清楚的就是


248
00:08:00,566 --> 00:08:01,946
这个测试


249
00:08:02,036 --> 00:08:03,686
测试了很多成分


250
00:08:04,056 --> 00:08:05,096
它测试了 Game


251
00:08:05,516 --> 00:08:06,596
还测试了 Shaders


252
00:08:07,236 --> 00:08:08,606
同时还测试了 Utilities


253
00:08:10,056 --> 00:08:11,866
在这个例子中


254
00:08:11,866 --> 00:08:13,426
最好将我们的测试分解


255
00:08:13,426 --> 00:08:14,366
这样它就能测试


256
00:08:14,366 --> 00:08:15,356
每个单独的成分


257
00:08:15,356 --> 00:08:17,586
我们来试试这样操作会怎样


258
00:08:17,586 --> 00:08:18,686
我们将介绍


259
00:08:18,686 --> 00:08:21,766
构建过程中的并行性


260
00:08:23,306 --> 00:08:25,246
我们在三个依赖性中都被构建了的


261
00:08:25,246 --> 00:08:26,676
测试目标


262
00:08:26,736 --> 00:08:27,926
现在可以只构建


263
00:08:27,926 --> 00:08:29,466
在 Game 测试中寻找的部分


264
00:08:30,436 --> 00:08:31,896
我们的 Shaders 测试和


265
00:08:31,896 --> 00:08:33,816
Utilities 测试可以被移去


266
00:08:33,816 --> 00:08:34,996
与我们其他的目标


267
00:08:34,996 --> 00:08:35,775
并行构建


268
00:08:36,066 --> 00:08:37,236
当它们各自的成分 


269
00:08:37,236 --> 00:08:38,395
Shaders 和 Utilities


270
00:08:38,395 --> 00:08:40,456
完成时即可进行构建


271
00:08:42,285 --> 00:08:44,626
下一个我想要看的


272
00:08:44,626 --> 00:08:46,696
依赖性类型就是


273
00:08:46,696 --> 00:08:48,526
我称之为“爱管闲事的邻居”的


274
00:08:48,526 --> 00:08:49,126
依赖性


275
00:08:49,706 --> 00:08:51,596
这是需要存在的一种


276
00:08:51,596 --> 00:08:53,426
依赖性


277
00:08:53,586 --> 00:08:54,806
这个要考虑另一个目标


278
00:08:55,136 --> 00:08:57,226
但是它只需要那个目标的一点


279
00:08:57,946 --> 00:08:59,276
不过它将获得


280
00:08:59,276 --> 00:09:00,426
在那个目标中的一切


281
00:09:01,226 --> 00:09:02,386
如果我们看一下我们的游戏


282
00:09:02,806 --> 00:09:04,506
它对 Physics Shaders 和 Utilities


283
00:09:04,676 --> 00:09:05,696
有一个依赖性


284
00:09:06,046 --> 00:09:06,906
这其实没问题


285
00:09:08,196 --> 00:09:09,936
值得怀疑的是


286
00:09:09,936 --> 00:09:11,306
在 Shaders 目标和 Utilities 目标


287
00:09:11,306 --> 00:09:13,026
之间的依赖性


288
00:09:13,786 --> 00:09:15,436
现在 我们的 Shaders目标


289
00:09:15,436 --> 00:09:16,936
产生了一个元函数库


290
00:09:16,936 --> 00:09:18,556
它本质上来说是一群


291
00:09:18,556 --> 00:09:19,596
将在我们的显示卡上 


292
00:09:19,596 --> 00:09:20,256
运行的 GPU 代码 


293
00:09:21,376 --> 00:09:23,286
我们的 Utilities 目标


294
00:09:23,286 --> 00:09:24,696
生成的则是一个正常的框架


295
00:09:24,696 --> 00:09:25,666
也就是 CPU 代码


296
00:09:25,936 --> 00:09:26,906
所以已经有一些
 
00:09:26,906 --> 00:09:28,946
疑似依赖性了


297
00:09:29,506 --> 00:09:30,926
当我们深入挖掘时


298
00:09:30,926 --> 00:09:32,796
我们会发现 Utilities 目标


299
00:09:32,796 --> 00:09:34,466
实际上有一个会生成


300
00:09:34,466 --> 00:09:36,316
被两个目标使用的信息


301
00:09:36,316 --> 00:09:37,566
的构建过程


302
00:09:37,826 --> 00:09:38,726
这样很好


303
00:09:39,276 --> 00:09:40,466
只不过 Shaders


304
00:09:40,466 --> 00:09:42,016
不再需要从 Utilities 目标中


305
00:09:42,016 --> 00:09:42,796
获得任何其他事物


306
00:09:43,306 --> 00:09:47,356
所以最好将其转入其目标


307
00:09:48,226 --> 00:09:49,666
我们会看到


308
00:09:49,666 --> 00:09:50,866
这个小小的增量改变


309
00:09:50,866 --> 00:09:52,196
其实对我们整个的


310
00:09:52,196 --> 00:09:53,666
构建时间线有着


311
00:09:53,666 --> 00:09:54,746
巨大的影响


312
00:09:56,826 --> 00:09:58,446
所以刚刚移入的


313
00:09:58,446 --> 00:09:59,896
新的绿色框是我们新的代码目标


314
00:10:00,186 --> 00:10:01,476
现在我们可以缩小我们的实用性目标


315
00:10:01,476 --> 00:10:03,426
因为我们将其


316
00:10:03,426 --> 00:10:05,346
移入到 Code Gen (自动生产安全程式码)


317
00:10:06,076 --> 00:10:07,426
因为 Code Gen 没有其他


318
00:10:07,426 --> 00:10:09,336
依赖性 它可以移动到


319
00:10:09,336 --> 00:10:11,176
我们构建过程的前端


320
00:10:11,506 --> 00:10:13,056
它还可以与我们的 Physics 目标


321
00:10:13,346 --> 00:10:14,516
也就是底端的红框


322
00:10:14,516 --> 00:10:15,686
一起并行构建


323
00:10:17,146 --> 00:10:18,756
最后 因为 Shaders 不再


324
00:10:18,756 --> 00:10:20,436
依赖于 Utilities


325
00:10:20,436 --> 00:10:21,616
它不需要等待


326
00:10:21,616 --> 00:10:25,396
Utilities 和 Physics 目标的构建


327
00:10:25,686 --> 00:10:26,896
与此相反 一旦 Code Gen 目标


328
00:10:26,896 --> 00:10:30,566
完成后它就能被构建


329
00:10:30,766 --> 00:10:31,986
最后我想要和大家介绍的


330
00:10:31,986 --> 00:10:33,476
依赖性我称之为


331
00:10:33,476 --> 00:10:35,336
“被遗忘的”


332
00:10:35,826 --> 00:10:37,906
在我们产品或


333
00:10:37,906 --> 00:10:40,376
代码的进化或生命周期中


334
00:10:40,376 --> 00:10:42,956
我们需要移动代码


335
00:10:42,956 --> 00:10:44,106
并删除事情


336
00:10:44,106 --> 00:10:45,356
我们得到的 仿佛是无作用程序代码


337
00:10:45,766 --> 00:10:47,056
我们的依赖性


338
00:10:47,056 --> 00:10:48,326
也会发生这样的事情


339
00:10:48,706 --> 00:10:49,816
有时候我们只是忘记


340
00:10:49,816 --> 00:10:50,376
清理它们


341
00:10:51,386 --> 00:10:52,506
在这些情况中


342
00:10:52,926 --> 00:10:54,306
移除依赖性


343
00:10:54,306 --> 00:10:54,976
是比较安全的


344
00:10:56,456 --> 00:10:58,276
最后一个变化将通过


345
00:10:58,276 --> 00:11:00,396
允许 Utilities 目标


346
00:11:00,396 --> 00:11:03,156
在 Code Gen 目标之后立马搭建


347
00:11:03,156 --> 00:11:04,716
而不需要等待


348
00:11:04,716 --> 00:11:06,146
Physics 目标完成


349
00:11:06,146 --> 00:11:11,156
来加强或构建图


350
00:11:11,346 --> 00:11:13,746
早前在 Xcode 中


351
00:11:13,746 --> 00:11:15,046
当你构建对其他目标


352
00:11:15,046 --> 00:11:16,396
有依赖性的目标时


353
00:11:16,396 --> 00:11:18,326
你必须要等待依赖的目标


354
00:11:18,326 --> 00:11:19,646
完成它的整体


355
00:11:19,646 --> 00:11:21,236
构建过程


356
00:11:21,756 --> 00:11:23,096
在 Xcode 10 中我们有


357
00:11:23,096 --> 00:11:24,916
一个新性能 


358
00:11:24,916 --> 00:11:27,046
可以让我们为你的构建


359
00:11:27,046 --> 00:11:28,086
引入一些并行


360
00:11:28,596 --> 00:11:32,226
一旦构建过程


361
00:11:32,226 --> 00:11:34,626
与适合我们编辑的依赖性


362
00:11:34,626 --> 00:11:36,596
完成了 我们就


363
00:11:36,596 --> 00:11:38,666
可以开始


364
00:11:38,706 --> 00:11:40,636
编辑你的目标了


365
00:11:41,696 --> 00:11:42,926
像连接之类的事情


366
00:11:42,926 --> 00:11:43,746
可以并行完成


367
00:11:45,936 --> 00:11:47,486
现在如果你运行了脚本阶段


368
00:11:47,486 --> 00:11:49,266
这就是你的目标


369
00:11:49,316 --> 00:11:50,896
在可以利用这些


370
00:11:50,996 --> 00:11:53,216
新的并行性之前


371
00:11:53,216 --> 00:11:54,796
为了有秩序的


372
00:11:54,796 --> 00:11:56,436
完成而需要


373
00:11:56,806 --> 00:11:58,886
等待的众多构建过程之一


374
00:11:58,956 --> 00:12:01,976
让我们来讨论一下 运行脚本过程


375
00:12:02,776 --> 00:12:04,116
运行脚本过程允许你


376
00:12:04,116 --> 00:12:05,636
根据你的需求来


377
00:12:05,636 --> 00:12:06,496
自定义你的构建过程


378
00:12:07,066 --> 00:12:08,436
这个弹性也给


379
00:12:08,826 --> 00:12:10,436
作为开发者的你


380
00:12:10,436 --> 00:12:11,906
带来了一些责任


381
00:12:12,316 --> 00:12:13,206
所以我们想要带大家


382
00:12:13,206 --> 00:12:14,266
看一下配置过程


383
00:12:14,266 --> 00:12:15,856
同时确保你已经


384
00:12:15,856 --> 00:12:17,196
设定好了你的脚本过程


385
00:12:17,196 --> 00:12:18,866
同时已经配置好


386
00:12:18,866 --> 00:12:19,856
这样你的构建才能运行


387
00:12:22,116 --> 00:12:24,786
这个是你的脚本过程编辑器


388
00:12:25,226 --> 00:12:26,566
它也可以在你的构建过程


389
00:12:26,566 --> 00:12:27,356
编辑器中被发现


390
00:12:27,356 --> 00:12:28,766
现在我想要


391
00:12:28,766 --> 00:12:31,406
让你们注意一下第一个


392
00:12:31,696 --> 00:12:32,176
脚本主体


393
00:12:32,786 --> 00:12:33,916
你可以把你整体的


394
00:12:33,916 --> 00:12:34,916
脚本内容放在这里


395
00:12:34,916 --> 00:12:36,176
或者你可以像我刚刚那样做


396
00:12:36,176 --> 00:12:37,456
并参考在你项目中的


397
00:12:37,456 --> 00:12:38,286
另一个脚本


398
00:12:39,666 --> 00:12:40,876
现在 在你运行的脚本过程的


399
00:12:40,876 --> 00:12:42,806
整体中 有一整套


400
00:12:42,806 --> 00:12:43,996
对你有效的


401
00:12:43,996 --> 00:12:44,746
构建设置


402
00:12:44,906 --> 00:12:45,926
我现在在利用这些中的


403
00:12:45,926 --> 00:12:47,746
一个 即源组


404
00:12:48,956 --> 00:12:50,506
在这种情况下你的


405
00:12:50,506 --> 00:12:52,646
产品工作时就不需要


406
00:12:52,646 --> 00:12:54,336
提供绝对路径


407
00:12:54,336 --> 00:12:55,956
或尝试做一些相关的


408
00:12:55,956 --> 00:12:56,116
路径侵入


409
00:12:57,436 --> 00:13:00,136
第二个部分是你输入文件


410
00:13:00,836 --> 00:13:02,286
这对于你的


411
00:13:02,286 --> 00:13:03,536
运行脚本过程非常重要


412
00:13:03,896 --> 00:13:05,356
这也是 Xcode 构建系统


413
00:13:05,356 --> 00:13:07,126
用来决定


414
00:13:07,126 --> 00:13:08,386
你的运行脚本是否能


415
00:13:08,386 --> 00:13:09,606
成功运行的


416
00:13:09,606 --> 00:13:12,146
关键信息


417
00:13:12,146 --> 00:13:13,946
这应该包含你运行脚本过程的


418
00:13:13,946 --> 00:13:15,986
所有文件 


419
00:13:16,026 --> 00:13:17,426
脚本内容其实应该在这个过程中


420
00:13:17,426 --> 00:13:19,646
被阅读或者被观看


421
00:13:21,096 --> 00:13:23,306
现在 你们中的一些人可能


422
00:13:23,876 --> 00:13:25,676
在你们的运行脚本过程中 有很多输入


423
00:13:25,816 --> 00:13:27,906
这个任务可能会有些令人气馁


424
00:13:28,506 --> 00:13:31,046
在 Xcode 10 中我们有能力为你


425
00:13:31,046 --> 00:13:32,666
或者说我们为你提供了


426
00:13:32,666 --> 00:13:33,776
能在一个外部文件中


427
00:13:33,776 --> 00:13:34,966
保留这个名单的能力


428
00:13:34,966 --> 00:13:37,426
我们称之为


429
00:13:37,426 --> 00:13:38,236
文件名单


430
00:13:39,626 --> 00:13:41,056
现在 一个文件名单是一个


431
00:13:41,256 --> 00:13:42,996
把所有输入都列在其中的


432
00:13:42,996 --> 00:13:44,826
简单的文本文件


433
00:13:46,226 --> 00:13:47,246
在你的运行脚本过程中


434
00:13:47,246 --> 00:13:48,866
你可以使用


435
00:13:48,866 --> 00:13:49,946
所有有效的


436
00:13:49,946 --> 00:13:51,456
相同的构建设置


437
00:13:52,656 --> 00:13:53,806
有一件重要的事需要注意


438
00:13:53,806 --> 00:13:54,796
这些文件不能


439
00:13:54,796 --> 00:13:56,376
在你的构建过程中


440
00:13:56,376 --> 00:13:58,306
被修改或生成


441
00:13:58,766 --> 00:14:00,796
当你的构建过程开始时


442
00:14:00,796 --> 00:14:01,666
它们就可以读取了


443
00:14:02,086 --> 00:14:03,576
所有的信息都被使用了


444
00:14:03,576 --> 00:14:07,216
接下来我要向你介绍一下


445
00:14:07,216 --> 00:14:08,266
你的输出文件


446
00:14:08,516 --> 00:14:09,596
你的输出文件是


447
00:14:09,596 --> 00:14:10,886
你的构建过程中使用的


448
00:14:10,886 --> 00:14:12,396
另一个关键信息


449
00:14:13,016 --> 00:14:14,086
Xcode 会使用


450
00:14:14,086 --> 00:14:15,926
这个信息来决定


451
00:14:15,926 --> 00:14:17,786
你的运行脚本过程 是否需要运行


452
00:14:17,886 --> 00:14:20,616
当然了 我们对输出文件


453
00:14:20,616 --> 00:14:23,026
有支撑 还有对你的输出


454
00:14:23,026 --> 00:14:24,376
文件的名单


455
00:14:25,336 --> 00:14:27,066
所以当你的


456
00:14:27,066 --> 00:14:28,726
运行脚本过程运行时 我想要为你概括


457
00:14:29,856 --> 00:14:31,186
如果你没有宣告任何


458
00:14:31,186 --> 00:14:33,896
输入文件 那 Xcode 构建系统


459
00:14:34,076 --> 00:14:35,186
会需要在每个单一的


460
00:14:35,186 --> 00:14:36,896
构建中都进入到你的运行脚本过程


461
00:14:37,556 --> 00:14:38,936
这就是为什么


462
00:14:38,936 --> 00:14:40,106
宣告你的输入是很重要的一个


463
00:14:40,106 --> 00:14:40,626
关键原因


464
00:14:42,006 --> 00:14:43,476
如果你的输入文件变化了


465
00:14:43,476 --> 00:14:45,396
包括你文件名单的内容


466
00:14:45,396 --> 00:14:47,996
或者其他文件名单指向的


467
00:14:47,996 --> 00:14:49,506
任何输入


468
00:14:49,506 --> 00:14:51,376
Xcode 都会知道它将


469
00:14:51,376 --> 00:14:52,596
为你返回你的


470
00:14:52,596 --> 00:14:53,196
脚本过程


471
00:14:53,696 --> 00:14:56,216
最后 如果你的任何输出


472
00:14:56,216 --> 00:14:58,426
文件丢失了


473
00:14:58,426 --> 00:14:59,876
Xcode 构建系统会运行


474
00:14:59,876 --> 00:15:01,116
你的运行脚本过程


475
00:15:01,116 --> 00:15:03,126
来为你提供


476
00:15:03,366 --> 00:15:04,606
生成丢失的输出文件的机会


477
00:15:05,836 --> 00:15:08,446
Xcode 10 还有一个新性能


478
00:15:08,446 --> 00:15:10,466
就是我们为运行脚本过程


479
00:15:10,466 --> 00:15:11,396
提供了文档


480
00:15:12,516 --> 00:15:16,916
[ 掌声 ]


481
00:15:17,416 --> 00:15:18,746
这包含了更多


482
00:15:18,746 --> 00:15:19,966
我刚刚解释过的细节


483
00:15:19,966 --> 00:15:20,726
也告诉了你


484
00:15:20,726 --> 00:15:21,886
那些对你有效的


485
00:15:21,886 --> 00:15:22,956
新增的构建设置


486
00:15:23,256 --> 00:15:24,546
包括你如何在


487
00:15:24,736 --> 00:15:26,906
你的脚本内容中 使用这些文件名单


488
00:15:28,216 --> 00:15:29,636
当你设定你的运行脚本过程


489
00:15:29,636 --> 00:15:30,896
并宣告所有这些


490
00:15:30,896 --> 00:15:32,166
新的依赖性


491
00:15:32,166 --> 00:15:34,046
包括你在目标中


492
00:15:34,046 --> 00:15:35,316
修改依赖性时


493
00:15:35,866 --> 00:15:37,986
你都可能遇到依赖性周期


494
00:15:38,636 --> 00:15:40,386
依赖性周期是一个


495
00:15:40,516 --> 00:15:42,036
有着回路的


496
00:15:42,036 --> 00:15:43,706
相互依赖的图表


497
00:15:44,836 --> 00:15:46,346
在 Xcode 10 中


498
00:15:46,346 --> 00:15:48,586
我们有检测这些周期的更好诊断


499
00:15:48,586 --> 00:15:49,836
同时会告诉你错误


500
00:15:49,836 --> 00:15:51,546
包括扩大


501
00:15:51,546 --> 00:15:53,046
获得所有输入的框的能力


502
00:15:53,046 --> 00:15:54,406
这些输入


503
00:15:54,406 --> 00:15:56,076
都是 Xcode 构建系统了解的参与了周期


504
00:15:56,076 --> 00:15:57,516
创建的


505
00:15:58,916 --> 00:16:01,016
其实 周期因为一些原因


506
00:16:01,746 --> 00:16:02,636
并不是很好


507
00:16:02,716 --> 00:16:04,516
首先 它们代表了在你项目中的


508
00:16:04,516 --> 00:16:06,386
一个配置问题


509
00:16:07,306 --> 00:16:08,846
其次 他们可能是


510
00:16:08,846 --> 00:16:10,676
你项目中虚假重建的来源


511
00:16:11,126 --> 00:16:12,346
或者在你的构建过程中


512
00:16:12,346 --> 00:16:13,956
获得过时的信息


513
00:16:15,176 --> 00:16:17,236
我们还在依赖性周期中


514
00:16:17,286 --> 00:16:19,156
更新了一些话题


515
00:16:20,026 --> 00:16:22,356
包括一些我们找到的


516
00:16:22,356 --> 00:16:26,086
你最常遇到的依赖性


517
00:16:26,086 --> 00:16:28,236
周期以及


518
00:16:28,236 --> 00:16:29,626
你修复它们的


519
00:16:29,626 --> 00:16:30,276
方法


520
00:16:30,796 --> 00:16:34,636
我今天要和你说的


521
00:16:34,636 --> 00:16:35,966
最后一件事


522
00:16:35,966 --> 00:16:37,256
就是测量你的构建时间


523
00:16:37,516 --> 00:16:39,406
在 Xcode 10 中


524
00:16:39,406 --> 00:16:40,976
我们针对此有两个新功能


525
00:16:42,436 --> 00:16:45,026
第一个就是我们介绍的


526
00:16:45,126 --> 00:16:47,016
内嵌的任务时间


527
00:16:47,016 --> 00:16:48,226
它可以告诉你


528
00:16:48,226 --> 00:16:49,586
每个任务运行的时间


529
00:16:49,586 --> 00:16:52,796
现在 我想要指出一些


530
00:16:52,796 --> 00:16:54,156
关于你的构建日志中的东西


531
00:16:54,586 --> 00:16:56,236
在顶端有一个过滤栏


532
00:16:57,166 --> 00:16:58,956
准确来说 是 All (所有）


533
00:16:58,956 --> 00:17:00,866
Recent (最近的）过滤器


534
00:17:02,236 --> 00:17:03,306
当你选择 ”All" 时


535
00:17:03,306 --> 00:17:04,626
它将会展示


536
00:17:04,626 --> 00:17:05,866
所有帮助你


537
00:17:05,866 --> 00:17:07,586
最终产品整体输出的


538
00:17:07,586 --> 00:17:08,506
任务


539
00:17:09,396 --> 00:17:10,435
这些往往是


540
00:17:10,435 --> 00:17:11,116
你不想看的


541
00:17:11,546 --> 00:17:12,455
你想要看的


542
00:17:12,455 --> 00:17:13,616
尤其是当你在


543
00:17:13,616 --> 00:17:15,486
增量构建中


544
00:17:15,486 --> 00:17:17,586
试图诊断的是 Recent 标签


545
00:17:18,506 --> 00:17:20,646
这将会向你展示


546
00:17:20,646 --> 00:17:22,096
所有在之前的构建运行中的


547
00:17:22,266 --> 00:17:23,886
构建路径


548
00:17:26,536 --> 00:17:29,056
Xcode 10 里另一个


549
00:17:29,056 --> 00:17:31,236
新特征是一个计时总结


550
00:17:31,526 --> 00:17:32,616
你可以通过打开


551
00:17:32,616 --> 00:17:34,326
Product (产品） 菜单


552
00:17:34,326 --> 00:17:36,066
选择 Perform with Action（与动作运行）


553
00:17:36,066 --> 00:17:38,196
再选择 Build with Timing Summary（采用


554
00:17:38,196 --> 00:17:38,576
计时总结构建）


555
00:17:39,796 --> 00:17:40,736
在你这样操作后 


556
00:17:40,736 --> 00:17:42,046
你会在构建日志最后


557
00:17:42,046 --> 00:17:43,046
得到一个新的日志部分


558
00:17:43,116 --> 00:17:47,606
如果我们集中关注它的话


559
00:17:47,606 --> 00:17:48,346
你会看到它给你


560
00:17:48,346 --> 00:17:50,026
一个你最后构建的操作内


561
00:17:50,026 --> 00:17:53,116
所有任务的时间总和


562
00:17:53,916 --> 00:17:54,786
这也是查看


563
00:17:54,786 --> 00:17:56,586
Recent 过滤器的


564
00:17:56,736 --> 00:17:57,376
另一个重要原因


565
00:17:57,856 --> 00:18:00,196
有一点我需要


566
00:18:00,196 --> 00:18:01,936
特别指出的是


567
00:18:01,936 --> 00:18:03,086
Phase Script Execution（过程脚本执行）


568
00:18:03,836 --> 00:18:05,196
你可以看到在我们刚刚操作的


569
00:18:05,196 --> 00:18:06,966
最后一个构建中


570
00:18:06,966 --> 00:18:07,886
我们有一个 shell 脚本


571
00:18:07,886 --> 00:18:08,816
这只是众多脚本中的一个


572
00:18:08,816 --> 00:18:09,676
它指明一个任务


573
00:18:10,276 --> 00:18:11,726
花费 5 秒钟


574
00:18:12,496 --> 00:18:14,266
如果你在你的


575
00:18:14,266 --> 00:18:15,476
每一个增量构建中


576
00:18:15,476 --> 00:18:17,126
都看到了它们


577
00:18:17,126 --> 00:18:18,506
这是在你的运行脚本过程中


578
00:18:18,506 --> 00:18:20,556
错误配置的指示


579
00:18:20,996 --> 00:18:21,836
可能有一些事情是


580
00:18:21,836 --> 00:18:23,726
你为了减少整体构建时间


581
00:18:23,726 --> 00:18:24,986
而想要说明的


582
00:18:28,456 --> 00:18:29,906
通过从命令行输入 Show Build Timing 


583
00:18:30,256 --> 00:18:34,796
Summary（展示构建计时总结）标识 你也可以获取


584
00:18:35,096 --> 00:18:37,456
构建计时总结


585
00:18:39,566 --> 00:18:40,976
下面我想要让 


586
00:18:40,976 --> 00:18:42,186
上台来给大家


587
00:18:42,186 --> 00:18:42,926
讲一下大家自己的项目也可以


588
00:18:42,926 --> 00:18:45,186
做的资源层面的提升


589
00:18:46,516 --> 00:18:51,966
[ 掌声 ]


590
00:18:52,466 --> 00:18:53,176
>> 谢谢 David


591
00:18:53,996 --> 00:18:54,456
好的


592
00:18:54,456 --> 00:18:56,066
只要一个小小的改变


593
00:18:56,066 --> 00:18:57,936
你们会有


594
00:18:57,936 --> 00:18:59,906
提升你们 Xcode 项目的


595
00:18:59,906 --> 00:19:00,886
多种方法


596
00:19:01,266 --> 00:19:02,116
在我们来到


597
00:19:02,116 --> 00:19:03,346
资源级和文件级


598
00:19:03,346 --> 00:19:05,256
主题时 我想要再说一个


599
00:19:05,256 --> 00:19:07,016
Xcode 10 中的新性能


600
00:19:07,016 --> 00:19:10,656
这是一个


601
00:19:10,656 --> 00:19:11,626
你们当中有些人


602
00:19:11,626 --> 00:19:13,096
在你们的项目有很多 Swift 文件时


603
00:19:13,346 --> 00:19:14,666
为了让它们构建得更快而采用的


604
00:19:14,666 --> 00:19:15,976
临时解决方法


605
00:19:17,696 --> 00:19:18,936
你们已经听说了


606
00:19:19,636 --> 00:19:21,026
这是用在调配置


607
00:19:21,026 --> 00:19:23,166
中的 Whole Module（整体模块）设置


608
00:19:23,966 --> 00:19:25,266
在之前版本的 Xcode 中


609
00:19:25,266 --> 00:19:27,236
对于一些项目来说


610
00:19:27,236 --> 00:19:28,446
开启整体模块编辑模式


611
00:19:28,446 --> 00:19:30,646
即便是调试构建


612
00:19:30,706 --> 00:19:32,496
也会比在默认增量模式


613
00:19:32,496 --> 00:19:36,336
中的构建速度更快


614
00:19:37,326 --> 00:19:39,186
这确实提升了构建速度


615
00:19:39,246 --> 00:19:40,846
因为它可以分享


616
00:19:40,846 --> 00:19:42,656
Swift 的编译器


617
00:19:42,656 --> 00:19:44,546
可以用增量模式不可行的方法


618
00:19:44,916 --> 00:19:46,846
在文件中分享工作


619
00:19:47,386 --> 00:19:48,576
但这也意味着


620
00:19:48,576 --> 00:19:49,806
你每次都要放弃


621
00:19:49,806 --> 00:19:51,286
你的增量构建


622
00:19:51,286 --> 00:19:52,826
并重建整个目标 Swift 


623
00:19:52,826 --> 00:19:54,446
文件的价值


624
00:19:55,346 --> 00:19:57,266
所以在 Xcode 10 中


625
00:19:57,266 --> 00:19:58,926
我们提升了增量构建


626
00:19:58,926 --> 00:20:00,546
让它们也能拥有那些通过文件


627
00:20:00,546 --> 00:20:01,416
分享的工作


628
00:20:01,416 --> 00:20:02,986
所以你应该不再需要


629
00:20:02,986 --> 00:20:04,646
使用整体模块模式


630
00:20:04,646 --> 00:20:06,660
来获得良好的构建时间


631
00:20:08,516 --> 00:20:11,376
[ 掌声 ]


632
00:20:11,876 --> 00:20:13,066
如果你在项目中完成了这个


633
00:20:13,066 --> 00:20:14,846
那你应该回到你的


634
00:20:14,846 --> 00:20:15,966
构建设定编辑器


635
00:20:16,176 --> 00:20:17,246
在编辑模式构架设置中


636
00:20:17,246 --> 00:20:18,426
选择编译配置


637
00:20:18,426 --> 00:20:21,466
然后点击删除


638
00:20:22,186 --> 00:20:23,606
这将回到 Xcode 的


639
00:20:23,606 --> 00:20:24,926
增量构建的


640
00:20:24,926 --> 00:20:25,716
默认设置


641
00:20:25,846 --> 00:20:27,916
关于这个我不会再多说


642
00:20:27,916 --> 00:20:29,826
因为你们已经了解了 这方面的知识


643
00:20:30,096 --> 00:20:31,066
我们在周二时在


644
00:20:31,066 --> 00:20:32,596
“Swift 中有什么新性能”演讲里提到了这个


645
00:20:33,056 --> 00:20:35,206
如果你想要了解更多


646
00:20:35,336 --> 00:20:36,786
在明天的 “Xcode 构建过程背后的情景”中


647
00:20:36,786 --> 00:20:37,956
我们将提到这个


648
00:20:37,956 --> 00:20:39,496
和其他可以让你的


649
00:20:39,496 --> 00:20:42,266
构建更有深度的话题


650
00:20:42,266 --> 00:20:46,606
今天我们有很多


651
00:20:46,606 --> 00:20:47,786
需要讲到的话题


652
00:20:47,786 --> 00:20:49,766
David 已经介绍了一半的内容


653
00:20:50,006 --> 00:20:51,346
我将会介绍剩下的


654
00:20:51,346 --> 00:20:53,156
三个解决


655
00:20:53,156 --> 00:20:55,606
列表顶端复杂表达式的问题


656
00:20:56,506 --> 00:20:58,186
这是因为它很好的同时


657
00:20:58,186 --> 00:20:59,126
举证了我们两个部分的


658
00:20:59,126 --> 00:21:01,966
一个关键点


659
00:21:01,966 --> 00:21:05,206
当一个构建花费很长时间时


660
00:21:05,206 --> 00:21:07,266
总会有一个


661
00:21:07,266 --> 00:21:08,556
你可以提供给 Xcode 的


662
00:21:08,556 --> 00:21:11,896
用来提升状态的关键信息


663
00:21:13,036 --> 00:21:13,946
所以我们要


664
00:21:13,946 --> 00:21:16,006
在复杂的 Swift 表达式语境中


665
00:21:16,006 --> 00:21:17,446
首先看看它


666
00:21:18,066 --> 00:21:21,546
这是我最近的一个项目


667
00:21:21,546 --> 00:21:22,836
中的一些编码


668
00:21:23,966 --> 00:21:26,406
这个结构的一个问题就是


669
00:21:26,966 --> 00:21:29,206
我在各个地方都使用它


670
00:21:30,076 --> 00:21:31,926
拥有一个结构真的很好


671
00:21:32,166 --> 00:21:33,016
拥有一个有性能的结构


672
00:21:33,016 --> 00:21:34,136
也很好


673
00:21:34,136 --> 00:21:35,346
拥有一个有推论的类型的


674
00:21:35,596 --> 00:21:37,826
性能的结构也很好


675
00:21:38,516 --> 00:21:39,696
但是我们在这里


676
00:21:39,696 --> 00:21:41,806
推论的表达式可能


677
00:21:41,806 --> 00:21:43,236
有一些复杂


678
00:21:43,416 --> 00:21:44,986
这不是像


679
00:21:45,256 --> 00:21:47,806
啊 我的 PPT 上已经展示出来了


680
00:21:48,126 --> 00:21:50,426
好吧 我在这里泄露了答案


681
00:21:50,586 --> 00:21:53,316
如果这是一些像 0.0 的东西


682
00:21:53,816 --> 00:21:55,506
那么 double 类型的推论


683
00:21:55,506 --> 00:21:57,636
在这里是没有必要的


684
00:21:58,126 --> 00:21:59,696
因为我们已经从系统框架中


685
00:21:59,696 --> 00:22:01,256
拥有包含


686
00:22:01,256 --> 00:22:03,236
简化函数和幂函数


687
00:22:03,236 --> 00:22:06,586
的大型、复杂的表达式


688
00:22:06,586 --> 00:22:08,026
你可能不会猜到


689
00:22:08,026 --> 00:22:09,566
double 是这个性能中的


690
00:22:09,566 --> 00:22:10,296
推论类型
 
00:22:11,066 --> 00:22:12,126
通过在这里提供这个信息


691
00:22:12,126 --> 00:22:14,076
编译器使用这个结构


692
00:22:14,076 --> 00:22:15,406
在每个文件中


693
00:22:15,406 --> 00:22:17,796
需要做的工作


694
00:22:17,826 --> 00:22:18,876
都被你节省了


695
00:22:19,626 --> 00:22:21,636
你还节省了


696
00:22:21,636 --> 00:22:23,046
你的同事


697
00:22:23,336 --> 00:22:25,086
为了弄清楚这个 big number 到底是什么  


698
00:22:25,086 --> 00:22:26,576
而花费的时间


699
00:22:27,156 --> 00:22:30,166
所以你通过用


700
00:22:30,166 --> 00:22:31,226
这个额外信息来帮助您


701
00:22:31,226 --> 00:22:32,596
优化构建时间


702
00:22:32,596 --> 00:22:34,786
就是一个很好的


703
00:22:37,806 --> 00:22:38,846
我们看看涉及闭包的


704
00:22:38,846 --> 00:22:40,516
其他例子


705
00:22:41,536 --> 00:22:43,286
这次我将会试着宏定义一个


706
00:22:43,286 --> 00:22:44,936
会返回所有


707
00:22:44,936 --> 00:22:48,186
非可选参数值的和的函数


708
00:22:48,926 --> 00:22:50,156
如果这三个参数是零


709
00:22:50,156 --> 00:22:51,826
它就会返回零


710
00:22:53,136 --> 00:22:54,696
我将会试着使用一个


711
00:22:54,696 --> 00:22:56,726
Swift 的性能


712
00:22:56,726 --> 00:22:58,526
如果你在主体内


713
00:22:58,526 --> 00:23:00,646
有一个拥有单一表达式的闭包


714
00:23:00,646 --> 00:23:02,026
那么编译器会


715
00:23:02,026 --> 00:23:03,986
使用该表达式来决定


716
00:23:03,986 --> 00:23:04,976
闭包的类型


717
00:23:05,786 --> 00:23:07,506
有时候这真的很方便


718
00:23:08,086 --> 00:23:10,976
其他时候它则会导致像这样的代码


719
00:23:12,506 --> 00:23:13,916
这样非常丑


720
00:23:13,916 --> 00:23:14,846
我不认为我会用这个
 
00:23:14,846 --> 00:23:16,046
来回顾过去的代码


721
00:23:17,276 --> 00:23:18,796
我们还有一些内嵌的工艺运算符


722
00:23:18,796 --> 00:23:20,876
和一些针对 nil 的


723
00:23:20,876 --> 00:23:22,316
明确的比较方法


724
00:23:22,406 --> 00:23:24,636
还有一些相关的其他运算


725
00:23:24,636 --> 00:23:26,676
我不认为它会运行的很好


726
00:23:27,316 --> 00:23:29,086
并且还有另一个问题


727
00:23:29,626 --> 00:23:31,136
因为这个表达式太大了


728
00:23:31,136 --> 00:23:32,976
拥有着很多独立的块


729
00:23:32,976 --> 00:23:35,316
Swift 编译器会报错说


730
00:23:35,316 --> 00:23:36,996
它不能在一个合理数量的


731
00:23:36,996 --> 00:23:38,656
时间内完成编译


732
00:23:38,656 --> 00:23:39,906
这个构建时间


733
00:23:40,966 --> 00:23:42,186
简直慢到头了


734
00:23:42,186 --> 00:23:44,646
甚至连编译器都放弃了


735
00:23:45,776 --> 00:23:46,826
这也真的让我对


736
00:23:46,826 --> 00:23:48,046
这个代码加深了理解


737
00:23:48,876 --> 00:23:50,906
我的首选是


738
00:23:50,906 --> 00:23:52,026
如之前的例子一样做相同的事情


739
00:23:52,026 --> 00:23:54,806
同时提供附加的类型


740
00:23:55,186 --> 00:23:56,586
通过一个闭包 你可以在 In Key 词


741
00:23:56,586 --> 00:23:57,906
之前就完成这些


742
00:23:59,156 --> 00:24:01,446
不过这对于特定的问题来说


743
00:24:01,446 --> 00:24:02,706
可能不是最好的


744
00:24:02,706 --> 00:24:03,256
解决办法


745
00:24:03,536 --> 00:24:05,116
所以让我们回到之前有的东西


746
00:24:06,686 --> 00:24:08,416
回想起我之前说的


747
00:24:08,416 --> 00:24:09,646
我想要试着在这里写一个


748
00:24:09,646 --> 00:24:11,596
表达式这样它就可以用来


749
00:24:11,596 --> 00:24:13,996
决定闭包的类型


750
00:24:15,176 --> 00:24:16,846
但是在这种情况下 


751
00:24:16,846 --> 00:24:17,856
这其实不太必要


752
00:24:18,716 --> 00:24:20,316
我们已经从 Reduce 的调用中了解到


753
00:24:20,316 --> 00:24:22,916
这个闭包是什么样的


754
00:24:23,266 --> 00:24:24,716
Reduce 对一个整型可选择的


755
00:24:24,716 --> 00:24:26,156
数组调用


756
00:24:26,766 --> 00:24:28,736
这个结果类型需要


757
00:24:28,776 --> 00:24:30,126
匹配这个函数的返回类型


758
00:24:31,076 --> 00:24:33,186
我们已经知道 Reduce 的回调


759
00:24:33,486 --> 00:24:35,576
只能对可选择


760
00:24:35,576 --> 00:24:37,746
的整型参数操作


761
00:24:38,336 --> 00:24:40,136
这意味着我们不需要


762
00:24:40,136 --> 00:24:42,046
在闭包中放上一个表达式


763
00:24:42,436 --> 00:24:44,626
我们可以把它分解成


764
00:24:44,626 --> 00:24:46,146
各自的部分


765
00:24:46,146 --> 00:24:47,146
成为更可读的指令


766
00:24:48,556 --> 00:24:49,966
这里有一个我之前的


767
00:24:49,966 --> 00:24:51,306
代码的直译


768
00:24:52,616 --> 00:24:53,936
我现在还可以让它


769
00:24:54,326 --> 00:24:55,776
更加的灵活


770
00:24:56,196 --> 00:24:57,806
这就更具有可读性了


771
00:24:58,076 --> 00:24:59,346
也可以更容易维护


772
00:24:59,686 --> 00:25:01,226
它在一个快速的


773
00:25:01,296 --> 00:25:02,596
合理的时间内编译


774
00:25:03,106 --> 00:25:06,336
我要在这个环节展示的最后一个例子


775
00:25:06,336 --> 00:25:07,856
并不像之前两个


776
00:25:07,856 --> 00:25:09,236
一样 应用的


777
00:25:09,236 --> 00:25:10,786
那么广泛


778
00:25:11,396 --> 00:25:13,256
我要说说 Any Object 这个类型


779
00:25:14,766 --> 00:25:17,516
Any Object 是一个描述


780
00:25:17,516 --> 00:25:20,646
所有类别实例的便利的类型


781
00:25:20,736 --> 00:25:22,226
不是一个结构体 或一个枚举


782
00:25:22,326 --> 00:25:23,416
而是一个类


783
00:25:23,526 --> 00:25:24,666
但是我们不知道是哪一个


784
00:25:25,726 --> 00:25:27,076
不过它还有一个


785
00:25:27,076 --> 00:25:28,736
从 Objective-C's ID 类型


786
00:25:28,736 --> 00:25:30,376
传下来的附加的功能


787
00:25:31,206 --> 00:25:33,886
这也是为什么 这个方法被称作语法


788
00:25:34,106 --> 00:25:36,066
如果你试图调用一个方法


789
00:25:36,066 --> 00:25:38,096
或在 Any Object 类型的数值上


790
00:25:38,156 --> 00:25:40,936
读取其性质


791
00:25:40,936 --> 00:25:42,816
Swift 会允许你这样做


792
00:25:42,816 --> 00:25:45,146
前提是这个方法在你的


793
00:25:45,146 --> 00:25:47,106
项目中是可见的


794
00:25:47,106 --> 00:25:48,416
并被展示给了 Objective-C 运行时间


795
00:25:49,416 --> 00:25:51,576
不过 这样是有代价的


796
00:25:52,346 --> 00:25:53,976
因为编译器不知道


797
00:25:53,976 --> 00:25:55,306
你要调用哪个方法


798
00:25:55,306 --> 00:25:57,616
它需要检索


799
00:25:57,616 --> 00:25:59,516
你整个项目所有可能的应用


800
00:25:59,756 --> 00:26:00,986
和你所有引入的框架


801
00:26:00,986 --> 00:26:03,516
因为编译器会认为


802
00:26:03,516 --> 00:26:04,576
任何一个都有可能


803
00:26:04,576 --> 00:26:05,746
是你要调用的那个


804
00:26:06,756 --> 00:26:08,316
必须这样做的原因是


805
00:26:08,316 --> 00:26:09,706
如果它们中没一个匹配


806
00:26:09,706 --> 00:26:10,776
它就需要报错


807
00:26:12,586 --> 00:26:14,966
所以与此相反 我们可以


808
00:26:14,966 --> 00:26:16,706
更好更多更全面的


809
00:26:16,706 --> 00:26:19,106
描述我们的意图


810
00:26:19,626 --> 00:26:21,096
我们可以宏定义一个协议


811
00:26:21,866 --> 00:26:22,696
它可以在相同的文件


812
00:26:22,696 --> 00:26:24,876
或不同的文件中完成


813
00:26:25,426 --> 00:26:27,236
重要的是一旦我们


814
00:26:27,236 --> 00:26:28,616
将委托的性质


815
00:26:28,616 --> 00:26:30,546
改成去使用我们协议


816
00:26:30,626 --> 00:26:32,756
而不是 Any Object


817
00:26:32,756 --> 00:26:34,806
那编译器就知道


818
00:26:34,806 --> 00:26:35,826
在调用的是哪个方法


819
00:26:37,186 --> 00:26:38,276
现在你有机会


820
00:26:38,276 --> 00:26:39,546
检查所有实施类型


821
00:26:39,546 --> 00:26:41,846
是否在正确


822
00:26:42,026 --> 00:26:43,866
实施方法


823
00:26:46,496 --> 00:26:48,186
我们已经谈论了


824
00:26:48,186 --> 00:26:50,576
当编译器决定


825
00:26:50,576 --> 00:26:51,856
重新编译一个文件时


826
00:26:51,856 --> 00:26:53,816
我们可以通过一些技术来减少


827
00:26:53,816 --> 00:26:55,136
编译器的工作量


828
00:26:56,106 --> 00:26:58,486
但是如果完全不重新编译


829
00:26:58,486 --> 00:26:59,556
这些文件会怎么样呢


830
00:26:59,956 --> 00:27:01,696
是什么让编译器决定


831
00:27:01,926 --> 00:27:03,186
一个文件是否需要


832
00:27:03,186 --> 00:27:03,906
重新编译呢


833
00:27:04,636 --> 00:27:06,536
这就需要我们了解


834
00:27:06,536 --> 00:27:07,836
Swift 的依赖性模型


835
00:27:09,496 --> 00:27:12,326
Swift 的依赖性模型


836
00:27:12,356 --> 00:27:13,686
是基于文件的


837
00:27:14,056 --> 00:27:15,366
这有一点棘手因为


838
00:27:15,466 --> 00:27:17,926
在 Swift 中没有头文件


839
00:27:18,546 --> 00:27:20,236
我们看到的都是


840
00:27:20,796 --> 00:27:22,626
在我们的目标中被


841
00:27:22,706 --> 00:27:23,286
默认定义的


842
00:27:24,256 --> 00:27:25,486
在这个例子中


843
00:27:25,486 --> 00:27:26,936
我在文件的左侧声明了


844
00:27:26,936 --> 00:27:27,316
一个结构体 名字是 Point


845
00:27:27,866 --> 00:27:29,176
如果我这时候从右侧引入一个文件


846
00:27:29,176 --> 00:27:31,106
编译器就会知道我是对


847
00:27:31,106 --> 00:27:33,656
第一个声明引入的


848
00:27:34,316 --> 00:27:35,766
这也同样适用于


849
00:27:35,766 --> 00:27:37,466
右侧文件的


850
00:27:37,466 --> 00:27:41,216
X 和 Y 属性


851
00:27:41,416 --> 00:27:43,286
这个以文件为基础的依赖性


852
00:27:43,286 --> 00:27:44,776
意味着如果我改变左边的文件


853
00:27:44,776 --> 00:27:47,846
那么两个文件


854
00:27:47,846 --> 00:27:49,086
都需要被重新编译


855
00:27:50,306 --> 00:27:51,686
这很重要因为


856
00:27:51,686 --> 00:27:52,886
我们其实在尝试调用这个


857
00:27:52,886 --> 00:27:53,816
初始化程序


858
00:27:54,016 --> 00:27:55,326
我们想要确保我们


859
00:27:55,326 --> 00:27:56,486
对其正确调用


860
00:27:57,036 --> 00:28:00,306
编译器很智能


861
00:28:00,306 --> 00:28:01,976
它能知道你什么时候在


862
00:28:01,976 --> 00:28:04,136
一个函数主体中做了修改


863
00:28:04,166 --> 00:28:05,586
在这个例子中是将 assertion 做得


864
00:28:05,586 --> 00:28:09,056
更加合适 所以就只有那个文件


865
00:28:09,056 --> 00:28:10,316
需要被重新编译


866
00:28:11,136 --> 00:28:13,446
其他文件不需要改变


867
00:28:13,616 --> 00:28:15,556
它们是如何使用第一个文件


868
00:28:15,586 --> 00:28:16,196
的 API 的


869
00:28:16,646 --> 00:28:20,946
不过 它确实需要稳妥一些


870
00:28:21,096 --> 00:28:22,916
如果我为这个文件


871
00:28:22,916 --> 00:28:25,326
增加了一个单独的类型 人们可以知道


872
00:28:25,326 --> 00:28:26,706
这个新的 名为 path segment 的结构体


873
00:28:26,906 --> 00:28:28,636
不会影响右侧的文件


874
00:28:29,256 --> 00:28:30,596
但是编译器还是需要稳妥一些


875
00:28:30,596 --> 00:28:31,876
它会重新编译


876
00:28:31,876 --> 00:28:32,186
这两个文件


877
00:28:32,726 --> 00:28:36,116
我们来看看这如何


878
00:28:36,116 --> 00:28:37,456
应用到前面 David 用到的


879
00:28:37,456 --> 00:28:38,216
游戏例子中


880
00:28:39,246 --> 00:28:40,576
现在我们有 App 目标


881
00:28:40,576 --> 00:28:41,856
和 Utilities 框架


882
00:28:41,856 --> 00:28:42,766
我要在每个目标中


883
00:28:42,766 --> 00:28:44,426
展示一些 Swift 文件


884
00:28:45,586 --> 00:28:47,096
如果我在 App 目标中


885
00:28:47,096 --> 00:28:50,636
改变了一个文件 我们就已经知道


886
00:28:50,636 --> 00:28:52,286
该文件需要被重新编译了


887
00:28:52,436 --> 00:28:53,606
当然了 任何依赖于


888
00:28:53,606 --> 00:28:55,146
这个文件的文件


889
00:28:55,146 --> 00:28:56,236
都需要被重新编译


890
00:28:57,026 --> 00:28:58,316
但是在 utilities 目标中的


891
00:28:58,316 --> 00:28:59,716
任何文件


892
00:28:59,756 --> 00:29:01,376
都不需要被重新编译


893
00:29:02,276 --> 00:29:03,326
因为这是另一个分离的目标


894
00:29:03,326 --> 00:29:05,576
它有明确的依赖性


895
00:29:05,676 --> 00:29:07,426
在两个文件中


896
00:29:07,426 --> 00:29:09,406
并没有不清晰的


897
00:29:09,406 --> 00:29:12,456
可见关系


898
00:29:12,626 --> 00:29:15,286
与此相似的是


899
00:29:15,286 --> 00:29:16,376
如果我在框架目标中做一些改变


900
00:29:16,376 --> 00:29:17,896
我将会需要


901
00:29:17,896 --> 00:29:20,246
重新编译这个文件以及


902
00:29:20,246 --> 00:29:21,416
在 utilities 框架中


903
00:29:21,416 --> 00:29:22,236
所有依赖于此的其他文件


904
00:29:23,156 --> 00:29:25,776
但是 这些依赖性更加保守


905
00:29:26,236 --> 00:29:28,296
所以 Xcode 也会


906
00:29:28,296 --> 00:29:29,906
重新编译在 Game 目标中的


907
00:29:29,906 --> 00:29:32,136
一切 除非修改


908
00:29:32,136 --> 00:29:34,846
被完全限制在函数体中


909
00:29:35,436 --> 00:29:38,996
为了综合这些规则


910
00:29:38,996 --> 00:29:40,746
编译器需要保守点


911
00:29:41,056 --> 00:29:42,506
即使人们知道说


912
00:29:42,506 --> 00:29:43,656
这个修改不会影响


913
00:29:43,656 --> 00:29:45,506
其他文件 这不代表


914
00:29:45,506 --> 00:29:46,936
编译器就可以知道


915
00:29:47,716 --> 00:29:49,486
不过 编译器可以知道


916
00:29:49,486 --> 00:29:52,696
该如何处理函数体的变化


917
00:29:52,936 --> 00:29:54,196
它知道其不会影响


918
00:29:54,196 --> 00:29:55,576
文件的界面


919
00:29:55,896 --> 00:29:57,776
因此 也不会要求其他


920
00:29:57,776 --> 00:29:59,406
文件被重新编译


921
00:30:02,406 --> 00:30:04,146
这个通过文件的依赖性基础


922
00:30:04,146 --> 00:30:06,006
在模块内发生


923
00:30:06,006 --> 00:30:08,386
在这里 Swift 的声明


924
00:30:08,386 --> 00:30:10,026
对彼此是隐式可见的


925
00:30:10,876 --> 00:30:11,666
当你在通过你的


926
00:30:11,666 --> 00:30:13,756
引入文件或者你的


927
00:30:13,756 --> 00:30:15,006
头文件来处理


928
00:30:15,006 --> 00:30:16,736
跨模块依赖性时 这些都是


929
00:30:16,736 --> 00:30:17,846 
整个目标的依赖性


930
00:30:18,386 --> 00:30:21,836
这些就是关于 Swift 依赖性


931
00:30:21,836 --> 00:30:25,546
和 Swift 目标的好的信息


932
00:30:25,856 --> 00:30:27,336
但我知道你们中很多人


933
00:30:27,546 --> 00:30:29,766
都是混合 Objective-C 目标和 Swift 目标


934
00:30:29,976 --> 00:30:31,336
所以最后一个部分将


935
00:30:31,336 --> 00:30:33,276
集中在


936
00:30:33,276 --> 00:30:34,696
混合源的 App 中如何减少


937
00:30:34,696 --> 00:30:37,756
Swift 和 Objective-C 代码的接口


938
00:30:38,976 --> 00:30:40,506
为了实现这一点 我们将


939
00:30:40,506 --> 00:30:42,966
讨论一下混合源 App 的一些内容


940
00:30:44,096 --> 00:30:46,796
这个图表将有些复杂 所以请耐心点


941
00:30:46,796 --> 00:30:48,356
如果你在观看视频


942
00:30:48,406 --> 00:30:49,626
你可能需要暂停并重新开始


943
00:30:50,386 --> 00:30:51,106
放轻松


944
00:30:52,406 --> 00:30:54,306
首先看到的是


945
00:30:54,676 --> 00:30:56,926
描述你的 Objective-C 接口的头文件


946
00:30:57,646 --> 00:30:58,756
这就是你 App 中用


947
00:30:58,796 --> 00:31:00,136
Objective-C 写的部分


948
00:31:00,296 --> 00:31:01,896
你可能想要把这部分给 Swift


949
00:31:02,376 --> 00:31:03,966
或者你只是想对


950
00:31:03,966 --> 00:31:05,656
你的 App 中的其他 Objective-C 


951
00:31:05,656 --> 00:31:07,046
部分 声明头文件


952
00:31:08,246 --> 00:31:09,796
我们还有桥接头文件


953
00:31:10,236 --> 00:31:11,696
这就是收集


954
00:31:11,696 --> 00:31:13,416
所有你想要展示给你的 App 的


955
00:31:13,416 --> 00:31:15,566
Swift 部分的信息


956
00:31:15,566 --> 00:31:16,886
的头文件


957
00:31:17,766 --> 00:31:19,656
这是 Xcode 中


958
00:31:19,786 --> 00:31:21,616
控制头文件使用的构建设置


959
00:31:21,836 --> 00:31:23,756
一旦它设置完成


960
00:31:23,756 --> 00:31:25,846
Swift 编译器就知道


961
00:31:25,846 --> 00:31:27,906
该把这些 Objective-C 接口


962
00:31:27,906 --> 00:31:28,736
给你的 Swift 代码


963
00:31:30,216 --> 00:31:32,196
Swift 编译器会接着


964
00:31:32,196 --> 00:31:34,616
产生一个生成的头文件


965
00:31:35,036 --> 00:31:36,796
它会反向地做相同的事情


966
00:31:37,246 --> 00:31:39,026
它描述了你的 Swift 代码中


967
00:31:39,026 --> 00:31:41,526
哪些部分会被展示给


968
00:31:41,526 --> 00:31:42,496
Objective-C


969
00:31:43,796 --> 00:31:45,656
这个可以在你的 Objective-C 应用


970
00:31:45,656 --> 00:31:47,046
文件中被使用 


971
00:31:47,046 --> 00:31:49,976
它们可能也会使用一些


972
00:31:49,976 --> 00:31:51,436
第一步中的头文件


973
00:31:51,956 --> 00:31:53,896
当然了 你可能拥有


974
00:31:53,896 --> 00:31:55,946
不依赖于任何 Swift 代码的


975
00:31:55,946 --> 00:31:58,246
Objective-C 代码


976
00:31:58,846 --> 00:32:00,106
这可能不是我们今天在这里


977
00:32:00,106 --> 00:32:01,596
要讨论的内容


978
00:32:02,316 --> 00:32:03,486
所以 让我们从左到右


979
00:32:03,486 --> 00:32:04,626
再缕一次


980
00:32:05,836 --> 00:32:07,746
我们拥有 Objective-C 头文件


981
00:32:08,996 --> 00:32:10,706
为了将某些


982
00:32:10,706 --> 00:32:12,176
信息接入 Swift 的桥接头文件


983
00:32:13,296 --> 00:32:14,906
你们的 Swift 应用文件


984
00:32:15,976 --> 00:32:17,556
将信息送回


985
00:32:17,556 --> 00:32:19,076
Objective-C 的


986
00:32:19,076 --> 00:32:20,176
生成的头文件


987
00:32:20,686 --> 00:32:21,966
最后 就是你的


988
00:32:21,966 --> 00:32:24,036
Objective-C 应用文件


989
00:32:24,506 --> 00:32:28,536
在像这样的图表中


990
00:32:28,536 --> 00:32:30,456
所有这些箭头都代表


991
00:32:30,456 --> 00:32:31,396
依赖性


992
00:32:31,476 --> 00:32:32,876
不是目标层面的依赖性


993
00:32:32,876 --> 00:32:34,966
而是目标内的


994
00:32:35,186 --> 00:32:37,516
文件间的依赖性


995
00:32:38,336 --> 00:32:40,216
所以 我们想要做的是


996
00:32:40,216 --> 00:32:41,556
关注生成的头文件和


997
00:32:41,556 --> 00:32:43,046
桥接头文件


998
00:32:43,046 --> 00:32:44,546
因为如果我们可以


999
00:32:44,546 --> 00:32:46,916
缩小这些头文件的内容


1000
00:32:46,916 --> 00:32:48,326
那我们就会知道事情变化的机会


1001
00:32:48,326 --> 00:32:49,056
其实更少


1002
00:32:49,366 --> 00:32:51,596
因此 需要重新构建的也更少


1003
00:32:52,206 --> 00:32:54,116
让我们来看一下


1004
00:32:54,916 --> 00:32:56,486
对于生成的头文件来说


1005
00:32:56,486 --> 00:32:57,906
你最有力的工具是


1006
00:32:57,906 --> 00:32:58,866
私有关键词


1007
00:32:59,486 --> 00:33:01,086
在这个例子中


1008
00:33:01,086 --> 00:33:02,126
我有一个在 Swift 定义的


1009
00:33:02,126 --> 00:33:03,036
视图控制器


1010
00:33:03,316 --> 00:33:04,476
它有一个 IBOutlet 属性


1011
00:33:04,516 --> 00:33:06,636
和一个 IBAction 方法


1012
00:33:07,606 --> 00:33:09,526
在默认情况下 这些会


1013
00:33:09,526 --> 00:33:11,966
展示在你生成的头文件中


1014
00:33:12,426 --> 00:33:16,596
因为它们是展示给 Objective-C 的方法和属性


1015
00:33:17,226 --> 00:33:18,876
它们并没有被声明成私有的


1016
00:33:20,276 --> 00:33:22,216
但大部分时间


1017
00:33:22,216 --> 00:33:23,756
你不需要将这些


1018
00:33:23,756 --> 00:33:24,986
展示给你项目中的任何其他文件
 
00:33:25,376 --> 00:33:26,276
它们只是为了与


1019
00:33:26,276 --> 00:33:27,206
Interface Builder（接口构建器）交互的


1020
00:33:28,286 --> 00:33:30,326
所以 在这种情况下 我可以将其标为私有


1021
00:33:30,366 --> 00:33:32,636
并看着属性和方法


1022
00:33:32,676 --> 00:33:35,396
从生成的头文件中消失


1023
00:33:37,216 --> 00:33:39,606
另外一个例子就是


1024
00:33:39,606 --> 00:33:41,746
在为了用于 Objective-C 运行时间特征


1025
00:33:41,746 --> 00:33:43,526
如 #selector


1026
00:33:43,526 --> 00:33:46,126
而处理展示给 Objective-C 的方法时


1027
00:33:46,786 --> 00:33:47,886
在这个例子中


1028
00:33:47,886 --> 00:33:49,476
我使用基础的  Notification Center


1029
00:33:49,476 --> 00:33:51,646
API 在通知发送时


1030
00:33:51,646 --> 00:33:54,326
它使用 selector 作为回调


1031
00:33:55,896 --> 00:33:58,026
再一次 这里唯一的要求


1032
00:33:58,086 --> 00:33:59,086
就是将方法


1033
00:33:59,086 --> 00:34:00,816
展示给 Objective-C


1034
00:34:00,916 --> 00:34:02,056
在我的项目


1035
00:34:02,056 --> 00:34:03,786
其他文件中 不论是


1036
00:34:03,786 --> 00:34:06,046
Swift 还是 Objective-C 它其实不太被使用


1037
00:34:06,486 --> 00:34:09,286
所以我可以把它标记为私有


1038
00:34:10,106 --> 00:34:11,775
这再一次


1039
00:34:11,775 --> 00:34:14,176
缩小了我生成的头文件的大小


1040
00:34:14,815 --> 00:34:17,255
在这种情况中


1041
00:34:17,255 --> 00:34:19,246
往往还有其他选择


1042
00:34:19,596 --> 00:34:20,585
那就是将其转换为


1043
00:34:20,585 --> 00:34:21,896
基于分块的 API


1044
00:34:22,775 --> 00:34:24,166
在很多例子中


1045
00:34:24,166 --> 00:34:25,866
这甚至可以清理你的代码


1046
00:34:25,866 --> 00:34:27,536
因为你可从那些


1047
00:34:27,666 --> 00:34:28,485
注册事件通知


1048
00:34:28,485 --> 00:34:30,016
的函数


1049
00:34:30,396 --> 00:34:31,516
暗中地获取状态


1050
00:34:31,516 --> 00:34:33,065
而不用一直带着它


1051
00:34:33,065 --> 00:34:33,456
就像带着个环境目标


1052
00:34:34,076 --> 00:34:37,286
最后一个


1053
00:34:37,286 --> 00:34:38,485
减少你生成的头文件大小


1054
00:34:38,485 --> 00:34:41,576
的方法其实是非常古老的


1055
00:34:41,815 --> 00:34:43,255
你可以更新到 Swift 4


1056
00:34:44,366 --> 00:34:45,646
你应该已经听说了


1057
00:34:45,646 --> 00:34:47,216
今年你就需要这么做


1058
00:34:47,596 --> 00:34:49,076
Xcode 10 将会是


1059
00:34:49,076 --> 00:34:51,795
Swift 3 模式被支持的


1060
00:34:51,795 --> 00:34:52,886
最后一个版本了


1061
00:34:53,976 --> 00:34:56,386
所以 这会是你之后


1062
00:34:56,386 --> 00:34:57,946
需要做的事情


1063
00:34:57,976 --> 00:34:59,166
编辑 转换


1064
00:34:59,316 --> 00:35:01,076
至现行的 Swift 语法


1065
00:35:02,496 --> 00:35:04,126
然而 当你在更新的时候


1066
00:35:04,396 --> 00:35:06,906
你可能会选择


1067
00:35:06,906 --> 00:35:09,936
为一个特定的构建设置


1068
00:35:09,936 --> 00:35:11,446
保持 Swift 3 的


1069
00:35:11,446 --> 00:35:12,576
兼容性模式


1070
00:35:12,696 --> 00:35:14,776
这就是 Swift 3 @objc 


1071
00:35:14,776 --> 00:35:15,406
inference


1072
00:35:16,196 --> 00:35:17,086
当你更新到 Swift 4 时


1073
00:35:17,086 --> 00:35:19,316
这是一个你可以选择的选项


1074
00:35:19,316 --> 00:35:22,176
它可以保持 Swift 3 中


1075
00:35:22,176 --> 00:35:23,686
在 NS 对象的任何子类中


1076
00:35:23,736 --> 00:35:26,416
自动向 Objective-C 展示内置方法和性能


1077
00:35:26,416 --> 00:35:30,096
的规则


1078
00:35:30,236 --> 00:35:31,626
如果你在 Swift 3 中编写程序


1079
00:35:31,666 --> 00:35:33,846
你可能会依赖这个性能


1080
00:35:34,196 --> 00:35:35,936
但是还有很多种情况


1081
00:35:36,086 --> 00:35:37,626
你们可能根本不需要


1082
00:35:37,626 --> 00:35:38,806
依赖于此


1083
00:35:39,446 --> 00:35:40,586
在运行时间


1084
00:35:40,746 --> 00:35:42,616
编译时间都不需要


1085
00:35:43,666 --> 00:35:45,466
一旦你合适的


1086
00:35:45,816 --> 00:35:47,256
将你的 Objective-C 依赖性明确地


1087
00:35:47,256 --> 00:35:48,176
标注为 @objc 


1088
00:35:48,176 --> 00:35:51,506
或者 IBOutlet 


1089
00:35:52,016 --> 00:35:54,116
或者 IBAction 


1090
00:35:54,116 --> 00:35:56,096
你就可以选择这些


1091
00:35:56,096 --> 00:35:57,826
构建设置并点击


1092
00:35:57,826 --> 00:35:59,186
删除来回到


1093
00:35:59,186 --> 00:36:01,176
默认模式 


1094
00:36:01,176 --> 00:36:02,866
在该模式下 OB-C 属性只会从


1095
00:36:03,566 --> 00:36:05,316
遵循协议要求的方法


1096
00:36:05,316 --> 00:36:08,176
和性能或者


1097
00:36:08,176 --> 00:36:09,716
那些重写自 Objective-C 的


1098
00:36:09,716 --> 00:36:10,806
方法推导出来


1099
00:36:11,306 --> 00:36:14,576
我们谈论了很多关于


1100
00:36:14,576 --> 00:36:15,856
生成的头文件和对你的 Swift 代码


1101
00:36:15,856 --> 00:36:17,026
可以做的事情


1102
00:36:17,416 --> 00:36:19,816
但是你也有 Objective-C 代码


1103
00:36:20,066 --> 00:36:21,386
Objective-C 代码也同样会


1104
00:36:21,386 --> 00:36:23,596
造成重新构建


1105
00:36:24,656 --> 00:36:25,846
一个桥接头文件一般看起来


1106
00:36:25,846 --> 00:36:27,186
是这样的


1107
00:36:27,186 --> 00:36:28,556
它拥有很多在项目中


1108
00:36:28,556 --> 00:36:29,996
你想要展示给


1109
00:36:29,996 --> 00:36:31,386
Swift 的其他头文件


1110
00:36:32,616 --> 00:36:34,016
我们可以放大显示


1111
00:36:34,016 --> 00:36:34,886
这些头文件中的一个


1112
00:36:34,886 --> 00:36:37,436
MyViewController 头文件


1113
00:36:37,436 --> 00:36:38,716
可以看到 它视图控制器的


1114
00:36:38,716 --> 00:36:40,086
一个非常正常的声明


1115
00:36:40,616 --> 00:36:42,476
它自己本身还包含了


1116
00:36:42,476 --> 00:36:43,196
其他头文件


1117
00:36:44,376 --> 00:36:46,006
这意味着如果


1118
00:36:46,006 --> 00:36:48,126
这些头文件中的任意一个变化了


1119
00:36:48,126 --> 00:36:49,886
你目标中的 Swift 代码


1120
00:36:49,886 --> 00:36:51,866
需要重新编译 


1121
00:36:51,866 --> 00:36:53,356
因为它可能依赖于 某些已经变化的东西


1122
00:36:54,616 --> 00:36:56,206
这并不是最理想的


1123
00:36:56,466 --> 00:36:59,886
在这个例子中我们可以注意


1124
00:36:59,886 --> 00:37:01,656
我们引入 MyNetwork Manager 头文件的


1125
00:37:01,656 --> 00:37:03,096
唯一理由就是


1126
00:37:03,096 --> 00:37:04,986
声明这个属性


1127
00:37:04,986 --> 00:37:06,436
这个视图控制器上的


1128
00:37:06,436 --> 00:37:08,176
网络管理属性


1129
00:37:09,576 --> 00:37:11,986
很有可能


1130
00:37:11,986 --> 00:37:14,816
该属性从来没在 Swift 中被使用过


1131
00:37:15,436 --> 00:37:17,876
在这种情况下


1132
00:37:17,876 --> 00:37:19,376
我们就不需要在这里声明它


1133
00:37:20,346 --> 00:37:21,976
你能做的就是使用分类


1134
00:37:21,976 --> 00:37:23,886
Objective-C 的等价


1135
00:37:23,886 --> 00:37:25,486
拓展包


1136
00:37:25,486 --> 00:37:26,866
来将这个接口分解


1137
00:37:27,606 --> 00:37:28,566
我将在这里定义


1138
00:37:28,566 --> 00:37:30,186
一个新的文件  MyViewController


1139
00:37:30,186 --> 00:37:32,526
Internal 并使用特别的


1140
00:37:32,526 --> 00:37:34,586
无名的语法 来让我们可以


1141
00:37:34,586 --> 00:37:36,116
声明附加的属性并


1142
00:37:36,116 --> 00:37:37,896
依旧可以使用


1143
00:37:37,896 --> 00:37:41,276
我的主要区块 Add Implementation 中的


1144
00:37:41,276 --> 00:37:42,326
属性整合功能


1145
00:37:42,436 --> 00:37:47,066
现在我可以将引入代码


1146
00:37:47,066 --> 00:37:48,696
和属性移入到的这个类别


1147
00:37:49,426 --> 00:37:50,066
看


1148
00:37:50,796 --> 00:37:52,316
引入到 Swift 的头文件


1149
00:37:52,316 --> 00:37:54,636
变得更小了


1150
00:37:54,636 --> 00:37:56,536
而且被改变的可能更小


1151
00:37:56,536 --> 00:37:58,246
同时也不会造成


1152
00:37:58,246 --> 00:37:59,506
不必要的重新构建


1153
00:38:00,476 --> 00:38:01,566
还有一点要注意的是


1154
00:38:02,636 --> 00:38:04,206
我刚刚定义的文件


1155
00:38:04,796 --> 00:38:06,626
很有可能在我的 Objective-C 代码中的


1156
00:38:06,626 --> 00:38:08,256
所有代码都不需要


1157
00:38:08,256 --> 00:38:09,966
访问这个属性


1158
00:38:11,156 --> 00:38:12,796
在这种情况下


1159
00:38:12,796 --> 00:38:13,786
我们不需要一个单独的文件


1160
00:38:14,266 --> 00:38:16,256
我可以直接将这个分类放进


1161
00:38:16,256 --> 00:38:17,176
我的 .m


1162
00:38:18,356 --> 00:38:19,946
这样做不会报错


1163
00:38:20,056 --> 00:38:21,316
一切都会运行得很好


1164
00:38:21,646 --> 00:38:23,076
正如我之前说的


1165
00:38:23,076 --> 00:38:24,736
属性综合还是会为


1166
00:38:24,736 --> 00:38:26,046
网络管理属性工作


1167
00:38:26,536 --> 00:38:28,976
所以我们看了些什么


1168
00:38:29,946 --> 00:38:34,456
我们使用私有和基于分块的 API


1169
00:38:34,456 --> 00:38:35,906
关闭构建设置来


1170
00:38:35,906 --> 00:38:37,586
缩减生成头文件的内容


1171
00:38:38,786 --> 00:38:40,826
我们从声明的 Objective-C


1172
00:38:40,826 --> 00:38:42,736
头文件中分离


1173
00:38:42,736 --> 00:38:44,266
单独的内容 


1174
00:38:44,266 --> 00:38:46,306
它们缩减了桥接头文件的内容


1175
00:38:47,096 --> 00:38:49,076
更少的内容意味着


1176
00:38:49,076 --> 00:38:49,996
在每个构建中更少的工作量


1177
00:38:50,336 --> 00:38:51,856
同时也意味着出现变化的


1178
00:38:51,856 --> 00:38:53,916
几率更小了


1179
00:38:53,916 --> 00:38:56,026
也意味着重新构建的几率更小


1180
00:38:56,686 --> 00:38:57,936
这真的是一箭双雕


1181
00:38:59,126 --> 00:39:01,066
让我们整理一下今天的内容


1182
00:39:02,316 --> 00:39:04,646
David 和我讲了


1183
00:39:04,946 --> 00:39:06,486
很多不同的话题


1184
00:39:06,486 --> 00:39:07,556
包括你可以从 Xcode 中获得


1185
00:39:07,556 --> 00:39:09,186
更多信息的方法


1186
00:39:09,186 --> 00:39:10,906
以及你可以为 Xcode 提供更多的信息


1187
00:39:11,196 --> 00:39:14,256
来提升你构建的速度


1188
00:39:14,646 --> 00:39:16,266
这包括提升你


1189
00:39:16,266 --> 00:39:17,366
构建的效率


1190
00:39:17,366 --> 00:39:19,426
和减少你重新构建


1191
00:39:19,426 --> 00:39:21,956
所需要的工作


1192
00:39:23,416 --> 00:39:25,436
所以我们就快速地总结一下


1193
00:39:25,616 --> 00:39:26,816
如果你想要再次观看


1194
00:39:26,816 --> 00:39:27,956
可以去我们的视频页面


1195
00:39:27,956 --> 00:39:29,486
你今天下午和


1196
00:39:29,486 --> 00:39:31,746
和明天下午也可以在


1197
00:39:31,746 --> 00:39:33,326
我们的实验室找到我们


1198
00:39:33,326 --> 00:39:33,936
非常感谢


1199
00:39:34,086 --> 00:39:36,426
祝你们享受接下来的会议


1200
00:39:37,176 --> 00:39:39,500
[ 掌声 ]

