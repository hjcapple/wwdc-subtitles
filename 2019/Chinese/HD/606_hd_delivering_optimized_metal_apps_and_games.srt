1
00:00:07,007 --> 00:00:11,945 line:0
（提交优化的Metal app
和游戏）


2
00:00:15,582 --> 00:00:17,251 line:-1
早上好 欢迎大家来参加演讲


3
00:00:17,317 --> 00:00:20,587 line:-2
我是Guillem Vinals Gangolells
来自Metal生态系统团队


4
00:00:21,054 --> 00:00:24,291 line:-2
去年我们和许多游戏开发人员
一起工作


5
00:00:24,525 --> 00:00:26,527 line:-1
并认识到了一些常见问题


6
00:00:26,860 --> 00:00:29,930 line:-2
结果是我们决定把它们放在一起
说一下


7
00:00:30,430 --> 00:00:34,168 line:-1
今天我总共会讲18个最佳实践


8
00:00:34,234 --> 00:00:35,936 line:-1
帮助你改善你的Metal app


9
00:00:37,471 --> 00:00:40,707 line:-1
请注意 我不会展示一些不错的范例


10
00:00:41,508 --> 00:00:43,610 line:-1
或可接受的范例


11
00:00:44,211 --> 00:00:48,081 line:-1
非常肯定不是那些能迎刃而解的范例


12
00:00:49,049 --> 00:00:52,519 line:-2
今天的主要内容是关于
Metal最佳实践


13
00:00:52,586 --> 00:00:53,820 line:-1
请按照最佳实践去做


14
00:00:53,887 --> 00:00:55,923 line:-1
（Metal最佳实践）


15
00:00:55,989 --> 00:00:57,024 line:-1
在我们开始之前


16
00:00:57,090 --> 00:00:59,793 line:-2
我想感谢来自
Digital Legends的朋友们


17
00:00:59,860 --> 00:01:02,129 line:-2
Digital Legends
是巴塞罗那的一支非常有才华的团队


18
00:01:02,496 --> 00:01:04,864 line:-1
他们开发了Afterpulse


19
00:01:05,232 --> 00:01:08,068 line:-2
Afterpulse
是一个精美的游戏


20
00:01:08,402 --> 00:01:12,339 line:-2
它使用了许多渲染技术
比如纹理映射


21
00:01:12,406 --> 00:01:14,208 line:-1
功能完备的延迟渲染


22
00:01:14,474 --> 00:01:17,477 line:-2
以及后置处理
比如全屏泛光和FXAA


23
00:01:18,345 --> 00:01:20,948 line:-2
我们将在本场演讲中 全程使用
Afterpulse作为例子


24
00:01:21,014 --> 00:01:23,984 line:-2
用于演示我们的工具
并突出一些最佳实践


25
00:01:24,051 --> 00:01:25,118 line:-2
（Afterpulse
- 精英部队）


26
00:01:25,185 --> 00:01:27,487 line:-1
我们把这场演讲分为三个部分


27
00:01:27,821 --> 00:01:29,056 line:-1
通用性能


28
00:01:29,590 --> 00:01:30,724 line:-1
内存带宽


29
00:01:31,258 --> 00:01:32,492 line:-1
和内存占用


30
00:01:33,026 --> 00:01:36,096 line:-1
让我们从通用性能开始讲


31
00:01:36,163 --> 00:01:40,000 line:-1
（通用性能）


32
00:01:40,067 --> 00:01:40,934 line:-1
在这部分中


33
00:01:41,001 --> 00:01:44,171 line:-1
我会讲选择正确的分辨率


34
00:01:44,605 --> 00:01:45,639 line:-1
避免过度绘制


35
00:01:45,706 --> 00:01:49,176 line:-2
减少所写入的每个像素的
片段着色器调用次数


36
00:01:49,877 --> 00:01:53,146 line:-1
我们还会讲GPU提交、资源传输


37
00:01:53,213 --> 00:01:54,882 line:-1
以及热感


38
00:01:54,948 --> 00:01:55,883 line:-1
（最佳实践）


39
00:01:55,949 --> 00:01:58,285 line:-1
让我们开始讲第一个最佳实践


40
00:01:58,552 --> 00:02:00,020 line:-1
选择正确的分辨率


41
00:02:00,988 --> 00:02:04,925 line:-2
请注意你游戏中的每个效果
可能都需要不同的分辨率


42
00:02:05,325 --> 00:02:07,794 line:-1
因此考虑每个分辨率的图片品质


43
00:02:07,861 --> 00:02:10,597 line:-1
和性能权衡非常重要


44
00:02:10,663 --> 00:02:12,165 line:-1
并谨慎选择


45
00:02:12,599 --> 00:02:17,871 line:-2
同时以原生分辨率
或接近原生的分辨率结合游戏UI


46
00:02:18,172 --> 00:02:21,308 line:-2
从而使UI看起来清晰
无论显示尺寸是什么


47
00:02:22,609 --> 00:02:25,579 line:-2
我们可以用Metal帧调试器
来检查分辨率


48
00:02:26,647 --> 00:02:30,350 line:-2
在Metal帧调试器内
我们希望使用依存查看器


49
00:02:30,651 --> 00:02:32,986 line:-1
它会显示每个渲染通道的图表


50
00:02:33,453 --> 00:02:36,390 line:-2
在这个例子中
我们使用Metal示例app


51
00:02:37,191 --> 00:02:40,127 line:-2
要获取依存查看器
我们要选择命令缓冲区


52
00:02:41,962 --> 00:02:43,597 line:-1
在这个例子中 你可以看到


53
00:02:43,664 --> 00:02:47,267 line:-2
这个示例Metal app
使用了一些效果


54
00:02:47,334 --> 00:02:49,336 line:-1
分辨率都不同


55
00:02:49,903 --> 00:02:52,706 line:-1
比如阴影映射和SSAO


56
00:02:52,773 --> 00:02:55,275 line:-1
与主光通道的分辨率不同


57
00:02:55,742 --> 00:02:58,378 line:-1
同时UI由原生分辨率合成


58
00:02:58,445 --> 00:02:59,646 line:-1
因此它总是看起来很尖锐


59
00:03:00,647 --> 00:03:02,115 line:-1
这些分辨率看起来不错


60
00:03:02,516 --> 00:03:05,085 line:-2
对于这个Metal app来说
性能也不错


61
00:03:05,152 --> 00:03:08,222 line:-2
我们希望你能在做你的游戏时
做出类似的选择


62
00:03:08,922 --> 00:03:11,258 line:-1
让我们继续看第二个最佳实践


63
00:03:12,259 --> 00:03:14,261 line:-1
最小化不透明过度绘制


64
00:03:15,062 --> 00:03:17,698 line:-1
过度绘制是片段着色器


65
00:03:17,764 --> 00:03:19,099 line:-1
对每个写入的像素的处理次数


66
00:03:19,666 --> 00:03:23,504 line:-2
iOS GPU极其擅长减少
不透明过度绘制


67
00:03:23,570 --> 00:03:25,305 line:-1
我们只需要提供一丁点帮助


68
00:03:26,640 --> 00:03:29,843 line:-2
这里的最佳实践是
首先渲染不透明网格


69
00:03:30,143 --> 00:03:31,912 line:-1
稍后渲染半透明网格


70
00:03:32,312 --> 00:03:36,350 line:-1
同时不要渲染全透明或不可见的网格


71
00:03:37,184 --> 00:03:40,254 line:-2
我们将再次使用Metal帧调试器
来帮助我们


72
00:03:40,621 --> 00:03:43,891 line:-1
这一次我们将查看GPU计数器


73
00:03:43,957 --> 00:03:46,660 line:-1
用于验证指定渲染通道的过度绘制


74
00:03:47,261 --> 00:03:49,363 line:-2
我们聚焦于
Metal Demo app的


75
00:03:49,429 --> 00:03:51,131 line:-1
主光通道


76
00:03:52,332 --> 00:03:54,201 line:-1
为了计算过度绘制


77
00:03:54,501 --> 00:03:56,937 line:-1
我们将用片段着色器调用次数


78
00:03:57,004 --> 00:03:59,072 line:-1
除以像素存储器数量


79
00:03:59,506 --> 00:04:01,208 line:-1
我们可以使用底部的筛选条


80
00:04:01,275 --> 00:04:03,944 line:-1
迅速查找我们所寻求的性能计数器


81
00:04:05,579 --> 00:04:09,483 line:-2
在这个例子中是全透明情境
没有其它需要验证的东西


82
00:04:09,550 --> 00:04:11,652 line:-1
没有过度绘制 我们准备好继续了


83
00:04:11,952 --> 00:04:14,655 line:-2
我们也要求你们在你的游戏中
做类似的选择


84
00:04:14,721 --> 00:04:16,690 line:-1
并验证你也准备好继续了


85
00:04:17,624 --> 00:04:19,927 line:-1
那么让我们继续讲下一个最佳实践


86
00:04:21,862 --> 00:04:23,664 line:-1
提早提交GPU工作


87
00:04:26,133 --> 00:04:30,037 line:-1
提早安排好后台GPU工作非常重要


88
00:04:30,103 --> 00:04:33,173 line:-1
它将改善游戏的延迟性和响应性


89
00:04:33,240 --> 00:04:36,810 line:-1
并允许系统更好地适应工作量


90
00:04:37,444 --> 00:04:40,180 line:-1
因此 在帧中拥有多个GPU提交


91
00:04:40,247 --> 00:04:41,215 line:-1
非常重要


92
00:04:41,481 --> 00:04:44,852 line:-2
特别是你要在获得可绘制物之前
提早提交GPU


93
00:04:44,918 --> 00:04:49,723 line:-1
并且有些可绘制物会拖延渲染


94
00:04:50,390 --> 00:04:52,359 line:-1
当你在帧中获得可绘制物之后


95
00:04:52,426 --> 00:04:54,761 line:-1
最好是尽可能晚的获得它们


96
00:04:54,828 --> 00:04:58,031 line:-1
然后你就会出现延迟GPU提交


97
00:04:58,098 --> 00:05:00,300 line:-1
你需要安排好所有前台工作


98
00:05:00,367 --> 00:05:02,469 line:-1
潜在的有UI合成通道


99
00:05:03,470 --> 00:05:06,306 line:-2
因为要解释这个问题有点棘手
我准备了一个演示


100
00:05:06,707 --> 00:05:07,941 line:-1
因此让我们快速看一个演示


101
00:05:08,008 --> 00:05:10,978 line:-2
我会告诉你如何用Metal
系统追踪进行识别


102
00:05:11,044 --> 00:05:12,212 line:-1
（演示）


103
00:05:13,981 --> 00:05:14,815 line:-1
很酷


104
00:05:15,082 --> 00:05:17,918 line:-2
我们在这里看到的是
Afterpulse的一个帧


105
00:05:17,985 --> 00:05:21,321 line:-1
是我们去年在老版游戏上捕捉到的


106
00:05:21,655 --> 00:05:24,291 line:-1
这是用游戏性能模板捕捉到的


107
00:05:24,591 --> 00:05:26,493 line:-1
我们去年引入了这个模板


108
00:05:26,760 --> 00:05:29,663 line:-1
因此你已经熟悉其中一些工具了


109
00:05:29,963 --> 00:05:32,299 line:-1
今年我们新添加了热状态


110
00:05:32,566 --> 00:05:34,601 line:-1
以及Metal资源分配


111
00:05:34,668 --> 00:05:36,270 line:-1
我们稍后会讲到这个


112
00:05:36,803 --> 00:05:41,041 line:-1
现在我们主要讲潜在的问题


113
00:05:41,375 --> 00:05:43,644 line:-1
在这个例子中我们想查看显示面板


114
00:05:43,710 --> 00:05:46,947 line:-1
并了解底部是否有大量事件


115
00:05:47,014 --> 00:05:50,484 line:-2
界面显示在前台的时间
是否比预期时间要长


116
00:05:50,551 --> 00:05:52,786 line:-2
那么也许这是个问题
我们应该解决它


117
00:05:53,120 --> 00:05:56,023 line:-1
我们要做的就是进入其中一个区域


118
00:05:56,089 --> 00:05:58,325 line:-1
按住“选项”键


119
00:05:58,959 --> 00:06:02,062 line:-1
并在这个区域上拖动游标


120
00:06:03,363 --> 00:06:07,234 line:-2
那么在这个例子中
我们可以看到有两个帧


121
00:06:07,301 --> 00:06:10,470 line:-1
看起来比预期的要晚


122
00:06:11,171 --> 00:06:14,441 line:-2
同时GPU有很长时间都处于
闲置状态


123
00:06:14,775 --> 00:06:17,177 line:-1
那可能就是导致


124
00:06:17,244 --> 00:06:18,345 line:-1
我们正在尝试调试的问题的原因


125
00:06:18,412 --> 00:06:20,013 line:-1
那么让我们具体看一下


126
00:06:20,614 --> 00:06:24,318 line:-1
我们通过披露你已经熟悉的


127
00:06:24,384 --> 00:06:26,420 line:-2
Metal系统追踪中的
所有追踪来实现


128
00:06:26,954 --> 00:06:32,226 line:-2
我们在这里所看到的是
app是如何编码的


129
00:06:32,292 --> 00:06:34,995 line:-1
以及GPU如何处理这个工作


130
00:06:35,262 --> 00:06:37,264 line:-1
让我们聚焦于这个橘色帧


131
00:06:37,764 --> 00:06:38,632 line:-1
正如你在这里所看到的


132
00:06:38,699 --> 00:06:41,401 line:-1
app编码了大量工作


133
00:06:41,468 --> 00:06:44,104 line:-1
因此我们有阴影映像、延迟通道


134
00:06:44,671 --> 00:06:47,007 line:-1
以及部分全屏反光链等等


135
00:06:47,474 --> 00:06:48,308 line:-1
因此…


136
00:06:48,809 --> 00:06:51,345 line:-1
GPU实际上并没有处理那个工作


137
00:06:51,612 --> 00:06:53,046 line:-1
同时


138
00:06:53,347 --> 00:06:56,083 line:-1
可绘制物正在出现危机


139
00:06:56,149 --> 00:06:58,252 line:-2
因此这就是导致这个
闲置缺口的原因


140
00:06:58,685 --> 00:07:02,422 line:-2
但我们已经编码了一些工作
我们只是不能提交它


141
00:07:03,190 --> 00:07:05,259 line:-1
这就是最佳实践


142
00:07:05,692 --> 00:07:08,061 line:-1
你在获得可绘制物之前


143
00:07:08,128 --> 00:07:11,532 line:-1
提交全部提前编码的后台工作


144
00:07:11,865 --> 00:07:14,935 line:-1
因此 方案是执行一次GPU提交


145
00:07:15,269 --> 00:07:17,371 line:-1
请注意只有一次GPU提交


146
00:07:17,437 --> 00:07:20,240 line:-1
我们可以从这里的帧末端看到


147
00:07:20,307 --> 00:07:23,277 line:-1
所有GPU工作都发生在最后


148
00:07:24,444 --> 00:07:27,614 line:-1
谢天谢地 这个很容易解决


149
00:07:27,681 --> 00:07:30,250 line:-2
Digital Legends
其实已修复了它


150
00:07:30,317 --> 00:07:33,687 line:-2
让我们看看Afterpulse
的新追踪 看看它看起来怎么样


151
00:07:34,855 --> 00:07:36,723 line:-1
好的 那么 让我们具体来看


152
00:07:37,524 --> 00:07:40,594 line:-2
在这个例子中
我们可以看到没有闲置时间


153
00:07:40,661 --> 00:07:42,329 line:-1
当我们正在等待获得可绘制物时


154
00:07:42,829 --> 00:07:44,998 line:-2
因此让我们披露
来自Metal系统追踪的追踪


155
00:07:45,065 --> 00:07:46,233 line:-1
正如我们之前所做的那样


156
00:07:47,201 --> 00:07:49,536 line:-1
在这个例子中 我们可以看到GPU


157
00:07:49,903 --> 00:07:52,940 line:-1
正在处理我们在获得可绘制物之前


158
00:07:53,507 --> 00:07:55,642 line:-1
安排好的工作


159
00:07:56,310 --> 00:07:59,713 line:-1
因此在这个例子中 闲置时间较少


160
00:07:59,780 --> 00:08:02,983 line:-2
因此这就允许系统
更好地适应工作量


161
00:08:03,283 --> 00:08:04,785 line:-1
并且不会出现任何问题


162
00:08:05,953 --> 00:08:08,388 line:-2
做完这个操作之后
我们就知道我们已经准备好继续了


163
00:08:08,655 --> 00:08:12,559 line:-1
并且我们已经拥有多个GPU提交


164
00:08:12,960 --> 00:08:14,228 line:-1
并且不会导致任何拖延


165
00:08:14,294 --> 00:08:16,496 line:-2
因为我们在等待获取可绘制物之前
就实现了这个操作


166
00:08:16,563 --> 00:08:17,931 line:-1
让我们返回到幻灯片中


167
00:08:17,998 --> 00:08:19,166 line:-1
（演示）


168
00:08:19,733 --> 00:08:22,569 line:-1
好的 修复那个问题其实非常简单


169
00:08:22,636 --> 00:08:25,339 line:-1
比解释这个问题简单多了


170
00:08:25,906 --> 00:08:26,907 line:-1
我们要做的就是


171
00:08:26,974 --> 00:08:29,843 line:-2
简单地给每个帧
创建多个命令缓冲区


172
00:08:30,344 --> 00:08:32,479 line:-1
因此我们首先要创建命令缓冲区


173
00:08:32,546 --> 00:08:37,618 line:-2
来编码所有后台工作
那将作为提早的GPU提交


174
00:08:37,683 --> 00:08:42,054 line:-2
我们将委托命令缓冲区
然后等待下一个可绘制物


175
00:08:42,121 --> 00:08:43,624 line:-1
那将会拖延我们的线程


176
00:08:44,558 --> 00:08:48,896 line:-2
在我们获得可绘制物之后
我们将创建最后一个命令缓冲区


177
00:08:48,962 --> 00:08:51,365 line:-2
我们将在命令缓冲区中
编码所有前台工作


178
00:08:51,431 --> 00:08:52,833 line:-1
并呈现可绘制物


179
00:08:53,467 --> 00:08:56,737 line:-1
这将作为最后一次GPU提交


180
00:08:57,271 --> 00:08:59,606 line:-1
并且这还将确保帧的工作流程


181
00:08:59,673 --> 00:09:01,375 line:-1
真的足够好


182
00:09:02,976 --> 00:09:05,946 line:-2
就那么简单
只需要使用多个命令缓冲区即可


183
00:09:06,480 --> 00:09:08,849 line:-1
让我们继续看第四个最佳实践：


184
00:09:09,316 --> 00:09:11,118 line:-1
高效地传输资源


185
00:09:11,785 --> 00:09:14,054 line:-1
资源分配真的很占时间


186
00:09:14,454 --> 00:09:16,757 line:-1
并且从渲染线程中传输资源


187
00:09:16,823 --> 00:09:18,025 line:-1
可能会导致拖延


188
00:09:18,358 --> 00:09:21,094 line:-1
因此 这里的最佳实践是考虑内存


189
00:09:21,161 --> 00:09:24,665 line:-1
和资源传输算法的性能权衡


190
00:09:24,965 --> 00:09:28,602 line:-2
并确保你在启动时分配并加载
GPU资源


191
00:09:28,669 --> 00:09:31,305 line:-1
因为你不需要在运行时分配它们


192
00:09:31,905 --> 00:09:34,775 line:-1
任何需要在运行时传输的资源


193
00:09:34,842 --> 00:09:37,411 line:-1
请一定要在专用线程上这样做


194
00:09:37,744 --> 00:09:41,048 line:-1
这样做可以避免拖延 这非常重要


195
00:09:42,049 --> 00:09:44,284 line:-1
我们稍后再重新讲资源传输


196
00:09:44,351 --> 00:09:46,286 line:-1
在内存占用部分


197
00:09:46,353 --> 00:09:49,089 line:-1
以及重新评估内存和性能权衡


198
00:09:49,656 --> 00:09:53,760 line:-2
现在 让我们使用Metal
系统追踪来调整资源传输


199
00:09:54,494 --> 00:09:57,197 line:-1
今年我们新增加了分配追踪


200
00:09:57,464 --> 00:10:00,334 line:-2
那会为你显示每一个
资源分配的事件


201
00:10:00,400 --> 00:10:04,371 line:-2
以及同一时间线上
所有其他工具的分配


202
00:10:04,872 --> 00:10:07,474 line:-1
这将允许你识别


203
00:10:07,541 --> 00:10:10,010 line:-1
从主渲染线程上传输的


204
00:10:10,077 --> 00:10:11,945 line:-1
所有可能导致拖延的资源


205
00:10:12,012 --> 00:10:13,614 line:-1
（Metal系统追踪）


206
00:10:13,680 --> 00:10:16,984 line:-1
还有一个应该调整的东西即热感


207
00:10:17,351 --> 00:10:21,088 line:-2
这对于保持游戏的持久性能来说
非常重要


208
00:10:21,154 --> 00:10:23,991 line:-1
这会改善系统的整体温度


209
00:10:24,057 --> 00:10:26,960 line:-1
以及游戏的稳定性和响应性


210
00:10:27,494 --> 00:10:30,664 line:-1
最佳实践就是在严峻的热状态下


211
00:10:30,731 --> 00:10:32,399 line:-1
测试游戏


212
00:10:32,866 --> 00:10:36,637 line:-2
同时考虑针对这种严峻的热状态
调整游戏


213
00:10:36,703 --> 00:10:40,440 line:-1
因为那很有可能会帮助你了解热节流


214
00:10:40,507 --> 00:10:41,875 line:-1
（最佳实践）


215
00:10:41,942 --> 00:10:46,380 line:-2
今年我们在Xcode中新增加了
设备状况


216
00:10:46,446 --> 00:10:49,283 line:-1
那将允许你直接从设备的窗口中


217
00:10:49,616 --> 00:10:51,685 line:-1
设置严峻的热状态


218
00:10:52,586 --> 00:10:54,054 line:-1
在底部有一场演讲


219
00:10:54,121 --> 00:10:56,223 line:-1
我们将具体讲这个话题


220
00:10:56,290 --> 00:10:57,791 line:-1
我建议你们来参加


221
00:10:57,858 --> 00:10:59,026 line:-1
（设备状况）


222
00:10:59,893 --> 00:11:02,429 line:-1
我们还可以使用Xcode能量计


223
00:11:02,496 --> 00:11:05,432 line:-1
来验证设备运行时所处的热状态


224
00:11:05,966 --> 00:11:06,834 line:-1
在这个例子中


225
00:11:06,900 --> 00:11:10,003 line:-1
我们让设备处于严峻的热状态下运行


226
00:11:10,370 --> 00:11:11,839 line:-1
并且我们有效地验证了


227
00:11:11,905 --> 00:11:14,374 line:-1
设备正在陷入严峻的热状态


228
00:11:14,441 --> 00:11:16,944 line:-2
只需要数秒钟就可以
上升到那个温度


229
00:11:17,010 --> 00:11:17,845 line:-1
（Xcode能量计）


230
00:11:17,911 --> 00:11:21,081 line:-2
很酷 现在让我们继续
演讲的第二个部分


231
00:11:21,815 --> 00:11:24,751 line:-1
在这个部分中 我们会讲内存带宽


232
00:11:24,818 --> 00:11:26,220 line:-1
（内存带宽）


233
00:11:27,020 --> 00:11:28,989 line:-1
内存带宽非常重要


234
00:11:29,256 --> 00:11:31,859 line:-1
那是因为内存传输非常昂贵


235
00:11:32,159 --> 00:11:34,428 line:-1
它们消耗能量并产生热量


236
00:11:35,195 --> 00:11:36,663 line:-1
为了帮助减轻这种现象


237
00:11:36,930 --> 00:11:41,201 line:-2
iOS设备在CPU和GPU之间
拥有共享系统内存


238
00:11:41,502 --> 00:11:44,671 line:-2
以及GPU专用的
Tile Memory


239
00:11:45,339 --> 00:11:48,475 line:-1
Metal会帮助你对两者进行平衡


240
00:11:49,009 --> 00:11:52,379 line:-1
因此现在让我们从纹理开始看起


241
00:11:52,446 --> 00:11:53,313 line:-1
（纹理）


242
00:11:53,380 --> 00:11:56,683 line:-1
纹理采样很可能是游戏中


243
00:11:56,750 --> 00:11:57,651 line:-1
主要消耗带宽的功能


244
00:11:57,951 --> 00:12:01,655 line:-2
因此我们有一些最佳实践
从而让你正确地配置纹理


245
00:12:02,389 --> 00:12:03,223 line:-1
在这个部分中


246
00:12:03,290 --> 00:12:06,627 line:-1
我们要讲游戏资产的离线纹理压缩


247
00:12:06,994 --> 00:12:08,896 line:-1
GPU纹理压缩


248
00:12:08,962 --> 00:12:11,498 line:-1
以及如何选择正确的像素格式


249
00:12:11,932 --> 00:12:13,667 line:-1
让我们从纹理资产开始讲


250
00:12:13,734 --> 00:12:15,269 line:-1
（最佳实践）


251
00:12:15,335 --> 00:12:18,372 line:-1
压缩纹理资产非常重要


252
00:12:18,839 --> 00:12:22,809 line:-1
那是因为大纹理的采样效率可能很低


253
00:12:22,876 --> 00:12:25,312 line:-1
并且资产可能也是任意大


254
00:12:25,712 --> 00:12:27,614 line:-1
因此确保它们都被压缩了


255
00:12:27,881 --> 00:12:28,882 line:-1
并且


256
00:12:28,949 --> 00:12:32,286 line:-2
还为所有可能被缩小了的纹理
生成了纹理映射


257
00:12:32,986 --> 00:12:35,756 line:-1
让我们看一下纹理压缩如何节约内存


258
00:12:35,822 --> 00:12:37,024 line:-1
（纹理压缩的内存节约）


259
00:12:37,090 --> 00:12:39,826 line:-2
这是Afterpulse
最大纹理中的一个


260
00:12:40,460 --> 00:12:43,263 line:-1
如果我们不压缩这个纹理


261
00:12:43,664 --> 00:12:46,767 line:-2
它可能需要占用16MB的内存
才能加载出来


262
00:12:47,801 --> 00:12:51,371 line:-2
通过使用纹理压缩
我们可以把它降低到


263
00:12:51,438 --> 00:12:55,375 line:-1
小于3MB 包含完整的纹理映射链


264
00:12:55,876 --> 00:12:57,711 line:-1
那极大地节约了内存


265
00:12:58,512 --> 00:13:01,982 line:-2
但请注意 Afterpulse
使用了PVRTC


266
00:13:02,049 --> 00:13:06,320 line:-2
因为它在A7设备上运行
比如iPhone 5S


267
00:13:07,054 --> 00:13:10,691 line:-2
如果你的游戏投放范围是
较新的设备 请使用STC


268
00:13:10,757 --> 00:13:14,027 line:-2
因为它在图片品质方面
提供更好的压缩率


269
00:13:15,195 --> 00:13:17,865 line:-2
为了验证我们的资产是否进行了
正确的压缩


270
00:13:18,165 --> 00:13:20,000 line:-1
我们可以使用内存查看器


271
00:13:20,067 --> 00:13:20,968 line:-1
（Metal内存查看器）


272
00:13:21,034 --> 00:13:22,870 line:-2
Metal内存查看器
是个很棒的工具


273
00:13:22,936 --> 00:13:25,772 line:-2
我将在内存占用部分
对它进行完全介绍


274
00:13:26,139 --> 00:13:30,310 line:-2
现在我们要用它来检验
我们的全部资产


275
00:13:30,577 --> 00:13:34,448 line:-2
我们可以双重检验它们是否被压缩、
被映射以及看起来是否还不错


276
00:13:36,216 --> 00:13:41,655 line:-2
但对于那些不能提前压缩的纹理来说
会怎么样


277
00:13:42,122 --> 00:13:45,959 line:-2
比如渲染目标或运行时
生成的所有纹理？


278
00:13:46,026 --> 00:13:47,427 line:-1
（无损耗纹理压缩）


279
00:13:47,494 --> 00:13:50,797 line:-2
最新的iOS GPU
支持无损耗纹理压缩


280
00:13:51,131 --> 00:13:54,268 line:-2
允许GPU压缩纹理
用于实现较快的访问速度


281
00:13:55,569 --> 00:13:58,872 line:-1
因此 下一个最佳实践是优化纹理


282
00:13:58,939 --> 00:14:00,974 line:-1
从而GPU可以拥有较快的访问速度


283
00:14:01,642 --> 00:14:04,711 line:-1
正确地配置纹理非常重要


284
00:14:05,078 --> 00:14:07,514 line:-1
你可以使用私有存储模式


285
00:14:07,581 --> 00:14:10,517 line:-2
因此只有GPU拥有
对纹理数据的访问权限


286
00:14:10,584 --> 00:14:12,853 line:-1
并允许它对内容进行优化


287
00:14:12,920 --> 00:14:15,889 line:-1
同时 不要设置未知的使用标志


288
00:14:15,956 --> 00:14:20,460 line:-2
并避免设置不必要的使用标志
比如shaderWrite或pixelView


289
00:14:20,727 --> 00:14:23,130 line:-1
因为那些可能会禁用压缩功能


290
00:14:23,197 --> 00:14:24,231 line:-1
（最佳实践）


291
00:14:24,298 --> 00:14:27,968 line:-2
可通过CPU和GPU
访问的共享纹理


292
00:14:28,268 --> 00:14:32,906 line:-2
应该当每次CPU升级数据后
进行明确的优化


293
00:14:32,973 --> 00:14:34,908 line:-1
这也非常重要


294
00:14:35,175 --> 00:14:38,011 line:-2
让我们看看如何用几行代码
来实现这两个操作


295
00:14:38,812 --> 00:14:40,781 line:-1
真的只需要几行代码


296
00:14:41,048 --> 00:14:42,916 line:-1
要创建最优纹理


297
00:14:42,983 --> 00:14:45,185 line:-1
我们要把存储模式设为私有


298
00:14:45,252 --> 00:14:47,321 line:-1
因此只有GPU有访问权限


299
00:14:48,255 --> 00:14:53,694 line:-2
并且我们要设置
明显但却保守的使用标志


300
00:14:54,728 --> 00:14:57,998 line:-2
在这个例子中
我们要把纹理作为中间的渲染目标


301
00:14:58,065 --> 00:15:00,133 line:-1
从而我们不需要任何其它使用标志


302
00:15:01,702 --> 00:15:03,237 line:-1
但对于共享纹理来说怎么样呢？


303
00:15:03,971 --> 00:15:05,372 line:-1
嗯 那更加棘手


304
00:15:05,706 --> 00:15:09,776 line:-2
因此 CPU和GPU可共同访问
共享纹理


305
00:15:10,377 --> 00:15:13,614 line:-1
因此如果CPU更新了纹理的一部分


306
00:15:13,680 --> 00:15:15,315 line:-1
或任何纹理数据


307
00:15:16,216 --> 00:15:20,487 line:-2
我们可能需要明确要求GPU
优化它的内容


308
00:15:21,021 --> 00:15:22,523 line:-1
请注意这里有一个权衡


309
00:15:22,589 --> 00:15:25,459 line:-1
在CPU更新数据的次数


310
00:15:25,526 --> 00:15:28,662 line:-1
和GPU稍后需要访问它的次数之间


311
00:15:30,597 --> 00:15:33,634 line:-1
内存查看器实际上是一个很好的工具


312
00:15:33,700 --> 00:15:34,968 line:-1
它可以帮助我们解决这个问题


313
00:15:35,369 --> 00:15:38,372 line:-1
那是因为我们可以配置内存查看器


314
00:15:38,438 --> 00:15:42,075 line:-2
使其显示所有纹理的存储模式
和使用标志


315
00:15:42,543 --> 00:15:46,113 line:-2
从这一个屏幕上我们可以看到
压缩纹理


316
00:15:46,180 --> 00:15:49,783 line:-1
并识别所有纹理的配置都正确


317
00:15:50,417 --> 00:15:51,552 line:-1
它是个很棒的工具


318
00:15:52,519 --> 00:15:56,056 line:-2
从这点上来说我们几乎已经完成了
对纹理的配置


319
00:15:56,523 --> 00:15:59,126 line:-1
我们只需选择正确的像素格式即可


320
00:16:00,360 --> 00:16:03,130 line:-1
较大的像素格式使用较多的带宽


321
00:16:03,197 --> 00:16:05,132 line:-1
因此最佳实践就是


322
00:16:05,399 --> 00:16:08,502 line:-1
避免使用带有不必要频道的像素格式


323
00:16:08,802 --> 00:16:11,605 line:-1
并尽可能尝试降低精度


324
00:16:12,673 --> 00:16:14,808 line:-1
但请注意 采样率自身


325
00:16:14,875 --> 00:16:17,377 line:-1
也取决于像素格式


326
00:16:18,145 --> 00:16:21,348 line:-2
在这个例子中
我们可以看到像素格式如何


327
00:16:21,415 --> 00:16:23,984 line:-1
直接影响


328
00:16:24,051 --> 00:16:25,185 line:-1
GPU的纹理采样率


329
00:16:25,619 --> 00:16:30,858 line:-1
你要特别注意128位格式


330
00:16:30,924 --> 00:16:35,495 line:-2
比如RGBA 32位浮点型 因为
那是以四分之一的比率进行采样的


331
00:16:36,129 --> 00:16:40,100 line:-1
这些高精度格式经常用于噪音纹理


332
00:16:40,167 --> 00:16:42,769 line:-1
或为后处理效果查找表


333
00:16:44,404 --> 00:16:47,541 line:-2
再一次 我们可以使用内存观察器
来帮助我们解决那个问题


334
00:16:48,108 --> 00:16:50,277 line:-1
内存观察器将允许我们


335
00:16:50,344 --> 00:16:52,045 line:-1
按名称或像素格式筛选纹理


336
00:16:52,713 --> 00:16:57,050 line:-2
因此我们将验证
Metal Demo


337
00:16:57,117 --> 00:16:58,952 line:-1
对SSAO实施使用了16位格式


338
00:16:59,520 --> 00:17:01,989 line:-1
这对于噪音纹理来说非常重要


339
00:17:02,055 --> 00:17:02,956 line:-1
（Metal内存观察器）


340
00:17:03,023 --> 00:17:04,391 line:-1
还有一点要注意


341
00:17:05,157 --> 00:17:06,859 line:-1
在这个例子中


342
00:17:07,227 --> 00:17:09,930 line:-1
绝大多数纹理实际上是渲染目标


343
00:17:10,696 --> 00:17:14,667 line:-2
因此随着游戏变得越来越复杂
作为渲染目标使用的纹理


344
00:17:14,734 --> 00:17:17,538 line:-1
实际上可能会消耗大量带宽


345
00:17:17,604 --> 00:17:19,071 line:-1
让我们具体看一下


346
00:17:20,574 --> 00:17:23,810 line:-2
在这个部分中 我们将回顾
渲染路径加载和存储操作


347
00:17:24,178 --> 00:17:28,916 line:-2
密切关注MSAA并稍微提一下
Tile Memory


348
00:17:29,883 --> 00:17:33,220 line:-1
让我们从优化加载和存储操作开始讲


349
00:17:34,888 --> 00:17:38,625 line:-2
你应该避免加载或存储
不必要的渲染目标


350
00:17:39,359 --> 00:17:42,863 line:-2
渲染目标加载和存储操作
非常容易被忽略


351
00:17:42,930 --> 00:17:45,566 line:-1
但可能很快就会成为一个问题


352
00:17:45,999 --> 00:17:48,869 line:-1
请一定要检查它们


353
00:17:49,536 --> 00:17:51,438 line:-1
实际上很简单


354
00:17:51,505 --> 00:17:53,740 line:-1
只需要几行代码


355
00:17:54,474 --> 00:17:57,444 line:-2
在这个例子中
我们配置了一个渲染路径描述符


356
00:17:57,511 --> 00:18:00,113 line:-1
我们希望那个颜色缓冲区是临时的


357
00:18:00,180 --> 00:18:02,916 line:-2
意思就是我们不想从它里头
加载或存储任何东西


358
00:18:03,383 --> 00:18:07,354 line:-2
它与设置正确的加载和存储操作
一样简单


359
00:18:07,688 --> 00:18:11,391 line:-2
我们希望加载操作明确
从而以后不需要转换到


360
00:18:12,025 --> 00:18:13,327 line:-1
芯片级GPU


361
00:18:13,660 --> 00:18:17,331 line:-2
我们希望存储操作是
DontCare


362
00:18:17,664 --> 00:18:21,101 line:-1
因此不需要在渲染路径末端写入数据


363
00:18:21,502 --> 00:18:22,836 line:-1
就这些了


364
00:18:23,370 --> 00:18:25,305 line:-1
验证我们拥有对的东西


365
00:18:25,372 --> 00:18:26,707 line:-1
也非常简单


366
00:18:27,241 --> 00:18:29,076 line:-1
我们可以使用依存查看器


367
00:18:30,811 --> 00:18:34,882 line:-2
在这个例子中
Metal示例存储了颜色缓冲区


368
00:18:34,948 --> 00:18:36,650 line:-1
即使以后用不到了


369
00:18:37,251 --> 00:18:39,419 line:-1
依存查看器会显示一个问题图标


370
00:18:39,486 --> 00:18:40,988 line:-1
来突显这个问题


371
00:18:41,722 --> 00:18:44,291 line:-1
我们应该设置


372
00:18:44,358 --> 00:18:46,460 line:-2
在刚才的幻灯片上所看到的
DontCare存储操作


373
00:18:46,760 --> 00:18:48,195 line:-1
问题就解决了


374
00:18:48,529 --> 00:18:50,330 line:-1
真的就是这么简单


375
00:18:51,965 --> 00:18:54,101 line:-1
这对于多重采样的渲染目标来说


376
00:18:54,701 --> 00:18:56,837 line:-1
尤其重要


377
00:18:58,071 --> 00:19:00,741 line:-1
iOS设备的MSAA非常快


378
00:19:01,074 --> 00:19:04,178 line:-1
那是因为Tile Memory


379
00:19:04,244 --> 00:19:06,647 line:-1
不会消耗任何额外的带宽


380
00:19:07,314 --> 00:19:08,282 line:-1
这也允许我们


381
00:19:08,348 --> 00:19:11,518 line:-1
声明多重采样的纹理完全是临时的


382
00:19:11,852 --> 00:19:14,421 line:-2
事实上我们起初甚至不需要
让系统内存分配


383
00:19:14,488 --> 00:19:15,923 line:-1
对它进行备份


384
00:19:16,557 --> 00:19:19,226 line:-2
因此最佳实践是
仔细考虑MSAA的原生分辨率


385
00:19:19,293 --> 00:19:21,929 line:-1
因为效率很高


386
00:19:22,296 --> 00:19:26,133 line:-2
同时 一定不要加载或存储
多重采样纹理


387
00:19:26,700 --> 00:19:28,468 line:-1
因为你把多重采样纹理的存储模式


388
00:19:28,535 --> 00:19:30,938 line:-1
设为了不耗内存


389
00:19:31,772 --> 00:19:34,208 line:-1
我稍后会具体介绍不耗内存


390
00:19:34,274 --> 00:19:37,377 line:-2
现在让我们看看
如何配置多重采样纹理


391
00:19:37,444 --> 00:19:39,213 line:-1
以及它所使用的渲染路径


392
00:19:40,881 --> 00:19:43,851 line:-2
在这个例子中我们只需要设置
不耗内存存储模式


393
00:19:44,518 --> 00:19:47,554 line:-1
并确保渲染路径使用它


394
00:19:47,888 --> 00:19:50,891 line:-1
清理它的内容并丢弃采样


395
00:19:51,258 --> 00:19:54,962 line:-2
我们只希望从多重采样纹理中
解决问题


396
00:19:55,028 --> 00:19:56,463 line:-1
我们不需要存储它


397
00:19:56,530 --> 00:19:59,032 line:-1
我们不想存储中间数据


398
00:19:59,433 --> 00:20:02,469 line:-1
应该只存储最终解决的纹理


399
00:20:03,303 --> 00:20:05,939 line:-1
我们可以再一次使用依存查看器


400
00:20:06,006 --> 00:20:08,542 line:-1
来帮助我们验证我们做了正确的操作


401
00:20:10,143 --> 00:20:12,613 line:-2
在这个例子中
Metal示例正在加载


402
00:20:12,679 --> 00:20:16,650 line:-1
和启动多重采样纹理 损耗很大


403
00:20:17,518 --> 00:20:20,254 line:-2
在设置正确的标志之后
正如我刚才给你演示的那样


404
00:20:20,687 --> 00:20:27,194 line:-1
我们将节约超过85MB的内存带宽


405
00:20:27,261 --> 00:20:28,762 line:-1
以及内存占用


406
00:20:29,530 --> 00:20:33,200 line:-2
这对于验证多重采样缓冲区来说
非常重要


407
00:20:33,800 --> 00:20:34,635 line:-1
但请注意


408
00:20:35,202 --> 00:20:38,539 line:-1
产生这样的节约只因为


409
00:20:38,605 --> 00:20:41,642 line:-1
因为我们通过使用MSAA


410
00:20:42,209 --> 00:20:44,645 line:-1
暗中权衡Tile Memory


411
00:20:45,279 --> 00:20:49,383 line:-2
因此下一个最佳实践是
明确权衡Tile Memory


412
00:20:50,150 --> 00:20:53,420 line:-2
Metal针对某些功能提供
Tile Memory的访问权限


413
00:20:53,487 --> 00:20:57,524 line:-1
比如程控混合、图像块和扁平着色器


414
00:20:57,991 --> 00:21:01,795 line:-1
最佳实践就是明确利用它


415
00:21:02,095 --> 00:21:06,166 line:-1
特别是实施更先进的渲染技术


416
00:21:06,900 --> 00:21:08,635 line:-2
在使用Metal
执行现代化渲染演讲中


417
00:21:08,702 --> 00:21:12,206 line:-1
具体讲了其中一些技术


418
00:21:13,073 --> 00:21:16,210 line:-1
现在我们只快速了解一下延迟着色


419
00:21:16,276 --> 00:21:17,644 line:-1
（传统的延迟着色）


420
00:21:17,711 --> 00:21:21,315 line:-1
延迟着色被认为很消耗带宽


421
00:21:21,949 --> 00:21:25,485 line:-1
那是因为从传统上它要求app


422
00:21:25,552 --> 00:21:28,655 line:-2
存储集合图形信息
或G-Buffer


423
00:21:28,722 --> 00:21:32,392 line:-1
因为一组纹理代表许多像素属性


424
00:21:32,993 --> 00:21:36,296 line:-1
然后在第二光通道中采样那些纹理


425
00:21:36,563 --> 00:21:39,733 line:-1
最终颜色堆积在渲染目标中


426
00:21:40,300 --> 00:21:44,505 line:-2
请注意我们存储
再从G-Buffer加载全部数据


427
00:21:44,571 --> 00:21:47,374 line:-1
因此这就是为什么会消耗带宽的原因


428
00:21:48,375 --> 00:21:51,278 line:-1
iOS让你效率更高


429
00:21:52,713 --> 00:21:53,547 line:-1
（单一路径延迟着色）


430
00:21:53,614 --> 00:21:56,316 line:-1
在iOS上 我们可以权衡程控混合


431
00:21:56,383 --> 00:22:00,754 line:-1
它允许片段着色器


432
00:22:00,821 --> 00:22:02,089 line:-2
直接从Tile Memory
访问像素数据


433
00:22:02,656 --> 00:22:06,527 line:-2
这意味着G-buffer数据
可存储在Tile Memory上


434
00:22:06,593 --> 00:22:11,765 line:-2
并通过全部光积聚着色器在同一个
渲染路径中进行访问


435
00:22:12,165 --> 00:22:14,134 line:-1
它是个强大的功能


436
00:22:15,102 --> 00:22:18,272 line:-2
Digital Legends
已经使用了很多年


437
00:22:18,772 --> 00:22:22,042 line:-1
这就是通过依存查看器看到的


438
00:22:22,309 --> 00:22:24,444 line:-2
Afterpulse的
单一通道延迟渲染


439
00:22:24,511 --> 00:22:25,579 line:-1
很漂亮


440
00:22:25,879 --> 00:22:28,682 line:-2
四个G-Buffer缓冲区
是完全临时的


441
00:22:28,749 --> 00:22:31,485 line:-1
只存储了最终颜色和深度


442
00:22:31,552 --> 00:22:34,087 line:-1
不仅漂亮 而且高效


443
00:22:34,655 --> 00:22:37,124 line:-2
现在请让我们欢迎
Samuel上台来


444
00:22:37,191 --> 00:22:39,092 line:-1
演示依存查看器


445
00:22:39,159 --> 00:22:43,697 line:-1
（演示）


446
00:22:48,902 --> 00:22:49,803 line:-1
谢谢Guillem


447
00:22:50,103 --> 00:22:52,773 line:-2
我们刚才了解了老版的
Afterpulse


448
00:22:52,840 --> 00:22:54,975 line:-1
想看看是否可以进行一些优化


449
00:22:55,042 --> 00:22:57,477 line:-1
来改善它的性能


450
00:22:58,545 --> 00:23:02,416 line:-2
现在我要使用Metal
帧调试器中的依存查看器


451
00:23:02,482 --> 00:23:05,152 line:-2
来讲一下Guillem
刚才提到过的一些问题


452
00:23:06,920 --> 00:23:09,790 line:-2
要开始 让我们点击
CommandBuffer


453
00:23:09,857 --> 00:23:11,592 line:-1
打开依存查看器


454
00:23:15,128 --> 00:23:18,065 line:-1
依存查看器给我们显示了


455
00:23:18,131 --> 00:23:19,499 line:-1
由app编码的所有GPU通道


456
00:23:20,901 --> 00:23:23,804 line:-2
我们可以看到Afterpulse
有一个CommandBuffer


457
00:23:24,137 --> 00:23:26,840 line:-1
并以渲染阴影图开始它的帧


458
00:23:27,341 --> 00:23:28,876 line:-1
然后是相位延迟


459
00:23:30,310 --> 00:23:32,613 line:-1
这会注入亮度计算


460
00:23:32,880 --> 00:23:35,315 line:-1
粒子模拟和布尔链


461
00:23:35,883 --> 00:23:38,285 line:-1
并由最终屏幕通道使用


462
00:23:39,520 --> 00:23:42,055 line:-1
今年依存压缩器变得更紧凑了


463
00:23:42,122 --> 00:23:43,023 line:-1
如果你有群


464
00:23:43,423 --> 00:23:45,759 line:-1
那从高层级看帧如何被渲染


465
00:23:45,826 --> 00:23:47,294 line:-1
非常简单


466
00:23:47,995 --> 00:23:51,832 line:-2
我们甚至可以更深入到任意群
如果我们想了解更多详情的话


467
00:23:52,366 --> 00:23:56,670 line:-2
因此 实际上这个布尔链
其实是12通道的


468
00:23:58,939 --> 00:24:00,707 line:-1
现在依存查看器是查找


469
00:24:00,774 --> 00:24:02,943 line:-2
Guillem刚提到过的
某些问题的好地方


470
00:24:03,243 --> 00:24:05,846 line:-2
并且我们可以在这个
最终屏幕通道上看到一些问题


471
00:24:06,613 --> 00:24:09,483 line:-1
让我们点击问题图标查找更多问题


472
00:24:11,552 --> 00:24:14,254 line:-2
看起来与
Guillem之前提到过的


473
00:24:14,321 --> 00:24:15,856 line:-1
一个加载存储操作问题很像


474
00:24:16,456 --> 00:24:18,659 line:-1
他们已经把存储操作设置为存储


475
00:24:19,059 --> 00:24:21,528 line:-1
但他们没有在帧中再次使用这个纹理


476
00:24:22,062 --> 00:24:25,866 line:-2
因此这个问题建议我们
应该把它设为DontCare


477
00:24:26,333 --> 00:24:29,570 line:-2
然后我们将节约差不多14MB
内存带宽


478
00:24:29,837 --> 00:24:31,471 line:-1
针对这两个联合的纹理


479
00:24:33,140 --> 00:24:37,044 line:-2
今年我们把这个过程变得更简单了
可以从图表中查找所有问题


480
00:24:37,611 --> 00:24:40,747 line:-1
只需要点击右下方的新问题按钮


481
00:24:40,814 --> 00:24:42,082 line:-1
即可获得一个问题列表


482
00:24:46,453 --> 00:24:48,288 line:-2
Guillem刚才提到的
另一个最佳实践是


483
00:24:48,355 --> 00:24:50,958 line:-1
选择正确的像素格式


484
00:24:51,525 --> 00:24:55,329 line:-2
因此今年在iOS上
我们引入了新的16深度格式


485
00:24:55,929 --> 00:24:59,900 line:-2
让我们使用新搜索来查找
32深度纹理


486
00:25:03,270 --> 00:25:06,373 line:-1
看起来它们占用了36MB内存


487
00:25:06,440 --> 00:25:07,875 line:-1
针对阴影图纹理


488
00:25:08,509 --> 00:25:12,479 line:-2
因此当Digital Legends团队
在WWDC结束返回巴塞罗那后


489
00:25:12,546 --> 00:25:17,451 line:-2
他们研究使用这个新格式
可能会节约一半的内存


490
00:25:17,518 --> 00:25:19,486 line:-1
如果他们的阴影需求允许的话


491
00:25:20,721 --> 00:25:22,789 line:-1
如果我们继续通过图表进行搜索


492
00:25:23,423 --> 00:25:26,727 line:-1
你可以看到由大量潜在的内存节约


493
00:25:28,228 --> 00:25:31,164 line:-2
如果你使用Metal帧调试器中的
依存查看器


494
00:25:31,231 --> 00:25:35,502 line:-2
来查找和诊断老版
Afterpulse中的一些问题


495
00:25:36,103 --> 00:25:37,004 line:-1
Digital Legends


496
00:25:37,070 --> 00:25:39,306 line:-1
其实已经做了一些改善


497
00:25:39,373 --> 00:25:40,607 line:-1
让我们快速看一下


498
00:25:42,509 --> 00:25:43,644 line:-1
我们可以立即看到


499
00:25:43,710 --> 00:25:45,879 line:-1
它们现在使用了多个命令缓冲区


500
00:25:46,346 --> 00:25:48,949 line:-2
那么这将修复Guillem
之前展示给我们的问题


501
00:25:49,016 --> 00:25:52,119 line:-2
CPU因为要等待下一个可绘制物
而被阻塞


502
00:25:52,186 --> 00:25:53,520 line:-1
而GPU处于闲置状态


503
00:25:54,855 --> 00:25:56,990 line:-1
如果我们具体看一下最终屏幕通道


504
00:25:57,891 --> 00:26:00,527 line:-2
我们可以看到他们已经修复了
存储操作问题


505
00:26:01,395 --> 00:26:04,665 line:-2
事实上
因为这两个纹理是完全临时的


506
00:26:04,731 --> 00:26:07,000 line:-2
并且他们已经把存储模式设置为
不耗内存


507
00:26:07,367 --> 00:26:09,870 line:-1
他们将不使用任何系统内存


508
00:26:11,004 --> 00:26:15,909 line:-2
因此 依存真的是一个
开始调试渲染管线的好地方


509
00:26:16,476 --> 00:26:19,813 line:-2
舞台交还给Guillem
他会继续讲


510
00:26:19,880 --> 00:26:22,216 line:-1
关于优化app内存占用的最佳实践


511
00:26:28,188 --> 00:26:29,857 line:-1
（演示）


512
00:26:29,923 --> 00:26:31,792 line:-1
谢谢Sam 演示很棒


513
00:26:31,859 --> 00:26:34,328 line:-1
我希望你们也可以使用依存查看器


514
00:26:35,262 --> 00:26:38,198 line:-2
很酷 那么让我们继续进入
演讲的最后一个部分


515
00:26:38,498 --> 00:26:39,633 line:-1
内存占用


516
00:26:39,933 --> 00:26:40,767 line:-1
（内存占用）


517
00:26:40,834 --> 00:26:43,003 line:-1
内存占用其实对于你的游戏来说


518
00:26:43,070 --> 00:26:43,971 line:-1
非常重要


519
00:26:44,671 --> 00:26:48,809 line:-2
那是因为iOS强制执行
严格的app内存限制


520
00:26:48,876 --> 00:26:52,346 line:-1
以便保持系统在app上的响应性


521
00:26:52,412 --> 00:26:53,580 line:-1
（app内存限制）


522
00:26:53,981 --> 00:26:55,849 line:-1
有些人可能已经注意到了


523
00:26:55,916 --> 00:27:00,053 line:-2
iOS 12在内存计算方面
做了一些改变


524
00:27:00,787 --> 00:27:04,191 line:-2
计算方式的修改影响了绝大多数
Metal资源


525
00:27:04,958 --> 00:27:07,661 line:-1
Metal资源 比如缓冲区或纹理


526
00:27:07,928 --> 00:27:10,898 line:-1
也许是大多数app的内存占用


527
00:27:10,964 --> 00:27:14,368 line:-2
因此衡量游戏的内存占用对你来说
非常重要


528
00:27:14,935 --> 00:27:17,771 line:-1
你可以使用Xcode内存计


529
00:27:17,838 --> 00:27:18,672 line:-1
（Xcode 11）


530
00:27:18,739 --> 00:27:22,376 line:-2
Xcode内存计
会报告系统所测量的


531
00:27:22,442 --> 00:27:25,812 line:-1
游戏的内存占用的数值


532
00:27:26,380 --> 00:27:30,284 line:-1
用它来验证游戏的状态非常重要


533
00:27:31,151 --> 00:27:35,122 line:-1
今年它还将显示app内存限制


534
00:27:35,422 --> 00:27:37,224 line:-2
如果游戏所占用的内存
接近所限制的内存的话


535
00:27:38,892 --> 00:27:41,628 line:-1
但如果我们想特别关注


536
00:27:42,162 --> 00:27:44,731 line:-2
我们的Metal资源所使用的内存
怎么办？


537
00:27:46,800 --> 00:27:49,570 line:-1
今年我们引入了内存查看器


538
00:27:50,470 --> 00:27:53,207 line:-2
我们把它添加到
Metal帧调试器中了


539
00:27:53,273 --> 00:27:54,241 line:-1
（Metal内存查看器）


540
00:27:54,308 --> 00:27:56,610 line:-1
内存查看器自身有两个部分


541
00:27:56,910 --> 00:27:59,179 line:-1
第一部分是顶部的条形图


542
00:27:59,646 --> 00:28:05,719 line:-2
显示按类别显示资源
比如按类型、存储模式和用法


543
00:28:06,253 --> 00:28:08,255 line:-1
我们还可以用这个条形图


544
00:28:08,755 --> 00:28:11,091 line:-1
在最大的资源中进行快速导航


545
00:28:11,158 --> 00:28:13,827 line:-1
并在显示时把它们突显出来


546
00:28:14,695 --> 00:28:17,064 line:-1
第二部分是底部有一个表


547
00:28:17,331 --> 00:28:20,000 line:-1
显示我们所筛选的资源


548
00:28:20,701 --> 00:28:24,471 line:-1
它包含资源类型的一些专有属性


549
00:28:24,538 --> 00:28:27,441 line:-1
比如纹理的像素格式和分辨率


550
00:28:28,041 --> 00:28:30,344 line:-1
底部还有一个筛选条


551
00:28:30,611 --> 00:28:33,413 line:-1
可以帮助你做进一步的筛选


552
00:28:33,914 --> 00:28:37,651 line:-2
它是个强大的工具
我们希望你可以利用它


553
00:28:37,718 --> 00:28:41,622 line:-1
来了解全部GPU资源的内存占用


554
00:28:43,023 --> 00:28:47,060 line:-2
同时 我们今年引入的另一个
强大的工具是


555
00:28:47,127 --> 00:28:49,930 line:-1
Metal资源分配工具


556
00:28:49,997 --> 00:28:51,031 line:-1
（Metal资源分配工具）


557
00:28:51,098 --> 00:28:52,900 line:-1
它有三个不同的组成部分：


558
00:28:53,800 --> 00:28:55,769 line:-1
Metal资源分配追踪


559
00:28:55,836 --> 00:28:59,206 line:-1
显示游戏的当前Metal内存占用


560
00:29:00,007 --> 00:29:01,608 line:-1
分配追踪


561
00:29:01,675 --> 00:29:05,345 line:-2
针对每个资源分配和再分配
显示一个事件


562
00:29:05,412 --> 00:29:07,047 line:-1
以及一些信息


563
00:29:08,348 --> 00:29:10,450 line:-1
还有详情表视图


564
00:29:10,517 --> 00:29:14,421 line:-1
显示所捕捉到的所有分配的更多信息


565
00:29:15,155 --> 00:29:19,293 line:-1
这些工具都很强大 让你很好地了解


566
00:29:19,626 --> 00:29:23,931 line:-2
游戏中的内存占用概况
以及内存占用如何随时间改变


567
00:29:25,232 --> 00:29:27,968 line:-1
但有些人还要求添加其它功能


568
00:29:28,268 --> 00:29:31,371 line:-2
特别是其中有一个功能
你们已经要求很久了


569
00:29:31,672 --> 00:29:34,041 line:-1
今年我要很高兴地向大家宣布


570
00:29:34,107 --> 00:29:38,011 line:-2
我们有基于C的API
用于在运行时查询可用的内存


571
00:29:38,579 --> 00:29:42,216 line:-1
这会让你的游戏更有效地传输资源


572
00:29:42,282 --> 00:29:45,252 line:-1
并避免内存尖峰


573
00:29:45,319 --> 00:29:48,755 line:-2
内存尖峰将导致游戏
超出app内存限制


574
00:29:48,822 --> 00:29:50,023 line:-1
（可用的内存）


575
00:29:50,090 --> 00:29:52,793 line:-2
今年我们引入的
另一个很酷的API是


576
00:29:52,860 --> 00:29:54,995 line:-1
设备上的GPU捕捉


577
00:29:55,262 --> 00:29:58,532 line:-1
允许你以编程方式触发GPU捕捉


578
00:29:58,832 --> 00:30:01,068 line:-1
不需要Xcode


579
00:30:01,435 --> 00:30:04,905 line:-2
我们认为它对处于QA过程的
游戏测试人员来说是个理想的工具


580
00:30:05,439 --> 00:30:06,273 line:-1
要启动它


581
00:30:06,540 --> 00:30:09,910 line:-2
你只需要向info.plist中添加
MetalCaptureEnabled即可


582
00:30:09,977 --> 00:30:11,144 line:-1
非常简单


583
00:30:11,211 --> 00:30:12,045 line:-1
（设备上的GPU捕捉）


584
00:30:12,112 --> 00:30:17,584 line:-2
现在让我们看看如何把这两个API
结合到一些代码中


585
00:30:18,719 --> 00:30:21,121 line:-1
在这个例子中我们想检查


586
00:30:21,188 --> 00:30:23,457 line:-2
app所占用的内存
是否接近内存限制


587
00:30:23,524 --> 00:30:25,325 line:-1
也许由于内存尖峰


588
00:30:25,726 --> 00:30:27,661 line:-1
捕捉到游戏的GPU追踪


589
00:30:27,728 --> 00:30:30,364 line:-2
因此我们可以使用内存查看器
来充分调试它


590
00:30:30,764 --> 00:30:31,798 line:-1
让我们开始吧


591
00:30:32,132 --> 00:30:35,903 line:-2
首先我们要检查app的内存占用
是否接近内存限制


592
00:30:36,770 --> 00:30:37,671 line:-1
如果接近


593
00:30:37,738 --> 00:30:40,474 line:-1
我们要捕捉下一个帧


594
00:30:41,074 --> 00:30:44,545 line:-2
我们只会进行正常渲染
跟不接近时一样


595
00:30:45,712 --> 00:30:48,448 line:-2
在这一个帧结束后
如果我们捕捉到它了


596
00:30:48,849 --> 00:30:52,286 line:-1
我们会停止捕捉并处理GPU追踪


597
00:30:52,352 --> 00:30:54,955 line:-1
由你来决定如何处理GPU追踪


598
00:30:55,489 --> 00:30:58,992 line:-1
潜在地 你可能还想退出游戏


599
00:30:59,059 --> 00:31:01,728 line:-1
或禁用这个会话的GPU捕捉


600
00:31:01,795 --> 00:31:05,299 line:-2
因为你可能不想在那点上
捕捉每一个帧


601
00:31:06,233 --> 00:31:10,270 line:-2
这会为你提供一个
利用两个API的好方式


602
00:31:10,604 --> 00:31:13,173 line:-1
比如进一步深究内存占用


603
00:31:13,240 --> 00:31:16,243 line:-1
那很棒 因此让我们来做一下吧


604
00:31:16,310 --> 00:31:19,479 line:-1
让我们看一下如何减少内存占用


605
00:31:19,813 --> 00:31:22,816 line:-1
为此 我们还有一堆最佳实践


606
00:31:23,517 --> 00:31:27,154 line:-2
在这部分我们要讲
不耗内存的渲染目标


607
00:31:27,221 --> 00:31:28,322 line:-1
资源传输


608
00:31:28,956 --> 00:31:32,826 line:-2
再提一下游戏资产
以及内存密集型效果


609
00:31:33,393 --> 00:31:36,563 line:-1
让我们从不耗内存的渲染目标开始讲


610
00:31:36,630 --> 00:31:37,664 line:-1
（最佳实践）


611
00:31:37,731 --> 00:31:40,868 line:-2
这大概就是我们在讲
内存带宽部分时的位置吧


612
00:31:42,102 --> 00:31:46,507 line:-2
请注意系统内存上不加载或存储
临时渲染目标


613
00:31:47,474 --> 00:31:51,345 line:-1
因此它们实际上不需要系统内存分配


614
00:31:51,879 --> 00:31:54,214 line:-2
这就是为什么你应该使用
不耗内存的存储模式的原因


615
00:31:54,581 --> 00:31:57,584 line:-2
特别是对于
所有多重采样的缓冲区来说


616
00:31:58,318 --> 00:32:01,788 line:-2
让我们看看该如何实现 再一次
只需要几行代码


617
00:32:03,123 --> 00:32:03,957 line:-1
在这个例子中


618
00:32:04,024 --> 00:32:07,294 line:-2
与给纹理描述符设置不耗内存
一样简单


619
00:32:07,895 --> 00:32:09,863 line:-1
并且我们要确保


620
00:32:09,930 --> 00:32:13,767 line:-1
渲染通道把渲染目标配置为完全临时


621
00:32:14,067 --> 00:32:14,968 line:-1
在这个例子中


622
00:32:15,235 --> 00:32:17,371 line:-1
我们把G-Buffer配置为临时


623
00:32:17,437 --> 00:32:20,107 line:-1
我们只需要把加载操作设置为清理


624
00:32:20,174 --> 00:32:21,808 line:-2
并把存储操作设置为
DontCare


625
00:32:22,075 --> 00:32:24,178 line:-1
因此我们没有存储G-Buffer


626
00:32:25,512 --> 00:32:29,850 line:-2
我们可以通过Afterpulse再看看
Digital Legends是如何实现的


627
00:32:30,517 --> 00:32:33,854 line:-2
在顶部我们可以看到
老版的Afterpulse


628
00:32:34,555 --> 00:32:39,059 line:-2
它有临时G-Buffer
但系统内存对它进行了备份


629
00:32:40,160 --> 00:32:41,094 line:-1
在底部


630
00:32:41,161 --> 00:32:45,899 line:-2
我们看到新版Afterpulse
实际上有个较大的G-Buffer


631
00:32:47,000 --> 00:32:49,803 line:-2
但这个G-Buffer
是完全临时的


632
00:32:49,870 --> 00:32:53,674 line:-1
这一次系统内存没有对它进行备份


633
00:32:53,740 --> 00:32:56,176 line:-2
他们对所有中间的
G-Buffer缓冲区


634
00:32:56,577 --> 00:32:58,846 line:-1
都使用了不耗内存存储模式


635
00:32:59,413 --> 00:33:02,382 line:-2
这很棒
因为新版Afterpulse


636
00:33:02,716 --> 00:33:06,153 line:-1
节约了大概60MB的内存占用


637
00:33:06,220 --> 00:33:08,121 line:-1
仅通过设置那一个标志


638
00:33:08,755 --> 00:33:09,590 line:-1
太棒了


639
00:33:10,090 --> 00:33:12,292 line:-1
并且没有做出任何妥协


640
00:33:12,626 --> 00:33:15,796 line:-1
这儿什么也没少 也没有任何权衡


641
00:33:15,863 --> 00:33:17,798 line:-1
它就是起作用了 很棒


642
00:33:18,498 --> 00:33:21,101 line:-2
那么现在让我们继续看
余下的最佳实践


643
00:33:21,168 --> 00:33:22,536 line:-1
（最佳实践）


644
00:33:22,603 --> 00:33:25,539 line:-1
其中一些涉及


645
00:33:25,939 --> 00:33:29,810 line:-2
内存和性能权衡
或内存和图片品质权衡


646
00:33:30,344 --> 00:33:33,013 line:-2
在这个例子中
我们要返回到资源传输


647
00:33:34,081 --> 00:33:36,583 line:-1
请注意 把所有资产都加载到内存中


648
00:33:36,650 --> 00:33:38,452 line:-1
将增加内存占用


649
00:33:38,519 --> 00:33:41,622 line:-1
因此你应该考虑内存和性能的权衡


650
00:33:42,055 --> 00:33:44,925 line:-2
并只加载全部你知道的
将被使用的资产


651
00:33:44,992 --> 00:33:47,194 line:-1
特别是当你接近内存限制时


652
00:33:48,028 --> 00:33:50,864 line:-1
并且你可能还想释放所有资源


653
00:33:50,931 --> 00:33:53,667 line:-1
一旦不再使用它们


654
00:33:53,734 --> 00:33:56,270 line:-1
潜在的比如启动画面或教程UI


655
00:33:56,336 --> 00:33:58,038 line:-1
都是很好的例子


656
00:33:59,339 --> 00:34:01,508 line:-1
这个决定很困难


657
00:34:01,942 --> 00:34:05,512 line:-2
幸运的是内存查看器会帮助我们处理
它是个很棒的工具


658
00:34:05,579 --> 00:34:06,847 line:-1
（Metal内存查看器）


659
00:34:06,914 --> 00:34:11,118 line:-2
我们可以使用筛选器快速查找
不用的资源


660
00:34:11,952 --> 00:34:15,121 line:-1
通过这样的操作会更新底部的表


661
00:34:15,188 --> 00:34:17,591 line:-1
然后我们可以查看在这个帧中


662
00:34:17,658 --> 00:34:19,426 line:-1
不使用的所有资源


663
00:34:20,159 --> 00:34:23,397 line:-1
在本场演讲的最后Onyechi


664
00:34:23,463 --> 00:34:24,797 line:-2
会在内存查看器的演示中
具体讲这个


665
00:34:25,666 --> 00:34:28,467 line:-2
那么现在让我们继续看
第14个最佳实践


666
00:34:28,969 --> 00:34:30,737 line:-1
使用较小的资产


667
00:34:32,039 --> 00:34:35,676 line:-1
事实上你应该只在必要时扩充资产


668
00:34:36,275 --> 00:34:39,179 line:-1
并再次考虑资产尺寸的图像品质


669
00:34:39,246 --> 00:34:40,746 line:-1
和内存权衡


670
00:34:40,813 --> 00:34:43,684 line:-1
确保既压缩了纹理又压缩了网格


671
00:34:44,217 --> 00:34:46,853 line:-1
潜在地 如果你接近了内存限制


672
00:34:47,321 --> 00:34:49,022 line:-1
你可能希望只加载


673
00:34:49,289 --> 00:34:51,625 line:-1
较小的纹理映射等级


674
00:34:52,292 --> 00:34:54,628 line:-1
或较低的网格LOD


675
00:34:56,096 --> 00:34:58,131 line:-1
但这里有一个权衡


676
00:34:58,198 --> 00:35:00,067 line:-1
在图像品质和内存之间


677
00:35:00,133 --> 00:35:03,370 line:-1
由你来决定何时采取这种操作


678
00:35:04,805 --> 00:35:08,342 line:-2
下一个最佳实践
第15个最佳实践与上一个很相似


679
00:35:09,209 --> 00:35:12,679 line:-1
我们想简化内存密集型效果


680
00:35:14,047 --> 00:35:17,084 line:-1
有些效果需要大的后台缓冲区


681
00:35:17,484 --> 00:35:19,620 line:-1
比如阴影图和SSAO


682
00:35:20,354 --> 00:35:21,321 line:-1
因此最佳实践是


683
00:35:21,388 --> 00:35:24,658 line:-1
考虑所有效果的


684
00:35:24,725 --> 00:35:26,059 line:-1
图像品质和内存权衡


685
00:35:27,094 --> 00:35:30,731 line:-2
潜在地
降低所有大的后台缓冲区的分辨率


686
00:35:31,298 --> 00:35:33,500 line:-1
并且如果你接近内存限制


687
00:35:33,767 --> 00:35:36,303 line:-1
就同时禁用全部效果


688
00:35:37,471 --> 00:35:41,175 line:-2
这要做出权衡
并且你需要意识到这个问题


689
00:35:41,241 --> 00:35:43,143 line:-1
但有时候我们没有其它选择


690
00:35:44,845 --> 00:35:47,981 line:-1
我们要将的下一个最佳实践


691
00:35:48,048 --> 00:35:49,516 line:-1
稍微有点不一样


692
00:35:50,117 --> 00:35:52,119 line:-1
在这个最后一部分中


693
00:35:52,553 --> 00:35:55,389 line:-1
我要介绍一些更先进的概念


694
00:35:55,455 --> 00:35:58,859 line:-1
从而帮助我们进一步减少内存占用


695
00:35:59,493 --> 00:36:02,029 line:-1
我们会讲到Metal资源堆积


696
00:36:03,564 --> 00:36:06,733 line:-1
可清除的内存以及管线状态对象


697
00:36:07,901 --> 00:36:10,204 line:-1
让我们从Metal资源堆积开始讲


698
00:36:10,270 --> 00:36:11,171 line:-1
（Metal资源堆积）


699
00:36:11,238 --> 00:36:13,507 line:-1
Metal资源堆积将允许app


700
00:36:13,574 --> 00:36:17,845 line:-1
明确控制在前台发生的


701
00:36:17,911 --> 00:36:19,213 line:-1
大的内存分配


702
00:36:19,980 --> 00:36:23,250 line:-2
在这个例子中
我们要把三个单独的纹理


703
00:36:23,317 --> 00:36:24,918 line:-1
它们分别有自己的分配


704
00:36:25,285 --> 00:36:29,056 line:-2
放到一个Metal资源堆积中
它是一个分配


705
00:36:29,122 --> 00:36:31,825 line:-1
那会分别包含这三个纹理


706
00:36:32,526 --> 00:36:35,996 line:-2
这还将允许系统把那些纹理
打包到一起


707
00:36:36,063 --> 00:36:38,065 line:-1
从而节约一些内存


708
00:36:38,899 --> 00:36:39,733 line:-1
（最佳实践）


709
00:36:39,800 --> 00:36:45,372 line:-1
但最节约内存的是使用别名


710
00:36:46,106 --> 00:36:50,544 line:-2
请注意渲染帧可能需要
大量的中间内存


711
00:36:50,978 --> 00:36:54,481 line:-1
特别是你的游戏向内扩展后处理管线


712
00:36:55,048 --> 00:36:57,885 line:-2
因此针对那些效果使用
Metal资源堆积


713
00:36:57,951 --> 00:37:01,922 line:-1
并尽可能地使用别名非常重要


714
00:37:02,356 --> 00:37:06,126 line:-2
比如你可能想针对
所有没有依存关系的资源


715
00:37:06,193 --> 00:37:07,761 line:-1
重新使用内存


716
00:37:08,262 --> 00:37:11,999 line:-2
潜在地 比如在SSAO
和景深效果中找到的那些


717
00:37:13,667 --> 00:37:16,170 line:-1
现在让我们看看那看起来如何


718
00:37:16,537 --> 00:37:19,239 line:-1
在这个例子中 我们拥有


719
00:37:19,306 --> 00:37:20,207 line:-1
跟以前一样的Metal资源堆积


720
00:37:21,074 --> 00:37:24,611 line:-1
但如果没有同时使用那三个纹理


721
00:37:24,678 --> 00:37:26,480 line:-1
我们可以潜在地给它们取个别名


722
00:37:26,813 --> 00:37:29,283 line:-1
通过这样做 我们会节约大量内存


723
00:37:30,150 --> 00:37:33,153 line:-1
这真的会帮助你的游戏


724
00:37:33,220 --> 00:37:36,023 line:-1
形成更复杂的后处理管线


725
00:37:36,356 --> 00:37:40,961 line:-1
而不需要为所有中间的渲染目标


726
00:37:41,028 --> 00:37:42,596 line:-1
和所有中间的内存付出巨大的代价


727
00:37:43,263 --> 00:37:46,800 line:-2
因此它是个很棒的功能
你应该考虑权衡


728
00:37:46,867 --> 00:37:47,935 line:-1
（Metal资源堆积）


729
00:37:48,001 --> 00:37:50,337 line:-1
现在让我们谈谈另一个先进概念


730
00:37:50,404 --> 00:37:52,105 line:-1
即可清除的内存


731
00:37:52,172 --> 00:37:53,207 line:-1
（可清除的内存）


732
00:37:53,273 --> 00:37:55,442 line:-1
可清除的内存有三个状态：


733
00:37:55,976 --> 00:37:59,546 line:-1
非易失性、易失性和空


734
00:38:00,514 --> 00:38:03,617 line:-1
请注意易失性和空分配


735
00:38:03,684 --> 00:38:07,120 line:-1
不计入app的内存占用


736
00:38:07,855 --> 00:38:09,223 line:-1
那是因为系统


737
00:38:09,289 --> 00:38:11,692 line:-1
可以在某个时刻回收那个内存


738
00:38:11,758 --> 00:38:13,160 line:-1
如果是易失性情况的话


739
00:38:13,460 --> 00:38:17,130 line:-2
或者之前已经回收它了
如果是空的情况的话


740
00:38:17,197 --> 00:38:19,833 line:-1
因此你可能需要重新生成那些资源


741
00:38:21,068 --> 00:38:25,506 line:-1
但使得这种内存非常合适资源缓存


742
00:38:26,707 --> 00:38:31,078 line:-2
因此最佳实践 第17个范例就是
把资源标记为易失性资源


743
00:38:31,645 --> 00:38:34,448 line:-1
易失性资源可能会占用


744
00:38:34,515 --> 00:38:35,849 line:-1
游戏的内存占用的大部分


745
00:38:36,917 --> 00:38:40,153 line:-2
并且Metal允许你
明确管理那些资源


746
00:38:40,220 --> 00:38:43,891 line:-1
明确设置所有资源的可清除状态


747
00:38:44,658 --> 00:38:47,060 line:-1
因此你要注意缓存


748
00:38:47,394 --> 00:38:50,597 line:-2
特别是占用绝大部分闲置内存的
那些缓存


749
00:38:50,898 --> 00:38:53,333 line:-1
并谨慎管理它们的可清除状态


750
00:38:53,700 --> 00:38:56,203 line:-2
从而使它们不计入
游戏的内存占用之内


751
00:38:56,970 --> 00:39:00,040 line:-1
让我们来看一段很短的代码


752
00:39:00,474 --> 00:39:02,576 line:-1
那会给你提供一个如何实现的例示例


753
00:39:03,010 --> 00:39:07,080 line:-2
在这个例子中 我们有纹理缓存
也可以是缓冲区缓存


754
00:39:08,115 --> 00:39:10,484 line:-2
我们要把那个缓存中
所有纹理的可清除状态


755
00:39:10,551 --> 00:39:16,123 line:-2
设置为易失性 因为我们知道
那个缓存多数时候是限制状态


756
00:39:16,190 --> 00:39:20,127 line:-2
我们偶尔只使用一个纹理
但不是太经常


757
00:39:21,228 --> 00:39:23,830 line:-2
因此如果我们需要使用
那个缓存中的资源


758
00:39:24,231 --> 00:39:26,900 line:-1
我们需要把它标记为非易失性


759
00:39:27,267 --> 00:39:31,104 line:-1
那将确保系统不会移除它的备份数据


760
00:39:32,172 --> 00:39:34,341 line:-1
在这个例子中 它是空


761
00:39:34,641 --> 00:39:38,045 line:-1
就是我们刚才讲到过的一个状态


762
00:39:38,545 --> 00:39:41,081 line:-1
我们实际上可能需要重新生成数据


763
00:39:41,715 --> 00:39:42,616 line:-1
可能不需要生成


764
00:39:42,683 --> 00:39:45,118 line:-1
取决于你所管理的缓存类型


765
00:39:45,452 --> 00:39:46,687 line:-1
但在我们这样做之后


766
00:39:47,087 --> 00:39:50,457 line:-2
我们就可以正常使用资源
就和不为空时一样


767
00:39:52,226 --> 00:39:56,063 line:-1
还有一个很好的范例就是


768
00:39:56,129 --> 00:39:59,633 line:-1
查看公共缓冲区的完成情况


769
00:40:00,300 --> 00:40:03,537 line:-1
并当公共缓冲区完成后就着手处理


770
00:40:03,604 --> 00:40:05,072 line:-1
潜在地


771
00:40:05,873 --> 00:40:08,141 line:-1
再一次把那个资源标记为易失性


772
00:40:08,475 --> 00:40:11,545 line:-1
因此它不会计入你的内存占用内


773
00:40:12,479 --> 00:40:16,116 line:-2
你可以非常明确地执行 并且事实上
你应该很有侵略性


774
00:40:16,183 --> 00:40:20,053 line:-2
特别是当你有大量多数时候
是闲置内存的缓存时


775
00:40:21,588 --> 00:40:26,527 line:-2
那么让我们介绍最后一个概念
即管线状态对象


776
00:40:26,593 --> 00:40:27,427 line:-1
（管线状态对象(PSO)）


777
00:40:27,494 --> 00:40:29,596 line:-1
大多数人已经很熟悉那些了


778
00:40:29,897 --> 00:40:33,534 line:-2
PSO封装大部分
Metal渲染状态


779
00:40:34,268 --> 00:40:36,537 line:-1
它们由描述符构建


780
00:40:36,603 --> 00:40:39,239 line:-1
包含顶点函数和片段函数


781
00:40:39,606 --> 00:40:42,509 line:-1
以及其它状态 比如混合状态


782
00:40:42,776 --> 00:40:44,211 line:-1
和顶点描述符


783
00:40:45,012 --> 00:40:48,515 line:-2
所有这些都被编译到
最终的Metal PSO中


784
00:40:49,650 --> 00:40:53,987 line:-2
我们只需要用这个最终的
Metal PSO进行渲染


785
00:40:54,688 --> 00:40:58,725 line:-2
因此下一个最佳实践是
明确地对它们进行权衡


786
00:40:59,459 --> 00:41:01,261 line:-1
因为Metal允许你的app


787
00:41:01,328 --> 00:41:03,964 line:-1
提前加载大多数渲染状态


788
00:41:04,031 --> 00:41:05,098 line:-1
你也应该这样做


789
00:41:05,365 --> 00:41:07,334 line:-1
那会很大地提高性能


790
00:41:07,935 --> 00:41:10,971 line:-2
然后 如果你那样做
就要考虑内存权衡


791
00:41:11,638 --> 00:41:16,610 line:-1
如果你的内存有限


792
00:41:16,910 --> 00:41:19,079 line:-2
一定不要抓住那些
不再需要的PSO引用不放


793
00:41:19,613 --> 00:41:21,481 line:-1
并且这一点也很重要


794
00:41:21,548 --> 00:41:26,653 line:-2
不要在你创建PSO缓存之后
还抓住Metal函数引用不放


795
00:41:26,920 --> 00:41:31,124 line:-2
因为渲染不再需要它们了
只有创建新PSO需要它们


796
00:41:32,292 --> 00:41:35,495 line:-2
让我们通过再看一下描述符
来解释一下


797
00:41:36,063 --> 00:41:37,831 line:-1
这是管线状态对象


798
00:41:37,898 --> 00:41:40,300 line:-1
以及管线状态对象描述符


799
00:41:40,367 --> 00:41:42,669 line:-1
并且这个最佳实践就是


800
00:41:43,136 --> 00:41:46,406 line:-1
在你创建PSO之后


801
00:41:46,473 --> 00:41:48,475 line:-1
释放顶点函数和片段函数的引用


802
00:41:48,542 --> 00:41:51,578 line:-1
潜在地 仅抓住那些当在加载时


803
00:41:51,912 --> 00:41:54,081 line:-1
填充主PSO缓存的那些引用


804
00:41:54,882 --> 00:41:58,418 line:-1
然后也要考虑释放PSO自身


805
00:41:58,485 --> 00:42:00,420 line:-1
当你的内存接近内存限制时


806
00:42:00,487 --> 00:42:03,056 line:-1
如果你知道不再需要那个PSO的话


807
00:42:04,591 --> 00:42:09,162 line:-2
现在请欢迎Onyechi上台来
做一个关于内存查看器的演示


808
00:42:09,229 --> 00:42:12,366 line:-1
（演示）


809
00:42:15,569 --> 00:42:17,838 line:-1
谢谢Guillem 大家好


810
00:42:19,239 --> 00:42:21,608 line:-2
你们已经从之前的幻灯片中
大概了解了


811
00:42:21,675 --> 00:42:23,443 line:-1
内存查看器


812
00:42:23,810 --> 00:42:27,114 line:-2
现在我要给你们演示
如何使用它了解内存占用


813
00:42:27,381 --> 00:42:29,516 line:-2
这是为了获得更好的内存性能
而进行的优化


814
00:42:31,618 --> 00:42:33,787 line:-1
在这里我们再一次捕获


815
00:42:33,854 --> 00:42:37,224 line:-2
来自Afterpulse早期版本
的这个帧


816
00:42:37,791 --> 00:42:39,893 line:-1
然后左上方有调试导航器


817
00:42:39,960 --> 00:42:41,695 line:-1
你可以找到一个新的内存计


818
00:42:42,396 --> 00:42:43,664 line:-1
当我点击它时


819
00:42:44,331 --> 00:42:45,832 line:-1
它会把我带入内存查看器中


820
00:42:46,834 --> 00:42:49,770 line:-1
这给我们显示了所捕捉的帧的


821
00:42:49,837 --> 00:42:50,904 line:-1
所有活跃的Metal资源


822
00:42:51,405 --> 00:42:54,775 line:-1
我的目标是找机会减少它的内存占用


823
00:42:55,475 --> 00:42:56,343 line:-1
因此开始


824
00:42:56,944 --> 00:42:59,213 line:-1
让我们先看看图表中的橘色条


825
00:42:59,813 --> 00:43:02,749 line:-2
这些显示了资源是如何
按类型进行分配的


826
00:43:03,350 --> 00:43:06,520 line:-2
我们可以看到纹理构成了最大的部分
对吗？


827
00:43:07,154 --> 00:43:09,423 line:-1
大概有440MB


828
00:43:09,489 --> 00:43:11,225 line:-1
现在我想关注这些部分


829
00:43:11,291 --> 00:43:14,928 line:-1
我可以通过点击筛选按钮实现


830
00:43:16,096 --> 00:43:19,266 line:-1
现在图标和表都已经更新了


831
00:43:19,333 --> 00:43:20,567 line:-1
只显示纹理


832
00:43:21,635 --> 00:43:23,170 line:-1
那么接下来 Guillem提到了


833
00:43:23,237 --> 00:43:25,205 line:-1
当查看如何减少内存占用时


834
00:43:25,806 --> 00:43:29,476 line:-2
要从未使用的资源开始
那是个不错的地方


835
00:43:29,543 --> 00:43:30,377 line:-1
因此


836
00:43:30,677 --> 00:43:32,846 line:-2
让我们实现它吧
这一次让我们看一下蓝色条


837
00:43:34,147 --> 00:43:35,949 line:-1
它代表我们的使用


838
00:43:36,383 --> 00:43:38,352 line:-1
并且我们看到我们有大约200MB


839
00:43:38,418 --> 00:43:39,753 line:-1
那么是不用的纹理


840
00:43:40,487 --> 00:43:42,422 line:-1
因此作为提醒


841
00:43:43,023 --> 00:43:46,159 line:-2
不使用的资源是指不会对这个
所渲染的帧的最终输出


842
00:43:46,226 --> 00:43:47,661 line:-1
做出贡献的资源


843
00:43:48,028 --> 00:43:50,297 line:-1
那意味着GPU不能访问它们


844
00:43:51,765 --> 00:43:52,599 line:-1
好的


845
00:43:52,900 --> 00:43:56,036 line:-2
那么我可以再一次
通过点击不用的筛选器实现


846
00:43:56,103 --> 00:43:58,338 line:-1
我们现在正在看的就是不用的纹理


847
00:43:59,640 --> 00:44:02,309 line:-2
接下来我会按所分配的尺寸
对表进行分类


848
00:44:02,643 --> 00:44:04,711 line:-1
从而我们只关注最大的纹理


849
00:44:05,746 --> 00:44:08,482 line:-1
并且我们可以立刻看到最大的纹理


850
00:44:08,549 --> 00:44:11,618 line:-1
是大约13MB 有一个问题


851
00:44:12,186 --> 00:44:14,755 line:-1
这里的问题与你在之前的演示中的


852
00:44:14,821 --> 00:44:16,456 line:-1
依存查看器中的问题差不多


853
00:44:16,723 --> 00:44:18,525 line:-1
让我们点击它来查看它是关于什么的


854
00:44:20,360 --> 00:44:22,863 line:-2
好的 那么它说我们有一个
大的不用的纹理


855
00:44:23,497 --> 00:44:25,199 line:-1
CPU不对它进行访问


856
00:44:25,566 --> 00:44:27,835 line:-1
并且从未被绑定到命令编码器中


857
00:44:28,302 --> 00:44:31,171 line:-1
以避免加载资源


858
00:44:31,238 --> 00:44:32,873 line:-1
或把它变为易失性资源


859
00:44:33,774 --> 00:44:36,710 line:-2
我们还可以有另一种解决方式
就是查看属性、


860
00:44:36,777 --> 00:44:39,213 line:-1
CPU访问和自上次绑定之后的时间


861
00:44:39,513 --> 00:44:42,850 line:-1
我们可以明显看到这部分绝对没有


862
00:44:42,916 --> 00:44:45,118 line:-1
被CPU或GPU访问过


863
00:44:45,419 --> 00:44:46,820 line:-1
因此我们可以自信地说


864
00:44:46,887 --> 00:44:49,556 line:-1
这是一个应该被释放的资源


865
00:44:49,623 --> 00:44:50,891 line:-1
除非我们实际需要它


866
00:44:52,059 --> 00:44:53,026 line:-1
好的 这非常鼓舞人心


867
00:44:53,093 --> 00:44:56,330 line:-2
我们会非常迅速的节约
13MB的内存


868
00:44:57,097 --> 00:44:58,465 line:-1
让我们查看下一个问题


869
00:44:59,967 --> 00:45:02,169 line:-1
在这个例子中 纹理被识别为


870
00:45:02,236 --> 00:45:03,770 line:-1
临时资源


871
00:45:03,837 --> 00:45:05,506 line:-1
CPU不对它进行访问


872
00:45:05,572 --> 00:45:07,407 line:-1
并且在过去的47秒内


873
00:45:07,474 --> 00:45:09,142 line:-1
它从未被绑定到命令编码器上


874
00:45:09,710 --> 00:45:12,412 line:-2
因此换句话说
这个纹理在过去的47秒内


875
00:45:12,479 --> 00:45:15,082 line:-1
没有使用这个帧或任意其它帧


876
00:45:15,516 --> 00:45:18,051 line:-2
因此这是一个
应该被标记为易失性的资源


877
00:45:18,118 --> 00:45:20,754 line:-1
如果可以的话


878
00:45:20,821 --> 00:45:23,190 line:-1
因为它只是偶尔对帧做贡献


879
00:45:23,790 --> 00:45:25,192 line:-1
好的 这非常好


880
00:45:27,394 --> 00:45:32,699 line:-2
我们非常迅速地找回了
14MB的内存


881
00:45:34,201 --> 00:45:37,137 line:-1
的确 当我们要减少内存占用时


882
00:45:37,204 --> 00:45:40,107 line:-1
查看不用的资源是个良好的开端


883
00:45:40,374 --> 00:45:42,442 line:-1
并且问题会帮助你快速识别


884
00:45:42,509 --> 00:45:44,211 line:-1
最需要移除的资源


885
00:45:44,978 --> 00:45:47,347 line:-1
但你还应该注意一下属性


886
00:45:47,981 --> 00:45:50,150 line:-1
自上次启动之后的时间


887
00:45:50,951 --> 00:45:52,753 line:-1
来了解哪个不用的资源


888
00:45:52,819 --> 00:45:54,788 line:-1
从未被提交给GPU


889
00:45:54,855 --> 00:45:57,457 line:-1
即使CPU可能会对它们进行访问


890
00:45:59,193 --> 00:46:00,661 line:-1
好的 让我们换个话题吧


891
00:46:01,161 --> 00:46:03,297 line:-2
看看我们可以发现哪些问题
或节约哪些内存


892
00:46:03,363 --> 00:46:06,700 line:-1
当纹理在使用中时


893
00:46:07,768 --> 00:46:09,636 line:-2
好的 这一次我要切换到
使用的筛选器


894
00:46:09,703 --> 00:46:11,371 line:-1
从而我们可以查看使用的纹理


895
00:46:11,939 --> 00:46:13,841 line:-1
我们可以看到其中一个最大的纹理


896
00:46:13,907 --> 00:46:16,677 line:-1
大约是18MB 有两个问题


897
00:46:17,344 --> 00:46:18,679 line:-1
让我们来看看分别是什么


898
00:46:20,247 --> 00:46:22,783 line:-1
好的 第一个是关于无损压缩


899
00:46:23,417 --> 00:46:25,686 line:-1
纹理选择退出无损压缩


900
00:46:25,752 --> 00:46:28,488 line:-2
由于ShaderWrite
使用标记的存在


901
00:46:28,989 --> 00:46:31,959 line:-1
即使它被唯一地用作渲染目标


902
00:46:32,960 --> 00:46:35,395 line:-1
第二个问题是关于存储模式


903
00:46:36,530 --> 00:46:40,133 line:-2
我们的纹理 即渲染目标
被识别为临时的纹理


904
00:46:40,400 --> 00:46:42,503 line:-1
很明显意味着针对这个纹理


905
00:46:42,569 --> 00:46:43,871 line:-1
没有任何加载或存储操作


906
00:46:44,171 --> 00:46:46,874 line:-1
但很遗憾 它有共享的存储模式


907
00:46:46,940 --> 00:46:48,809 line:-1
当它真的应该是不耗内存的时候


908
00:46:49,877 --> 00:46:52,746 line:-1
我们在这里有两个不同的推荐


909
00:46:53,547 --> 00:46:56,650 line:-2
如果你思考一下
我们只需要从中选一个就好


910
00:46:57,584 --> 00:47:00,687 line:-2
但在这一点上
我应该强调这两个推荐


911
00:47:00,754 --> 00:47:02,256 line:-1
都由内存查看器提供


912
00:47:02,322 --> 00:47:05,292 line:-1
都是基于把数据收集到当前帧中


913
00:47:05,926 --> 00:47:09,229 line:-2
然而 你更清楚
你打算如何在当前帧之外


914
00:47:09,296 --> 00:47:10,631 line:-1
使用你的资源


915
00:47:11,431 --> 00:47:12,833 line:-1
因此


916
00:47:13,534 --> 00:47:16,370 line:-2
如果我们确定这个纹理
将保持临时状态


917
00:47:16,737 --> 00:47:18,939 line:-1
比如将来的渲染通道


918
00:47:19,006 --> 00:47:21,642 line:-2
然后切换到不耗内存状态
这是更好选项


919
00:47:21,708 --> 00:47:24,344 line:-1
这样会减少纹理尺寸的内存占用


920
00:47:24,411 --> 00:47:26,947 line:-1
即18MB


921
00:47:27,681 --> 00:47:29,149 line:-1
如果 在另一方面


922
00:47:29,216 --> 00:47:33,453 line:-2
我们的纹理在将来的渲染通道中
不是临时状态了


923
00:47:33,820 --> 00:47:37,457 line:-2
那么我们应该认真考虑
选择不耗内存压缩


924
00:47:37,824 --> 00:47:39,860 line:-2
因为那样会对我们的内存带宽
产生积极影响


925
00:47:39,927 --> 00:47:42,296 line:-1
刚才Guillem曾建议过


926
00:47:43,163 --> 00:47:43,997 line:-1
在这个例子中


927
00:47:44,331 --> 00:47:46,800 line:-2
移除冗余的
ShaderWrite标记


928
00:47:46,867 --> 00:47:47,868 line:-1
就可以了


929
00:47:49,636 --> 00:47:50,470 line:-1
那么


930
00:47:51,972 --> 00:47:54,174 line:-1
我们只是披露了用内存查看器


931
00:47:54,241 --> 00:47:55,209 line:-1
可能实现的一部分功能


932
00:47:55,509 --> 00:47:57,110 line:-2
你已经了解如何使用它
仅通过几次鼠标点击


933
00:47:57,177 --> 00:47:59,346 line:-1
它可以让你轻松地


934
00:47:59,413 --> 00:48:00,514 line:-1
了解你的内存使用情况


935
00:48:00,581 --> 00:48:03,483 line:-1
同时它还可以让你快速识别


936
00:48:03,550 --> 00:48:06,353 line:-2
那些可能会影响你的性能的
很难发现的问题


937
00:48:06,920 --> 00:48:08,655 line:-1
然后我要欢迎Guillem


938
00:48:08,722 --> 00:48:09,623 line:-1
回到舞台上来


939
00:48:09,957 --> 00:48:10,791 line:-1
谢谢


940
00:48:15,362 --> 00:48:17,798 line:-2
谢谢Onyechi
那是一个很棒的演示


941
00:48:17,865 --> 00:48:18,765 line:-1
（演示）


942
00:48:18,832 --> 00:48:19,666 line:-1
很酷


943
00:48:19,733 --> 00:48:23,237 line:-1
那么我们今天讲了很多最佳实践


944
00:48:23,303 --> 00:48:24,137 line:-1
我们…


945
00:48:24,571 --> 00:48:26,173 line:-1
总共讲了18个


946
00:48:26,240 --> 00:48:28,775 line:-1
内容真的非常多


947
00:48:29,409 --> 00:48:33,180 line:-2
请注意大部分最佳实践
实际上都很有关联 对吧？


948
00:48:33,247 --> 00:48:36,250 line:-1
绝大部分内存带宽最佳实践


949
00:48:36,316 --> 00:48:39,219 line:-1
还会帮助你减少内存占用


950
00:48:39,887 --> 00:48:40,721 line:-1
因此…


951
00:48:41,054 --> 00:48:44,858 line:-1
也许思考所有这些内容的最佳方式


952
00:48:45,359 --> 00:48:49,396 line:-2
是这个针对你的Metal游戏
或app的优化清单


953
00:48:50,364 --> 00:48:55,102 line:-1
当你认真思考每一个元素时


954
00:48:55,435 --> 00:48:59,339 line:-2
你一定会提交
优化的Metal游戏和app


955
00:48:59,406 --> 00:49:02,142 line:-1
这就是本场演讲所讲的内容


956
00:49:03,377 --> 00:49:06,647 line:-2
要获取更多信息
请查看我们的在线文档


957
00:49:06,947 --> 00:49:09,583 line:-1
并在今天下午3点参加我们的演讲


958
00:49:10,450 --> 00:49:13,253 line:-2
非常感谢
我希望你们享受接下来的会议


959
00:49:13,320 --> 00:49:14,154 line:-1
谢谢

