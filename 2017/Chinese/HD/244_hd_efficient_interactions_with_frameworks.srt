1
00:00:17,551 --> 00:00:21,154 line:10%
<c.magenta>（通过框架性能案例研究</c>
<c.magenta>实现高效率交互）</c>


2
00:00:24,591 --> 00:00:26,360 line:90%,end
<c.magenta>大家下午好</c>
<c.magenta>我是菲力浦豪斯勒</c>


3
00:00:26,426 --> 00:00:28,662 line:90%,end
<c.magenta>今天 我和我的同事</c>
<c.magenta>唐娜汤姆一起</c>


4
00:00:28,729 --> 00:00:31,865 line:90%,end
<c.magenta>和大家一起讨论</c>
<c.magenta>如何使用框架实现高效率交互</c>


5
00:00:32,566 --> 00:00:35,769 line:90%,end
<c.magenta>如今 我们所有人</c>
<c.magenta>都非常关心性能问题</c>


6
00:00:35,903 --> 00:00:37,538 line:90%,end
<c.magenta>我们希望笔记本电脑飞速运行</c>


7
00:00:37,604 --> 00:00:40,807 line:90%,end
<c.magenta>希望我们的手机和平板电脑</c>
<c.magenta>支持一整天的使用时间</c>


8
00:00:41,175 --> 00:00:43,777 line:90%,end
<c.magenta>期待我们的桌面电脑</c>
<c.magenta>具有强大的性能</c>


9
00:00:43,977 --> 00:00:44,945 line:90%,end
<c.magenta>事实上</c>


10
00:00:45,045 --> 00:00:47,648 line:90%,end
<c.magenta>所有这些设备</c>
<c.magenta>都应该具备良好的性能</c>


11
00:00:48,081 --> 00:00:50,651 line:90%,end
<c.magenta>我们的任务是</c>
<c.magenta>努力实现这个目标</c>


12
00:00:52,252 --> 00:00:54,188 line:90%,end
<c.magenta>我们需要从不同维度来评价性能</c>


13
00:00:54,254 --> 00:00:57,457 line:90%,end
<c.magenta>例如 代码的运行速度</c>
<c.magenta>程序耗用的电量</c>


14
00:00:57,658 --> 00:00:59,960 line:90%,end
<c.magenta>以及内存占用大小等</c>


15
00:01:00,394 --> 00:01:01,795 line:10%
<c.magenta>由于具有多个不同的维度</c>


16
00:01:01,862 --> 00:01:03,931 line:10%
<c.magenta>我们如何使用图形</c>
<c.magenta>来更好地进行描述呢？</c>


17
00:01:04,697 --> 00:01:06,967 line:90%,end
<c.magenta>这里有一个框架</c>


18
00:01:07,234 --> 00:01:09,670 line:90%,end
<c.magenta>进行形象化描述</c>
<c.magenta>你可以将它视为一个图表</c>


19
00:01:09,903 --> 00:01:12,906 line:90%,end
<c.magenta>其中的一个轴</c>
<c.magenta>表示你所处理的数据量</c>


20
00:01:13,140 --> 00:01:14,908 line:90%,end
<c.magenta>另一个轴表示处理频率</c>


21
00:01:16,009 --> 00:01:19,746 line:90%,end
<c.magenta>如果你需要处理大量的数据</c>
<c.magenta>而且代码运行非常频繁</c>


22
00:01:20,047 --> 00:01:22,516 line:90%,end
<c.magenta>那么其性能水平</c>
<c.magenta>将会位于第一象限</c>


23
00:01:22,649 --> 00:01:27,654 line:90%,end
<c.magenta>这样的话很有可能会</c>
<c.magenta>对性能造成很大的影响</c>


24
00:01:27,888 --> 00:01:31,758 line:90%,end
<c.magenta>你需要花费大量的时间</c>
<c.magenta>来进行优化</c>


25
00:01:32,492 --> 00:01:34,161 line:90%,end
<c.magenta>但是 如果你处理的</c>


26
00:01:34,228 --> 00:01:37,464 line:90%,end
<c.magenta>数据量比较小</c>
<c.magenta>而且代码运行次数较低</c>


27
00:01:37,531 --> 00:01:39,600 line:90%,end
<c.magenta>那么性能水平</c>
<c.magenta>将会位于第三象限</c>


28
00:01:39,766 --> 00:01:41,068 line:90%,end
<c.magenta>老实说</c>


29
00:01:41,335 --> 00:01:43,170 line:90%,end
<c.magenta>你并不希望</c>
<c.magenta>花费很多的时间</c>


30
00:01:43,237 --> 00:01:44,805 line:90%,end
<c.magenta>来优化性能</c>


31
00:01:45,539 --> 00:01:49,476 line:90%,end
<c.magenta>第二象限和第四象限</c>
<c.magenta>的情况有点复杂</c>


32
00:01:49,710 --> 00:01:51,078 line:90%,end
<c.magenta>它们的性能水平</c>


33
00:01:51,144 --> 00:01:53,347 line:90%,end
<c.magenta>在很大程度上</c>
<c.magenta>取决于具体的情况</c>


34
00:01:53,413 --> 00:01:54,348 line:90%,end
<c.magenta>在这些情况下</c>


35
00:01:54,414 --> 00:02:00,053 line:90%,end
<c.magenta>你希望能够结合实际应用</c>
<c.magenta>来评估性能水平</c>


36
00:02:00,254 --> 00:02:01,755 line:90%,end
<c.magenta>然后 根据性能指标</c>


37
00:02:01,822 --> 00:02:04,124 line:90%,end
<c.magenta>来确定是否值得花时间</c>


38
00:02:04,191 --> 00:02:05,626 line:90%,end
<c.magenta>进行修改</c>


39
00:02:07,694 --> 00:02:09,596 line:90%,end
<c.magenta>在本版本中 我们深入地研究</c>


40
00:02:09,663 --> 00:02:12,032 line:90%,end
<c.magenta>确保我们能够理解</c>
<c.magenta>该如何在整个操作系统中</c>


41
00:02:12,099 --> 00:02:13,534 line:90%,end
<c.magenta>优化性能</c>


42
00:02:13,700 --> 00:02:15,235 line:90%,end
<c.magenta>对于应用开发也是如此</c>


43
00:02:15,903 --> 00:02:18,005 line:90%,end
<c.magenta>我们对Foundation</c>
<c.magenta>进行了一些</c>


44
00:02:18,071 --> 00:02:19,540 line:90%,end
<c.magenta>非常重要的改变</c>


45
00:02:20,274 --> 00:02:23,177 line:90%,end
<c.magenta>当然</c>
<c.magenta>Swift也是本版本的主要部分</c>


46
00:02:23,343 --> 00:02:26,246 line:90%,end
<c.magenta>我们进行大量的工作</c>
<c.magenta>以保证一些Foundation类型</c>


47
00:02:26,313 --> 00:02:27,848 line:90%,end
<c.magenta>之间的桥接</c>


48
00:02:28,015 --> 00:02:32,219 line:90%,end
<c.magenta>以提升它们的运行速度</c>
<c.magenta>在你们的应用中更好地工作</c>


49
00:02:33,687 --> 00:02:37,024 line:90%,end
<c.magenta>现在 许多应用</c>
<c.magenta>大量使用字符串</c>


50
00:02:37,090 --> 00:02:40,027 line:90%,end
<c.magenta>它们被用作口令</c>
<c.magenta>作为易于识读的数据格式</c>


51
00:02:40,093 --> 00:02:41,728 line:90%,end
<c.magenta>显示在屏幕上</c>


52
00:02:42,062 --> 00:02:44,064 line:90%,end
<c.magenta>高效率的字符串处理</c>


53
00:02:44,298 --> 00:02:46,600 line:90%,end
<c.magenta>对于提升应用性能具有很大意义</c>


54
00:02:46,700 --> 00:02:49,503 line:90%,end
<c.magenta>作为关键性内容的</c>
<c.magenta>字符串占有很大的比例</c>


55
00:02:49,570 --> 00:02:51,205 line:90%,end
<c.magenta>显示给用户</c>


56
00:02:52,139 --> 00:02:54,208 line:90%,end
<c.magenta>当然</c>
<c.magenta>今天的演讲</c>


57
00:02:54,341 --> 00:02:56,643 line:90%,end
<c.magenta>是为了帮助你们提升应用运行速度</c>


58
00:02:56,743 --> 00:02:58,245 line:90%,end
<c.magenta>你们想要减少资源占用</c>


59
00:02:58,445 --> 00:03:00,447 line:90%,end
<c.magenta>使用更少的资源</c>
<c.magenta>来完成更多的工作</c>


60
00:03:00,514 --> 00:03:03,984 line:90%,end
<c.magenta>不要着急</c>
<c.magenta>后面我们将会详细论述</c>


61
00:03:04,051 --> 00:03:06,019 line:90%,end
<c.magenta>今天 我们将会</c>
<c.magenta>进行讨论</c>


62
00:03:06,353 --> 00:03:10,357 line:90%,end
<c.magenta>并为你们介绍一些</c>
<c.magenta>性能优化技巧</c>


63
00:03:11,592 --> 00:03:14,761 line:90%,end
<c.magenta>前面我说过</c>
<c.magenta>我们在整个操作系统范围内</c>


64
00:03:14,828 --> 00:03:16,363 line:90%,end
<c.magenta>进行大量的性能优化</c>


65
00:03:16,563 --> 00:03:19,266 line:90%,end
<c.magenta>在Foundation中</c>
<c.magenta>我们进行一些不错的改变</c>


66
00:03:19,399 --> 00:03:21,668 line:90%,end
<c.magenta>让我们来看一些代表性例子</c>


67
00:03:22,369 --> 00:03:25,138 line:90%,end
<c.magenta>我们对NSCalendar日期枚举</c>
<c.magenta>进行重大更改</c>


68
00:03:25,272 --> 00:03:29,343 line:90%,end
<c.magenta>不仅减少内存占用</c>
<c.magenta>而且加快速度</c>


69
00:03:29,810 --> 00:03:31,044 line:90%,end
<c.magenta>在以前</c>


70
00:03:31,111 --> 00:03:34,882 line:90%,end
<c.magenta>很难进行</c>
<c.magenta>正确的日历计算</c>


71
00:03:35,182 --> 00:03:39,186 line:90%,end
<c.magenta>经过更新的</c>
<c.magenta>NSCalendar实现</c>


72
00:03:39,253 --> 00:03:42,890 line:90%,end
<c.magenta>不仅更快速 而且</c>
<c.magenta>更正了一些</c>


73
00:03:42,956 --> 00:03:44,791 line:90%,end
<c.magenta>长期以来没解决的</c>
<c.magenta>极端条件计算问题</c>


74
00:03:46,093 --> 00:03:47,594 line:90%,end
<c.magenta>但是 在我们进行更改时</c>


75
00:03:47,661 --> 00:03:51,031 line:90%,end
<c.magenta>必须考虑这些更改</c>
<c.magenta>的影响范围</c>


76
00:03:51,465 --> 00:03:53,534 line:90%,end
<c.magenta>在Foundation和Core Foundation中</c>


77
00:03:53,667 --> 00:03:57,004 line:90%,end
<c.magenta>我们在一些位置</c>
<c.magenta>将一些小项目进行整合</c>


78
00:03:57,471 --> 00:03:58,906 line:90%,end
<c.magenta>我们深入分析</c>


79
00:03:58,972 --> 00:04:01,508 line:90%,end
<c.magenta>Foundation 中的</c>
<c.magenta>线程安全运行机制</c>


80
00:04:01,675 --> 00:04:05,012 line:90%,end
<c.magenta>决定转移到</c>
<c.magenta>使用Atomics和OS及Fairlock</c>


81
00:04:05,212 --> 00:04:08,882 line:90%,end
<c.magenta>这让服务质量</c>
<c.magenta>得到很大提升</c>


82
00:04:10,050 --> 00:04:12,519 line:90%,end
<c.magenta>在服务质量方面</c>


83
00:04:12,719 --> 00:04:16,156 line:90%,end
<c.magenta>NSOperation和OperationQueue</c>
<c.magenta>经过重大修改</c>


84
00:04:16,390 --> 00:04:18,257 line:90%,end
<c.magenta>以提升实现的正确水平</c>


85
00:04:18,325 --> 00:04:20,560 line:90%,end
<c.magenta>从而提高</c>
<c.magenta>它们的服务质量</c>


86
00:04:20,894 --> 00:04:23,697 line:90%,end
<c.magenta>你将会看到一些</c>
<c.magenta>非常灵巧的性能提升</c>


87
00:04:24,031 --> 00:04:27,935 line:90%,end
<c.magenta>在重负载应用中</c>
<c.magenta>队列操作的性能提升</c>


88
00:04:28,001 --> 00:04:31,338 line:90%,end
<c.magenta>最高可达25%</c>
<c.magenta>这只是其中一个代表性例子</c>


89
00:04:32,906 --> 00:04:35,809 line:90%,end
<c.magenta>在研究Swift</c>
<c.magenta>一段时间之后</c>


90
00:04:36,210 --> 00:04:40,080 line:90%,end
<c.magenta>我们发现</c>
<c.magenta>写时复制技术非常不错</c>


91
00:04:40,547 --> 00:04:42,216 line:90%,end
<c.magenta>在Foundation中</c>


92
00:04:42,282 --> 00:04:44,251 line:90%,end
<c.magenta>一些集合类型</c>


93
00:04:44,318 --> 00:04:47,354 line:90%,end
<c.magenta>现在将使用写时复制</c>
<c.magenta>作为辅助存储</c>


94
00:04:48,622 --> 00:04:51,058 line:10%
<c.magenta>那么 什么是写时复制？</c>


95
00:04:51,658 --> 00:04:55,429 line:10%
<c.magenta>写时复制是一种机制</c>
<c.magenta>简称COW</c>


96
00:04:55,762 --> 00:04:59,032 line:10%
<c.magenta>在这种机制中</c>
<c.magenta>两个项目可以指向共享后备存储</c>


97
00:04:59,099 --> 00:05:01,134 line:10%
<c.magenta>直到发生变更</c>


98
00:05:01,668 --> 00:05:03,437 line:10%
<c.magenta>当发生变更时</c>


99
00:05:03,604 --> 00:05:06,507 line:10%
<c.magenta>突变方</c>
<c.magenta>复制后备存储</c>


100
00:05:06,573 --> 00:05:08,609 line:10%
<c.magenta>从而允许</c>
<c.magenta>进行写入</c>


101
00:05:08,942 --> 00:05:12,446 line:10%
<c.magenta>简而言之</c>
<c.magenta>复制操作不会占用过多资源</c>


102
00:05:12,913 --> 00:05:15,215 line:10%
<c.magenta>这意味着</c>
<c.magenta>当你保护性地复制</c>


103
00:05:15,282 --> 00:05:17,985 line:10%
<c.magenta>可变容器时 不会占用任何资源</c>


104
00:05:19,052 --> 00:05:22,556 line:10%
<c.magenta>在以前</c>
<c.magenta>复制集合至少也会</c>


105
00:05:22,689 --> 00:05:24,191 line:10%
<c.magenta>占用线性执行时间</c>


106
00:05:24,558 --> 00:05:26,360 line:10%
<c.magenta>现在 无论何时复制它们</c>


107
00:05:26,493 --> 00:05:29,530 line:10%
<c.magenta>资源耗用始终不变</c>


108
00:05:30,063 --> 00:05:31,965 line:90%,end
<c.magenta>让我们来看一个例子</c>


109
00:05:32,032 --> 00:05:34,668 line:90%,end
<c.magenta>以了解</c>
<c.magenta>其底层工作机制</c>


110
00:05:36,170 --> 00:05:37,404 line:90%,end
<c.magenta>在这个例子中</c>


111
00:05:37,471 --> 00:05:39,139 line:90%,end
<c.magenta>我们创建一个新可变数组</c>


112
00:05:39,740 --> 00:05:42,142 line:90%,end
<c.magenta>创建之后</c>


113
00:05:42,209 --> 00:05:46,246 line:90%,end
<c.magenta>我们得到一个COW后备存储</c>
<c.magenta>其存储项目数量为零</c>


114
00:05:47,047 --> 00:05:51,952 line:90%,end
<c.magenta>我们需要做一些工作</c>
<c.magenta>在应用中 我们进行复制</c>


115
00:05:52,653 --> 00:05:56,089 line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>我们分配B 作为A的副本</c>


116
00:05:56,657 --> 00:05:59,026 line:90%,end
<c.magenta>发生复制时</c>


117
00:05:59,126 --> 00:06:01,895 line:90%,end
<c.magenta>在应用中</c>
<c.magenta>只有付款价格</c>


118
00:06:02,129 --> 00:06:04,932 line:90%,end
<c.magenta>是分配新集合</c>


119
00:06:05,265 --> 00:06:07,568 line:90%,end
<c.magenta>实际上 你不必复制</c>
<c.magenta>任何项目</c>


120
00:06:07,835 --> 00:06:11,138 line:90%,end
<c.magenta>因此在本例中 我们仍然指向</c>
<c.magenta>相同的后备存储</c>


121
00:06:11,338 --> 00:06:13,473 line:90%,end
<c.magenta>存储项目数量为零</c>


122
00:06:14,241 --> 00:06:17,411 line:10%
<c.magenta>以后</c>
<c.magenta>如果我们想要进行变更</c>


123
00:06:17,711 --> 00:06:21,615 line:10%
<c.magenta>所发生的情况是</c>
<c.magenta>复制方</c>


124
00:06:21,982 --> 00:06:25,953 line:10%
<c.magenta>获得一个指向共享</c>
<c.magenta>后备存储的引用</c>


125
00:06:26,253 --> 00:06:27,821 line:10%
<c.magenta>为了进行变更</c>


126
00:06:27,888 --> 00:06:30,090 line:10%
<c.magenta>必须从后备存储进行复制</c>


127
00:06:30,324 --> 00:06:33,093 line:10%
<c.magenta>以确保</c>
<c.magenta>变更是安全的</c>


128
00:06:34,361 --> 00:06:36,396 line:90%,end
<c.magenta>但是你必须考虑</c>


129
00:06:36,463 --> 00:06:39,800 line:90%,end
<c.magenta>大多数应用</c>
<c.magenta>将会到此为止</c>


130
00:06:39,867 --> 00:06:43,170 line:90%,end
<c.magenta>而不再进行</c>
<c.magenta>进一步的变更</c>


131
00:06:43,637 --> 00:06:45,172 line:90%,end
<c.magenta>因此你可以看到</c>


132
00:06:45,239 --> 00:06:48,075 line:90%,end
<c.magenta>利用此功能</c>
<c.magenta>性能将会得到</c>


133
00:06:48,141 --> 00:06:51,445 line:90%,end
<c.magenta>大幅的提升</c>


134
00:06:52,279 --> 00:06:54,681 line:90%,end
<c.magenta>现在 让我们来看</c>
<c.magenta>如何在你的应用中</c>


135
00:06:54,748 --> 00:06:55,983 line:90%,end
<c.magenta>使用这项技术</c>


136
00:06:56,917 --> 00:06:59,019 line:90%,end
<c.magenta>假设我是一名开发者</c>


137
00:06:59,319 --> 00:07:01,822 line:90%,end
<c.magenta>我编写这样的代码 并附有注释</c>


138
00:07:02,189 --> 00:07:05,759 line:90%,end
<c.magenta>希望我的同事</c>
<c.magenta>能够听从我的建议</c>


139
00:07:05,826 --> 00:07:07,828 line:90%,end
<c.magenta>以提升性能</c>


140
00:07:08,295 --> 00:07:10,397 line:90%,end
<c.magenta>但是这里有一个小陷阱</c>


141
00:07:10,664 --> 00:07:13,634 line:90%,end
<c.magenta>如果需要用到</c>
<c.magenta>可变数组</c>


142
00:07:13,901 --> 00:07:16,370 line:90%,end
<c.magenta>那么可能将会</c>
<c.magenta>共享可变状态</c>


143
00:07:16,436 --> 00:07:18,639 line:90%,end
<c.magenta>这意味着</c>
<c.magenta>将会共享漏洞</c>


144
00:07:18,972 --> 00:07:20,174 line:90%,end
<c.magenta>这不是我们想要的</c>


145
00:07:20,774 --> 00:07:23,343 line:90%,end
<c.magenta>由于现在复制不会占用资源</c>


146
00:07:23,577 --> 00:07:25,913 line:90%,end
<c.magenta>因此每次都可以进行同样的操作</c>


147
00:07:25,979 --> 00:07:27,981 line:90%,end
<c.magenta>而不必担心</c>
<c.magenta>性能降低</c>


148
00:07:28,715 --> 00:07:29,550 line:90%,end
<c.magenta>这非常不错</c>


149
00:07:30,484 --> 00:07:32,920 line:90%,end
<c.magenta>这不仅仅是资产的</c>
<c.magenta>复制性质</c>


150
00:07:33,220 --> 00:07:36,056 line:90%,end
<c.magenta>很多情况下 可变容器</c>
<c.magenta>用于构建工作</c>


151
00:07:36,557 --> 00:07:40,294 line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>开发者知道NSMutableArray是</c>


152
00:07:40,360 --> 00:07:41,995 line:90%,end
<c.magenta>NSArray的一个子类</c>


153
00:07:42,462 --> 00:07:45,632 line:90%,end
<c.magenta>其返回值是</c>
<c.magenta>一个NSArray</c>


154
00:07:45,732 --> 00:07:48,135 line:90%,end
<c.magenta>这应该很安全 是吧？</c>


155
00:07:48,735 --> 00:07:51,471 line:90%,end
<c.magenta>但不幸的是</c>
<c.magenta>这里也可能</c>


156
00:07:51,538 --> 00:07:53,073 line:90%,end
<c.magenta>存在一些后果</c>


157
00:07:53,340 --> 00:07:56,243 line:90%,end
<c.magenta>如果我们查看</c>
<c.magenta>返回类型的实际类</c>


158
00:07:56,543 --> 00:07:57,477 line:90%,end
<c.magenta>情况不妙</c>


159
00:07:57,544 --> 00:08:00,380 line:90%,end
<c.magenta>它们可能具有</c>
<c.magenta>共享的变更状态</c>


160
00:08:00,914 --> 00:08:04,751 line:90%,end
<c.magenta>因此</c>
<c.magenta>你可以保护性地复制返回值</c>


161
00:08:04,985 --> 00:08:06,486 line:90%,end
<c.magenta>确保获得正确的结果</c>


162
00:08:06,553 --> 00:08:09,189 line:90%,end
<c.magenta>而不必担心</c>
<c.magenta>性能开销</c>


163
00:08:10,390 --> 00:08:14,628 line:90%,end
<c.magenta>还有另一个例子</c>
<c.magenta>看上去更隐蔽</c>


164
00:08:14,862 --> 00:08:15,929 line:90%,end
<c.magenta>在Swift中</c>


165
00:08:16,864 --> 00:08:20,133 line:90%,end
<c.magenta>无论何时</c>
<c.magenta>导出这两个API</c>


166
00:08:20,400 --> 00:08:24,438 line:90%,end
<c.magenta>都必须进行复制</c>
<c.magenta>以保留值类型</c>


167
00:08:24,905 --> 00:08:27,808 line:90%,end
<c.magenta>如果你将数据转换为</c>


168
00:08:27,875 --> 00:08:30,611 line:90%,end
<c.magenta>任何NSArray类型</c>
<c.magenta>以使用这两个API中的任意一个</c>


169
00:08:30,744 --> 00:08:32,312 line:90%,end
<c.magenta>以前的实现</c>


170
00:08:32,379 --> 00:08:35,582 line:90%,end
<c.magenta>必须花费</c>
<c.magenta>线性执行时间</c>


171
00:08:35,649 --> 00:08:37,017 line:90%,end
<c.magenta>才能够进行复制</c>


172
00:08:37,417 --> 00:08:39,119 line:90%,end
<c.magenta>如果使用保护性的方法</c>


173
00:08:39,520 --> 00:08:42,655 line:90%,end
<c.magenta>复制将不会</c>
<c.magenta>占用资源</c>


174
00:08:42,722 --> 00:08:45,392 line:90%,end
<c.magenta>因此不会降低性能</c>


175
00:08:47,661 --> 00:08:48,795 line:90%,end
<c.magenta>在Swift 3中</c>


176
00:08:49,296 --> 00:08:52,766 line:90%,end
<c.magenta>我们为Foundation</c>
<c.magenta>引入多个结构化的类型</c>


177
00:08:53,267 --> 00:08:55,602 line:90%,end
<c.magenta>这种做法</c>


178
00:08:55,669 --> 00:08:58,639 line:90%,end
<c.magenta>将NSData引导向</c>
<c.magenta>结构型数据</c>


179
00:08:59,439 --> 00:09:01,675 line:90%,end
<c.magenta>我们对数据进行大量研究</c>


180
00:09:01,742 --> 00:09:04,378 line:90%,end
<c.magenta>理解常见的用例</c>


181
00:09:04,444 --> 00:09:06,513 line:90%,end
<c.magenta>和情况并改进数据</c>


182
00:09:06,580 --> 00:09:09,249 line:90%,end
<c.magenta>让它能够</c>
<c.magenta>在你们的应用中更好地工作</c>


183
00:09:09,917 --> 00:09:14,721 line:90%,end
<c.magenta>在这个版本中</c>
<c.magenta>数据现在拥有自己的类型</c>


184
00:09:14,788 --> 00:09:16,323 line:90%,end
<c.magenta>我们研究</c>


185
00:09:16,390 --> 00:09:18,926 line:90%,end
<c.magenta>在执行常见任务时的</c>
<c.magenta>性能水平</c>


186
00:09:19,026 --> 00:09:20,561 line:90%,end
<c.magenta>比如获取数据计数</c>


187
00:09:20,661 --> 00:09:23,730 line:90%,end
<c.magenta>偏移位置的</c>
<c.magenta>特定字节索引等</c>


188
00:09:24,631 --> 00:09:28,569 line:90%,end
<c.magenta>一些实现的情况</c>
<c.magenta>比较极端</c>


189
00:09:28,802 --> 00:09:32,472 line:90%,end
<c.magenta>一般来说 几行机器指令</c>
<c.magenta>并不能起多大的作用</c>


190
00:09:32,906 --> 00:09:35,776 line:90%,end
<c.magenta>但是 当表示</c>
<c.magenta>字节缓冲时</c>


191
00:09:36,176 --> 00:09:38,679 line:90%,end
<c.magenta>少数几行指令</c>


192
00:09:38,946 --> 00:09:40,547 line:90%,end
<c.magenta>就可能带来很大的变化</c>


193
00:09:41,982 --> 00:09:44,284 line:90%,end
<c.magenta>这段代码看上去非常简单</c>


194
00:09:45,719 --> 00:09:48,488 line:90%,end
<c.magenta>但是它具有</c>
<c.magenta>一些有趣的特性</c>


195
00:09:48,555 --> 00:09:51,792 line:90%,end
<c.magenta>揭示我们可以</c>
<c.magenta>如何让数据变得更快</c>


196
00:09:52,593 --> 00:09:55,762 line:90%,end
<c.magenta>首先 数据是一个集合</c>
<c.magenta>如同数据一样</c>


197
00:09:55,929 --> 00:09:59,066 line:90%,end
<c.magenta>它可以具有标注</c>
<c.magenta>包括索引和范围</c>


198
00:09:59,633 --> 00:10:02,769 line:90%,end
<c.magenta>因此 这意味着</c>
<c.magenta>数据的起始索引</c>


199
00:10:03,003 --> 00:10:04,605 line:90%,end
<c.magenta>不一定是零</c>


200
00:10:04,872 --> 00:10:08,609 line:90%,end
<c.magenta>索引类似于</c>
<c.magenta>其它语言中的迭代器</c>


201
00:10:09,042 --> 00:10:11,545 line:90%,end
<c.magenta>这段代码</c>
<c.magenta>并没有什么问题</c>


202
00:10:12,312 --> 00:10:14,147 line:90%,end
<c.magenta>我们使用它来帮助理解</c>


203
00:10:14,214 --> 00:10:16,283 line:90%,end
<c.magenta>需要改进数据的哪些部分</c>


204
00:10:16,783 --> 00:10:19,086 line:90%,end
<c.magenta>这里的两个问题是</c>


205
00:10:19,453 --> 00:10:21,321 line:90%,end
<c.magenta>所要处理的数据量是多少</c>


206
00:10:21,488 --> 00:10:23,524 line:90%,end
<c.magenta>另外 调用次数是多少？</c>


207
00:10:23,957 --> 00:10:25,425 line:90%,end
<c.magenta>其性能水平位于哪个象限？</c>


208
00:10:26,193 --> 00:10:30,330 line:90%,end
<c.magenta>正确的答案是</c>
<c.magenta>性能水平可能会位于任意象限</c>


209
00:10:30,797 --> 00:10:34,334 line:90%,end
<c.magenta>最可能的情况是</c>
<c.magenta>我们需要分析性能水平</c>


210
00:10:34,935 --> 00:10:36,970 line:90%,end
<c.magenta>我们的确这样做了</c>


211
00:10:38,372 --> 00:10:40,207 line:90%,end
<c.magenta>上方的蓝色曲线</c>


212
00:10:40,274 --> 00:10:42,543 line:90%,end
<c.magenta>表示初始的Swift 3 Data版本</c>


213
00:10:43,043 --> 00:10:48,048 line:90%,end
<c.magenta>进行标注时</c>
<c.magenta>用时约为16纳秒</c>


214
00:10:48,115 --> 00:10:51,118 line:90%,end
<c.magenta>这是在我进行分析时</c>
<c.magenta>所使用的计算机上的结果</c>


215
00:10:51,919 --> 00:10:57,157 line:90%,end
<c.magenta>由于处理数据</c>
<c.magenta>实际上是处理字节集合</c>


216
00:10:57,491 --> 00:11:00,294 line:90%,end
<c.magenta>因此速度应该非常快</c>


217
00:11:00,961 --> 00:11:04,698 line:90%,end
<c.magenta>经过改进之后</c>
<c.magenta>用时降低为4纳秒</c>


218
00:11:04,865 --> 00:11:05,899 line:90%,end
<c.magenta>提升非常明显</c>


219
00:11:06,433 --> 00:11:08,902 line:90%,end
<c.magenta>如果你以前曾经使用Data</c>


220
00:11:09,236 --> 00:11:11,538 line:90%,end
<c.magenta>就可以知道其优点</c>


221
00:11:12,172 --> 00:11:14,808 line:90%,end
<c.magenta>它将能够与</c>


222
00:11:14,942 --> 00:11:18,111 line:90%,end
<c.magenta>获取和使用Data的</c>
<c.magenta>所有其余API进行互操作</c>


223
00:11:20,714 --> 00:11:21,548 line:90%,end
<c.magenta>谢谢</c>


224
00:11:23,817 --> 00:11:26,687 line:90%,end
<c.magenta>需要提醒你们的是</c>


225
00:11:26,753 --> 00:11:30,090 line:90%,end
<c.magenta>这些例子</c>
<c.magenta>都没有明显的错误或缺点</c>


226
00:11:30,257 --> 00:11:32,759 line:90%,end
<c.magenta>但是 它们确实</c>
<c.magenta>在某些方面</c>


227
00:11:32,993 --> 00:11:34,695 line:90%,end
<c.magenta>还需要改进</c>


228
00:11:35,729 --> 00:11:38,398 line:90%,end
<c.magenta>通常 我们认为</c>
<c.magenta>字节集合</c>


229
00:11:38,465 --> 00:11:39,766 line:90%,end
<c.magenta>可以用数组表示</c>


230
00:11:39,833 --> 00:11:42,436 line:90%,end
<c.magenta>对于少量数据 确实可以</c>


231
00:11:42,536 --> 00:11:43,704 line:90%,end
<c.magenta>工作也很正常</c>


232
00:11:44,104 --> 00:11:46,473 line:90%,end
<c.magenta>但是 从某种角度来说</c>


233
00:11:46,540 --> 00:11:50,344 line:90%,end
<c.magenta>这也存在隐藏的开销</c>
<c.magenta>比如当你写入文件时</c>


234
00:11:51,111 --> 00:11:52,312 line:90%,end
<c.magenta>会增加复杂性</c>


235
00:11:52,379 --> 00:11:54,047 line:90%,end
<c.magenta>有很多这样的边界例子</c>


236
00:11:54,181 --> 00:11:55,782 line:90%,end
<c.magenta>我们已经考虑到这一点</c>


237
00:11:56,049 --> 00:11:58,986 line:90%,end
<c.magenta>由于能够进行互操作</c>
<c.magenta>比如写文件</c>


238
00:11:59,052 --> 00:12:02,789 line:90%,end
<c.magenta>转换成为基本C4</c>
<c.magenta>Data具有明显的优势</c>


239
00:12:04,124 --> 00:12:06,693 line:90%,end
<c.magenta>有时候我们更喜欢老做法</c>


240
00:12:06,760 --> 00:12:10,464 line:90%,end
<c.magenta>使用可靠的malloc方法</c>


241
00:12:10,864 --> 00:12:12,733 line:90%,end
<c.magenta>不幸的是</c>


242
00:12:12,833 --> 00:12:16,069 line:90%,end
<c.magenta>这可能会错失</c>
<c.magenta>其它一些优化机会</c>


243
00:12:16,236 --> 00:12:19,006 line:90%,end
<c.magenta>比如</c>
<c.magenta>可以自动分配合适的内存</c>


244
00:12:19,072 --> 00:12:21,708 line:90%,end
<c.magenta>而不需要</c>
<c.magenta>估算malloc 将多少内存</c>


245
00:12:21,775 --> 00:12:24,311 line:90%,end
<c.magenta>交回给缓冲区</c>


246
00:12:25,179 --> 00:12:27,281 line:90%,end
<c.magenta>Data为你完成所有这些工作</c>


247
00:12:27,347 --> 00:12:29,950 line:90%,end
<c.magenta>你不必担心</c>
<c.magenta>重分配问题</c>


248
00:12:30,017 --> 00:12:33,220 line:90%,end
<c.magenta>你不必担心</c>
<c.magenta>边界例子</c>


249
00:12:33,287 --> 00:12:36,924 line:90%,end
<c.magenta>比如</c>
<c.magenta>malloc应该分配多少内存</c>


250
00:12:39,159 --> 00:12:42,563 line:90%,end
<c.magenta>这两行代码</c>
<c.magenta>非常相似</c>


251
00:12:42,796 --> 00:12:44,598 line:90%,end
<c.magenta>但是它们用处不大</c>


252
00:12:44,798 --> 00:12:46,567 line:90%,end
<c.magenta>在某些情况</c>


253
00:12:46,633 --> 00:12:49,536 line:90%,end
<c.magenta>你需要能够处理</c>
<c.magenta>大型数据区域</c>


254
00:12:49,770 --> 00:12:51,071 line:90%,end
<c.magenta>另一些情况下</c>


255
00:12:51,138 --> 00:12:54,441 line:90%,end
<c.magenta>你想要能够</c>
<c.magenta>保留一部分数据</c>


256
00:12:55,108 --> 00:12:56,944 line:90%,end
<c.magenta>因此 Data有两个API</c>


257
00:12:57,010 --> 00:12:59,012 line:90%,end
<c.magenta>其中一个是Subdata</c>
<c.magenta>有范围参数</c>


258
00:12:59,146 --> 00:13:00,647 line:90%,end
<c.magenta>它创建一个副本</c>


259
00:13:00,714 --> 00:13:03,283 line:90%,end
<c.magenta>如果你需要</c>
<c.magenta>处理大文件</c>


260
00:13:03,450 --> 00:13:05,819 line:90%,end
<c.magenta>而只想保留其中一部分</c>


261
00:13:06,119 --> 00:13:09,656 line:90%,end
<c.magenta>带有范围参数的Subdata</c>
<c.magenta>将进行强制复制 像这样</c>


262
00:13:10,424 --> 00:13:13,894 line:90%,end
<c.magenta>我们已经更改Data</c>
<c.magenta>使它成为自己的子类型</c>


263
00:13:14,061 --> 00:13:16,997 line:90%,end
<c.magenta>或类型的子集</c>


264
00:13:17,331 --> 00:13:19,566 line:90%,end
<c.magenta>无论你是否使用范围语法</c>


265
00:13:19,633 --> 00:13:22,002 line:90%,end
<c.magenta>举例来说 即使有这样的范围</c>


266
00:13:22,803 --> 00:13:26,673 line:90%,end
<c.magenta>你也可以将它用作窗口</c>
<c.magenta>来了解你的数据量</c>


267
00:13:26,940 --> 00:13:29,309 line:90%,end
<c.magenta>如果你需要</c>
<c.magenta>处理大文件</c>


268
00:13:29,376 --> 00:13:31,378 line:90%,end
<c.magenta>只需要进行分析</c>


269
00:13:31,578 --> 00:13:34,214 line:90%,end
<c.magenta>而且数据本身</c>
<c.magenta>将是临时性的</c>


270
00:13:34,615 --> 00:13:38,318 line:90%,end
<c.magenta>然后 使用数据片段</c>
<c.magenta>是一种非常高效的方法</c>


271
00:13:38,385 --> 00:13:41,288 line:90%,end
<c.magenta>让你轻松地访问数据</c>
<c.magenta>因为它无需进行复制</c>


272
00:13:43,557 --> 00:13:46,560 line:90%,end
<c.magenta>我们多次</c>
<c.magenta>谈到桥接</c>


273
00:13:46,793 --> 00:13:50,631 line:90%,end
<c.magenta>这里我们需要</c>
<c.magenta>了解两种类型的桥接</c>


274
00:13:51,498 --> 00:13:55,135 line:90%,end
<c.magenta>在右侧</c>
<c.magenta>是无资源开销桥接</c>


275
00:13:55,669 --> 00:13:57,437 line:90%,end
<c.magenta>在这些例子中</c>


276
00:13:57,638 --> 00:13:59,806 line:90%,end
<c.magenta>它们将Foundation类型</c>


277
00:13:59,907 --> 00:14:01,308 line:90%,end
<c.magenta>桥接到Core Foundation类型</c>


278
00:14:01,842 --> 00:14:04,511 line:90%,end
<c.magenta>或者从Foundation类型</c>
<c.magenta>桥接到Core Foundation类型</c>


279
00:14:05,212 --> 00:14:09,183 line:90%,end
<c.magenta>在转换过程中不会产生开销</c>


280
00:14:09,383 --> 00:14:11,818 line:90%,end
<c.magenta>因此 在这个例子中</c>
<c.magenta>所做的工作是</c>


281
00:14:11,885 --> 00:14:15,489 line:90%,end
<c.magenta>将NSArray桥接到CFArray</c>


282
00:14:16,123 --> 00:14:18,525 line:90%,end
<c.magenta>这只是重新解释指针</c>


283
00:14:19,359 --> 00:14:22,529 line:90%,end
<c.magenta>但是这里有少量的资源开销</c>


284
00:14:22,663 --> 00:14:27,801 line:90%,end
<c.magenta>当你传递对象</c>
<c.magenta>到CFArrayGetCount时</c>


285
00:14:28,502 --> 00:14:30,304 line:90%,end
<c.magenta>你会得到一些东西</c>


286
00:14:30,537 --> 00:14:32,306 line:90%,end
<c.magenta>我们将会</c>
<c.magenta>稍作了解</c>


287
00:14:33,340 --> 00:14:37,711 line:90%,end
<c.magenta>在Swift桥接中</c>
<c.magenta>有些情况下</c>


288
00:14:37,778 --> 00:14:40,013 line:90%,end
<c.magenta>你需要</c>
<c.magenta>将引用类型</c>


289
00:14:40,080 --> 00:14:41,415 line:90%,end
<c.magenta>桥接到结构类型</c>


290
00:14:42,382 --> 00:14:44,551 line:90%,end
<c.magenta>或者也可以</c>


291
00:14:44,685 --> 00:14:47,521 line:90%,end
<c.magenta>从结构类型</c>
<c.magenta>桥接到引用类型</c>


292
00:14:48,956 --> 00:14:52,793 line:90%,end
<c.magenta>但是这些例子中的</c>
<c.magenta>资源开销已经预先提供</c>


293
00:14:52,960 --> 00:14:55,229 line:90%,end
<c.magenta>因此 无论何时从Objective-C导入</c>


294
00:14:55,395 --> 00:14:58,365 line:90%,end
<c.magenta>或者 在本例中</c>
<c.magenta>使用as？</c>


295
00:14:58,599 --> 00:15:00,601 line:90%,end
<c.magenta>在二者之间进行转换</c>


296
00:15:00,767 --> 00:15:03,003 line:90%,end
<c.magenta>这时会产生开销</c>


297
00:15:04,538 --> 00:15:06,540 line:90%,end
<c.magenta>但是区别在于</c>


298
00:15:06,607 --> 00:15:09,943 line:90%,end
<c.magenta>这些开销</c>
<c.magenta>是正常的资源开销</c>


299
00:15:10,944 --> 00:15:12,513 line:90%,end
<c.magenta>让我们来深入了解</c>


300
00:15:12,779 --> 00:15:14,214 line:90%,end
<c.magenta>我知道这看上去有点吓人/b></c>


301
00:15:14,648 --> 00:15:16,383 line:90%,end
<c.magenta>如果不使用写时复制</c>
<c.magenta>事实上</c>


302
00:15:16,450 --> 00:15:17,518 line:90%,end
<c.magenta>这并不会…</c>


303
00:15:17,584 --> 00:15:19,853 line:90%,end
<c.magenta>CFArray 并不实现写时复制</c>


304
00:15:21,054 --> 00:15:24,791 line:90%,end
<c.magenta>但是当你传递</c>
<c.magenta>一个NSArray或子类</c>


305
00:15:24,858 --> 00:15:26,793 line:90%,end
<c.magenta>到CFArrayGetCount时</c>


306
00:15:27,127 --> 00:15:30,731 line:90%,end
<c.magenta>它将魔术般地</c>
<c.magenta>调出这个Objective-C 方法count</c>


307
00:15:31,532 --> 00:15:33,233 line:90%,end
<c.magenta>让我们来进一步</c>
<c.magenta>并进行分析</c>


308
00:15:33,300 --> 00:15:36,370 line:90%,end
<c.magenta>弄清楚这与</c>
<c.magenta>Swift桥接之间的区别</c>


309
00:15:38,906 --> 00:15:40,841 line:90%,end
<c.magenta>这里进行了简化</c>


310
00:15:41,141 --> 00:15:44,645 line:90%,end
<c.magenta>首先 我们使用数组</c>
<c.magenta>和Objective-C子类</c>


311
00:15:44,912 --> 00:15:47,247 line:90%,end
<c.magenta>我们发现</c>
<c.magenta>将执行计数方法</c>


312
00:15:47,648 --> 00:15:51,485 line:90%,end
<c.magenta>如果不是 我们会知道</c>
<c.magenta>对象的结构化部分</c>


313
00:15:51,618 --> 00:15:54,788 line:90%,end
<c.magenta>我们获得</c>
<c.magenta>可变数量</c>


314
00:15:56,523 --> 00:15:58,258 line:90%,end
<c.magenta>让我们更深入地分析</c>


315
00:15:58,926 --> 00:16:00,994 line:90%,end
<c.magenta>它检查</c>
<c.magenta>对象的内部布局</c>


316
00:16:01,061 --> 00:16:02,996 line:90%,end
<c.magenta>参照预期的类表</c>


317
00:16:03,230 --> 00:16:04,097 line:90%,end
<c.magenta>因此 事实上</c>


318
00:16:04,831 --> 00:16:07,467 line:90%,end
<c.magenta>它会进行</c>
<c.magenta>两次重导向</c>


319
00:16:07,534 --> 00:16:09,336 line:90%,end
<c.magenta>和一次函数调用 以确定</c>


320
00:16:09,403 --> 00:16:12,906 line:90%,end
<c.magenta>是否需调用</c>
<c.magenta>Objective-C子类方法</c>


321
00:16:12,973 --> 00:16:14,908 line:90%,end
<c.magenta>Objective-C方法</c>


322
00:16:16,343 --> 00:16:17,945 line:90%,end
<c.magenta>让我们进行总结</c>


323
00:16:18,111 --> 00:16:22,616 line:90%,end
<c.magenta>转换为数组</c>
<c.magenta>或 CFArray子类</c>


324
00:16:22,683 --> 00:16:25,185 line:90%,end
<c.magenta>仅仅是重新解释指针</c>


325
00:16:25,819 --> 00:16:28,922 line:90%,end
<c.magenta>其使用过程</c>
<c.magenta>会占用资源</c>


326
00:16:29,823 --> 00:16:32,726 line:90%,end
<c.magenta>但是这只会产生</c>
<c.magenta>较小的性能影响</c>


327
00:16:32,993 --> 00:16:37,030 line:90%,end
<c.magenta>但是在极少数情况</c>
<c.magenta>也可能产生较大影响</c>


328
00:16:37,397 --> 00:16:39,967 line:90%,end
<c.magenta>因此 性能水平可能</c>


329
00:16:40,033 --> 00:16:42,970 line:90%,end
<c.magenta>位于第三象限</c>
<c.magenta>可能位于比较向上的位置</c>


330
00:16:44,905 --> 00:16:48,242 line:90%,end
<c.magenta>现在 我们来看另一种做法</c>
<c.magenta>我们使用Swift桥接</c>


331
00:16:48,609 --> 00:16:52,112 line:90%,end
<c.magenta>请记住</c>
<c.magenta>无论何时调用as？</c>


332
00:16:52,312 --> 00:16:54,648 line:90%,end
<c.magenta>或者使用Objective-C API</c>


333
00:16:55,082 --> 00:16:57,284 line:90%,end
<c.magenta>无论何时使用桥接引用类型</c>


334
00:16:57,918 --> 00:17:01,655 line:90%,end
<c.magenta>编译器将会</c>
<c.magenta>使用可桥接函数族</c>


335
00:17:01,855 --> 00:17:04,458 line:90%,end
<c.magenta>反过来</c>
<c.magenta>在这个例子中</c>


336
00:17:04,525 --> 00:17:06,859 line:90%,end
<c.magenta>为Data调用</c>
<c.magenta>引用初始化函数</c>


337
00:17:08,262 --> 00:17:11,265 line:90%,end
<c.magenta>当Data初始化时</c>


338
00:17:11,464 --> 00:17:12,965 line:90%,end
<c.magenta>将会将存储数据</c>


339
00:17:13,099 --> 00:17:16,136 line:90%,end
<c.magenta>复制到数据的</c>
<c.magenta>后备存储</c>


340
00:17:16,270 --> 00:17:18,539 line:90%,end
<c.magenta>我们不仅需要保留</c>


341
00:17:18,605 --> 00:17:21,441 line:90%,end
<c.magenta>数据的</c>
<c.magenta>值类型属性</c>


342
00:17:21,642 --> 00:17:22,675 line:90%,end
<c.magenta>而且必须确保</c>


343
00:17:22,742 --> 00:17:25,412 line:90%,end
<c.magenta>我们不会使用</c>
<c.magenta>共享可变引用</c>


344
00:17:25,546 --> 00:17:27,214 line:90%,end
<c.magenta>因为这会产生漏洞</c>


345
00:17:28,080 --> 00:17:31,785 line:90%,end
<c.magenta>你可以看到</c>
<c.magenta>如果这是可变数据</c>


346
00:17:31,852 --> 00:17:34,354 line:90%,end
<c.magenta>或代理或其他子类</c>


347
00:17:34,821 --> 00:17:38,125 line:90%,end
<c.magenta>这可能是一个</c>
<c.magenta>隐藏的资源开销点</c>


348
00:17:39,660 --> 00:17:41,828 line:90%,end
<c.magenta>我们完成所有桥接</c>


349
00:17:41,895 --> 00:17:43,330 line:90%,end
<c.magenta>再来看性能图</c>


350
00:17:44,164 --> 00:17:46,733 line:90%,end
<c.magenta>这次</c>


351
00:17:46,800 --> 00:17:49,603 line:90%,end
<c.magenta>桥接并没有占用过多资源</c>


352
00:17:49,736 --> 00:17:52,840 line:90%,end
<c.magenta>通常情况下</c>


353
00:17:53,207 --> 00:17:55,509 line:90%,end
<c.magenta>仅复制限定的部分</c>


354
00:17:55,809 --> 00:17:58,645 line:90%,end
<c.magenta>因此 性能水平</c>
<c.magenta>可能仍然位于第三象限</c>


355
00:17:59,279 --> 00:18:02,749 line:90%,end
<c.magenta>但是 对于子类之外的</c>
<c.magenta>其他情况</c>


356
00:18:02,816 --> 00:18:04,484 line:90%,end
<c.magenta>比如可变数据</c>


357
00:18:04,551 --> 00:18:08,288 line:90%,end
<c.magenta>复制可能导致</c>
<c.magenta>性能水平位于任意象限</c>


358
00:18:08,589 --> 00:18:11,959 line:90%,end
<c.magenta>因此 如果你需要</c>
<c.magenta>处理子类</c>


359
00:18:12,226 --> 00:18:16,230 line:90%,end
<c.magenta>或者在桥接之间</c>
<c.magenta>来回传递可变数据</c>


360
00:18:16,763 --> 00:18:19,333 line:90%,end
<c.magenta>你应该结合这些有用的范例</c>


361
00:18:19,399 --> 00:18:22,336 line:90%,end
<c.magenta>利用更好的测量参数</c>
<c.magenta>理解性能水平</c>


362
00:18:23,337 --> 00:18:26,773 line:90%,end
<c.magenta>这种模式</c>
<c.magenta>不仅适用于Data</c>


363
00:18:26,874 --> 00:18:29,743 line:90%,end
<c.magenta>也适用于Swift中的</c>
<c.magenta>所有结构类型</c>


364
00:18:29,977 --> 00:18:32,946 line:90%,end
<c.magenta>比如数组</c>
<c.magenta>字典 字符串</c>


365
00:18:33,380 --> 00:18:36,650 line:90%,end
<c.magenta>说到字符串</c>
<c.magenta>我听说它们非常受欢迎</c>


366
00:18:37,317 --> 00:18:38,151 line:90%,end
<c.magenta>接下来</c>


367
00:18:38,218 --> 00:18:42,956 line:90%,end
<c.magenta>唐娜将会和大家一起</c>
<c.magenta>讨论字符串、范围和文本</c>


368
00:18:48,428 --> 00:18:49,263 line:90%,end
<c.magenta>谢谢 菲力浦</c>


369
00:18:51,899 --> 00:18:52,900 line:90%,end
<c.magenta>字符串</c>


370
00:18:52,966 --> 00:18:55,269 line:90%,end
<c.magenta>可能是使用频率最高的</c>
<c.magenta>数据类型之一</c>


371
00:18:55,636 --> 00:18:56,737 line:90%,end
<c.magenta>如果你是应用开发者</c>


372
00:18:56,837 --> 00:18:58,739 line:90%,end
<c.magenta>你的应用在使用时</c>
<c.magenta>可能会创建</c>


373
00:18:58,805 --> 00:19:01,208 line:90%,end
<c.magenta>成百上千的</c>
<c.magenta>各种类型的字符串</c>


374
00:19:01,742 --> 00:19:03,143 line:90%,end
<c.magenta>如果你是框架开发者</c>


375
00:19:03,210 --> 00:19:05,279 line:90%,end
<c.magenta>每次用户</c>
<c.magenta>调用我们的API</c>


376
00:19:05,445 --> 00:19:07,481 line:90%,end
<c.magenta>框架可能产生和更改字符串</c>


377
00:19:07,881 --> 00:19:09,850 line:90%,end
<c.magenta>这些字符串</c>
<c.magenta>可能会在你的框架边界之外</c>


378
00:19:10,017 --> 00:19:11,485 line:90%,end
<c.magenta>发生变化</c>


379
00:19:11,952 --> 00:19:13,987 line:90%,end
<c.magenta>字符串并不会单独使用</c>


380
00:19:14,188 --> 00:19:15,489 line:90%,end
<c.magenta>你需要与框架交互</c>


381
00:19:15,556 --> 00:19:17,157 line:90%,end
<c.magenta>利用字符串完成一些工作</c>


382
00:19:17,224 --> 00:19:20,527 line:90%,end
<c.magenta>无论分割</c>
<c.magenta>分组和组合</c>


383
00:19:20,727 --> 00:19:22,362 line:90%,end
<c.magenta>或是简单地在屏幕上呈现</c>


384
00:19:22,763 --> 00:19:26,266 line:90%,end
<c.magenta>你可能需要改进</c>
<c.magenta>你的应用或框架的性能</c>


385
00:19:26,333 --> 00:19:30,871 line:90%,end
<c.magenta>理解字符串、范围、</c>
<c.magenta>文本与框架之间的交互方式</c>


386
00:19:30,938 --> 00:19:33,874 line:90%,end
<c.magenta>在此理解基础上</c>
<c.magenta>选择合适的实现方法</c>


387
00:19:34,708 --> 00:19:36,777 line:90%,end
<c.magenta>在我们讨论</c>
<c.magenta>技术细节之前</c>


388
00:19:36,977 --> 00:19:37,978 line:90%,end
<c.magenta>我想回过头来</c>


389
00:19:38,045 --> 00:19:40,180 line:90%,end
<c.magenta>重复菲力浦讲过的一些内容</c>


390
00:19:40,314 --> 00:19:41,281 line:90%,end
<c.magenta>简要讨论</c>


391
00:19:41,348 --> 00:19:44,184 line:90%,end
<c.magenta>如何评价</c>
<c.magenta>性能改进的影响</c>


392
00:19:46,186 --> 00:19:48,822 line:90%,end
<c.magenta>很重要的一点是</c>
<c.magenta>当你思考如何改进性能时</c>


393
00:19:48,889 --> 00:19:50,524 line:90%,end
<c.magenta>你必须</c>
<c.magenta>着眼于大局</c>


394
00:19:51,325 --> 00:19:53,393 line:90%,end
<c.magenta>我们很容易</c>
<c.magenta>拘泥于细节</c>


395
00:19:53,560 --> 00:19:57,197 line:90%,end
<c.magenta>专注于优化</c>
<c.magenta>特定的方案</c>


396
00:19:57,364 --> 00:19:59,666 line:90%,end
<c.magenta>但是 如果方案不能反映</c>


397
00:19:59,733 --> 00:20:01,969 line:90%,end
<c.magenta>用户如何</c>
<c.magenta>使用你的应用框架</c>


398
00:20:02,336 --> 00:20:04,071 line:90%,end
<c.magenta>那么优化它们</c>
<c.magenta>将不会产生</c>


399
00:20:04,137 --> 00:20:05,172 line:90%,end
<c.magenta>多么大的作用</c>


400
00:20:06,039 --> 00:20:07,407 line:90%,end
<c.magenta>因此 如果你</c>


401
00:20:07,641 --> 00:20:10,377 line:90%,end
<c.magenta>使用的方案反映</c>
<c.magenta>实际的框架使用情况</c>


402
00:20:10,444 --> 00:20:13,247 line:90%,end
<c.magenta>你可以分析</c>
<c.magenta>特定代码段的性能</c>


403
00:20:13,614 --> 00:20:16,750 line:90%,end
<c.magenta>在做这项工作时你应该回忆</c>
<c.magenta>前面我们讲过的一些概念</c>


404
00:20:16,984 --> 00:20:18,785 line:90%,end
<c.magenta>我处理的数据量有多大？</c>


405
00:20:18,852 --> 00:20:20,487 line:90%,end
<c.magenta>代码的运行频率如何？</c>


406
00:20:21,955 --> 00:20:23,357 line:90%,end
<c.magenta>另外我们要使用性能象限图</c>


407
00:20:23,824 --> 00:20:26,560 line:10%
<c.magenta>但我们需要</c>
<c.magenta>对轴标签进行一些更改</c>


408
00:20:26,693 --> 00:20:28,095 line:10%
<c.magenta>以适用于字符串和文本</c>


409
00:20:28,562 --> 00:20:30,197 line:90%,end
<c.magenta>总体思想是相同的</c>


410
00:20:30,364 --> 00:20:31,465 line:90%,end
<c.magenta>但是对于字符串</c>


411
00:20:31,532 --> 00:20:33,734 line:90%,end
<c.magenta>我们需要考虑</c>
<c.magenta>字符串的长短</c>


412
00:20:33,867 --> 00:20:35,802 line:90%,end
<c.magenta>和代码的运行频率</c>


413
00:20:37,471 --> 00:20:39,740 line:90%,end
<c.magenta>在我们回顾这些主题时</c>
<c.magenta>我们应该记住</c>


414
00:20:39,806 --> 00:20:41,108 line:90%,end
<c.magenta>这些规模和频率概念</c>


415
00:20:42,543 --> 00:20:44,278 line:90%,end
<c.magenta>首先 让我们来看</c>
<c.magenta>字符串桥接</c>


416
00:20:45,012 --> 00:20:46,647 line:90%,end
<c.magenta>我们会讨论范围</c>


417
00:20:46,713 --> 00:20:48,315 line:90%,end
<c.magenta>和字符串索引的精妙之处</c>


418
00:20:48,949 --> 00:20:51,285 line:90%,end
<c.magenta>最后 我们将会分享一些技术</c>
<c.magenta>帮助你高效率地处理</c>


419
00:20:51,351 --> 00:20:53,787 line:90%,end
<c.magenta>文本布局</c>
<c.magenta>和AVKit及UIKit中的显示</c>


420
00:20:54,922 --> 00:20:56,390 line:90%,end
<c.magenta>我们先来看</c>
<c.magenta>字符串桥接</c>


421
00:20:58,025 --> 00:21:00,427 line:90%,end
<c.magenta>我们的第一个例子</c>
<c.magenta>是UILabel</c>


422
00:21:02,095 --> 00:21:03,630 line:90%,end
<c.magenta>假设我有一个这样的标签</c>


423
00:21:03,697 --> 00:21:05,265 line:90%,end
<c.magenta>我想要访问它的文本</c>


424
00:21:07,267 --> 00:21:09,169 line:90%,end
<c.magenta>在Swift中</c>
<c.magenta>我想启动这样的界面</c>


425
00:21:10,103 --> 00:21:13,407 line:90%,end
<c.magenta>我们要求UIKit框架</c>
<c.magenta>提供标签的文本</c>


426
00:21:14,241 --> 00:21:16,543 line:90%,end
<c.magenta>因此 界面看起来是这样的</c>


427
00:21:18,178 --> 00:21:20,647 line:90%,end
<c.magenta>但是 请注意</c>
<c.magenta>这只是生成的界面</c>


428
00:21:20,781 --> 00:21:23,116 line:90%,end
<c.magenta>UILabel在Objective-C中实现</c>


429
00:21:24,685 --> 00:21:27,487 line:90%,end
<c.magenta>因此 虽然我们的可变文本</c>
<c.magenta>是一个Swift字符串</c>


430
00:21:27,754 --> 00:21:29,823 line:10%
<c.magenta>后备存储实际上是一个NSString</c>


431
00:21:29,890 --> 00:21:31,625 line:10%
<c.magenta>是从Objective-C桥接过来的</c>


432
00:21:33,527 --> 00:21:35,095 line:90%,end
<c.magenta>让我们来看看</c>
<c.magenta>当我们在Swift中</c>


433
00:21:35,162 --> 00:21:36,897 line:90%,end
<c.magenta>请求获取标签的文本时</c>
<c.magenta>将会发生什么</c>


434
00:21:38,265 --> 00:21:40,300 line:90%,end
<c.magenta>框架中的NSString</c>
<c.magenta>是一个引用类型</c>


435
00:21:40,767 --> 00:21:42,536 line:90%,end
<c.magenta>Swift的字符串是一个值类型</c>


436
00:21:43,103 --> 00:21:45,772 line:90%,end
<c.magenta>因此 如果我们向框架</c>
<c.magenta>请求那个NSString</c>


437
00:21:46,073 --> 00:21:48,542 line:90%,end
<c.magenta>当进行Swift桥接时</c>
<c.magenta>它被封装为值类型</c>


438
00:21:49,943 --> 00:21:53,347 line:90%,end
<c.magenta>但是 我们并不知道在桥接之后</c>
<c.magenta>初始NSString将会发生什么</c>


439
00:21:53,647 --> 00:21:55,849 line:90%,end
<c.magenta>为了保留Swift值语义</c>


440
00:21:55,983 --> 00:21:57,951 line:90%,end
<c.magenta>框架必须复制它</c>


441
00:21:58,919 --> 00:22:02,122 line:90%,end
<c.magenta>幸运的是 在本例中</c>
<c.magenta>初始NSString是不可变的</c>


442
00:22:02,356 --> 00:22:04,224 line:90%,end
<c.magenta>因此 当框架进行复制时</c>


443
00:22:04,291 --> 00:22:06,760 line:90%,end
<c.magenta>将经过优化</c>
<c.magenta>这并不需要很多开销</c>


444
00:22:06,827 --> 00:22:08,829 line:90%,end
<c.magenta>因为这只是增大引用数量</c>


445
00:22:11,965 --> 00:22:14,034 line:90%,end
<c.magenta>但是 如果我们</c>
<c.magenta>完整复制这个字符串</c>


446
00:22:14,168 --> 00:22:16,436 line:90%,end
<c.magenta>我们回到图表</c>
<c.magenta>来评价性能影响</c>


447
00:22:17,905 --> 00:22:20,974 line:90%,end
<c.magenta>在本例中 初始字符串</c>
<c.magenta>包含7个ASCII字符</c>


448
00:22:21,074 --> 00:22:23,010 line:90%,end
<c.magenta>即使进行完整复制</c>


449
00:22:23,844 --> 00:22:24,945 line:90%,end
<c.magenta>影响也是非常小的</c>


450
00:22:26,013 --> 00:22:27,281 line:90%,end
<c.magenta>大多数情况下 UILabel</c>


451
00:22:27,347 --> 00:22:28,949 line:90%,end
<c.magenta>仅包含短字符串</c>


452
00:22:29,016 --> 00:22:30,717 line:90%,end
<c.magenta>这些字符串用于UI显示</c>


453
00:22:31,251 --> 00:22:34,321 line:90%,end
<c.magenta>因此 你可能不会</c>
<c.magenta>频繁地获取它们的文本</c>


454
00:22:34,721 --> 00:22:37,357 line:10%
<c.magenta>大多数情况下</c>
<c.magenta>性能水平位于这个象限</c>


455
00:22:37,691 --> 00:22:40,227 line:10%
<c.magenta>因此 桥接复制</c>
<c.magenta>并不会造成很大的影响</c>


456
00:22:43,096 --> 00:22:46,166 line:90%,end
<c.magenta>但是 让我们来看</c>
<c.magenta>对于大量数据 将会发生什么</c>


457
00:22:46,233 --> 00:22:47,334 line:90%,end
<c.magenta>比如在NSTextStorage中</c>


458
00:22:49,069 --> 00:22:49,903 line:90%,end
<c.magenta>NSTextStorage</c>


459
00:22:49,970 --> 00:22:52,039 line:90%,end
<c.magenta>是TextKit背后的</c>
<c.magenta>基本存储机制</c>


460
00:22:52,506 --> 00:22:54,608 line:90%,end
<c.magenta>它用于在Cocoa 和Cocoa Touch中</c>
<c.magenta>支持文本视图</c>


461
00:22:54,675 --> 00:22:56,076 line:90%,end
<c.magenta>比如你在这里所看到的</c>


462
00:22:57,144 --> 00:22:59,146 line:90%,end
<c.magenta>因此 如果你处理文本视图</c>


463
00:22:59,413 --> 00:23:00,848 line:90%,end
<c.magenta>你需要能够</c>
<c.magenta>访问文本存储中的</c>


464
00:23:00,914 --> 00:23:02,182 line:90%,end
<c.magenta>文本</c>


465
00:23:03,217 --> 00:23:04,785 line:90%,end
<c.magenta>这是Swift中的内容</c>


466
00:23:07,921 --> 00:23:09,356 line:90%,end
<c.magenta>这是生成的界面</c>


467
00:23:10,257 --> 00:23:13,794 line:90%,end
<c.magenta>这是Objective-C界面</c>


468
00:23:14,962 --> 00:23:16,997 line:10%
<c.magenta>但是请注意 NSTextStorage</c>


469
00:23:17,064 --> 00:23:19,733 line:10%
<c.magenta>是NSMutableAttributedString的</c>
<c.magenta>子类</c>


470
00:23:21,435 --> 00:23:24,471 line:10%
<c.magenta>由于这里NSTextStorage</c>
<c.magenta>用于文本编辑</c>


471
00:23:24,671 --> 00:23:27,508 line:10%
<c.magenta>因此我们希望</c>
<c.magenta>文本存储的内容</c>


472
00:23:27,574 --> 00:23:28,809 line:10%
<c.magenta>频繁发生变化</c>


473
00:23:29,977 --> 00:23:32,946 line:10%
<c.magenta>文本存储的内容</c>
<c.magenta>也应该是很长的字符串</c>


474
00:23:33,013 --> 00:23:35,482 line:10%
<c.magenta>可能是MB</c>
<c.magenta>甚至GB级别</c>


475
00:23:36,216 --> 00:23:37,284 line:10%
<c.magenta>因此 为了确保效率</c>


476
00:23:37,351 --> 00:23:39,620 line:10%
<c.magenta>框架仅保留</c>
<c.magenta>可变字符串</c>


477
00:23:39,920 --> 00:23:42,656 line:10%
<c.magenta>当你请求文本存储中的</c>
<c.magenta>字符串资产时</c>


478
00:23:43,190 --> 00:23:45,459 line:10%
<c.magenta>将会得到</c>
<c.magenta>NSString提供的结果</c>


479
00:23:45,526 --> 00:23:47,227 line:10%
<c.magenta>它指向可变字符串</c>


480
00:23:49,730 --> 00:23:50,664 line:90%,end
<c.magenta>现在 让我们再来看一看</c>


481
00:23:50,731 --> 00:23:51,732 line:90%,end
<c.magenta>发生了什么</c>


482
00:23:51,798 --> 00:23:53,634 line:90%,end
<c.magenta>当我们从Swift中</c>
<c.magenta>请求字符串资产时</c>


483
00:23:55,769 --> 00:23:58,005 line:90%,end
<c.magenta>与前面一样</c>
<c.magenta>它封装为值类型</c>


484
00:23:58,071 --> 00:24:00,941 line:90%,end
<c.magenta>当进行桥接时</c>
<c.magenta>因为它是一个NSString</c>


485
00:24:01,441 --> 00:24:02,943 line:90%,end
<c.magenta>框架将会进行复制</c>


486
00:24:04,011 --> 00:24:05,579 line:90%,end
<c.magenta>但与UILabel例子不一样</c>


487
00:24:05,646 --> 00:24:08,515 line:90%,end
<c.magenta>在这里 底层NSString</c>
<c.magenta>实际上是不可变的</c>


488
00:24:09,316 --> 00:24:10,784 line:90%,end
<c.magenta>因此 此复制将会占用大量资源</c>


489
00:24:11,818 --> 00:24:12,819 line:90%,end
<c.magenta>如我们前面所述</c>


490
00:24:12,886 --> 00:24:16,423 line:90%,end
<c.magenta>textStorage更适合</c>
<c.magenta>包含很长的字符串</c>


491
00:24:16,823 --> 00:24:18,759 line:90%,end
<c.magenta>其大小可能是MB</c>
<c.magenta>甚至GB级别</c>


492
00:24:18,825 --> 00:24:21,195 line:90%,end
<c.magenta>因此 这种复制</c>
<c.magenta>会占量非常多的资源</c>


493
00:24:23,564 --> 00:24:24,865 line:90%,end
<c.magenta>现在 让我们看看</c>


494
00:24:24,932 --> 00:24:26,600 line:90%,end
<c.magenta>当我们请求</c>
<c.magenta>可变字符串资产时 会发生什么</c>


495
00:24:28,535 --> 00:24:31,104 line:90%,end
<c.magenta>NSMutableString是一个引用类型</c>
<c.magenta>没有进行桥接</c>


496
00:24:32,139 --> 00:24:34,007 line:90%,end
<c.magenta>因为没有进行桥接</c>
<c.magenta>因此不会进行复制</c>


497
00:24:34,575 --> 00:24:36,176 line:90%,end
<c.magenta>从而避免占用大量资源的复制操作</c>


498
00:24:37,511 --> 00:24:39,413 line:90%,end
<c.magenta>这种情况源自于</c>


499
00:24:39,479 --> 00:24:41,181 line:90%,end
<c.magenta>Swift的值语义与</c>


500
00:24:41,315 --> 00:24:42,816 line:90%,end
<c.magenta>NSTextStorage设计之间的不匹配</c>


501
00:24:42,950 --> 00:24:44,618 line:90%,end
<c.magenta>而需要使用引用语义</c>


502
00:24:44,685 --> 00:24:46,753 line:90%,end
<c.magenta>针对文本</c>
<c.magenta>进行性能管理</c>


503
00:24:47,754 --> 00:24:49,890 line:90%,end
<c.magenta>因此 现在Apple</c>
<c.magenta>致力于解决这个问题</c>


504
00:24:49,957 --> 00:24:51,792 line:90%,end
<c.magenta>但是我们还没有很好的解决方法</c>


505
00:24:51,925 --> 00:24:54,161 line:90%,end
<c.magenta>因此 你们应该认识到</c>
<c.magenta>这是可能会发生的情况</c>


506
00:24:54,394 --> 00:24:56,396 line:90%,end
<c.magenta>如果你要处理</c>
<c.magenta>大量的文本</c>


507
00:24:56,463 --> 00:24:59,066 line:90%,end
<c.magenta>并进行文本存储</c>
<c.magenta>使用MutableString访问文本</c>


508
00:24:59,299 --> 00:25:00,901 line:90%,end
<c.magenta>即使你不打算改变文本内容</c>


509
00:25:03,070 --> 00:25:04,137 line:90%,end
<c.magenta>但是 当你</c>


510
00:25:04,204 --> 00:25:06,073 line:90%,end
<c.magenta>将所有字符串访问</c>
<c.magenta>更改为使用MutableString之前</c>


511
00:25:06,139 --> 00:25:07,441 line:90%,end
<c.magenta>让我们再次考虑性能象限图</c>


512
00:25:08,208 --> 00:25:10,043 line:90%,end
<c.magenta>由于TextStorage API /b></c>
<c.magenta>的性质</c>


513
00:25:10,210 --> 00:25:13,480 line:90%,end
<c.magenta>从频率的角度来看</c>
<c.magenta>性能水平可能会处于上方位置</c>


514
00:25:13,714 --> 00:25:15,182 line:90%,end
<c.magenta>因此 真正的问题是</c>


515
00:25:15,449 --> 00:25:18,652 line:90%,end
<c.magenta>你希望TextStorage</c>
<c.magenta>包含多少内容？</c>


516
00:25:20,120 --> 00:25:23,123 line:90%,end
<c.magenta>1 KB？</c>
<c.magenta>这也许比较合适</c>


517
00:25:23,323 --> 00:25:25,292 line:90%,end
<c.magenta>如果你使用字符串资产</c>
<c.magenta>这没有问题</c>


518
00:25:26,960 --> 00:25:29,162 line:90%,end
<c.magenta>如果是1MB</c>


519
00:25:29,229 --> 00:25:30,731 line:90%,end
<c.magenta>性能水平将位于第一象限</c>


520
00:25:30,864 --> 00:25:32,766 line:90%,end
<c.magenta>你可能想要</c>
<c.magenta>使用MutableString</c>


521
00:25:34,001 --> 00:25:37,004 line:90%,end
<c.magenta>如果是1GB 那我真的希望</c>
<c.magenta>你使用MutableString</c>


522
00:25:39,106 --> 00:25:41,542 line:90%,end
<c.magenta>前面我说过 我们正在</c>
<c.magenta>努力解决这个问题</c>


523
00:25:41,642 --> 00:25:43,544 line:90%,end
<c.magenta>请在未来的版本中</c>
<c.magenta>留意这一点</c>


524
00:25:45,412 --> 00:25:46,914 line:90%,end
<c.magenta>现在 我们对于</c>
<c.magenta>字符串桥接</c>


525
00:25:46,980 --> 00:25:49,283 line:90%,end
<c.magenta>具有更透彻的理解</c>
<c.magenta>现在来看范围</c>


526
00:25:52,553 --> 00:25:54,821 line:90%,end
<c.magenta>我不知道你们是怎么想的</c>
<c.magenta>但是 当我必须在Swift中</c>


527
00:25:54,888 --> 00:25:57,291 line:90%,end
<c.magenta>使用范围和字符串索引时</c>
<c.magenta>我就是这样的心情</c>


528
00:25:58,225 --> 00:26:00,127 line:90%,end
<c.magenta>为了弄清楚原因 让我们来看</c>


529
00:26:00,260 --> 00:26:02,162 line:90%,end
<c.magenta>一个字符串 它含有用手捂脸的表情</c>


530
00:26:02,229 --> 00:26:04,398 line:90%,end
<c.magenta>这有一点</c>
<c.magenta>像我本人</c>


531
00:26:06,600 --> 00:26:07,568 line:90%,end
<c.magenta>这是我们的字符串</c>


532
00:26:07,801 --> 00:26:10,003 line:90%,end
<c.magenta>是一个长字符串</c>
<c.magenta>里面有很多人物表情</c>


533
00:26:10,771 --> 00:26:13,440 line:90%,end
<c.magenta>这个角色</c>
<c.magenta>包含三个图形组成部分</c>


534
00:26:13,674 --> 00:26:15,209 line:90%,end
<c.magenta>有一个黄色的捂脸表情</c>


535
00:26:15,876 --> 00:26:18,645 line:90%,end
<c.magenta>一个肤色修改器</c>
<c.magenta>可以修改黄肤色</c>


536
00:26:19,146 --> 00:26:20,314 line:90%,end
<c.magenta>还有一个性别修改器</c>


537
00:26:21,415 --> 00:26:23,817 line:90%,end
<c.magenta>这些图形组成部分</c>
<c.magenta>还不是全部</c>


538
00:26:24,017 --> 00:26:25,953 line:90%,end
<c.magenta>字符串中还有</c>
<c.magenta>两个控制角色</c>


539
00:26:26,019 --> 00:26:28,655 line:90%,end
<c.magenta>一个零宽度连接器</c>
<c.magenta>和一个变体选择器</c>


540
00:26:29,289 --> 00:26:31,425 line:90%,end
<c.magenta>让我们来看</c>
<c.magenta>构成字符串的</c>


541
00:26:31,491 --> 00:26:32,392 line:90%,end
<c.magenta>Unicode Scalar值</c>


542
00:26:32,492 --> 00:26:33,961 line:90%,end
<c.magenta>你可能不熟悉这个名词</c>


543
00:26:34,094 --> 00:26:37,097 line:90%,end
<c.magenta>Unicode Scalar值是一个21位数字</c>


544
00:26:37,164 --> 00:26:39,299 line:90%,end
<c.magenta>唯一地表示</c>
<c.magenta>Unicode字符</c>


545
00:26:40,067 --> 00:26:42,669 line:90%,end
<c.magenta>这是构成字符串的</c>
<c.magenta>Unicode Scalar值</c>


546
00:26:42,836 --> 00:26:45,606 line:90%,end
<c.magenta>以及与这些值</c>
<c.magenta>相关联的名称</c>


547
00:26:46,106 --> 00:26:48,509 line:90%,end
<c.magenta>如果你从Unicode Scalar角度</c>
<c.magenta>分析这个字符串</c>


548
00:26:48,775 --> 00:26:50,310 line:90%,end
<c.magenta>就会发现 它实际上</c>
<c.magenta>由五个不同的值构成</c>


549
00:26:50,377 --> 00:26:51,645 line:90%,end
<c.magenta>其长度为5</c>


550
00:26:53,247 --> 00:26:54,381 line:90%,end
<c.magenta>目前一切正常</c>


551
00:26:54,448 --> 00:26:56,416 line:90%,end
<c.magenta>如果你使用</c>
<c.magenta>Swift的字符串API</c>


552
00:26:56,884 --> 00:26:58,852 line:90%,end
<c.magenta>但是如果你使用NSAttributedString</c>


553
00:26:59,186 --> 00:27:01,622 line:90%,end
<c.magenta>或任何使用NSRange</c>


554
00:27:01,989 --> 00:27:04,024 line:90%,end
<c.magenta>它们实际上使用UTF-16</c>


555
00:27:04,558 --> 00:27:06,760 line:90%,end
<c.magenta>因此 若你从UTF-16</c>
<c.magenta>的角度看待这个字符串</c>


556
00:27:06,827 --> 00:27:09,696 line:90%,end
<c.magenta>它实际上包含7个值</c>
<c.magenta>其长度是7</c>


557
00:27:10,464 --> 00:27:12,966 line:90%,end
<c.magenta>这很容易让人感到困惑</c>
<c.magenta>当我们使用NSRange</c>


558
00:27:13,033 --> 00:27:15,035 line:90%,end
<c.magenta>和字符串索引范围时</c>
<c.magenta>会变得困难重重</c>


559
00:27:16,904 --> 00:27:18,205 line:90%,end
<c.magenta>因此 让我们来消除这些困惑</c>


560
00:27:18,272 --> 00:27:20,307 line:90%,end
<c.magenta>我们来讨论</c>
<c.magenta>如何使用NSAttributedString</c>


561
00:27:20,374 --> 00:27:21,875 line:90%,end
<c.magenta>它大量使用NSRange</c>


562
00:27:23,677 --> 00:27:24,978 line:90%,end
<c.magenta>这里有一个字符串</c>


563
00:27:26,146 --> 00:27:28,282 line:90%,end
<c.magenta>我想使用它</c>
<c.magenta>创建一个属性化字符串</c>


564
00:27:28,348 --> 00:27:31,118 line:90%,end
<c.magenta>并且将一个表情的</c>
<c.magenta>背景更改为绿色</c>


565
00:27:34,154 --> 00:27:35,322 line:90%,end
<c.magenta>这个工作比较复杂</c>


566
00:27:35,389 --> 00:27:38,025 line:90%,end
<c.magenta>我自己都好几次</c>
<c.magenta>忘记怎么做了 但请不要告诉别人</c>


567
00:27:39,560 --> 00:27:41,128 line:90%,end
<c.magenta>我可能需要在网上查找</c>


568
00:27:41,195 --> 00:27:42,229 line:90%,end
<c.magenta>然后</c>


569
00:27:42,362 --> 00:27:44,264 line:90%,end
<c.magenta>我可能会编写</c>
<c.magenta>这样的代码</c>


570
00:27:45,232 --> 00:27:47,201 line:90%,end
<c.magenta>看上去并不合适</c>
<c.magenta>因为我必须</c>


571
00:27:47,267 --> 00:27:50,003 line:90%,end
<c.magenta>在这个字符串API</c>
<c.magenta>和这个NSString API之间转来转去</c>


572
00:27:51,071 --> 00:27:54,007 line:90%,end
<c.magenta>我必须获取我的初始字符串</c>
<c.magenta>然后使用它创建一个NSString</c>


573
00:27:54,074 --> 00:27:56,510 line:90%,end
<c.magenta>然后使用NSString</c>
<c.magenta>计算NSRange</c>


574
00:27:56,743 --> 00:27:57,778 line:90%,end
<c.magenta>然后 我必须回过头来</c>


575
00:27:58,078 --> 00:27:59,980 line:90%,end
<c.magenta>再次使用我的初始字符串</c>


576
00:28:00,047 --> 00:28:01,448 line:90%,end
<c.magenta>创建我的NSMutableAttributedString</c>


577
00:28:01,849 --> 00:28:03,784 line:90%,end
<c.magenta>哎 我可不喜欢这样做</c>


578
00:28:04,318 --> 00:28:05,485 line:90%,end
<c.magenta>没有人喜欢这样做</c>


579
00:28:06,920 --> 00:28:08,856 line:90%,end
<c.magenta>一个好消息是</c>
<c.magenta>你再也不用这样做了</c>


580
00:28:09,089 --> 00:28:11,425 line:90%,end
<c.magenta>因为在Swift 4中</c>
<c.magenta>我们为NSRange 和Range</c>


581
00:28:11,491 --> 00:28:12,926 line:90%,end
<c.magenta>引入新的初始化器</c>


582
00:28:13,560 --> 00:28:17,030 line:90%,end
<c.magenta>因此 当我们使用</c>
<c.magenta>这些新初始化器时——谢谢</c>


583
00:28:17,631 --> 00:28:20,901 line:90%,end
<c.magenta>同样的代码将会变得如此简短</c>


584
00:28:20,968 --> 00:28:23,704 line:90%,end
<c.magenta>从而更容易识读</c>
<c.magenta>编写和记住</c>


585
00:28:24,204 --> 00:28:26,773 line:90%,end
<c.magenta>这里使用的</c>
<c.magenta>新NSRange初始化器</c>


586
00:28:26,840 --> 00:28:28,542 line:90%,end
<c.magenta>获取范围和Swift字符串</c>


587
00:28:28,609 --> 00:28:30,310 line:90%,end
<c.magenta>并使用它创建NSRange</c>


588
00:28:30,377 --> 00:28:33,247 line:90%,end
<c.magenta>你可以将它直接</c>
<c.magenta>传递给AttributedString API</c>


589
00:28:35,649 --> 00:28:37,718 line:90%,end
<c.magenta>现在 让我们</c>
<c.magenta>从另一个方向来看待这种转换</c>


590
00:28:37,784 --> 00:28:39,553 line:90%,end
<c.magenta>也就是从NSRange</c>
<c.magenta>到Range 和String Index</c>


591
00:28:41,555 --> 00:28:42,523 line:90%,end
<c.magenta>请看这个简单的例子</c>


592
00:28:42,589 --> 00:28:44,291 line:90%,end
<c.magenta>假设我们有这样的html代码</c>


593
00:28:44,525 --> 00:28:46,260 line:90%,end
<c.magenta>我们想要</c>
<c.magenta>打印所有起始标记</c>


594
00:28:46,960 --> 00:28:48,295 line:90%,end
<c.magenta>为此</c>


595
00:28:48,829 --> 00:28:51,131 line:90%,end
<c.magenta>我们将使用NSRegularExpression</c>
<c.magenta>查找我们想要的标记</c>


596
00:28:51,198 --> 00:28:52,432 line:90%,end
<c.magenta>然后将它们追加到字符串</c>


597
00:28:52,699 --> 00:28:53,567 line:90%,end
<c.magenta>听上去很正确 是吧？</c>


598
00:28:55,602 --> 00:28:57,304 line:90%,end
<c.magenta>但是NSRegularExpression API</c>


599
00:28:57,404 --> 00:28:59,339 line:90%,end
<c.magenta>从我的匹配组中</c>
<c.magenta>为我返回NSRange</c>


600
00:28:59,473 --> 00:29:01,074 line:90%,end
<c.magenta>我需要字符串索引的范围</c>


601
00:29:01,141 --> 00:29:02,743 line:90%,end
<c.magenta>以便将内容追加到我的Swift字符串</c>


602
00:29:04,178 --> 00:29:06,446 line:90%,end
<c.magenta>在这些新初始化器</c>
<c.magenta>推出之前</c>


603
00:29:06,813 --> 00:29:08,048 line:90%,end
<c.magenta>我们可能会使用这样的代码</c>


604
00:29:08,115 --> 00:29:10,384 line:90%,end
<c.magenta>从NSRange</c>
<c.magenta>转换到范围字符串索引</c>


605
00:29:11,151 --> 00:29:12,319 line:90%,end
<c.magenta>请回忆几分钟前</c>


606
00:29:12,386 --> 00:29:15,055 line:90%,end
<c.magenta>我们讲过的捂脸表情</c>
<c.magenta>为什么说从UTF-16的角度来看</c>


607
00:29:15,122 --> 00:29:16,423 line:90%,end
<c.magenta>它的长度为7</c>


608
00:29:16,490 --> 00:29:18,392 line:90%,end
<c.magenta>而从Unicode Scalar 的角度来看</c>
<c.magenta>它的长度是5？</c>


609
00:29:18,659 --> 00:29:23,263 line:90%,end
<c.magenta>这段代码有一点复杂</c>
<c.magenta>因为它进行从UTF-16</c>


610
00:29:23,597 --> 00:29:24,698 line:90%,end
<c.magenta>到Unicode Scalar的转换工作</c>


611
00:29:26,433 --> 00:29:27,968 line:90%,end
<c.magenta>但是现在</c>
<c.magenta>利用这些新数组初始化器</c>


612
00:29:28,035 --> 00:29:29,269 line:90%,end
<c.magenta>你不必自己完成这些工作</c>


613
00:29:29,803 --> 00:29:32,072 line:90%,end
<c.magenta>我们可以获取NSRange</c>
<c.magenta>从匹配组中取回</c>


614
00:29:32,372 --> 00:29:34,708 line:90%,end
<c.magenta>然后用它创建</c>
<c.magenta>字符串索引范围</c>


615
00:29:34,775 --> 00:29:36,243 line:90%,end
<c.magenta>然后直接追加到字符串</c>


616
00:29:36,844 --> 00:29:39,213 line:90%,end
<c.magenta>这更加方便</c>
<c.magenta>更容易使用</c>


617
00:29:39,913 --> 00:29:41,281 line:90%,end
<c.magenta>这些新初始化器</c>
<c.magenta>真的很不错</c>


618
00:29:41,348 --> 00:29:42,850 line:90%,end
<c.magenta>我希望你们使用它们</c>


619
00:29:42,916 --> 00:29:44,918 line:90%,end
<c.magenta>进行所有的Range</c>
<c.magenta>和NSRange转换</c>


620
00:29:47,321 --> 00:29:48,155 line:90%,end
<c.magenta>谢谢</c>


621
00:29:49,923 --> 00:29:51,191 line:90%,end
<c.magenta>关于Range就是这些</c>


622
00:29:51,258 --> 00:29:53,126 line:90%,end
<c.magenta>让我们来讨论文本布局</c>
<c.magenta>和呈现</c>


623
00:29:54,962 --> 00:29:55,796 line:90%,end
<c.magenta>文本是硬内容</c>


624
00:29:56,597 --> 00:29:57,965 line:90%,end
<c.magenta>在界面上 它看上去比较简单</c>


625
00:29:58,432 --> 00:29:59,766 line:90%,end
<c.magenta>因为每个人都知道文本内容是什么</c>


626
00:30:00,100 --> 00:30:01,902 line:90%,end
<c.magenta>所有人每天都会看到它</c>


627
00:30:02,236 --> 00:30:04,238 line:90%,end
<c.magenta>文本常见而又普通</c>


628
00:30:04,771 --> 00:30:08,141 line:90%,end
<c.magenta>因此 人们认为</c>
<c.magenta>它很简单</c>


629
00:30:09,243 --> 00:30:10,410 line:90%,end
<c.magenta>其实并不简单</c>


630
00:30:10,978 --> 00:30:12,880 line:90%,end
<c.magenta>文本会带来</c>
<c.magenta>一些性能挑战</c>


631
00:30:12,946 --> 00:30:14,481 line:90%,end
<c.magenta>因为它的大小变化多样</c>


632
00:30:16,717 --> 00:30:17,584 line:90%,end
<c.magenta>请思考这样的例子</c>


633
00:30:17,651 --> 00:30:22,389 line:90%,end
<c.magenta>我们的iOS有40个本地化版本</c>
<c.magenta>macOS有35个版本</c>


634
00:30:23,690 --> 00:30:27,327 line:90%,end
<c.magenta>watchOS有39个</c>
<c.magenta>tvOS有40个</c>


635
00:30:28,562 --> 00:30:29,830 line:90%,end
<c.magenta>在所有这些平台上</c>


636
00:30:29,897 --> 00:30:32,799 line:10%
<c.magenta>我们支持300种其它语言的</c>
<c.magenta>文本输入</c>


637
00:30:34,468 --> 00:30:36,537 line:10%
<c.magenta>每种语言都有</c>
<c.magenta>不同的规则</c>


638
00:30:36,603 --> 00:30:38,438 line:10%
<c.magenta>比如</c>
<c.magenta>断词和连字符等</c>


639
00:30:38,839 --> 00:30:41,141 line:10%
<c.magenta>这些会影响到分行</c>


640
00:30:41,275 --> 00:30:42,943 line:10%
<c.magenta>从而影响文本布局</c>


641
00:30:43,143 --> 00:30:44,811 line:10%
<c.magenta>进而影响文本呈现</c>


642
00:30:45,345 --> 00:30:46,847 line:10%
<c.magenta>我们的框架</c>
<c.magenta>需要正确地</c>


643
00:30:46,914 --> 00:30:48,482 line:10%
<c.magenta>处理所有这些语言</c>


644
00:30:50,217 --> 00:30:51,118 line:90%,end
<c.magenta>如果这还不能说明问题</c>


645
00:30:51,185 --> 00:30:52,853 line:90%,end
<c.magenta>让我们来看</c>


646
00:30:52,986 --> 00:30:54,388 line:90%,end
<c.magenta>在执行文本和呈现时</c>


647
00:30:54,488 --> 00:30:56,123 line:90%,end
<c.magenta>框架需要考虑的其它一些因素</c>


648
00:30:56,590 --> 00:30:57,991 line:90%,end
<c.magenta>我们必须考虑所有这些因素</c>


649
00:30:58,058 --> 00:31:00,861 line:90%,end
<c.magenta>以正确、高性能地</c>
<c.magenta>呈现你的文本</c>


650
00:31:01,094 --> 00:31:01,995 line:90%,end
<c.magenta>因此我建议你们</c>


651
00:31:02,062 --> 00:31:04,631 line:90%,end
<c.magenta>尽可能地</c>
<c.magenta>使用标准标签控件</c>


652
00:31:05,532 --> 00:31:08,702 line:90%,end
<c.magenta>由于要考虑许多不同的可变因素</c>
<c.magenta>我们的框架使用</c>


653
00:31:08,769 --> 00:31:10,838 line:90%,end
<c.magenta>多种底层</c>
<c.magenta>优化策略</c>


654
00:31:11,471 --> 00:31:14,408 line:90%,end
<c.magenta>必须根据具体的情况</c>
<c.magenta>选择合适的优化策略</c>


655
00:31:14,474 --> 00:31:16,476 line:90%,end
<c.magenta>而且必须满足多个条件</c>


656
00:31:16,610 --> 00:31:17,711 line:90%,end
<c.magenta>以正确地应用策略</c>


657
00:31:18,812 --> 00:31:20,614 line:90%,end
<c.magenta>我想要提醒你们</c>


658
00:31:20,681 --> 00:31:22,616 line:90%,end
<c.magenta>当你们在标准控件基础上</c>
<c.magenta>使用自己的优化策略时</c>


659
00:31:22,683 --> 00:31:24,017 line:90%,end
<c.magenta>必须非常小心</c>


660
00:31:24,551 --> 00:31:26,653 line:90%,end
<c.magenta>因为呈现条件或</c>
<c.magenta>输入数据的改变</c>


661
00:31:26,820 --> 00:31:29,489 line:90%,end
<c.magenta>可能会让你的优化失效</c>
<c.magenta>而无法获得性能提升</c>


662
00:31:31,124 --> 00:31:32,459 line:90%,end
<c.magenta>为了描述我的含义</c>


663
00:31:32,526 --> 00:31:35,362 line:90%,end
<c.magenta>让我们来看一个例子</c>
<c.magenta>一个含有两个标签的表格</c>


664
00:31:37,464 --> 00:31:38,565 line:90%,end
<c.magenta>曾经有一位开发者</c>


665
00:31:39,032 --> 00:31:41,668 line:90%,end
<c.magenta>想要在她的应用中</c>
<c.magenta>显示许多的标签</c>


666
00:31:42,603 --> 00:31:45,072 line:90%,end
<c.magenta>而且每个标签</c>
<c.magenta>都有一行粗体文本</c>


667
00:31:45,305 --> 00:31:47,107 line:90%,end
<c.magenta>后面是一行普通文本</c>


668
00:31:48,141 --> 00:31:51,211 line:90%,end
<c.magenta>她想要手动设置标准边框</c>
<c.magenta>来定位她的标签</c>


669
00:31:51,278 --> 00:31:52,946 line:90%,end
<c.magenta>这是出于商业原因</c>


670
00:31:54,882 --> 00:31:57,784 line:90%,end
<c.magenta>她使用属性字符串</c>
<c.magenta>设置标签 显示她的内容</c>


671
00:31:59,486 --> 00:32:02,256 line:90%,end
<c.magenta>但是她注意到</c>
<c.magenta>应用的滚动显示性能</c>


672
00:32:02,322 --> 00:32:04,091 line:90%,end
<c.magenta>低于她的预期</c>


673
00:32:04,892 --> 00:32:06,393 line:90%,end
<c.magenta>因此她进行分析</c>


674
00:32:06,793 --> 00:32:09,396 line:90%,end
<c.magenta>结果发现</c>
<c.magenta>标签的布局和呈现</c>


675
00:32:09,463 --> 00:32:11,398 line:90%,end
<c.magenta>花费了大量的时间</c>


676
00:32:13,066 --> 00:32:14,701 line:90%,end
<c.magenta>于是 她做了一些试验</c>


677
00:32:15,002 --> 00:32:19,973 line:90%,end
<c.magenta>然后注意到</c>
<c.magenta>如果每个行显示在单独的标签中</c>


678
00:32:20,207 --> 00:32:21,842 line:90%,end
<c.magenta>应用滚动显示性能将会得到提升</c>


679
00:32:22,242 --> 00:32:23,610 line:90%,end
<c.magenta>“这太神奇了” 她心里想到</c>


680
00:32:23,877 --> 00:32:24,711 line:90%,end
<c.magenta>于是她修改应用</c>


681
00:32:24,778 --> 00:32:26,346 line:90%,end
<c.magenta>每个行都使用单独的标签</c>


682
00:32:26,547 --> 00:32:27,948 line:90%,end
<c.magenta>然后她感到很高兴</c>


683
00:32:28,015 --> 00:32:31,618 line:90%,end
<c.magenta>直到有一天 她的公司</c>
<c.magenta>进入中国市场</c>


684
00:32:33,053 --> 00:32:35,489 line:90%,end
<c.magenta>于是她使用中文</c>
<c.magenta>测试她的应用</c>


685
00:32:36,056 --> 00:32:37,591 line:90%,end
<c.magenta>她吃惊地发现</c>


686
00:32:37,891 --> 00:32:41,028 line:90%,end
<c.magenta>滚动显示性能</c>
<c.magenta>比以前更低了</c>


687
00:32:42,262 --> 00:32:43,430 line:90%,end
<c.magenta>这到底是怎么了？</c>


688
00:32:44,998 --> 00:32:47,868 line:90%,end
<c.magenta>这位开发者</c>
<c.magenta>尝试找到正确的方法</c>


689
00:32:48,268 --> 00:32:50,938 line:90%,end
<c.magenta>她看到许多短字符串</c>
<c.magenta>频繁地进行显示</c>


690
00:32:51,305 --> 00:32:53,106 line:90%,end
<c.magenta>从而让性能水平落入第二象限</c>


691
00:32:54,508 --> 00:32:56,143 line:90%,end
<c.magenta>因此 她采取一些措施</c>


692
00:32:56,276 --> 00:32:57,744 line:90%,end
<c.magenta>找到改进突破口</c>


693
00:32:57,811 --> 00:32:59,513 line:90%,end
<c.magenta>于是进行优化</c>


694
00:33:00,447 --> 00:33:03,083 line:90%,end
<c.magenta>但是 当输入数据</c>
<c.magenta>变成中文时</c>


695
00:33:03,217 --> 00:33:05,385 line:90%,end
<c.magenta>优化无法</c>
<c.magenta>获得性能改进</c>


696
00:33:06,286 --> 00:33:08,088 line:90%,end
<c.magenta>为了弄清楚原因 我们进行事后分析</c>


697
00:33:09,489 --> 00:33:10,457 line:90%,end
<c.magenta>在这个例子中</c>


698
00:33:10,724 --> 00:33:12,926 line:90%,end
<c.magenta>初始条件</c>
<c.magenta>支持在框架内</c>


699
00:33:13,060 --> 00:33:14,928 line:90%,end
<c.magenta>更快速地显示</c>
<c.magenta>属性化字符串</c>


700
00:33:15,596 --> 00:33:18,265 line:90%,end
<c.magenta>优化方法</c>
<c.magenta>是将每个行放入单独的标签</c>


701
00:33:18,398 --> 00:33:20,267 line:90%,end
<c.magenta>利用这样一个特性</c>
<c.magenta>即仅包含一种文本样式的</c>


702
00:33:20,334 --> 00:33:23,770 line:90%,end
<c.magenta>属性化字符串</c>
<c.magenta>支持更快速的呈现</c>


703
00:33:25,472 --> 00:33:28,308 line:90%,end
<c.magenta>但是 要实现更快速的呈现</c>
<c.magenta>只有这个条件还不够</c>


704
00:33:28,909 --> 00:33:30,944 line:90%,end
<c.magenta>快速呈现方案会走捷径</c>


705
00:33:31,011 --> 00:33:33,080 line:90%,end
<c.magenta>对输入数据和</c>
<c.magenta>呈现条件</c>


706
00:33:33,146 --> 00:33:34,381 line:90%,end
<c.magenta>进行特定的预测</c>


707
00:33:34,615 --> 00:33:37,317 line:90%,end
<c.magenta>在本例中 使用中文文本</c>
<c.magenta>将需要字体回调</c>


708
00:33:37,384 --> 00:33:39,086 line:90%,end
<c.magenta>强制在框架内</c>
<c.magenta>使用慢速的</c>


709
00:33:39,152 --> 00:33:40,988 line:90%,end
<c.magenta>呈现路径</c>
<c.magenta>以保持正确性</c>


710
00:33:42,055 --> 00:33:42,923 line:90%,end
<c.magenta>在此基础上</c>


711
00:33:42,990 --> 00:33:44,791 line:90%,end
<c.magenta>将双行字符串</c>
<c.magenta>放入不同的标签</c>


712
00:33:44,858 --> 00:33:47,761 line:90%,end
<c.magenta>意味着将需要</c>
<c.magenta>对许多标签进行两次呈现</c>


713
00:33:50,097 --> 00:33:52,966 line:90%,end
<c.magenta>此外应用使用陈旧的布局方法</c>


714
00:33:53,033 --> 00:33:55,569 line:90%,end
<c.magenta>手动设置边框</c>
<c.magenta>而不是使用自动布局 也会降低性能</c>


715
00:33:56,270 --> 00:33:58,172 line:90%,end
<c.magenta>因此一般来说</c>
<c.magenta>在使用新技术时</c>


716
00:33:58,238 --> 00:34:00,807 line:90%,end
<c.magenta>比如自动布局</c>
<c.magenta>我们应该更加注意</c>


717
00:34:00,874 --> 00:34:01,708 line:90%,end
<c.magenta>特定条件下的性能问题</c>


718
00:34:01,775 --> 00:34:03,410 line:90%,end
<c.magenta>因为多数应用都会使用这些技术</c>


719
00:34:03,477 --> 00:34:04,912 line:90%,end
<c.magenta>且在这些方面</c>
<c.magenta>性能优化会带来</c>


720
00:34:04,978 --> 00:34:06,113 line:90%,end
<c.magenta>最大的影响</c>


721
00:34:07,047 --> 00:34:08,282 line:90%,end
<c.magenta>以自动布局为例</c>


722
00:34:08,348 --> 00:34:10,617 line:90%,end
<c.magenta>文本系统缓存</c>
<c.magenta>一些布局信息</c>


723
00:34:10,851 --> 00:34:12,219 line:90%,end
<c.magenta>这可以切实地提升性能</c>


724
00:34:12,286 --> 00:34:14,188 line:90%,end
<c.magenta>但是由于这个应用</c>
<c.magenta>未使用自动布局</c>


725
00:34:14,721 --> 00:34:15,856 line:90%,end
<c.magenta>因此无法利用这一优势</c>


726
00:34:17,190 --> 00:34:18,192 line:90%,end
<c.magenta>因此请记住</c>


727
00:34:18,559 --> 00:34:20,694 line:90%,end
<c.magenta>有一些策略和技巧</c>
<c.magenta>可以帮助你</c>


728
00:34:20,761 --> 00:34:23,797 line:90%,end
<c.magenta>改进应用中的文本布局</c>
<c.magenta>和呈现性能</c>


729
00:34:25,666 --> 00:34:26,733 line:90%,end
<c.magenta>若你一直在认真听讲</c>


730
00:34:26,800 --> 00:34:28,668 line:90%,end
<c.magenta>你可能已知道</c>
<c.magenta>我要说的第一个策略是</c>


731
00:34:30,237 --> 00:34:32,139 line:90%,end
<c.magenta>使用标准标签</c>
<c.magenta>来呈现你的文本</c>


732
00:34:32,306 --> 00:34:33,907 line:90%,end
<c.magenta>其它的幕后工作请交给我们</c>


733
00:34:34,675 --> 00:34:37,177 line:90%,end
<c.magenta>在框架中</c>
<c.magenta>可以很好地运用优化策略</c>


734
00:34:37,244 --> 00:34:39,413 line:90%,end
<c.magenta>因为它能够概览地</c>
<c.magenta>显示整个界面</c>


735
00:34:39,478 --> 00:34:41,547 line:90%,end
<c.magenta>并且提供关于</c>
<c.magenta>呈现条件的更多信息</c>


736
00:34:42,516 --> 00:34:44,384 line:90%,end
<c.magenta>当我们进行性能优化之后</c>


737
00:34:44,451 --> 00:34:46,286 line:90%,end
<c.magenta>你们将自动获得这些好处</c>


738
00:34:46,887 --> 00:34:48,054 line:90%,end
<c.magenta>来看一个例子</c>


739
00:34:48,422 --> 00:34:51,058 line:90%,end
<c.magenta>在macOS 10.13中 NSTextField的</c>


740
00:34:51,123 --> 00:34:54,360 line:90%,end
<c.magenta>文本呈现速度提高三倍</c>
<c.magenta>在实时大小调整时</c>


741
00:34:54,527 --> 00:34:55,529 line:90%,end
<c.magenta>速度达到5.7毫秒/帧</c>


742
00:34:55,762 --> 00:34:59,132 line:90%,end
<c.magenta>相比以前的</c>
<c.magenta>16.67毫秒/帧缩短10.12毫秒</c>


743
00:34:59,800 --> 00:35:01,735 line:90%,end
<c.magenta>你们将会免费</c>
<c.magenta>得到这种性能提升</c>


744
00:35:01,802 --> 00:35:03,437 line:90%,end
<c.magenta>如果你们使用</c>
<c.magenta>标准框架控件</c>


745
00:35:03,871 --> 00:35:04,872 line:90%,end
<c.magenta>因此 使用标准控制</c>


746
00:35:04,938 --> 00:35:07,007 line:90%,end
<c.magenta>确实是很好的做法</c>
<c.magenta>应该尽可能这样做</c>


747
00:35:10,444 --> 00:35:12,546 line:90%,end
<c.magenta>第二个策略</c>
<c.magenta>也就是刚才的故事中所讲到的</c>


748
00:35:13,080 --> 00:35:14,948 line:90%,end
<c.magenta>应该使用最新的布局方法</c>
<c.magenta>比如自动布局</c>


749
00:35:15,516 --> 00:35:16,917 line:90%,end
<c.magenta>我们认真地研究了</c>


750
00:35:16,984 --> 00:35:18,018 line:90%,end
<c.magenta>使用新技术</c>


751
00:35:18,085 --> 00:35:20,287 line:90%,end
<c.magenta>所获得的文本布局和呈现性能提升</c>


752
00:35:20,888 --> 00:35:22,623 line:90%,end
<c.magenta>通过采用这些新技术</c>


753
00:35:22,689 --> 00:35:25,158 line:90%,end
<c.magenta>将很少会遇到</c>
<c.magenta>我们还没见到和改进的</c>


754
00:35:25,225 --> 00:35:26,860 line:90%,end
<c.magenta>边界情况</c>


755
00:35:30,797 --> 00:35:32,432 line:90%,end
<c.magenta>接下来介绍一个基本技巧</c>


756
00:35:32,799 --> 00:35:34,668 line:90%,end
<c.magenta>如果你使用NSAttributedString</c>


757
00:35:34,968 --> 00:35:35,903 line:90%,end
<c.magenta>有一些属性</c>


758
00:35:35,969 --> 00:35:38,438 line:90%,end
<c.magenta>对于布局和呈现来说</c>
<c.magenta>十分必要</c>


759
00:35:39,339 --> 00:35:41,275 line:90%,end
<c.magenta>如果你没有</c>
<c.magenta>自己提供这些属性</c>


760
00:35:41,375 --> 00:35:44,178 line:90%,end
<c.magenta>文本系统将需要处理它们</c>
<c.magenta>才能进行呈现</c>


761
00:35:44,545 --> 00:35:46,446 line:90%,end
<c.magenta>因此 如果你自己提供</c>
<c.magenta>这些属性</c>


762
00:35:46,513 --> 00:35:48,115 line:90%,end
<c.magenta>在呈现属性化字符串时</c>


763
00:35:48,348 --> 00:35:49,650 line:90%,end
<c.magenta>可以节约一些时间</c>


764
00:35:52,186 --> 00:35:53,153 line:90%,end
<c.magenta>同样地</c>


765
00:35:53,453 --> 00:35:54,655 line:90%,end
<c.magenta>显式指定写入方向和对齐</c>


766
00:35:54,721 --> 00:35:57,491 line:90%,end
<c.magenta>而不是使用默认设置</c>
<c.magenta>也可以带来</c>


767
00:35:57,558 --> 00:35:59,059 line:90%,end
<c.magenta>少量的性能提升</c>


768
00:35:59,960 --> 00:36:01,061 line:90%,end
<c.magenta>这将帮助你节约一些时间</c>


769
00:36:01,128 --> 00:36:02,996 line:90%,end
<c.magenta>因为文本系统</c>
<c.magenta>会跳过一些逻辑</c>


770
00:36:03,063 --> 00:36:05,399 line:90%,end
<c.magenta>无需花费时间来确定</c>
<c.magenta>写入方向和对齐</c>


771
00:36:06,500 --> 00:36:07,968 line:90%,end
<c.magenta>但是请记住</c>
<c.magenta>在这样做时</c>


772
00:36:08,035 --> 00:36:10,204 line:90%,end
<c.magenta>你必须绝对确定</c>
<c.magenta>你的输入数据</c>


773
00:36:10,270 --> 00:36:12,206 line:90%,end
<c.magenta>不会包含混合式写入方向</c>


774
00:36:12,539 --> 00:36:14,675 line:90%,end
<c.magenta>现在 我们已经在</c>
<c.magenta>性能与正确性之间取得平衡</c>


775
00:36:14,875 --> 00:36:17,311 line:90%,end
<c.magenta>一个优化方法是</c>
<c.magenta>如果你对输入不是很确定</c>


776
00:36:17,444 --> 00:36:20,147 line:90%,end
<c.magenta>可以让平衡点</c>
<c.magenta>偏离正确性远一点</c>


777
00:36:23,584 --> 00:36:26,086 line:90%,end
<c.magenta>这些代码描述如何</c>
<c.magenta>在性能与正确性之间进行取舍</c>


778
00:36:26,420 --> 00:36:29,389 line:90%,end
<c.magenta>如果你知道你的所有标签</c>
<c.magenta>都只会包含一行内容</c>


779
00:36:29,723 --> 00:36:31,658 line:90%,end
<c.magenta>你可以设置换行模式</c>
<c.magenta>以使用剪辑</c>


780
00:36:32,392 --> 00:36:34,628 line:90%,end
<c.magenta>默认情况下</c>
<c.magenta>标签使用文字包裹</c>


781
00:36:34,795 --> 00:36:36,930 line:90%,end
<c.magenta>当你这样做时</c>
<c.magenta>文本系统需要确定</c>


782
00:36:36,997 --> 00:36:38,198 line:90%,end
<c.magenta>在哪些位置进行分行</c>


783
00:36:38,599 --> 00:36:40,367 line:90%,end
<c.magenta>如果你使用</c>
<c.magenta>剪辑分行模式</c>


784
00:36:40,467 --> 00:36:43,136 line:90%,end
<c.magenta>将会跳过这个分行</c>
<c.magenta>和连字逻辑</c>


785
00:36:43,203 --> 00:36:45,172 line:90%,end
<c.magenta>文本呈现速度</c>
<c.magenta>将会加快</c>


786
00:36:47,875 --> 00:36:50,410 line:90%,end
<c.magenta>最后进行总结</c>
<c.magenta>今天我们讨论了很多内容</c>


787
00:36:50,511 --> 00:36:52,312 line:90%,end
<c.magenta>从Foundation 中的</c>
<c.magenta>性能改进</c>


788
00:36:52,546 --> 00:36:54,548 line:90%,end
<c.magenta>到字符串桥接和文本处理</c>


789
00:36:55,182 --> 00:36:56,984 line:90%,end
<c.magenta>如果你只能记住本演讲中的</c>
<c.magenta>一项内容</c>


790
00:36:57,217 --> 00:36:58,085 line:90%,end
<c.magenta>那么应该是这个图表</c>


791
00:36:58,685 --> 00:37:00,654 line:90%,end
<c.magenta>请使用规模和频率概念</c>


792
00:37:00,787 --> 00:37:03,390 line:90%,end
<c.magenta>最低限度减少代码中的</c>
<c.magenta>运行资源开支</c>


793
00:37:03,724 --> 00:37:05,259 line:90%,end
<c.magenta>不要专注于不常用的项目</c>


794
00:37:05,592 --> 00:37:07,261 line:90%,end
<c.magenta>在不确定时 应该进行评估</c>


795
00:37:10,063 --> 00:37:12,833 line:90%,end
<c.magenta>想了解更多内容</c>
<c.magenta>请访问我们的演讲URL</c>


796
00:37:12,933 --> 00:37:14,234 line:90%,end
<c.magenta>本演讲是244</c>


797
00:37:15,769 --> 00:37:19,406 line:90%,end
<c.magenta>另外请观看</c>
<c.magenta>这些相关的演讲视频</c>


798
00:37:19,840 --> 00:37:22,309 line:90%,end
<c.magenta>它们非常不错 遗憾的是</c>
<c.magenta>大多数演讲已经结束</c>


799
00:37:23,277 --> 00:37:24,945 line:90%,end
<c.magenta>谢谢</c>
<c.magenta>请关注本次大会的其它内容</c>

