1
00:00:16,750 --> 00:00:22,656 line:0
（使用XCODE和LLDB
进行高级调试）


2
00:00:22,723 --> 00:00:25,092 line:0
（演讲412）


3
00:00:29,696 --> 00:00:33,767 line:-2
大家好 欢迎来到“使用Xcode
和LLDB进行高级调试”


4
00:00:33,834 --> 00:00:35,769 line:-2
我是Chris Miles
Xcode团队的工程经理之一


5
00:00:35,836 --> 00:00:38,372 line:-1
今天我非常高兴能够来到这里


6
00:00:38,772 --> 00:00:41,475 line:-2
我知道你们已经对稍后的啤酒狂欢节
早已迫不及待


7
00:00:41,542 --> 00:00:43,443 line:-1
所以谢谢你们的光临


8
00:00:43,577 --> 00:00:44,645 line:-1
我们会及时结束


9
00:00:44,811 --> 00:00:47,147 line:-2
但今天我们为你提供了
许多精彩的内容


10
00:00:47,548 --> 00:00:48,782 line:-1
所以我们马上来看看吧


11
00:00:49,583 --> 00:00:52,786 line:-1
我想先谈谈Swift调试的可靠性


12
00:00:53,220 --> 00:00:55,722 line:-1
这里的重点是我们带来了好消息


13
00:00:55,923 --> 00:00:59,960 line:-2
我们团队已在Xcode 10中
修复了很多可靠性问题


14
00:01:02,095 --> 00:01:03,931 line:-1
谢谢


15
00:01:08,502 --> 00:01:10,971 line:-1
编译器和调试器团队已经解决了


16
00:01:11,038 --> 00:01:14,441 line:-2
许多导致Swift调试
令人头痛的问题


17
00:01:14,675 --> 00:01:16,243 line:-1
我想告诉你们其中几个


18
00:01:17,477 --> 00:01:20,013 line:-2
在某些情况下
通常是在更复杂的项目或构建配置中


19
00:01:20,080 --> 00:01:22,749 line:-1
尝试po一个对象


20
00:01:22,816 --> 00:01:25,085 line:-1
或在控制台中执行一条表达式


21
00:01:25,786 --> 00:01:27,855 line:-2
可能会失败
并产生这样的错误信息


22
00:01:28,589 --> 00:01:32,626 line:-2
此错误所说的AST上下文
是一个表达式上下文


23
00:01:32,693 --> 00:01:35,829 line:-1
LLDB需要它来恢复你构建项目时


24
00:01:35,896 --> 00:01:37,231 line:-1
编译器的状态


25
00:01:37,598 --> 00:01:38,565 line:-1
而在某些情况下


26
00:01:38,632 --> 00:01:40,100 line:-1
比如当模块有冲突时


27
00:01:40,400 --> 00:01:43,570 line:-1
这时表达式上下文不能可靠地重建


28
00:01:43,837 --> 00:01:45,305 line:-1
你的表达式就会失败


29
00:01:46,273 --> 00:01:49,343 line:-2
在Xcode 10中
LLDB实现了回退机制


30
00:01:49,409 --> 00:01:51,011 line:-1
以处理这种情况


31
00:01:51,278 --> 00:01:53,213 line:-1
如果它不能重建上下文


32
00:01:53,547 --> 00:01:56,083 line:-2
它会回退到创建一个
当前帧的更简单的上下文


33
00:01:56,316 --> 00:01:59,319 line:-1
并使用它来评估你的表达式


34
00:02:00,854 --> 00:02:03,090 line:-1
一些开发者可能遇到的另一种错误


35
00:02:03,357 --> 00:02:06,894 line:-2
是由于调试器无法在调试时
实现某些变量类型


36
00:02:07,127 --> 00:02:07,995 line:-1
所造成的


37
00:02:08,695 --> 00:02:11,565 line:-1
这在Xcode中看起来像这样


38
00:02:11,932 --> 00:02:13,967 line:-1
在左侧 你可以看到变量视图


39
00:02:14,034 --> 00:02:15,936 line:-1
显示了当前帧中所有变量的名称


40
00:02:16,336 --> 00:02:18,605 line:-1
但不会显示任何类型信息或值


41
00:02:18,972 --> 00:02:21,308 line:-1
尝试打印出变量的值


42
00:02:21,508 --> 00:02:23,076 line:-1
可能会失败并产生像这样的错误


43
00:02:24,711 --> 00:02:26,914 line:-1
现在 再次感谢你们的漏洞报告


44
00:02:26,980 --> 00:02:30,417 line:-1
我们团队已经能够追踪并修复这些


45
00:02:30,484 --> 00:02:33,320 line:-1
调试信息不能可靠生成的边缘案例


46
00:02:33,754 --> 00:02:36,089 line:-1
所以我想再次代表团队感谢你们


47
00:02:36,156 --> 00:02:39,259 line:-1
在遇到调试问题时


48
00:02:39,326 --> 00:02:40,594 line:-1
能够提交问题报告


49
00:02:40,928 --> 00:02:43,931 line:-2
如果你在调试项目时
发现Xcode 10


50
00:02:43,997 --> 00:02:45,098 line:-1
还有其他问题


51
00:02:45,399 --> 00:02:47,234 line:-1
请继续为我们提交错误报告


52
00:02:47,634 --> 00:02:49,136 line:-1
对于参加这次演讲的你们来说


53
00:02:49,203 --> 00:02:50,437 line:-1
如果你发现项目存在问题


54
00:02:50,504 --> 00:02:51,705 line:-1
请到实验室来


55
00:02:51,772 --> 00:02:55,676 line:-2
明天早上我们有一个
Xcode调试和分析实验


56
00:02:55,742 --> 00:02:56,677 line:-1
从九点到十二点


57
00:02:57,077 --> 00:02:59,246 line:-2
带上你的项目并找到
Xcode调试工程师


58
00:02:59,446 --> 00:03:02,282 line:-2
或LLDB工程师
他们很期待看到你的项目


59
00:03:05,419 --> 00:03:07,321 line:-1
现在我想继续告诉你


60
00:03:07,387 --> 00:03:10,157 line:-1
一些我最喜欢的调试技巧和窍门


61
00:03:10,424 --> 00:03:12,826 line:-1
我喜欢用它们来增强我的调试流程


62
00:03:13,393 --> 00:03:15,028 line:-1
事实上 我不只是要告诉你


63
00:03:15,162 --> 00:03:16,697 line:-1
我还想为你演示一下


64
00:03:26,306 --> 00:03:29,743 line:-2
我们今天要使用的项目是一个叫做
Solar System的iOS app


65
00:03:29,977 --> 00:03:32,980 line:-2
你可能见到过
Solar System出现在


66
00:03:33,046 --> 00:03:35,182 line:-2
Keynote演讲
和“国情咨文”中


67
00:03:35,849 --> 00:03:38,218 line:-2
我们将要调试
Solar System中的一个部分


68
00:03:38,352 --> 00:03:39,419 line:-1
其被称为Moon Jumper


69
00:03:40,354 --> 00:03:42,523 line:-2
Moon Jumper
允许用户握住手机


70
00:03:42,589 --> 00:03:43,724 line:-1
并跳到空中


71
00:03:44,525 --> 00:03:45,993 line:-1
该app可衡量你的跳跃力量


72
00:03:46,059 --> 00:03:48,128 line:-1
然后将其转换为月球重力


73
00:03:48,529 --> 00:03:51,298 line:-1
并向你展示如果你站在月球上


74
00:03:51,365 --> 00:03:52,733 line:-1
你刚才跳跃的高度


75
00:03:53,400 --> 00:03:55,569 line:-1
你可以设置一条栏来作为目标


76
00:03:55,836 --> 00:03:58,739 line:-2
然后你可以试着挑战自己
尽量在月球重力下


77
00:03:58,805 --> 00:03:59,940 line:-1
跳到该栏的高度


78
00:04:01,008 --> 00:04:03,610 line:-2
现在我们对Moon Jumper
进行一些改进


79
00:04:04,344 --> 00:04:07,681 line:-2
如一些视觉增强
和GamePlay模式


80
00:04:08,148 --> 00:04:09,383 line:-1
我们还没有准备好交付


81
00:04:09,550 --> 00:04:12,519 line:-2
我们已经做了一次测试
并得到一个漏洞列表


82
00:04:12,886 --> 00:04:14,154 line:-1
我们需要仔细看看它


83
00:04:14,688 --> 00:04:16,223 line:-2
所以这些都是
Solar System的漏洞


84
00:04:16,456 --> 00:04:18,291 line:-1
我会先解决iOS上的漏洞


85
00:04:18,358 --> 00:04:22,129 line:-2
稍后 Sebastian将上台
解决macOS端的漏洞


86
00:04:22,663 --> 00:04:25,632 line:-2
现在 正如它所说的
谁都不能离开去参加啤酒狂欢


87
00:04:25,699 --> 00:04:27,201 line:-1
直到我们修复所有这些漏洞


88
00:04:27,501 --> 00:04:31,205 line:-2
所以没什么比与2000人结对编程
更令人振奋的事了


89
00:04:33,006 --> 00:04:35,642 line:-2
让我们马上动手
并从第一个漏洞开始


90
00:04:35,709 --> 00:04:38,212 line:-1
跳跃失败动画与规范不符


91
00:04:38,946 --> 00:04:40,047 line:-1
那是在说什么？


92
00:04:40,681 --> 00:04:42,049 line:-1
我们切换到模拟器


93
00:04:42,115 --> 00:04:45,519 line:-2
因为我们正在使用模拟器
来加快调试和开发


94
00:04:45,819 --> 00:04:47,521 line:-1
我连接了点击动作来识别它们


95
00:04:47,888 --> 00:04:49,122 line:-1
所以每次我点击宇航员


96
00:04:49,189 --> 00:04:51,425 line:-1
他都会成功跳到栏的高度


97
00:04:52,359 --> 00:04:54,862 line:-2
现在这个漏洞说的是
当宇航员没有达到


98
00:04:54,928 --> 00:04:57,297 line:-2
栏的高度的情况
所以让我们重现一下


99
00:04:57,764 --> 00:04:59,032 line:-1
切换到编辑器


100
00:04:59,333 --> 00:05:02,236 line:-1
我将使用跳转栏导航到jump函数


101
00:05:02,936 --> 00:05:04,905 line:-1
并在该函数的开始处设置一个断点


102
00:05:05,472 --> 00:05:06,473 line:-1
现在我点击宇航员


103
00:05:06,974 --> 00:05:09,610 line:-2
我们将进行一次跳跃
现在我们在调试器中暂停了


104
00:05:10,444 --> 00:05:13,146 line:-1
要指出的第一件事是在标签栏中


105
00:05:13,480 --> 00:05:14,748 line:-1
这里有四个选项卡


106
00:05:14,815 --> 00:05:17,150 line:-2
这个调试选项卡是由Xcode
刚为我们创建的


107
00:05:17,518 --> 00:05:19,987 line:-2
对于那些像我一样
喜欢在选项卡中工作的人来说


108
00:05:20,454 --> 00:05:22,489 line:-1
这是你可以定义的Xcode行为


109
00:05:26,727 --> 00:05:29,963 line:-2
为了做到这一点 你需要使用
Xcode菜单来编辑行为


110
00:05:30,030 --> 00:05:33,033 line:-2
这将你带到Behavior
选项卡中的首选项


111
00:05:33,100 --> 00:05:35,235 line:-1
在这里你可以配置许多行为


112
00:05:35,602 --> 00:05:38,939 line:-2
在这个例子中
你需要配置Running部分中的


113
00:05:39,239 --> 00:05:40,374 line:-1
Pauses的行为


114
00:05:40,674 --> 00:05:44,545 line:-2
这就是
当Xcode在调试器中暂停时


115
00:05:44,611 --> 00:05:45,612 line:-1
所触发的行为


116
00:05:45,679 --> 00:05:48,348 line:-2
你可在此看到我已配置它
显示名为Debug的选项卡


117
00:05:48,615 --> 00:05:50,551 line:-2
当在调试器中暂停时
Xcode将始终


118
00:05:50,717 --> 00:05:51,852 line:-1
切换到该选项卡


119
00:05:52,152 --> 00:05:54,855 line:-2
对于像我一样喜欢在选项卡中
工作的用户 这非常棒


120
00:05:55,622 --> 00:05:56,590 line:-1
现在切换回代码


121
00:05:56,657 --> 00:05:58,792 line:-2
我们可以看到有一个条件语句
基于这个


122
00:05:59,059 --> 00:06:00,227 line:-1
didReachSelectedHeight属性


123
00:06:00,627 --> 00:06:03,297 line:-1
所以我想看看这个属性的值


124
00:06:03,597 --> 00:06:05,365 line:-1
我们切换到调试控制台


125
00:06:05,732 --> 00:06:08,569 line:-2
我可以使用po命令来查看
该属性的值


126
00:06:08,635 --> 00:06:09,937 line:-1
它当前的值为true


127
00:06:11,004 --> 00:06:11,972 line:-1
现在我想…


128
00:06:12,039 --> 00:06:14,508 line:-2
点击动作只是识别我已连接
并且总是


129
00:06:14,575 --> 00:06:15,709 line:-1
将其值设置为true


130
00:06:15,776 --> 00:06:18,078 line:-2
我想将其更改为false
以便重现该错误


131
00:06:18,579 --> 00:06:20,681 line:-1
现在我们在代码中对其进行修改


132
00:06:20,881 --> 00:06:22,883 line:-2
点击以识别它
并将其设置为false


133
00:06:22,950 --> 00:06:26,587 line:-2
但我不想仅为了调试目的
而对我的代码进行更改


134
00:06:26,653 --> 00:06:27,654 line:-1
如果我能避免的话


135
00:06:28,021 --> 00:06:31,358 line:-2
所以在这种情况下
我可以让调试器为我做这件事


136
00:06:31,425 --> 00:06:33,093 line:-2
我可使用
expression命令


137
00:06:33,360 --> 00:06:37,464 line:-2
我可以给它任何Swift表达式
例如


138
00:06:37,531 --> 00:06:39,733 line:-1
didReachSelectedHeight=false


139
00:06:39,800 --> 00:06:42,302 line:-1
它会评估并执行它


140
00:06:42,436 --> 00:06:45,873 line:-2
现在我们可以看到这个属性
确实已经变成了false


141
00:06:46,473 --> 00:06:48,642 line:-1
如果我使用调试器单步执行这行代码


142
00:06:48,709 --> 00:06:51,044 line:-2
可以看到 我们已进入了
分支的else语句块


143
00:06:51,645 --> 00:06:53,780 line:-2
当我们继续运行时
我们可以看到宇航员


144
00:06:54,181 --> 00:06:56,717 line:-1
无法跳到栏的高度并掉落下来


145
00:06:57,217 --> 00:06:59,086 line:-1
这正是我们试图重现的情况


146
00:06:59,152 --> 00:07:02,389 line:-2
我希望每次点击宇航员时
都会发生这种情况


147
00:07:02,556 --> 00:07:05,058 line:-2
但我不想每次都暂停
并输入这个表达式


148
00:07:05,626 --> 00:07:08,562 line:-2
所以我要做的就是配置这个断点
来为我做这件事


149
00:07:09,296 --> 00:07:10,631 line:-1
如果我右键点击断点


150
00:07:10,998 --> 00:07:12,566 line:0
我可以选择
Edit Breakpoint


151
00:07:13,000 --> 00:07:14,568 line:0
这将显示一个弹出窗口


152
00:07:15,035 --> 00:07:18,472 line:0
用一些配置来定制断点的行为


153
00:07:18,839 --> 00:07:20,908 line:0
我将Action设置为
Debugger Command


154
00:07:21,708 --> 00:07:23,744 line:0
并输入表达式命令


155
00:07:23,810 --> 00:07:26,680 line:0
即我在调试控制台中使用的命令


156
00:07:27,948 --> 00:07:29,950 line:0
并使其成为一个自动继续断点


157
00:07:30,417 --> 00:07:31,985 line:0
我们在这里配置的是一个断点


158
00:07:32,052 --> 00:07:34,021 line:0
一旦执行到这个函数


159
00:07:34,087 --> 00:07:35,389 line:0
该断点将被触发


160
00:07:35,455 --> 00:07:36,757 line:0
为我们执行这个命令


161
00:07:36,857 --> 00:07:39,359 line:-2
更改属性的值
然后自动继续执行


162
00:07:39,760 --> 00:07:41,428 line:-1
现在每当我点击宇航员时


163
00:07:41,728 --> 00:07:44,531 line:-1
他都会执行这个不成功的跳跃并回落


164
00:07:45,132 --> 00:07:47,067 line:-1
现在我们需要解决什么问题呢？


165
00:07:47,534 --> 00:07:49,269 line:-1
规范说 跌倒后


166
00:07:49,336 --> 00:07:51,071 line:-1
宇航员应该再次站起来


167
00:07:51,438 --> 00:07:52,639 line:-1
现在我们来修复它


168
00:07:53,607 --> 00:07:57,277 line:-2
我将导航到此函数
updateUIForJumpFailed


169
00:07:57,744 --> 00:08:00,080 line:-2
我们可以看到这个函数
使用UIKit Dynamics


170
00:08:00,147 --> 00:08:02,382 line:-1
来模拟失败跳跃


171
00:08:02,916 --> 00:08:05,853 line:-2
它首先创建一个
UIDynamicAnimator


172
00:08:06,153 --> 00:08:09,022 line:-2
然后调用一个函数来添加行为
以创建物理效果


173
00:08:09,423 --> 00:08:12,693 line:-2
然后宇航员应该在
dynamicAnimatorDidPause代理回调中


174
00:08:12,960 --> 00:08:16,463 line:-1
被重新调整方向并定位到屏幕中间


175
00:08:17,331 --> 00:08:19,566 line:-2
现在我们可以向下滚动
并看到委托回调


176
00:08:19,766 --> 00:08:21,235 line:-1
已成功实现


177
00:08:21,502 --> 00:08:22,402 line:-1
这部分看起来很好


178
00:08:22,936 --> 00:08:25,572 line:-1
但我注意到这个对象没有设置委托


179
00:08:26,340 --> 00:08:28,408 line:-1
所以如果我在这里添加该代码


180
00:08:28,775 --> 00:08:30,911 line:-1
我认为这个更改可以解决我们的问题


181
00:08:31,512 --> 00:08:34,114 line:-1
现在我可以重新编译并运行


182
00:08:34,313 --> 00:08:35,682 line:-1
并尝试和验证我的修复


183
00:08:36,049 --> 00:08:38,485 line:-2
但如果可以的话
我想尽量缩短整个周期


184
00:08:38,552 --> 00:08:42,256 line:-2
所以我要做的是使用一个断点
来为我注入这个变化


185
00:08:42,322 --> 00:08:46,026 line:-2
以便我可以快速方便地看到
这是否可以解决问题


186
00:08:46,660 --> 00:08:50,430 line:0
我在这里创建一个断点
双击打开编辑窗口


187
00:08:51,031 --> 00:08:53,033 line:0
这是调出编辑窗口的快捷方式


188
00:08:53,433 --> 00:08:55,602 line:0
然后再次使用值为
Debugger Command的Action


189
00:08:55,669 --> 00:08:56,870 line:0
来注入一个表达式


190
00:08:57,137 --> 00:08:59,373 line:0
输入我认为能解决问题的


191
00:08:59,473 --> 00:09:00,741 line:0
那行代码


192
00:09:01,241 --> 00:09:02,976 line:0
并使其成为一个自动继续的断点


193
00:09:03,410 --> 00:09:04,311 line:0
我在这里进行配置


194
00:09:04,378 --> 00:09:05,679 line:0
尽管我已经修改了代码


195
00:09:05,746 --> 00:09:06,980 line:-1
但我还没有重新编译过


196
00:09:07,147 --> 00:09:09,416 line:-1
我通过使用自定义断点


197
00:09:09,483 --> 00:09:10,817 line:-1
来为我注入更改


198
00:09:10,884 --> 00:09:13,820 line:-2
因此我可以使用
当前的实时app进行测试


199
00:09:14,388 --> 00:09:15,522 line:-1
如果我现在点击宇航员


200
00:09:15,589 --> 00:09:19,059 line:-2
他执行了这次不成功的跳跃并摔倒
然后重新站起来


201
00:09:19,126 --> 00:09:20,694 line:-1
我们似乎已经解决了这个问题


202
00:09:20,928 --> 00:09:22,596 line:-2
我喜欢这个效果
我打算再做一次


203
00:09:28,602 --> 00:09:31,004 line:-1
现在我们再看看笔记


204
00:09:31,939 --> 00:09:34,007 line:-1
我们可以勾掉第一个


205
00:09:34,842 --> 00:09:35,976 line:-1
漏洞表示已修复


206
00:09:36,610 --> 00:09:38,779 line:-1
没有比勾掉已修复的漏洞更好的事了


207
00:09:39,446 --> 00:09:42,249 line:-2
接下来的三个漏洞
是关于新的GamePlay模式的


208
00:09:42,316 --> 00:09:43,183 line:-1
我一直在研究它


209
00:09:43,317 --> 00:09:45,652 line:-2
我在模拟器中
点击Play向你展示它


210
00:09:45,853 --> 00:09:49,156 line:-2
这里的挑战是
尝试跳过栏10次以上


211
00:09:49,456 --> 00:09:51,658 line:-2
栏一开始较低
随后每次升高一些


212
00:09:53,193 --> 00:09:56,096 line:-2
你还可以看到
顶部添加了一些分数标签


213
00:09:56,430 --> 00:09:57,598 line:-1
如果我点击宇航员


214
00:09:57,831 --> 00:10:00,367 line:-2
你会看到他仍然被配置为
执行不成功的跳跃


215
00:10:00,868 --> 00:10:03,537 line:-2
这时顶部的Attempts标签
应该增加


216
00:10:03,804 --> 00:10:04,638 line:-1
但它没有


217
00:10:04,972 --> 00:10:06,406 line:-2
这是我们在此遇到的
第一个漏洞


218
00:10:06,473 --> 00:10:08,141 line:-1
这个标签闪了一下但没有改变


219
00:10:08,876 --> 00:10:10,978 line:-1
我们也遇到了游戏结束状态


220
00:10:11,044 --> 00:10:12,179 line:-1
处理不当的问题


221
00:10:12,579 --> 00:10:15,282 line:-2
及Scores标签
和Attempts标签布局问题


222
00:10:15,349 --> 00:10:16,517 line:-1
我们稍后再解决它们


223
00:10:16,950 --> 00:10:17,951 line:-1
回到这个漏洞


224
00:10:18,418 --> 00:10:20,387 line:-2
如果你没有注意到
让我再次点击宇航员


225
00:10:20,454 --> 00:10:22,489 line:-2
并密切关注顶部的
Attempts标签


226
00:10:23,190 --> 00:10:25,692 line:-1
你会看到它闪了一下但没有更新


227
00:10:26,126 --> 00:10:29,029 line:-1
所以这表明标签正在获取一个值


228
00:10:29,096 --> 00:10:30,797 line:-1
因为我们看到了过渡动画


229
00:10:31,331 --> 00:10:32,499 line:-1
然而值不正确


230
00:10:32,666 --> 00:10:34,101 line:-1
所以我想找到


231
00:10:34,368 --> 00:10:36,136 line:-1
修改此标签的代码


232
00:10:36,336 --> 00:10:38,071 line:-1
来看看它的逻辑是什么


233
00:10:38,705 --> 00:10:41,542 line:-2
我们注意到用户界面标签正在尝试
改变文本属性


234
00:10:41,775 --> 00:10:44,077 line:-1
所以我要做的是切换到断点导航器


235
00:10:44,511 --> 00:10:46,680 line:-1
并点击底部这里的加号按钮


236
00:10:46,980 --> 00:10:49,383 line:-1
来创建这些专门断点之一


237
00:10:50,050 --> 00:10:52,052 line:-2
你可以看到这里有
Swift Error Breakpoint


238
00:10:52,119 --> 00:10:53,787 line:-2
和Exception Breakpoint
甚至Test Failure Breakpoint


239
00:10:54,054 --> 00:10:56,190 line:-2
但在这个例子中
我将使用Symbolic Breakpoint


240
00:10:57,124 --> 00:10:59,326 line:-2
这样就创建了一个新的断点
并启动了编辑器


241
00:10:59,393 --> 00:11:02,963 line:-1
在这里我们可以输入任何函数


242
00:11:03,030 --> 00:11:05,365 line:-2
或方法名称
如我们在这里用到的


243
00:11:06,333 --> 00:11:07,701 line:-1
UILabel setText


244
00:11:08,302 --> 00:11:10,404 line:-1
且我们用Objective-C格式输入


245
00:11:10,470 --> 00:11:12,806 line:-2
因为UIKit是一个
Objective-C框架


246
00:11:13,507 --> 00:11:17,277 line:-1
需要指出的是断点下面


247
00:11:17,344 --> 00:11:19,213 line:-1
有一个子行


248
00:11:19,346 --> 00:11:21,815 line:-2
这是来自调试器的反馈
它告诉我们


249
00:11:21,882 --> 00:11:23,617 line:-2
它能够在UIKit Core中的
一个位置


250
00:11:23,750 --> 00:11:25,552 line:-1
解析这个断点


251
00:11:26,086 --> 00:11:28,121 line:-1
某些符号可能会解析到多个位置


252
00:11:28,188 --> 00:11:29,489 line:-1
它们都会显示在这里


253
00:11:29,556 --> 00:11:31,258 line:-1
如果你没有看到子条目


254
00:11:31,425 --> 00:11:34,761 line:-1
这表明调试器无法解析你的断点


255
00:11:34,862 --> 00:11:36,129 line:-1
因此它永远不会命中


256
00:11:36,196 --> 00:11:37,431 line:-1
准备好这些以后


257
00:11:37,764 --> 00:11:39,666 line:-1
我再次点击宇航员


258
00:11:40,367 --> 00:11:43,570 line:-2
现在可以看到 我们在
UILabel setText中命中了该断点


259
00:11:43,804 --> 00:11:46,607 line:-1
然而我们没有UIKit的源代码


260
00:11:46,773 --> 00:11:48,208 line:-1
所以我们看到的是汇编代码


261
00:11:48,509 --> 00:11:50,010 line:-1
但没有必要留在黑暗中


262
00:11:50,077 --> 00:11:52,513 line:-1
即使你处于一个框架的汇编代码中


263
00:11:52,880 --> 00:11:54,281 line:-1
并且是系统中的的一个框架


264
00:11:54,348 --> 00:11:57,150 line:-1
我们可以检查传入函数的参数


265
00:11:57,684 --> 00:11:59,987 line:-1
你只需要知道该架构的调用约定


266
00:12:00,053 --> 00:12:02,456 line:-1
就可以检查寄存器以查看参数


267
00:12:02,856 --> 00:12:05,259 line:-1
我承认我永远记不住


268
00:12:05,859 --> 00:12:06,994 line:-1
那些寄存器是什么


269
00:12:07,060 --> 00:12:09,796 line:-2
但幸运的是我不必这样做
因为调试器提供了


270
00:12:09,863 --> 00:12:10,998 line:-1
伪寄存器


271
00:12:11,698 --> 00:12:14,234 line:-1
现在 $arg1代表保存了


272
00:12:14,301 --> 00:12:15,602 line:-1
第一个参数的寄存器


273
00:12:15,836 --> 00:12:17,804 line:-1
现在我们可以看看


274
00:12:17,871 --> 00:12:19,306 line:-2
该Objective-C
消息的接受者


275
00:12:19,573 --> 00:12:21,041 line:-1
这是一个UILabel实例


276
00:12:22,009 --> 00:12:24,278 line:-1
我们看到它的值为“17 ft”


277
00:12:24,678 --> 00:12:27,381 line:-1
这表明它是这里的这个高度标签


278
00:12:27,981 --> 00:12:29,516 line:-1
因此它不是我们感兴趣的标签


279
00:12:29,583 --> 00:12:31,451 line:-1
我们再来看看其他的参数


280
00:12:32,119 --> 00:12:34,121 line:-2
如果你熟悉
objc_msgSend


281
00:12:34,388 --> 00:12:36,857 line:-2
你可能会记得第二个参数
应该是选择器


282
00:12:37,558 --> 00:12:39,059 line:-2
可我们并没有看到它
那是因为


283
00:12:39,126 --> 00:12:42,095 line:-2
LLDB不会自动知道
这些参数的类型


284
00:12:42,162 --> 00:12:43,931 line:-2
因此在某些情况下
我们需要对它进行类型转换


285
00:12:44,164 --> 00:12:45,933 line:-1
现在我们看到了这个消息的选择器


286
00:12:46,633 --> 00:12:49,303 line:-1
第三个参数是传递到方法中的


287
00:12:49,369 --> 00:12:50,871 line:-1
第一个参数


288
00:12:51,471 --> 00:12:53,807 line:-2
换句话说
它是传递给setText的字符串


289
00:12:54,174 --> 00:12:56,577 line:-1
所以这对于在一个框架的汇编帧中


290
00:12:56,643 --> 00:13:00,147 line:-1
检查参数来说非常方便


291
00:13:01,048 --> 00:13:02,382 line:-1
这也不是我们感兴趣的标签


292
00:13:02,449 --> 00:13:05,085 line:-1
所以让我们点击继续


293
00:13:05,219 --> 00:13:06,420 line:-1
现在我们再次命中断点


294
00:13:06,486 --> 00:13:08,722 line:-1
我们可以检查$arg1


295
00:13:08,789 --> 00:13:10,591 line:-1
看看接收者是什么


296
00:13:10,891 --> 00:13:13,861 line:-2
看起来它是同一个高度标签
其值现在为“0 ft”


297
00:13:14,328 --> 00:13:15,996 line:-1
现在我知道我的策略出了什么问题


298
00:13:16,997 --> 00:13:18,298 line:-1
当宇航员跳跃时


299
00:13:18,665 --> 00:13:20,934 line:-1
代码实时更新高度标签


300
00:13:21,235 --> 00:13:26,173 line:-1
所以断点会频繁地命中这个对象


301
00:13:26,406 --> 00:13:27,574 line:-1
这将花费我们很长时间


302
00:13:27,641 --> 00:13:29,476 line:-1
要命中一个Attempts标签的


303
00:13:29,543 --> 00:13:31,979 line:-2
UILabel setText
断点是非常困难的


304
00:13:32,346 --> 00:13:36,250 line:-2
所以我认为我应该做的
只是将这个符号断点


305
00:13:36,383 --> 00:13:38,252 line:-1
设置在跳跃动画完成后


306
00:13:38,852 --> 00:13:40,254 line:-1
有一个方法可以做到这一点


307
00:13:41,054 --> 00:13:42,923 line:-1
我将切换到断点导航器


308
00:13:43,056 --> 00:13:45,859 line:-1
如果我双击符号断点的指示符


309
00:13:46,126 --> 00:13:47,761 line:-1
就可以重新调出编辑器


310
00:13:48,128 --> 00:13:49,696 line:-2
我们可以使用这个
Condition字段


311
00:13:49,963 --> 00:13:52,332 line:-2
我们可以在这里输入一个
返回true或false的表达式


312
00:13:52,699 --> 00:13:55,769 line:-2
只有当该表达式计算结果
为true时 才会触发断点


313
00:13:56,170 --> 00:13:59,206 line:-2
因此如果我们有一个属性
如jumpAnimationInProgress


314
00:13:59,506 --> 00:14:01,708 line:-2
我们写一个表达式
测试它是否为false


315
00:14:01,975 --> 00:14:03,343 line:-1
然后断点就会被触发


316
00:14:03,744 --> 00:14:05,045 line:-1
然而我没有该属性


317
00:14:05,112 --> 00:14:06,547 line:-1
我要告诉你一个不同的方法


318
00:14:07,114 --> 00:14:08,949 line:-1
我将删除该符号断点


319
00:14:09,449 --> 00:14:12,819 line:-2
并向下滚动到此函数
jumpCompleted


320
00:14:12,886 --> 00:14:14,087 line:-1
并在这里设置一个断点


321
00:14:14,655 --> 00:14:17,791 line:-2
jumpCompleted函数
将会在动画完成后被调用


322
00:14:18,225 --> 00:14:20,394 line:-2
以便它可以更新用户界面
并更新游戏状态


323
00:14:21,094 --> 00:14:23,030 line:-1
然而我们不希望在这个函数中中断


324
00:14:23,297 --> 00:14:26,300 line:-1
我想要做的只是配置这个断点


325
00:14:26,366 --> 00:14:29,136 line:-2
并让它在UILabel setText处
替我设置一个符号断点


326
00:14:29,603 --> 00:14:31,805 line:-2
我可以通过添加一个
Debugger Command的Action来做到这点


327
00:14:32,472 --> 00:14:36,410 line:-2
命令为breakpoint set
参数为--one-shot true


328
00:14:37,077 --> 00:14:39,680 line:-1
这个一次性断点是一个临时断点


329
00:14:39,746 --> 00:14:43,150 line:-1
它一旦触发后就会被自动删除


330
00:14:44,017 --> 00:14:46,019 line:-1
我们给它起一个有意义的名字


331
00:14:46,887 --> 00:14:48,088 line:-1
UILabel setText


332
00:14:48,255 --> 00:14:50,057 line:-1
并使其成为自动继续断点


333
00:14:50,390 --> 00:14:51,959 line:-1
这里我们创建了这样一个断点


334
00:14:52,359 --> 00:14:56,396 line:-2
即当执行进入
jumpCompleted函数时


335
00:14:56,697 --> 00:14:58,866 line:-1
它会替我们在我们感兴趣的位置


336
00:14:58,932 --> 00:15:01,134 line:-2
设置一个临时断点
然后继续执行


337
00:15:01,535 --> 00:15:03,637 line:-1
从而使我们只会在进入这个函数之后


338
00:15:03,704 --> 00:15:05,506 line:-1
才命中setText断点


339
00:15:06,173 --> 00:15:08,609 line:-2
让我们点击继续
我们看到跳跃动画


340
00:15:08,675 --> 00:15:09,943 line:-1
在模拟器中完成


341
00:15:10,911 --> 00:15:13,447 line:-2
并且现在我们在UILabel setText处
触发了断点


342
00:15:14,014 --> 00:15:16,750 line:-2
现在我们可以
通过使用po $arg1命令


343
00:15:17,084 --> 00:15:18,952 line:-1
看看该消息的接收者


344
00:15:19,319 --> 00:15:21,955 line:-2
我们看到这确实是
一个不同的UILabel实例


345
00:15:22,289 --> 00:15:23,223 line:-1
其值为0


346
00:15:23,457 --> 00:15:25,425 line:-2
因此它很可能是
顶部标签其中的一个


347
00:15:25,959 --> 00:15:27,561 line:-1
看起来我们找到了正确的对象


348
00:15:27,628 --> 00:15:30,564 line:-1
我们来看看修改这个标签值的代码


349
00:15:31,098 --> 00:15:33,000 line:-1
我们可以在调试导航器中执行此操作


350
00:15:33,066 --> 00:15:34,935 line:-1
通过选择栈中的下一帧


351
00:15:35,302 --> 00:15:37,638 line:-2
现在我们已经找到了
修改标签值的代码


352
00:15:38,105 --> 00:15:40,707 line:-1
它当前使用labelText变量


353
00:15:40,974 --> 00:15:42,442 line:-1
传入一个“0”字符串


354
00:15:42,743 --> 00:15:45,379 line:-2
往上看 我们看到
labelText始终被设置为


355
00:15:45,445 --> 00:15:47,781 line:-2
标签的当前值
难怪它不会改变


356
00:15:48,282 --> 00:15:51,418 line:-2
看起来valueText才是
包含新值的变量


357
00:15:51,485 --> 00:15:53,587 line:-1
所以可能只是打错了


358
00:15:53,654 --> 00:15:54,555 line:-1
让我们解决它


359
00:15:55,622 --> 00:15:57,024 line:-1
我们将它改为valueText


360
00:16:00,194 --> 00:16:01,695 line:-1
接下来我想做的


361
00:16:02,329 --> 00:16:04,865 line:-1
不是重新编译并运行以测试此更改


362
00:16:04,932 --> 00:16:08,001 line:-2
我想像之前一样
在当前运行的app上下文中


363
00:16:08,068 --> 00:16:10,571 line:-1
直接测试这个改变


364
00:16:10,938 --> 00:16:13,040 line:-2
所以我要在当前行的下面
添加一个断点


365
00:16:13,106 --> 00:16:15,776 line:-2
请记住 我们已经更改了代码
但我们没有重新编译


366
00:16:15,843 --> 00:16:17,411 line:-1
所以标签仍会被设为原来的样子


367
00:16:17,778 --> 00:16:21,081 line:-2
我们在下面添加我们的代码
将其设置为我们认为正确的值


368
00:16:21,448 --> 00:16:24,985 line:-2
设置另一个自定义断点
我们可以再次使用表达式


369
00:16:25,052 --> 00:16:28,355 line:-1
来注入该代码并使其自动继续


370
00:16:29,590 --> 00:16:31,959 line:-1
现在如果我点击继续


371
00:16:32,359 --> 00:16:33,660 line:-1
代码执行将经过这里


372
00:16:33,894 --> 00:16:36,196 line:-2
我们看到Attempts标签
确实已更新


373
00:16:36,964 --> 00:16:38,532 line:-1
我想确保它…


374
00:16:38,732 --> 00:16:39,733 line:-1
谢谢大家


375
00:16:44,671 --> 00:16:47,007 line:-1
我想确保它在一次成功跳跃后


376
00:16:47,274 --> 00:16:48,542 line:-1
也适用于Score标签


377
00:16:48,809 --> 00:16:51,311 line:-1
让我们回到这里


378
00:16:51,745 --> 00:16:54,081 line:-2
先移除jumpCompleted中的
替我们创建


379
00:16:54,147 --> 00:16:55,716 line:-1
一次性断点的这个断点


380
00:16:55,782 --> 00:16:57,017 line:-1
因为我们不再需要它了


381
00:16:57,384 --> 00:16:59,286 line:-1
我还要禁用jump函数中的断点


382
00:16:59,353 --> 00:17:02,356 line:-2
因为我们不想再改变
didReachSelectedHeight了


383
00:17:02,656 --> 00:17:03,924 line:-1
现在当我点击宇航员时


384
00:17:03,991 --> 00:17:05,392 line:-1
他进行一次成功的跳跃


385
00:17:05,692 --> 00:17:07,794 line:-1
我们可以看到所有标签都正确更新


386
00:17:07,861 --> 00:17:09,195 line:-1
这样看起来很棒


387
00:17:11,231 --> 00:17:13,066 line:-1
让我们回头把它勾掉


388
00:17:14,101 --> 00:17:15,636 line:-1
好的 接下来的漏洞是一个


389
00:17:15,702 --> 00:17:17,271 line:-1
关于游戏结束状态的问题


390
00:17:18,704 --> 00:17:20,607 line:-1
游戏本应该在10次尝试后结束


391
00:17:20,674 --> 00:17:23,676 line:-1
我可以点击宇航员并等待动画播放


392
00:17:23,877 --> 00:17:27,114 line:-2
持续这个过程直到那个状态
以尝试重现它


393
00:17:27,548 --> 00:17:28,916 line:-1
但播放动画需要一些时间


394
00:17:29,049 --> 00:17:30,918 line:-1
当测试并验证我的修复程序时


395
00:17:30,984 --> 00:17:33,153 line:-1
我可能需要多次这样做


396
00:17:33,487 --> 00:17:36,123 line:-1
因此我想跳过所有的跳跃动画


397
00:17:36,790 --> 00:17:38,158 line:-1
我们来看看如何做到这一点


398
00:17:38,892 --> 00:17:42,062 line:-2
我们导航到
updateUIForJumpSucceeded函数


399
00:17:42,796 --> 00:17:46,200 line:-2
我们可以看到这个函数
修改了一些颜色


400
00:17:46,266 --> 00:17:48,602 line:-2
然后调用了
jumpAstronaut(animated:true)


401
00:17:49,069 --> 00:17:51,705 line:-2
所以看起来我只需要调用
jumpAstronaut(animated:false)


402
00:17:52,072 --> 00:17:53,507 line:-1
我可以更改代码并重新编译


403
00:17:53,574 --> 00:17:54,441 line:-1
但正如我之前所说的


404
00:17:54,508 --> 00:17:56,777 line:-2
我不喜欢为了调试目的
而改变我的代码


405
00:17:56,844 --> 00:17:59,813 line:-2
如果我能避免这样做的话
所以我们来看看我将使用的技术


406
00:18:00,380 --> 00:18:01,849 line:-1
我在这一行上设置一个断点


407
00:18:02,049 --> 00:18:05,052 line:-2
让我们清除调试控制台
并通过点击宇航员


408
00:18:05,118 --> 00:18:06,320 line:-1
进行一次新的跳跃


409
00:18:06,386 --> 00:18:07,721 line:-1
现在我们在这一行暂停


410
00:18:08,088 --> 00:18:09,423 line:-1
我需要让调试器


411
00:18:09,723 --> 00:18:13,093 line:-2
将这行代码替换为
jumpAstronaut(animated:false)


412
00:18:13,627 --> 00:18:15,696 line:-2
然而代码已经编译过了
我们无法取代它


413
00:18:15,896 --> 00:18:18,966 line:-2
但我们可以做的是
让调试器跳过这一行


414
00:18:19,166 --> 00:18:20,567 line:-1
不执行它 而是跳过它


415
00:18:20,634 --> 00:18:23,070 line:-1
然后我们可以使用表达式来注入


416
00:18:23,270 --> 00:18:24,538 line:-1
我们所希望的调用


417
00:18:25,038 --> 00:18:26,540 line:-1
那么我们如何跳过一行代码呢


418
00:18:26,940 --> 00:18:29,409 line:-2
我们把注意力放在这个绿色的
Thread 1


419
00:18:29,576 --> 00:18:30,410 line:-1
注解标签上


420
00:18:30,477 --> 00:18:32,279 line:-1
我们称之为指令指针


421
00:18:32,579 --> 00:18:34,615 line:-1
它指向包含


422
00:18:34,681 --> 00:18:36,016 line:-1
接下来会执行的指令的行


423
00:18:36,416 --> 00:18:38,719 line:-1
这里的这个看起来像握柄的图标


424
00:18:39,286 --> 00:18:40,354 line:-1
实际上就是一个握柄


425
00:18:40,521 --> 00:18:42,356 line:-1
按住鼠标就可以移动它


426
00:18:42,723 --> 00:18:45,325 line:-1
这样我就可以在暂停时更改指令指针


427
00:18:45,759 --> 00:18:47,794 line:-1
我可以把它往下移动一行 然后放手


428
00:18:48,095 --> 00:18:50,430 line:-2
接着Xcode
会显示一条可怕的消息


429
00:18:50,898 --> 00:18:52,799 line:-1
它所说的基本就是


430
00:18:52,866 --> 00:18:55,002 line:-1
巨大的权力会带来巨大的责任


431
00:18:55,269 --> 00:18:56,970 line:-2
说实话
这是我今天告诉你们的


432
00:18:57,037 --> 00:18:58,071 line:-1
最危险的功能


433
00:18:58,505 --> 00:19:02,109 line:-2
这项操作是有风险的
因为调试器允许你移动指令指针


434
00:19:02,176 --> 00:19:03,577 line:-2
到你想要的任何地方
它并不关心


435
00:19:03,710 --> 00:19:05,779 line:-1
但它不能保证app的状态


436
00:19:05,846 --> 00:19:06,747 line:-1
完好无损


437
00:19:07,147 --> 00:19:09,449 line:-1
例如 这可能会造成内存管理问题


438
00:19:09,616 --> 00:19:12,686 line:-1
当你试图引用尚未初始化的对象


439
00:19:12,953 --> 00:19:14,655 line:-1
或过早释放对象时


440
00:19:15,255 --> 00:19:17,791 line:-2
但既然这是高级调试演讲
所以我们知道


441
00:19:17,858 --> 00:19:18,692 line:-1
我们在做什么


442
00:19:18,759 --> 00:19:19,893 line:-1
让我们按下蓝色按钮


443
00:19:21,361 --> 00:19:22,963 line:-1
现在我们跳过了那行代码


444
00:19:23,030 --> 00:19:24,064 line:-1
在控制台中


445
00:19:24,131 --> 00:19:26,967 line:-2
我们可以使用expression命令调用
jumpAstronaut(animated:false)


446
00:19:29,036 --> 00:19:31,038 line:-2
现在我们点击继续
来看看这一切是否奏效


447
00:19:31,672 --> 00:19:35,809 line:-2
游戏状态的确已更新
而且我们跳过了所有跳跃动画


448
00:19:37,244 --> 00:19:39,580 line:-1
我希望每当我点击宇航员时都能这样


449
00:19:39,880 --> 00:19:42,616 line:-2
所以我要配置这个断点
来为我做这件事


450
00:19:43,717 --> 00:19:47,487 line:-2
首先我们需要一个
跳过一行代码的调试器操作


451
00:19:47,621 --> 00:19:49,489 line:-2
它的命令是
thread jump


452
00:19:50,157 --> 00:19:51,491 line:-2
再给它一个参数
--by 1


453
00:19:51,692 --> 00:19:55,229 line:-1
这告诉调试器为当前线程


454
00:19:55,295 --> 00:19:56,230 line:-1
跳过一行代码


455
00:19:56,763 --> 00:19:59,566 line:-1
然后我们只需要调用表达式


456
00:19:59,633 --> 00:20:01,568 line:-1
我们可以通过点击加号按钮来


457
00:20:01,969 --> 00:20:03,737 line:-1
添加另一个命令操作


458
00:20:04,838 --> 00:20:08,208 line:-2
expression
jumpAstronaut(animated:false)


459
00:20:08,876 --> 00:20:10,244 line:-1
然后将其设置为自动继续


460
00:20:10,644 --> 00:20:14,014 line:-1
我们这里有一个断点


461
00:20:14,081 --> 00:20:17,251 line:-1
当运行到此行 但在执行此行之前


462
00:20:17,317 --> 00:20:18,752 line:-1
断点将被触发


463
00:20:19,052 --> 00:20:21,688 line:-1
它将执行跳过该行的命令


464
00:20:21,889 --> 00:20:24,124 line:-1
然后使用表达式来调用


465
00:20:24,491 --> 00:20:26,560 line:-1
我们想要调用的函数


466
00:20:27,294 --> 00:20:29,329 line:-1
现在 如果我们点击宇航员


467
00:20:29,696 --> 00:20:31,832 line:-1
我们可以快速推进游戏进展


468
00:20:31,899 --> 00:20:34,501 line:-2
并跳过所有动画
从而轻松地重现我们的漏洞


469
00:20:35,302 --> 00:20:38,872 line:-2
所以正如我所说的那样
游戏本应该在10次尝试后结束


470
00:20:38,939 --> 00:20:40,307 line:-1
我们已经远远超过了它


471
00:20:40,641 --> 00:20:43,243 line:-1
让我们来看看游戏状态


472
00:20:44,144 --> 00:20:46,380 line:-1
它们都被保存在上面这个属性中


473
00:20:47,014 --> 00:20:47,981 line:-1
即gamePlay


474
00:20:48,048 --> 00:20:50,217 line:-1
所以我会在该属性上设置一个断点


475
00:20:50,684 --> 00:20:52,019 line:-1
并执行一次新的跳跃


476
00:20:52,252 --> 00:20:54,922 line:-2
现在我们在对该属性的
下一个引用处暂停


477
00:20:55,556 --> 00:20:58,759 line:-2
我将使用po命令来查看
该对象的当前状态


478
00:20:59,159 --> 00:21:00,928 line:-1
这里我们看到对这个


479
00:21:01,228 --> 00:21:02,529 line:-1
GamePlay对象的调试描述


480
00:21:02,963 --> 00:21:04,865 line:-1
这里有一个自定义的调试描述


481
00:21:05,232 --> 00:21:07,601 line:-2
所以值得指出的是
po命令能够获得


482
00:21:07,668 --> 00:21:09,536 line:-1
对象的编程调试描述


483
00:21:09,937 --> 00:21:11,171 line:-1
而且你可以自定义该描述


484
00:21:11,738 --> 00:21:13,240 line:-2
来看看我们对GamePlay
做了什么


485
00:21:13,307 --> 00:21:14,641 line:-1
如果我切换到源代码


486
00:21:14,975 --> 00:21:15,976 line:-1
并滚动到底部


487
00:21:16,476 --> 00:21:19,379 line:-2
你可以看到我们添加了一个扩展
以使GamePlay符合


488
00:21:19,446 --> 00:21:21,582 line:-1
CustomDebugStringConvertible约束


489
00:21:22,149 --> 00:21:24,751 line:-1
该约束要求你实现


490
00:21:24,885 --> 00:21:27,588 line:-2
一个名为debugDescription的属性
并返回一个字符串


491
00:21:27,855 --> 00:21:30,224 line:-2
你可以返回你喜欢的
任何用于调试的字符串


492
00:21:30,457 --> 00:21:33,327 line:-1
来表示这个对象


493
00:21:34,027 --> 00:21:36,864 line:-2
你也可以通过实现
debugDescription


494
00:21:36,930 --> 00:21:39,366 line:-2
来对Objective-C对象
执行相同的操作


495
00:21:39,733 --> 00:21:41,835 line:-2
将其与命令
p GamePlay对比


496
00:21:42,936 --> 00:21:44,137 line:-1
p是另一种…


497
00:21:44,705 --> 00:21:46,773 line:-1
或LLDB命令


498
00:21:47,107 --> 00:21:50,644 line:-2
它使用LLDB的内置格式化程序
来表示对象


499
00:21:50,878 --> 00:21:53,080 line:-2
因此这里我们看到了
同一个对象的两个表示


500
00:21:53,547 --> 00:21:56,683 line:-2
并且默认格式化程序向你显示
完整限定类型名称


501
00:21:56,750 --> 00:21:59,920 line:-2
内存地址
以及所有属性及其值的列表


502
00:22:00,354 --> 00:22:02,489 line:-2
我们可在此看到
有一个maxAttempts属性


503
00:22:02,556 --> 00:22:03,857 line:-1
其值被正确设置为10


504
00:22:04,525 --> 00:22:06,827 line:-1
因此可能某处存在逻辑错误


505
00:22:07,027 --> 00:22:08,629 line:-1
在attempts的值增加后


506
00:22:08,695 --> 00:22:11,865 line:-2
没有正确判断出
它已经超过了最大值


507
00:22:12,199 --> 00:22:14,601 line:-2
所以我想找到修改
attempts值的代码


508
00:22:14,668 --> 00:22:15,502 line:-1
来看看其中的逻辑


509
00:22:16,303 --> 00:22:19,406 line:0
我将打开变量视图并展开视图控制器


510
00:22:19,473 --> 00:22:21,441 line:0
以查看其所有属性


511
00:22:21,508 --> 00:22:24,011 line:0
在底部我将在过滤器中
输入GamePlay


512
00:22:24,211 --> 00:22:25,345 line:0
来找到这个属性


513
00:22:25,679 --> 00:22:28,949 line:0
展开它的属性列表
然后选择attempts属性


514
00:22:29,716 --> 00:22:32,586 line:0
在这里打开其上下文菜单


515
00:22:32,953 --> 00:22:34,755 line:0
并选择
Watch “attempts”


516
00:22:36,256 --> 00:22:38,992 line:0
它所做的是创建一个所谓的观察点


517
00:22:39,626 --> 00:22:40,861 line:0
在断点导航器中


518
00:22:40,928 --> 00:22:42,095 line:0
在所有断点下面


519
00:22:42,296 --> 00:22:44,498 line:-2
你会看到有一个叫做
Watchpoints的新组


520
00:22:44,565 --> 00:22:46,400 line:-1
我们有一个attempts观察点


521
00:22:46,800 --> 00:22:48,635 line:-1
观察点就像一个断点


522
00:22:48,836 --> 00:22:51,905 line:-2
但它会在下一次变量的值改变时
暂停调试器


523
00:22:52,606 --> 00:22:55,576 line:-2
现在我们可以移除这个属性断点
因为我们不再需要它


524
00:22:55,943 --> 00:22:56,944 line:-1
然后点击继续


525
00:22:57,177 --> 00:22:58,979 line:-1
现在我们已经在这个观察点停了下来


526
00:22:59,146 --> 00:23:01,782 line:-2
并且我们找到了
修改attempts变量的代码


527
00:23:03,050 --> 00:23:05,285 line:-2
我现在禁用这个观察点
因为我不再需要它


528
00:23:05,552 --> 00:23:07,888 line:-2
我们看看这里的代码
当游戏正在进行时


529
00:23:07,955 --> 00:23:10,390 line:-2
增加attempts
如跳跃成功则增加score


530
00:23:10,657 --> 00:23:13,093 line:-2
我没有看到任何会检测
attempts是否已超过最大值


531
00:23:13,160 --> 00:23:16,496 line:-1
并转换到游戏结束状态的逻辑


532
00:23:17,130 --> 00:23:19,166 line:-1
所以我认为这就是需要改的地方


533
00:23:19,233 --> 00:23:20,734 line:-1
但在我实际更改任何代码之前


534
00:23:20,934 --> 00:23:22,836 line:-1
我想先测试我的假设


535
00:23:23,337 --> 00:23:25,105 line:-1
所以在我更改任何代码之前


536
00:23:25,405 --> 00:23:28,408 line:-2
我要创建一个断点
并配置它注入该更改


537
00:23:28,609 --> 00:23:30,077 line:-1
以查看它是否修复了问题


538
00:23:30,444 --> 00:23:32,513 line:-2
我可以再次添加一个
调试器命令行为


539
00:23:32,579 --> 00:23:33,514 line:-1
和一个表达式


540
00:23:33,780 --> 00:23:37,818 line:-2
我们要的是如果attempts
大于等于maxAttempts


541
00:23:38,252 --> 00:23:40,287 line:-1
则将游戏状态更改为已结束


542
00:23:41,054 --> 00:23:42,389 line:-1
并将其设为自动继续


543
00:23:42,956 --> 00:23:45,526 line:-2
所以现在只需按下继续按钮
来测试一下


544
00:23:45,626 --> 00:23:46,660 line:-1
是否真正解决了问题


545
00:23:46,793 --> 00:23:48,829 line:-1
程序执行到这个断点


546
00:23:49,096 --> 00:23:50,364 line:-2
注入代码
我们可以看到


547
00:23:50,430 --> 00:23:52,332 line:-1
它确实修复了问题


548
00:23:52,799 --> 00:23:54,902 line:-1
我想从游戏开始时验证一下


549
00:23:54,968 --> 00:23:57,337 line:-2
我可以点击Play again
快速轻松地完成此操作


550
00:23:57,571 --> 00:23:59,540 line:-1
并迅速进行10次尝试


551
00:23:59,940 --> 00:24:02,776 line:-2
在第十次我们看到它确实检测到
游戏结束状态


552
00:24:02,843 --> 00:24:04,378 line:-1
看起来这正是我们需要的修复


553
00:24:12,152 --> 00:24:14,254 line:-1
别忘了将更改应用于你的代码


554
00:24:14,321 --> 00:24:17,357 line:-2
我将代码复制出来
拖动断点以删除它


555
00:24:17,691 --> 00:24:19,593 line:-2
然后将代码粘贴进去
看起来不错


556
00:24:20,327 --> 00:24:21,461 line:-1
我们来勾掉这一项


557
00:24:21,528 --> 00:24:23,363 line:-1
这个部分我们只剩下一个漏洞了


558
00:24:23,897 --> 00:24:26,266 line:-2
即Attempts
和Score标签的布局


559
00:24:26,633 --> 00:24:30,137 line:-2
现在这个app的布局工作
被留给了工程师们


560
00:24:30,404 --> 00:24:31,805 line:-1
就像优秀的工程师一样


561
00:24:32,105 --> 00:24:35,108 line:-2
我们找到了一个好位置
将它们填到顶角


562
00:24:35,509 --> 00:24:38,579 line:-1
但是团队认为这不太合适


563
00:24:38,779 --> 00:24:40,447 line:-2
他们将app退回
并要求我们再试一次


564
00:24:40,848 --> 00:24:44,351 line:-2
所以我想模拟出
这些分数标签的新布局


565
00:24:44,651 --> 00:24:47,321 line:-2
现在我可以打开我的图形app
并开始建模了


566
00:24:47,387 --> 00:24:49,423 line:-2
但我是一名工程师
我喜欢用代码建模


567
00:24:49,656 --> 00:24:50,858 line:-1
我其实是调试工程师


568
00:24:50,924 --> 00:24:54,027 line:-2
所以我喜欢用实时app
和真实数据在调试器中建模


569
00:24:54,094 --> 00:24:55,262 line:-1
我们看看如何做到这点


570
00:24:58,732 --> 00:25:02,703 line:-2
让我们导航回去
并在jump函数中设置断点


571
00:25:03,136 --> 00:25:05,772 line:-1
我们首先需要找到一个


572
00:25:05,839 --> 00:25:07,274 line:-1
可与其交互的视图的引用


573
00:25:07,708 --> 00:25:09,877 line:-1
所以我要清空这里并打开它


574
00:25:10,244 --> 00:25:12,412 line:-2
进行一次新的跳跃
然后调试器在


575
00:25:12,713 --> 00:25:15,382 line:-2
视图控制器内的这个
jump函数中暂停


576
00:25:15,949 --> 00:25:18,585 line:-2
所以如果你有一个视图的
属性或输出口


577
00:25:18,652 --> 00:25:20,320 line:-1
那么这是会一个很好的引用


578
00:25:20,387 --> 00:25:22,656 line:-2
但如果你没有
那你需要获得视图的内存地址


579
00:25:22,723 --> 00:25:24,892 line:-2
因此让我向你展示一些
查找内存地址的方法


580
00:25:24,958 --> 00:25:27,561 line:-1
以及如何仅通过内存地址来操作视图


581
00:25:28,195 --> 00:25:29,162 line:-1
像我们之前说的那样


582
00:25:30,197 --> 00:25:32,599 line:-1
调试描述包含一个自定义描述


583
00:25:32,900 --> 00:25:34,468 line:-1
所以看一下视图控制器的视图


584
00:25:34,535 --> 00:25:37,104 line:-2
我们可以看到UIView的
默认调试描述


585
00:25:37,437 --> 00:25:39,873 line:-1
其中包含视图的类和内存地址


586
00:25:40,140 --> 00:25:44,645 line:-2
所以一种方法就是
获取对象的调试描述


587
00:25:45,145 --> 00:25:48,315 line:-2
由于我们有一个属性指向它
所以很容易得到这个信息


588
00:25:48,682 --> 00:25:52,085 line:-2
但这个视图控制器视图
下面的所有视图该怎么办呢？


589
00:25:52,719 --> 00:25:54,121 line:-1
我们需要查看视图层次结构


590
00:25:54,188 --> 00:25:57,090 line:-1
一种方法是使用这里的这个按钮


591
00:25:57,157 --> 00:25:59,593 line:-2
它会调用Xcode的
可视化视图调试器


592
00:25:59,927 --> 00:26:03,130 line:-2
它将为层次结构拍摄快照
并为你提供3D分解视图


593
00:26:03,197 --> 00:26:05,232 line:-1
你可以用它来检查视图


594
00:26:05,666 --> 00:26:07,568 line:-2
Sebastian稍后
会详细讨论这个问题


595
00:26:07,634 --> 00:26:09,169 line:-1
所以我们来看看另一种方式


596
00:26:09,236 --> 00:26:11,338 line:-1
这对于更简单的层次结构很有用


597
00:26:11,738 --> 00:26:13,907 line:-1
并且只需在调试控制台中操作


598
00:26:14,708 --> 00:26:18,812 line:-2
这就是使用UIView上的调试函数
recursiveDescription


599
00:26:20,214 --> 00:26:23,717 line:-2
我们应该可以调用 po self.view.
.recursiveDescription()


600
00:26:24,751 --> 00:26:25,853 line:-1
但这行不通


601
00:26:25,986 --> 00:26:26,820 line:-1
为什么呢？


602
00:26:27,521 --> 00:26:30,257 line:-2
recursiveDescription
仅用于调试目的


603
00:26:30,457 --> 00:26:33,894 line:-2
它不是公共API的一部分
因此也不会被Swift扫描


604
00:26:34,328 --> 00:26:35,162 line:-1
所以…


605
00:26:35,462 --> 00:26:38,165 line:-2
Swift是一种严格的语言
不允许你调用


606
00:26:38,232 --> 00:26:39,733 line:-1
尚未严格定义的函数


607
00:26:40,434 --> 00:26:41,935 line:-1
然而Objective-C不同


608
00:26:42,102 --> 00:26:44,304 line:-2
在Objective-C世界中
代码可以自由放纵的运行


609
00:26:44,438 --> 00:26:45,639 line:-1
你可以做任何你想做的事


610
00:26:45,706 --> 00:26:48,509 line:-2
我的意思是它是一种动态语言
所以你可以调用这样的函数


611
00:26:49,142 --> 00:26:50,277 line:-1
所以我们要做的


612
00:26:50,410 --> 00:26:53,146 line:0
是告诉调试器使用
Objective-C语法


613
00:26:53,213 --> 00:26:55,516 line:0
来评估这个表达式


614
00:26:55,949 --> 00:27:00,087 line:0
实现这点的方法是
使用expression命令和选项参数-l objc


615
00:27:00,721 --> 00:27:02,723 line:0
这表明你即将
给expression命令


616
00:27:02,789 --> 00:27:05,092 line:0
一段Objective-C代码
即使你处于Swift框架中


617
00:27:06,793 --> 00:27:08,061 line:0
我们再加上-O


618
00:27:08,128 --> 00:27:09,863 line:0
来告诉它我们也想要调试描述


619
00:27:09,930 --> 00:27:11,298 line:0
就像用po一样


620
00:27:11,598 --> 00:27:14,134 line:0
再加上--以表示没有更多选项


621
00:27:14,902 --> 00:27:17,004 line:0
该行的其余部分仅仅是
原始表达式输入


622
00:27:17,471 --> 00:27:20,841 line:0
所以我们应该能够给它
这个方法调用的


623
00:27:20,908 --> 00:27:22,042 line:0
Objective-C格式


624
00:27:22,809 --> 00:27:24,244 line:0
不幸的是 这并不奏效


625
00:27:24,311 --> 00:27:25,746 line:0
其原因是这个表达式


626
00:27:25,812 --> 00:27:29,650 line:-2
将为Objective-C
编译创建一个临时表达式上下文


627
00:27:29,883 --> 00:27:32,186 line:-2
并且它不会继承
Swift框架中的所有变量


628
00:27:32,519 --> 00:27:33,854 line:-1
尽管如此 还是有办法的


629
00:27:34,421 --> 00:27:36,089 line:0
如果我们把self.view
放到反引号中


630
00:27:36,390 --> 00:27:38,025 line:0
反引号就像预处理器一样


631
00:27:38,392 --> 00:27:41,228 line:0
它表示先评估其在当前帧中的内容


632
00:27:41,295 --> 00:27:43,397 line:0
并插入结果
然后我们可以评估其余部分


633
00:27:43,730 --> 00:27:45,299 line:0
现在我们可以得到递归描述了


634
00:27:52,005 --> 00:27:53,974 line:-1
现在我们就可以看到所有视图的


635
00:27:54,041 --> 00:27:54,942 line:0
调试描述


636
00:27:55,342 --> 00:27:57,077 line:0
我对ScoreboardView
很感兴趣


637
00:27:57,144 --> 00:27:58,378 line:0
它承载着这些标签


638
00:27:58,512 --> 00:28:00,347 line:0
我们可以找到其中之一的内存地址


639
00:28:00,647 --> 00:28:03,650 line:0
现在我们可以使用
po内存地址


640
00:28:03,717 --> 00:28:06,453 line:0
如果你是Objective-C开发者
你可能熟悉该命令


641
00:28:06,520 --> 00:28:08,255 line:0
这也行不通
那是因为Swift


642
00:28:08,322 --> 00:28:11,792 line:-1
不会将数字视为指针


643
00:28:11,859 --> 00:28:13,126 line:0
并为你解引用


644
00:28:13,193 --> 00:28:16,396 line:0
所以需要在Objective-C
上下文中做到这一点


645
00:28:16,930 --> 00:28:18,565 line:0
我们可以做跟刚才同样的事情


646
00:28:18,932 --> 00:28:20,434 line:0
但我觉得这样更方便


647
00:28:20,634 --> 00:28:22,402 line:-1
我喜欢将其简化为


648
00:28:22,469 --> 00:28:25,372 line:-1
一个简单的命令


649
00:28:26,340 --> 00:28:28,709 line:-2
所以我打算通过使用命令别名
来做到这一点


650
00:28:29,042 --> 00:28:30,711 line:0
我把这个命令称为poc


651
00:28:31,211 --> 00:28:32,312 line:0
我已创建了一个别名


652
00:28:32,379 --> 00:28:33,914 line:0
我能简单地poc那个内存地址


653
00:28:34,114 --> 00:28:36,149 line:0
并查看该对象的调试描述


654
00:28:36,750 --> 00:28:37,885 line:0
我想向你展示另一种方式


655
00:28:38,085 --> 00:28:41,955 line:0
来查看对象的描述
当你只有其内存地址的时候


656
00:28:42,322 --> 00:28:45,759 line:0
在Swift中你可以使用一个叫做
unsafeBitCast的函数


657
00:28:46,360 --> 00:28:48,061 line:0
给它一个内存地址
它不安全是因为


658
00:28:48,128 --> 00:28:50,931 line:0
它依赖你来提供正确的类型


659
00:28:51,231 --> 00:28:53,100 line:0
因此我给它
ScoreboardView.self


660
00:28:54,001 --> 00:28:57,471 line:0
现在我们看到我们可以使用
unsafeBitCast函数来查看一个对象的


661
00:28:57,538 --> 00:28:58,405 line:0
调试描述


662
00:28:59,139 --> 00:29:01,041 line:0
unsafeBitCast函数
的一个好处是


663
00:29:01,108 --> 00:29:02,676 line:-1
它返回一个经过类型转换的结果


664
00:29:02,943 --> 00:29:06,246 line:-2
所以我们可以调用它的函数
和属性名称 例如.frame


665
00:29:06,780 --> 00:29:09,016 line:0
我想看一下它的中心点


666
00:29:09,349 --> 00:29:10,884 line:0
然后修改该中心点


667
00:29:10,951 --> 00:29:12,152 line:0
我们将其改为300


668
00:29:12,819 --> 00:29:15,088 line:0
现在我们可以看到
它已经变成了300


669
00:29:15,622 --> 00:29:18,258 line:0
但模拟器中的视图并没有移动


670
00:29:18,325 --> 00:29:19,159 line:0
为什么会这样呢？


671
00:29:19,693 --> 00:29:20,727 line:0
我们在调试器中暂停了


672
00:29:20,794 --> 00:29:24,198 line:0
所以Core Animation
目前不会将任何视图模块更改


673
00:29:24,264 --> 00:29:25,432 line:0
应用到屏幕的帧缓冲区


674
00:29:25,499 --> 00:29:27,534 line:-2
但我们可以要求Core Animation
为我们做这件事


675
00:29:28,001 --> 00:29:31,572 line:0
只需使用表达式
CAtransaction.flush()


676
00:29:33,106 --> 00:29:35,976 line:0
这告诉Core Animation
更新屏幕的帧缓冲区


677
00:29:42,049 --> 00:29:45,252 line:-2
现在我可以用这两行代码
来修复新的位置


678
00:29:45,319 --> 00:29:47,921 line:0
继续刷新屏幕
并四处移动该视图


679
00:29:47,988 --> 00:29:49,590 line:0
实际上 我觉得将这些都包装到


680
00:29:49,656 --> 00:29:51,992 line:0
一条命令中来移动视图会很方便


681
00:29:52,092 --> 00:29:54,094 line:0
所以我将这么做


682
00:29:54,661 --> 00:29:55,662 line:0
我们来看看


683
00:29:56,196 --> 00:29:58,932 line:-2
我将切换到终端
并打开一个Python文件


684
00:29:59,666 --> 00:30:00,968 line:-1
为什么使用Python文件呢？


685
00:30:01,368 --> 00:30:03,770 line:-2
LLDB可以使用
Python编写脚本


686
00:30:03,837 --> 00:30:06,473 line:-1
你可以完全访问LLDB API


687
00:30:06,907 --> 00:30:11,645 line:-2
我创建了LLDB Python
脚本实现一个nudge命令


688
00:30:11,845 --> 00:30:14,081 line:-2
它需要一个x偏移量、一个y偏移量
和一个视图表达式


689
00:30:14,314 --> 00:30:16,850 line:-2
你可以在调试器中暂停时
使用它来移动视图


690
00:30:17,518 --> 00:30:18,952 line:-1
它可能看起来很长


691
00:30:19,019 --> 00:30:20,821 line:-1
但大部分都是参数解析


692
00:30:21,288 --> 00:30:24,258 line:-1
其位于中间的核心部分只是在调用


693
00:30:24,324 --> 00:30:26,126 line:-1
我们原来手动调用的表达式


694
00:30:26,760 --> 00:30:29,229 line:-2
不幸的是我们没有时间
详细研究这个脚本


695
00:30:29,463 --> 00:30:30,931 line:-1
但我们会将其放到网上以供下载


696
00:30:30,998 --> 00:30:33,467 line:-2
以便你可以看到它是如何工作的
并以此为基础


697
00:30:33,567 --> 00:30:35,269 line:-1
开发你自己的自定义调试命令


698
00:30:36,303 --> 00:30:37,471 line:-1
让我向你展示如何


699
00:30:38,939 --> 00:30:40,307 line:-1
启用这样的脚本


700
00:30:40,574 --> 00:30:42,643 line:-1
只需编辑你的主目录中的


701
00:30:43,210 --> 00:30:44,344 line:-1
.lldb文件…


702
00:30:44,912 --> 00:30:47,181 line:-2
并添加一行
command script import


703
00:30:47,714 --> 00:30:50,484 line:-1
我也想添加一些我觉得方便的别名


704
00:30:50,751 --> 00:30:52,886 line:-1
比如我之前创建的poc别名


705
00:30:53,120 --> 00:30:54,855 line:-1
和一个用于刷新事务的别名


706
00:30:54,988 --> 00:30:56,290 line:-1
我想我会记住这个


707
00:31:00,127 --> 00:31:03,096 line:-2
我将复制command script import
以便我们可以直接将其粘贴到


708
00:31:03,363 --> 00:31:05,999 line:-1
调试会话以免重新启动该会话


709
00:31:06,233 --> 00:31:07,768 line:-2
现在我们有了一个
叫做nudge的命令


710
00:31:08,202 --> 00:31:12,506 line:-2
现在我可以 比方说
水平移动0点 垂直-5点


711
00:31:12,940 --> 00:31:14,708 line:-1
为其提供一个视图的内存地址


712
00:31:15,008 --> 00:31:18,011 line:-1
并开始在模拟器中四处移动它


713
00:31:26,720 --> 00:31:29,857 line:-2
关于LLDB的一个很棒的地方在于
如果你只是在空行上按回车


714
00:31:29,923 --> 00:31:31,992 line:-2
它会重复执行上一行
所以非常适合移动


715
00:31:32,826 --> 00:31:35,062 line:-1
我可以将它稍微推向右侧


716
00:31:35,128 --> 00:31:36,263 line:-1
让它看起来更好一点


717
00:31:36,496 --> 00:31:38,332 line:-1
然后我们来移动另一个视图


718
00:31:38,398 --> 00:31:41,935 line:-1
我们可以给它任何视图表达式


719
00:31:42,336 --> 00:31:43,971 line:-1
比如这个attemptsView


720
00:31:44,371 --> 00:31:47,040 line:-2
nudge的另一个特点是
一旦你给它一个视图表达式


721
00:31:47,107 --> 00:31:48,842 line:-1
下次你就不必重复它


722
00:31:50,244 --> 00:31:52,379 line:-1
它会记住该视图并将命令应用于


723
00:31:53,413 --> 00:31:54,681 line:-1
你上一次指定的视图


724
00:31:54,748 --> 00:31:55,983 line:-1
这样看起来很好


725
00:31:56,049 --> 00:31:57,651 line:-1
这是一个比以前更好的布局


726
00:31:57,718 --> 00:31:59,319 line:-1
现在我能做的就是获取


727
00:32:00,254 --> 00:32:01,889 line:-1
nudge提供的信息


728
00:32:01,955 --> 00:32:04,124 line:-1
例如应用于该视图的相对于


729
00:32:04,191 --> 00:32:05,759 line:-1
其原始中心点的总偏移量


730
00:32:06,093 --> 00:32:07,194 line:-1
然后是你的框架值


731
00:32:07,394 --> 00:32:11,198 line:-2
我可以回到代码并修改布局代码
或我的自动布局约束


732
00:32:11,398 --> 00:32:14,067 line:-2
我轻松地为自己的场景
构建了一种新的布局


733
00:32:15,969 --> 00:32:17,437 line:-1
最后要做的事情是


734
00:32:17,938 --> 00:32:21,175 line:-2
首先别忘了勾掉该漏洞
这非常重要


735
00:32:22,509 --> 00:32:25,379 line:-2
然后在重新启动或编译运行之前
要做的最后一件事


736
00:32:25,445 --> 00:32:29,116 line:-1
是禁用或删除任何


737
00:32:29,183 --> 00:32:30,217 line:-1
注入表达式的断点


738
00:32:30,284 --> 00:32:32,386 line:-1
因为你不希望这些代码被执行两次


739
00:32:32,986 --> 00:32:35,355 line:-2
选择它们或它们所在的组
并点击删除


740
00:32:35,455 --> 00:32:36,790 line:-1
是删除这些内容的快速方法


741
00:32:37,558 --> 00:32:39,726 line:-1
这些都是一些调试技巧


742
00:32:39,793 --> 00:32:42,196 line:-2
我喜欢用它们来增强
我的调试工作流程


743
00:32:43,197 --> 00:32:48,068 line:-2
请注意我们如何诊断和修复
所有四个错误


744
00:32:48,135 --> 00:32:50,604 line:-1
而无需重新编译或重新运行


745
00:32:51,271 --> 00:32:54,875 line:-2
这可以节省大量的时间
特别是对于复杂的项目


746
00:32:55,142 --> 00:32:59,246 line:-2
并且在尝试解决难以重现的漏洞时
可能至关重要


747
00:32:59,680 --> 00:33:01,348 line:-1
非常感谢你们与我结对编程


748
00:33:01,415 --> 00:33:03,116 line:-2
希望你们喜欢它
并且可以在调试中


749
00:33:03,183 --> 00:33:04,518 line:-1
使用这些技巧


750
00:33:15,729 --> 00:33:17,264 line:-1
我想快速回顾一下


751
00:33:17,331 --> 00:33:19,867 line:-1
刚才谈到的所有的


752
00:33:20,767 --> 00:33:22,436 line:-1
功能和技巧


753
00:33:23,003 --> 00:33:25,739 line:-2
首先 我们看到了
如何使用Xcode行为


754
00:33:25,806 --> 00:33:27,407 line:-1
来调出一个专门调试选项卡


755
00:33:27,474 --> 00:33:30,410 line:-2
以及如何使用LLDB表达式
修改程序状态


756
00:33:31,011 --> 00:33:33,881 line:-2
我们可以在调试器命令中
使用自动继续断点


757
00:33:33,947 --> 00:33:35,182 line:-1
来实时注入代码


758
00:33:35,616 --> 00:33:38,418 line:-2
我们还可以使用命令
breakpoint set --one-shot


759
00:33:38,485 --> 00:33:40,087 line:-1
创建依赖断点配置


760
00:33:40,287 --> 00:33:42,623 line:-2
以作为设置另一个断点的
调试器命令行为


761
00:33:43,457 --> 00:33:45,025 line:-1
即使在汇编帧中


762
00:33:45,092 --> 00:33:47,494 line:-2
我们可以很容易使用
po $arg1 $arg2等


763
00:33:47,561 --> 00:33:49,863 line:-1
来检查函数的参数


764
00:33:50,230 --> 00:33:52,065 line:-1
我们也可以通过拖动指令指针


765
00:33:52,266 --> 00:33:55,469 line:-2
或使用命令thread jump
来跳过代码行


766
00:33:56,270 --> 00:33:57,938 line:-2
我们可以在使用观察点的变量
被修改时


767
00:33:58,005 --> 00:33:59,973 line:-1
请求调试器暂停


768
00:34:01,208 --> 00:34:04,745 line:-2
我们甚至可以使用
表达式expression -l objc


769
00:34:04,978 --> 00:34:07,047 line:-2
来在Swift框架中
执行Objective-C代码


770
00:34:08,348 --> 00:34:11,150 line:-2
我们可以使用 expression
CATransition.flush()


771
00:34:11,217 --> 00:34:13,187 line:-1
将视图更改直接刷新到屏幕上


772
00:34:13,286 --> 00:34:15,289 line:-1
即使是在调试器中暂停时


773
00:34:16,056 --> 00:34:18,958 line:-1
你还可以添加自定义LLDB命令


774
00:34:19,025 --> 00:34:22,429 line:-1
无论是给常用命令设置别名


775
00:34:23,030 --> 00:34:26,366 line:-2
还是使用
LLDB Python脚本


776
00:34:26,433 --> 00:34:28,268 line:-1
完全自定义并创建自己的命令


777
00:34:28,768 --> 00:34:30,704 line:-1
别忘了访问我们的演讲网站


778
00:34:30,804 --> 00:34:33,473 line:-2
我们会尽快发布这个nudge脚本
以便你可以下载它


779
00:34:33,706 --> 00:34:35,943 line:-2
研究它并将其用作
你自己的命令的基础


780
00:34:38,212 --> 00:34:40,246 line:-1
还有一件事我想和你们提一下


781
00:34:40,313 --> 00:34:42,983 line:-1
就是当前的LLDB打印命令


782
00:34:43,417 --> 00:34:44,685 line:-1
你可能已经很熟悉po了


783
00:34:44,751 --> 00:34:46,186 line:-1
在演示中我们多次用到它


784
00:34:46,420 --> 00:34:47,721 line:-1
我们看到po


785
00:34:47,888 --> 00:34:49,755 line:-1
会请求对象的调试描述


786
00:34:49,857 --> 00:34:51,158 line:-1
而且你可以自定义该描述


787
00:34:51,391 --> 00:34:53,293 line:-2
那是因为po只是一个
以下命令的别名


788
00:34:53,527 --> 00:34:55,629 line:-2
expression
--object-description


789
00:34:56,864 --> 00:34:58,632 line:-1
或expression -O


790
00:34:59,366 --> 00:35:01,268 line:-1
与p命令相比


791
00:35:01,335 --> 00:35:03,036 line:-2
p只是expression命令
的别名


792
00:35:03,637 --> 00:35:07,841 line:-1
它使用LLDB的内置格式化程序


793
00:35:07,908 --> 00:35:08,909 line:-1
来显示对象的表示


794
00:35:10,043 --> 00:35:13,347 line:-2
需要知道的第三个命令是
frame variable


795
00:35:13,614 --> 00:35:16,149 line:-2
它与前两个的不同之处在于
它完全不需要编译


796
00:35:16,216 --> 00:35:17,684 line:-1
和评估表达式


797
00:35:17,918 --> 00:35:20,087 line:-2
它只是直接从内存中
读取变量中的值


798
00:35:20,320 --> 00:35:23,524 line:-1
然后使用LLDB的内置格式化程序


799
00:35:24,157 --> 00:35:26,760 line:-2
所以选择使用哪个命令
其实取决于个人喜好


800
00:35:26,827 --> 00:35:29,062 line:-1
以及你希望在调试时看到的信息类型


801
00:35:29,763 --> 00:35:32,432 line:-2
但重要的是要记住
如果你遇到这种情况


802
00:35:32,833 --> 00:35:37,204 line:-2
即当表达式失败时
po和p可能无法工作


803
00:35:37,471 --> 00:35:39,573 line:-1
如果你需要检查当前帧中的变量


804
00:35:39,806 --> 00:35:41,575 line:-2
那么frame variable
应该还能正常工作


805
00:35:44,178 --> 00:35:46,480 line:-2
接下来 我想将话筒
交给Sebastian


806
00:35:46,780 --> 00:35:49,383 line:-1
他会告诉你一些高级视图调试技术


807
00:35:49,449 --> 00:35:50,317 line:-1
谢谢


808
00:35:55,422 --> 00:35:56,490 line:-1
谢谢你 Chris


809
00:35:58,725 --> 00:36:00,294 line:-1
我很高兴能够向你展示…


810
00:36:01,228 --> 00:36:04,097 line:-2
关于如何充分利用
Xcode视图调试器的提示和技巧


811
00:36:04,164 --> 00:36:06,700 line:-2
我们也会看看我们
为Xcode 10所做的改进


812
00:36:07,267 --> 00:36:10,137 line:-2
为采用macOS Mojave
暗色外观的Mac app


813
00:36:10,204 --> 00:36:14,141 line:-1
的调试提供更好的体验


814
00:36:14,808 --> 00:36:16,844 line:-1
我们将在一个演示中看到这点


815
00:36:17,978 --> 00:36:19,346 line:-1
让我切换到演示机


816
00:36:20,714 --> 00:36:23,684 line:-2
我将使用与Chris刚才使用的
相同的项目


817
00:36:23,750 --> 00:36:27,054 line:-2
并且你已经看到
我们还有两个错误需要解决


818
00:36:29,790 --> 00:36:32,492 line:-1
但是我不打算使用iOS app


819
00:36:32,626 --> 00:36:33,927 line:-1
我将使用Mac app


820
00:36:34,661 --> 00:36:37,664 line:-2
我们可以在这里看到
Solar System app的Mac版本


821
00:36:38,131 --> 00:36:40,000 line:-1
它在暗色模式下看起来很不错


822
00:36:41,168 --> 00:36:43,070 line:-1
但有两个漏洞我们需要解决掉


823
00:36:43,737 --> 00:36:47,307 line:-1
首先 星球图像没有正确水平居中


824
00:36:47,875 --> 00:36:49,276 line:-1
这是一个非常明显的漏洞


825
00:36:49,409 --> 00:36:51,812 line:-2
你可以看到在右边
这张地球图片


826
00:36:52,012 --> 00:36:53,313 line:-1
被移到右侧


827
00:36:53,814 --> 00:36:55,649 line:-1
我们将会看看这个问题


828
00:36:55,916 --> 00:36:58,252 line:-1
第二个漏洞是


829
00:36:58,418 --> 00:37:01,021 line:-2
在暗色模式下
弹出框中的文本不可读


830
00:37:01,221 --> 00:37:03,056 line:-1
我们来看看这是指的是什么


831
00:37:03,724 --> 00:37:04,691 line:-1
当我切换到这个app时


832
00:37:05,225 --> 00:37:07,060 line:-1
我可以显示轨道细节


833
00:37:07,127 --> 00:37:08,729 line:-1
信息显示在弹出框中


834
00:37:09,129 --> 00:37:11,365 line:-1
你可以看到顶部的标签清晰可见


835
00:37:11,431 --> 00:37:14,067 line:-1
然而底部的标签很难阅读


836
00:37:14,134 --> 00:37:15,769 line:-1
我必须通过选择文本来阅读它


837
00:37:16,670 --> 00:37:18,672 line:-2
所以这些是
我们必须要解决的两个漏洞


838
00:37:19,306 --> 00:37:21,508 line:-2
让我隐藏待办事项列表
然后我们开始吧


839
00:37:22,342 --> 00:37:24,444 line:-2
所以我要使用
Xcode捕获该app的


840
00:37:24,511 --> 00:37:26,146 line:-1
视图层次结构


841
00:37:26,680 --> 00:37:27,915 line:-1
然后检查它


842
00:37:28,515 --> 00:37:30,717 line:-2
我们会定位问题
然后希望能够修复它


843
00:37:30,784 --> 00:37:31,885 line:-1
我们就能去喝啤酒了


844
00:37:32,819 --> 00:37:35,956 line:-2
问题是当我切换到Xcode
以捕捉视图层次结构时


845
00:37:36,190 --> 00:37:37,724 line:-1
这个弹出框将会消失


846
00:37:37,791 --> 00:37:40,093 line:-1
因为app进入了后台


847
00:37:40,527 --> 00:37:42,529 line:-1
因此我们将无法捕获其视图层次结构


848
00:37:43,230 --> 00:37:45,165 line:-1
我们必须要在app处于活动状态时


849
00:37:45,299 --> 00:37:46,567 line:-1
来对app进行捕捉


850
00:37:46,867 --> 00:37:48,569 line:-1
我会向你展示做到这点的两种方法


851
00:37:49,903 --> 00:37:53,006 line:-2
你可以看到当我切换到Xcode时
这个弹出框如何消失


852
00:37:54,508 --> 00:37:55,976 line:-1
首先 我们可以使用触摸栏


853
00:37:56,243 --> 00:37:59,012 line:-2
我会通过从Xcode的窗口菜单
调出触摸栏模拟器


854
00:37:59,079 --> 00:38:00,347 line:0
来向你展示它的样子


855
00:38:00,781 --> 00:38:02,182 line:0
我将切换回
Solar System app


856
00:38:02,249 --> 00:38:03,784 line:0
并再次调出弹出框


857
00:38:04,585 --> 00:38:05,686 line:-1
然后看看触摸栏


858
00:38:05,752 --> 00:38:07,821 line:0
你可以看到这里有个喷雾罐图标


859
00:38:08,422 --> 00:38:09,823 line:0
当我在触摸栏上点击它时


860
00:38:09,890 --> 00:38:12,860 line:0
你可以看到Xcode在其调试栏中


861
00:38:13,493 --> 00:38:15,429 line:0
提供的该调试选项的子集


862
00:38:15,996 --> 00:38:18,932 line:0
因此从触摸栏访问这些工具非常方便


863
00:38:19,399 --> 00:38:22,636 line:-2
如你所见 我可以在Xcode
处于背景中的情况下调出它们


864
00:38:22,736 --> 00:38:24,771 line:-1
因此你甚至可以在以全屏模式


865
00:38:24,872 --> 00:38:26,507 line:-1
开发app时访问它们


866
00:38:27,474 --> 00:38:30,377 line:-1
这其中一个选项允许我捕捉


867
00:38:30,944 --> 00:38:31,812 line:-1
视图的层次结构


868
00:38:31,879 --> 00:38:32,713 line:-1
我不打算这样做


869
00:38:32,779 --> 00:38:35,249 line:-2
因为我知道不是每个人都有
带触摸栏的Mac


870
00:38:35,315 --> 00:38:36,884 line:-1
所以我会告诉你另一种方法


871
00:38:38,151 --> 00:38:39,253 line:-1
我要关闭模拟器


872
00:38:39,319 --> 00:38:42,022 line:-1
我将使用命令点击


873
00:38:42,489 --> 00:38:45,192 line:-1
来点击Xcode的调试栏中的按钮


874
00:38:46,493 --> 00:38:48,061 line:-1
命令点击是一个系统手势


875
00:38:48,161 --> 00:38:51,431 line:-1
它允许你在不激活app的情况下


876
00:38:51,498 --> 00:38:52,799 line:-1
执行鼠标事件


877
00:38:53,967 --> 00:38:56,036 line:-1
所以这允许我们


878
00:38:56,837 --> 00:38:58,505 line:-1
调用对视图层次结构的捕获


879
00:38:58,739 --> 00:39:01,742 line:-2
调试器在app仍处于活动状态时
将其暂停


880
00:39:02,075 --> 00:39:03,877 line:-1
我们可以看到用户界面仍然显示


881
00:39:04,077 --> 00:39:07,014 line:-2
就好像app还在屏幕最前面
并且弹出框没有消失


882
00:39:07,447 --> 00:39:09,583 line:-2
如果你想知道
为什么那个旋转的光标会出现


883
00:39:09,650 --> 00:39:11,418 line:-1
这是因为app在调试器中暂停


884
00:39:11,485 --> 00:39:13,287 line:-1
并且不再响应鼠标事件


885
00:39:14,755 --> 00:39:15,789 line:-1
现在你可能在想


886
00:39:15,856 --> 00:39:17,457 line:-1
如果我们看看这里的视图调试器


887
00:39:18,058 --> 00:39:19,560 line:-1
为什么弹出框不可见呢


888
00:39:20,360 --> 00:39:22,396 line:-1
别担心 视图层次结构已被捕获


889
00:39:22,462 --> 00:39:24,565 line:-1
当我们谈到那个漏洞的时候


890
00:39:24,631 --> 00:39:25,832 line:-1
再看看该如何查看弹出框


891
00:39:26,066 --> 00:39:28,001 line:-2
但首先我想看看
这个ImageView的


892
00:39:28,068 --> 00:39:29,036 line:-1
布局问题


893
00:39:29,770 --> 00:39:32,372 line:-2
我先选择这个图像视图
让我放大一点


894
00:39:33,173 --> 00:39:35,375 line:-1
当我们看一下右侧的内容时


895
00:39:35,843 --> 00:39:39,479 line:-2
我们可以看到这是一个
_NSImageViewSimpleImageView


896
00:39:39,746 --> 00:39:42,316 line:-1
这个下划线前缀


897
00:39:42,749 --> 00:39:46,220 line:-1
通常暗示这是来自系统框架的内部类


898
00:39:46,520 --> 00:39:48,322 line:-1
而不是我们在代码或界面构建器中


899
00:39:48,388 --> 00:39:51,658 line:-1
设置图像视图时所使用的类


900
00:39:51,925 --> 00:39:54,561 line:-2
我们来看看这个对象
在视图层次结构中的样子


901
00:39:54,628 --> 00:39:56,563 line:-2
我可以通过点击
Navigate菜单并选择


902
00:39:56,897 --> 00:39:58,565 line:-2
Reveal in Debug Navigator
来做到这一点


903
00:39:58,999 --> 00:40:00,334 line:-1
我们现在可以在左侧


904
00:40:00,400 --> 00:40:03,337 line:-1
看到它以及它的父视图和子视图


905
00:40:04,538 --> 00:40:06,974 line:-2
我们能看到其父视图为
NSImageView


906
00:40:07,040 --> 00:40:08,509 line:-1
这就是我们正在寻找的


907
00:40:08,575 --> 00:40:11,378 line:-2
我们也看到其父视图
是PlanetGlobeView


908
00:40:11,879 --> 00:40:15,616 line:-2
以及PlanetGlobeView的父视图
是NSVisualEffectView


909
00:40:16,950 --> 00:40:18,285 line:-1
现在我要选择这个图像视图


910
00:40:19,186 --> 00:40:22,990 line:-2
我们可以在右侧看到
该图像视图的其他属性


911
00:40:23,557 --> 00:40:25,192 line:-1
我们来看看这个视图的布局


912
00:40:25,759 --> 00:40:27,461 line:-1
我在这个app中使用了自动布局


913
00:40:27,694 --> 00:40:29,830 line:-1
所以我想看看其自动布局约束


914
00:40:30,163 --> 00:40:32,366 line:-1
我可以使用这个按钮来显示约束


915
00:40:33,734 --> 00:40:35,402 line:-1
现在我们可以看到


916
00:40:35,469 --> 00:40:37,437 line:-1
会影响此视图布局的所有约束


917
00:40:38,539 --> 00:40:39,840 line:-1
你可以看到 例如


918
00:40:39,907 --> 00:40:41,475 line:-1
此处的宽高比约束


919
00:40:41,975 --> 00:40:45,579 line:-2
还有这条垂直线
这是一个对齐约束


920
00:40:46,513 --> 00:40:48,282 line:-1
当我选择这个约束时


921
00:40:48,348 --> 00:40:50,884 line:-1
我们可以在右侧看到其中所有属性


922
00:40:51,251 --> 00:40:52,619 line:-1
现在 如果你想知道


923
00:40:52,686 --> 00:40:54,521 line:-1
为什么视图调试器只显示线框


924
00:40:54,755 --> 00:40:56,990 line:-1
这是因为它只显示特定视图的内容


925
00:40:57,057 --> 00:40:59,626 line:-1
该视图需要处于所选视图的布局中


926
00:40:59,993 --> 00:41:02,696 line:-1
由于所有这些视图本身都没有内容


927
00:41:03,096 --> 00:41:04,565 line:-1
所以我们目前只显示线框


928
00:41:05,766 --> 00:41:07,701 line:-1
选择约束后


929
00:41:07,968 --> 00:41:10,103 line:-1
让我们来看看右侧的信息


930
00:41:10,470 --> 00:41:14,274 line:-2
我们可以看到
它与图像视图的水平中心对齐


931
00:41:14,708 --> 00:41:16,844 line:-2
也与PlanetGlobeView的
水平中心对齐


932
00:41:16,910 --> 00:41:18,879 line:-1
并且它以常量0进行对齐


933
00:41:19,012 --> 00:41:21,481 line:-1
所以它在其父视图中水平居中对齐


934
00:41:22,449 --> 00:41:26,787 line:-2
现在我们从调试导航器中
选中PlanetGlobeView


935
00:41:27,087 --> 00:41:29,823 line:-1
我们可以看到它向左侧稍大一些


936
00:41:30,190 --> 00:41:31,425 line:-1
但它在右侧对齐


937
00:41:31,491 --> 00:41:32,926 line:-1
所以这有点奇怪


938
00:41:32,993 --> 00:41:35,395 line:-2
因为我们刚刚看到了
能够正确对齐的约束


939
00:41:35,596 --> 00:41:37,097 line:-1
即准确的水平居中


940
00:41:37,798 --> 00:41:39,933 line:-2
但我们在视图调试器中
看到的却不是这样


941
00:41:40,133 --> 00:41:41,568 line:-2
我们来看看
PlanetGlobeView的约束


942
00:41:41,835 --> 00:41:44,605 line:-1
希望能够理解正在发生的事情


943
00:41:45,539 --> 00:41:47,374 line:-1
我在这里选择前沿约束


944
00:41:47,441 --> 00:41:49,042 line:-1
再次看看其信息


945
00:41:49,309 --> 00:41:52,112 line:-2
我们可以看到
PlanetGlobeView的前沿


946
00:41:52,412 --> 00:41:55,015 line:-2
与NSVisualEffectView
的前沿对齐


947
00:41:55,082 --> 00:41:56,517 line:-1
而后者是在父视图中的


948
00:41:56,884 --> 00:41:59,253 line:-2
所以它只是相对于它的父视图
插入进去


949
00:41:59,620 --> 00:42:01,655 line:-1
并且它以常量30这样做


950
00:42:01,955 --> 00:42:02,923 line:-1
这还算合理


951
00:42:03,390 --> 00:42:04,925 line:-1
然后这个后沿约束


952
00:42:06,460 --> 00:42:08,795 line:-2
将PlanetGlobeView
的后沿


953
00:42:08,996 --> 00:42:10,531 line:-1
与父视图的后沿对齐


954
00:42:10,898 --> 00:42:12,900 line:-1
它也以常数30这样做


955
00:42:13,367 --> 00:42:14,668 line:-1
现在这个约束


956
00:42:15,068 --> 00:42:16,703 line:-1
没有附加到右侧的任何内容


957
00:42:16,770 --> 00:42:18,338 line:-2
这有点值得怀疑
这让我在想


958
00:42:18,405 --> 00:42:19,740 line:-1
我们是否在此看到了整个图景


959
00:42:20,207 --> 00:42:21,942 line:-2
在这种情况下
通常有一个好主意


960
00:42:22,009 --> 00:42:24,044 line:-1
即查看是否有任何内容被裁剪了


961
00:42:24,111 --> 00:42:25,445 line:-1
而我们默认看不到它们


962
00:42:26,013 --> 00:42:29,183 line:-2
你可以使用这里的这个按钮
来显示裁剪内容


963
00:42:30,117 --> 00:42:31,485 line:-1
现在当我启用此功能时


964
00:42:31,552 --> 00:42:34,621 line:-2
你可以看到PlanetGlobeView
实际上向右延伸


965
00:42:34,688 --> 00:42:35,923 line:-1
超过了窗口范围


966
00:42:36,323 --> 00:42:38,058 line:-1
现在水平居中约束变得合理了


967
00:42:38,592 --> 00:42:41,361 line:-1
因为它实际上正确的在父视图中


968
00:42:41,528 --> 00:42:42,896 line:-1
水平居中了


969
00:42:43,263 --> 00:42:46,066 line:-1
只是父视图延伸到了窗口之外


970
00:42:46,900 --> 00:42:48,969 line:-2
这是一个很常见的问题
如果你在代码中设置约束


971
00:42:49,036 --> 00:42:51,471 line:-1
你不小心交换了第一个和第二个项目


972
00:42:51,538 --> 00:42:53,373 line:-1
从而导致布局方向错误


973
00:42:53,440 --> 00:42:55,409 line:-1
或者你不小心弄反了常量


974
00:42:55,609 --> 00:42:59,246 line:-2
在这个例子中
我们使用了30而不是-30


975
00:42:59,446 --> 00:43:01,215 line:-1
来将其插入左侧


976
00:43:01,415 --> 00:43:04,051 line:-1
所以我想要做的就是尝试反转常量


977
00:43:04,117 --> 00:43:06,587 line:-2
进行修复 我将使用
与Chris使用的相同技巧


978
00:43:06,653 --> 00:43:10,324 line:-1
简单的在LLDB中应用它


979
00:43:11,425 --> 00:43:13,727 line:-1
选中这个约束


980
00:43:16,864 --> 00:43:19,633 line:-1
再选择Edit->Copy


981
00:43:20,334 --> 00:43:23,170 line:0
再调出底部的控制台区域


982
00:43:23,937 --> 00:43:26,106 line:0
刚才我复制的内容


983
00:43:27,007 --> 00:43:29,676 line:0
是所选对象的经过类型转换的指针


984
00:43:29,743 --> 00:43:32,479 line:0
这适用于你在视图调试器中
以及内存图形调试器中


985
00:43:32,546 --> 00:43:34,114 line:0
选择的所有对象


986
00:43:34,181 --> 00:43:36,283 line:0
这使得在控制台中使用它们非常方便


987
00:43:36,817 --> 00:43:37,751 line:0
让我们…


988
00:43:42,022 --> 00:43:42,856 line:-1
谢谢


989
00:43:43,257 --> 00:43:44,391 line:-1
让我们打印调试描述


990
00:43:44,458 --> 00:43:47,728 line:-1
我们可以确定这个常数的确是正30


991
00:43:48,161 --> 00:43:50,264 line:-1
这也是我们在信息栏中看到的


992
00:43:50,764 --> 00:43:52,799 line:0
所以让我们将常数设置为-30


993
00:43:53,233 --> 00:43:56,503 line:0
输入e
这是expression超短缩写


994
00:43:56,904 --> 00:44:00,607 line:-2
转换指针的类型
然后setConstant


995
00:44:01,675 --> 00:44:02,843 line:-1
为-30


996
00:44:03,710 --> 00:44:06,446 line:-2
我们遇到与Chris
在上个app中看到的相同问题


997
00:44:06,513 --> 00:44:08,115 line:-1
即app没有及时更新


998
00:44:08,549 --> 00:44:11,018 line:-1
所以我必须要做的是


999
00:44:11,285 --> 00:44:13,020 line:-1
执行一个命令


1000
00:44:13,086 --> 00:44:16,056 line:-1
来让暂停的app


1001
00:44:17,257 --> 00:44:18,926 line:-1
调度其用户界面的更新


1002
00:44:19,693 --> 00:44:21,995 line:-2
我可以使用
Chris刚才添加的方便命令


1003
00:44:23,230 --> 00:44:25,632 line:-1
我可以在这里找到命令


1004
00:44:26,333 --> 00:44:28,402 line:-1
现在我们可以看到地球图像


1005
00:44:28,468 --> 00:44:30,003 line:-1
正确地水平居中了


1006
00:44:30,070 --> 00:44:32,005 line:-1
所以反转常量是正确的修复方法


1007
00:44:32,439 --> 00:44:36,109 line:-2
现在我们能够确认这一点
所以让我们在代码中应用这个改变


1008
00:44:37,978 --> 00:44:39,179 line:-1
选中约束后


1009
00:44:39,379 --> 00:44:41,014 line:-1
你可以在右侧看到


1010
00:44:41,548 --> 00:44:42,850 line:-1
这个回溯信息


1011
00:44:42,950 --> 00:44:45,319 line:-1
那就是约束的分配回溯路径


1012
00:44:45,385 --> 00:44:47,754 line:-1
它准确告诉我它被分配在哪个框中


1013
00:44:47,988 --> 00:44:49,756 line:-1
所以它可以让我直接找到


1014
00:44:50,257 --> 00:44:51,758 line:-1
创建该约束的相应代码


1015
00:44:52,726 --> 00:44:55,662 line:-1
为了显示这个回溯信息


1016
00:44:55,896 --> 00:44:57,731 line:-2
你必须启用
Malloc Stack日志


1017
00:44:57,931 --> 00:44:59,800 line:-1
让我告诉你如何启用它


1018
00:45:00,334 --> 00:45:02,636 line:-2
在此找到你的方案
然后选择Edit Scheme


1019
00:45:03,770 --> 00:45:05,239 line:-1
并在Scheme Options的


1020
00:45:05,372 --> 00:45:07,641 line:-1
Diagnostics选项卡中


1021
00:45:07,808 --> 00:45:10,511 line:-2
在Logging选项处
可启用Malloc Stack日志


1022
00:45:10,911 --> 00:45:12,713 line:-2
并选中 All Allocations
and Free History


1023
00:45:13,580 --> 00:45:16,216 line:-2
这将为你提供这些方便的
分配回溯信息 即视图调试器


1024
00:45:16,283 --> 00:45:18,151 line:-1
和Xcode的内存图像调试器中的


1025
00:45:18,218 --> 00:45:20,053 line:-1
所选对象的分配回溯信息


1026
00:45:21,088 --> 00:45:23,991 line:-1
现在当我将鼠标悬停在这个堆栈上时


1027
00:45:24,324 --> 00:45:26,894 line:-1
我们可以看到该框的全名


1028
00:45:27,594 --> 00:45:31,231 line:-2
我们可以看到
这是SceneViewController中的


1029
00:45:31,298 --> 00:45:32,533 line:-1
setupPlanetGlobeLayout方法


1030
00:45:33,467 --> 00:45:36,436 line:-1
我可以使用此跳转箭头


1031
00:45:36,837 --> 00:45:38,138 line:-1
跳到这部分代码


1032
00:45:39,139 --> 00:45:41,775 line:-2
我通过按住Shift-Control-Option键
来做到这点


1033
00:45:41,975 --> 00:45:44,011 line:-1
这将打开这个导航框


1034
00:45:44,211 --> 00:45:46,947 line:-1
并允许我在新窗口中打开此文件


1035
00:45:48,715 --> 00:45:50,517 line:-1
现在你可以看到分配约束的这行代码


1036
00:45:50,584 --> 00:45:52,786 line:-1
被高亮显示了


1037
00:45:52,853 --> 00:45:54,154 line:-1
我们看到值为30的常量


1038
00:45:54,221 --> 00:45:55,756 line:-1
我可以将其反转为-30


1039
00:45:56,490 --> 00:45:58,325 line:-1
保存该文件并关闭它


1040
00:45:58,392 --> 00:45:59,793 line:-1
我们解决了第一个漏洞


1041
00:46:01,261 --> 00:46:04,498 line:-2
完美
第二个漏洞是我们无法看清


1042
00:46:04,932 --> 00:46:08,068 line:-1
弹出框中的描述


1043
00:46:08,268 --> 00:46:09,369 line:-1
让我们来看看这个


1044
00:46:10,404 --> 00:46:12,673 line:-1
首先我想禁用约束模式和裁剪


1045
00:46:13,640 --> 00:46:15,576 line:-1
以便我们可以看到内容


1046
00:46:17,110 --> 00:46:18,879 line:-1
我也将清除控制台


1047
00:46:19,913 --> 00:46:22,549 line:-2
我一开始向你展示了如何在这款
Mac app处于活动状态时


1048
00:46:22,749 --> 00:46:26,420 line:-2
进行捕捉
这样我们就可以在弹出窗口打开时


1049
00:46:26,486 --> 00:46:27,754 line:-1
看到其视图层次结构


1050
00:46:28,188 --> 00:46:29,223 line:-1
然而我们没有看到它


1051
00:46:29,423 --> 00:46:32,593 line:-2
这是因为视图调试器
一次只显示一个窗口


1052
00:46:33,493 --> 00:46:35,562 line:-1
我们来看看如何查看其他窗口


1053
00:46:36,363 --> 00:46:39,132 line:-1
当我在视图层次结构中向上滚动


1054
00:46:39,333 --> 00:46:42,736 line:-1
并最终找到当前窗口时


1055
00:46:43,003 --> 00:46:45,005 line:-1
我们可以看到它在窗口控制器下面


1056
00:46:45,138 --> 00:46:48,108 line:-1
如果我在这里折叠这个根项目


1057
00:46:48,342 --> 00:46:50,344 line:-1
我们可以看到实际上有另一个根项目


1058
00:46:50,410 --> 00:46:52,079 line:-1
这正是我们正在寻找的


1059
00:46:52,646 --> 00:46:53,647 line:-1
我们的弹出窗口


1060
00:46:54,281 --> 00:46:55,949 line:-1
所以如果你的app有多个窗口


1061
00:46:56,016 --> 00:46:58,018 line:-1
macOS和iOS也是如此


1062
00:46:58,352 --> 00:47:00,053 line:-1
它们会在左侧的导航栏中


1063
00:47:00,120 --> 00:47:02,222 line:-1
显示为多个根级别的对象


1064
00:47:02,756 --> 00:47:05,859 line:-2
所以如果你认为你的app
包含多个窗口


1065
00:47:06,059 --> 00:47:07,427 line:-1
那么就看看那里


1066
00:47:07,494 --> 00:47:09,296 line:-1
它们会被视图调试器所捕获


1067
00:47:10,397 --> 00:47:11,932 line:-1
我们可以在3D模式下看看它


1068
00:47:12,099 --> 00:47:14,067 line:-1
我们可以看到这个大视图


1069
00:47:14,468 --> 00:47:17,938 line:-1
阻挡了我们对标签的点击


1070
00:47:18,038 --> 00:47:20,440 line:-1
我想看看这些标签以检查它们


1071
00:47:21,008 --> 00:47:23,477 line:-2
让点击穿过视图调试器中的视图
有一个技巧


1072
00:47:23,544 --> 00:47:25,012 line:-1
你只需按住Command键


1073
00:47:25,612 --> 00:47:28,749 line:-2
现在我可以穿过前面这个视图
并点击选中这个蓝色标签


1074
00:47:29,449 --> 00:47:31,952 line:-1
我们来看看这个标签的文字颜色


1075
00:47:32,252 --> 00:47:34,621 line:-2
我想先看看在暗色中
看起来很棒的那些标签


1076
00:47:34,688 --> 00:47:36,723 line:-1
以便我们可以为底部的问题标签


1077
00:47:36,790 --> 00:47:38,592 line:-1
找出解决方案


1078
00:47:39,993 --> 00:47:41,228 line:-1
我们来看看文字的颜色


1079
00:47:41,295 --> 00:47:43,030 line:-1
我们可以看到这是一种RGB颜色


1080
00:47:43,764 --> 00:47:46,800 line:-2
效果为这种蓝色
我们也可以看到信息栏向我们提供了


1081
00:47:47,134 --> 00:47:48,168 line:-1
这种颜色的名称


1082
00:47:48,235 --> 00:47:49,803 line:-1
这表明这种颜色


1083
00:47:50,170 --> 00:47:52,472 line:-1
来自我们项目中的素材目录


1084
00:47:52,906 --> 00:47:55,843 line:-2
在Xcode 10中
你可以提供你定义的


1085
00:47:56,243 --> 00:47:57,611 line:-1
单个颜色的多种颜色变体


1086
00:47:57,744 --> 00:48:00,280 line:-2
例如 你可以提供一种用于浅色
另一种用于暗色


1087
00:48:00,747 --> 00:48:04,551 line:-1
并且使用哪种颜色变体


1088
00:48:04,618 --> 00:48:05,819 line:-1
取决于视图的外观


1089
00:48:05,986 --> 00:48:06,820 line:-1
你也可以


1090
00:48:07,187 --> 00:48:08,989 line:-1
在信息栏中得到这些信息


1091
00:48:09,389 --> 00:48:11,225 line:-1
向下滚动信息栏


1092
00:48:11,291 --> 00:48:12,259 line:-1
到视图部分


1093
00:48:12,426 --> 00:48:13,794 line:-1
你可以看到有Appearance


1094
00:48:13,861 --> 00:48:14,962 line:-1
和Effective外观选项


1095
00:48:15,395 --> 00:48:18,298 line:-2
现在Appearance选项
没有在这个视图上明确设置


1096
00:48:18,365 --> 00:48:19,900 line:-1
这是一种非常常见的情况


1097
00:48:19,967 --> 00:48:21,635 line:-1
因为大多数视图继承了


1098
00:48:22,035 --> 00:48:24,771 line:-1
其任意一个父视图的外观


1099
00:48:24,838 --> 00:48:26,340 line:-1
比如窗口或app


1100
00:48:27,107 --> 00:48:29,610 line:-2
但是你可以在这里看到
所继承的有效外观


1101
00:48:29,676 --> 00:48:30,944 line:-1
那就是VibrantDark


1102
00:48:31,411 --> 00:48:32,880 line:-1
这将决定你在素材目录中


1103
00:48:32,946 --> 00:48:35,415 line:-1
定义的哪种颜色会被使用


1104
00:48:36,683 --> 00:48:39,386 line:-1
好的 事实上在信息栏的此处


1105
00:48:39,887 --> 00:48:41,622 line:-2
我想指出
Description属性


1106
00:48:41,688 --> 00:48:43,757 line:-1
这是该对象的调试描述


1107
00:48:44,157 --> 00:48:46,727 line:-2
Chris先前向你展示了
如何为你的对象提供


1108
00:48:46,793 --> 00:48:47,661 line:-1
自定义调试描述


1109
00:48:47,861 --> 00:48:49,363 line:-1
所以你不仅受益于


1110
00:48:49,696 --> 00:48:52,132 line:-1
当你在对象上使用po时


1111
00:48:52,199 --> 00:48:54,368 line:-1
你的控制台会显示清晰的调试描述


1112
00:48:54,434 --> 00:48:56,336 line:-1
你也可以从视图调试器中获益


1113
00:48:56,403 --> 00:48:58,105 line:-1
因为它在信息栏中也会显示


1114
00:48:59,506 --> 00:49:01,542 line:-1
好的 让我们回到文本颜色


1115
00:49:01,909 --> 00:49:04,778 line:-2
我想选择第二个标签
因为它在暗色中看起来也还不错


1116
00:49:05,412 --> 00:49:07,414 line:-2
这次我们仍可以看到
一个带有名称的颜色


1117
00:49:07,481 --> 00:49:09,950 line:-2
它是labelColor
但它以System为前缀


1118
00:49:10,217 --> 00:49:12,753 line:-2
这表明它不是
来自我们自己的素材目录


1119
00:49:12,886 --> 00:49:13,787 line:-1
而是来自系统


1120
00:49:14,021 --> 00:49:15,155 line:-1
当然 系统颜色


1121
00:49:15,222 --> 00:49:17,324 line:-1
也会自动适应外观变化


1122
00:49:18,292 --> 00:49:20,928 line:-1
现在看看这个有问题的标签


1123
00:49:21,461 --> 00:49:23,630 line:-1
我们可以看到它是非常深的灰色


1124
00:49:24,131 --> 00:49:25,098 line:-1
并且没有名字


1125
00:49:25,165 --> 00:49:27,267 line:-1
这意味着它是一种自定义颜色


1126
00:49:27,334 --> 00:49:30,037 line:-1
它不会适应外观变化


1127
00:49:30,971 --> 00:49:33,841 line:-1
所以我们想要做的是改变它的颜色


1128
00:49:33,907 --> 00:49:36,343 line:-1
将其文本颜色设置为系统颜色


1129
00:49:37,911 --> 00:49:40,314 line:-2
所以选中这个对象后
我按下Command-C键


1130
00:49:41,181 --> 00:49:45,352 line:0
键入e命令 粘贴类型转换后的指针
并设置setTextColor


1131
00:49:47,654 --> 00:49:49,723 line:0
为NSColortextColor


1132
00:49:51,358 --> 00:49:53,327 line:0
我必须再次刷新才能看到效果


1133
00:49:53,994 --> 00:49:55,863 line:0
我们可以看到弹出框现在更新了


1134
00:49:55,929 --> 00:49:57,531 line:0
字体很好看并且可读性强


1135
00:49:58,832 --> 00:50:01,902 line:0
现在 我不打算在我的故事本文件中
应用此修复


1136
00:50:02,569 --> 00:50:05,272 line:-2
但我想指出的一点是
你这么做很重要


1137
00:50:05,506 --> 00:50:08,942 line:-2
即当你对用户界面进行更改时
你需要验证你的app


1138
00:50:09,243 --> 00:50:11,478 line:-1
在所有外观中都仍然很好看


1139
00:50:11,712 --> 00:50:13,981 line:-1
因为现在存在多种系统外观


1140
00:50:14,047 --> 00:50:15,449 line:-1
我会告诉你如何做到这一点


1141
00:50:15,616 --> 00:50:16,550 line:-1
我将继续运行


1142
00:50:18,418 --> 00:50:20,888 line:-2
我并不需要将我的整个系统外观
切换为浅色


1143
00:50:21,021 --> 00:50:24,424 line:-2
以查看标签在浅色背景下
是否仍然看起来不错


1144
00:50:24,958 --> 00:50:26,426 line:-2
Xcode 10
为你提供了一种方法


1145
00:50:26,760 --> 00:50:29,229 line:-1
来仅仅改变目标app的外观


1146
00:50:29,463 --> 00:50:31,565 line:-1
你可以在调试栏中使用这个按钮


1147
00:50:31,999 --> 00:50:32,933 line:-1
我可以在这里选择Light


1148
00:50:33,834 --> 00:50:37,037 line:-2
你可以看到app
现在以浅色外观呈现


1149
00:50:37,504 --> 00:50:40,440 line:-2
我可以调出弹出框
从而验证


1150
00:50:41,108 --> 00:50:42,309 line:-1
其文本清晰可读


1151
00:50:42,609 --> 00:50:45,312 line:-2
这证实我们的确
解决了我们的问题


1152
00:50:45,746 --> 00:50:47,481 line:-1
由于以不同的外观查看你的app


1153
00:50:47,548 --> 00:50:49,983 line:-1
是一个非常普遍的行为


1154
00:50:50,050 --> 00:50:52,753 line:-1
我们实际上在触摸栏中提供了该选项


1155
00:50:53,053 --> 00:50:54,188 line:-1
我马上向你演示一下


1156
00:50:54,454 --> 00:50:56,223 line:-1
我将再次调出触摸栏模拟器


1157
00:50:56,523 --> 00:50:58,091 line:-1
并打开弹出框


1158
00:50:59,126 --> 00:51:00,694 line:0
我可以选择这个选项


1159
00:51:01,728 --> 00:51:03,463 line:0
你现在可以在触控栏中


1160
00:51:03,530 --> 00:51:04,464 line:0
看到所有的覆盖选项


1161
00:51:04,698 --> 00:51:06,667 line:0
所以即使你的app处于全屏模式


1162
00:51:06,733 --> 00:51:08,001 line:-1
你也可以访问它们


1163
00:51:08,735 --> 00:51:10,270 line:0
让我切换到
High Contrast Light模式


1164
00:51:10,504 --> 00:51:14,341 line:0
它可以实现高对比度的无障碍功能


1165
00:51:14,842 --> 00:51:17,277 line:0
同时覆盖外观为浅色


1166
00:51:17,778 --> 00:51:21,615 line:-2
这样你可以确保你的app
在该配置中也看起来不错


1167
00:51:22,282 --> 00:51:24,818 line:-1
当然我也可以回到系统外观


1168
00:51:25,719 --> 00:51:27,721 line:-1
我们确认了我们的问题已经解决


1169
00:51:28,822 --> 00:51:30,924 line:-1
现在我可以在漏洞列表中勾掉它


1170
00:51:31,491 --> 00:51:33,827 line:-2
就这样
我们完成了我们的演示


1171
00:51:33,894 --> 00:51:35,429 line:-1
我会回到幻灯片


1172
00:51:43,737 --> 00:51:45,339 line:-1
让我们回顾一下刚刚看到的内容


1173
00:51:46,240 --> 00:51:48,775 line:-2
我向你展示了如何使用
Reveal in Debug Navigator选项


1174
00:51:48,842 --> 00:51:50,210 line:-1
在左侧的层次结构中


1175
00:51:50,611 --> 00:51:52,813 line:-1
定位你当前选中的对象


1176
00:51:53,380 --> 00:51:55,549 line:-1
我向你展示了如何显示裁剪内容


1177
00:51:56,650 --> 00:51:58,886 line:-1
并且我们使用了自动布局调试功能


1178
00:51:58,952 --> 00:52:00,821 line:-1
来定位我们的约束问题


1179
00:52:01,321 --> 00:52:03,724 line:-1
我向你展示了如何使用对象指针


1180
00:52:03,790 --> 00:52:07,127 line:-1
要使用它你只需复制选定对象


1181
00:52:07,194 --> 00:52:08,362 line:-1
并在LLDB中使用


1182
00:52:08,862 --> 00:52:10,564 line:-1
我们看了一下构建过程回溯


1183
00:52:10,764 --> 00:52:12,766 line:-2
如果你在Scheme Options中
启用了


1184
00:52:12,833 --> 00:52:14,368 line:-2
Malloc Stack日志
就可以使用它


1185
00:52:15,202 --> 00:52:17,271 line:-1
来直接跳转到代码


1186
00:52:17,671 --> 00:52:19,239 line:-1
并应用约束所需的更改


1187
00:52:19,840 --> 00:52:21,742 line:-1
我们看了一下调试描述


1188
00:52:21,875 --> 00:52:24,578 line:-2
它在视图调试器的信息栏中
用起来很方便


1189
00:52:25,412 --> 00:52:27,848 line:-1
我们使用了点击量功能


1190
00:52:27,981 --> 00:52:29,683 line:-1
来选中位于一个视图后面的视图


1191
00:52:31,018 --> 00:52:32,586 line:-1
关于调试暗色模式


1192
00:52:32,653 --> 00:52:36,356 line:-2
我们看到你可以通过直接使用
Xcode的调试栏或触摸栏


1193
00:52:36,557 --> 00:52:38,792 line:-1
轻松更改目标app的外观


1194
00:52:39,660 --> 00:52:42,196 line:-2
我向你展示了如何捕捉
处于活动状态的Mac app


1195
00:52:42,396 --> 00:52:44,464 line:-1
我们也看了一下命名颜色信息


1196
00:52:44,531 --> 00:52:45,599 line:-1
及其NSAppearance信息


1197
00:52:45,666 --> 00:52:48,068 line:-2
它们在Xcode的视图调试器的
信息栏中可见


1198
00:52:49,303 --> 00:52:51,572 line:-2
若你想了解更多
关于在你的Mac app中


1199
00:52:51,738 --> 00:52:53,407 line:-1
使用暗色模式的信息


1200
00:52:53,807 --> 00:52:55,976 line:-1
请观看这两场演讲的视频


1201
00:52:57,344 --> 00:52:59,179 line:0
我们这次的演讲就到此结束了


1202
00:52:59,847 --> 00:53:01,615 line:0
若你想了解更多此次演讲的信息


1203
00:53:01,682 --> 00:53:04,785 line:0
包括Chris先前向你展示的
nudge脚本


1204
00:53:05,252 --> 00:53:07,254 line:0
它们会被发布在演讲网站上


1205
00:53:07,521 --> 00:53:10,090 line:0
如果你对本次演讲的任何内容
或一般性调试问题


1206
00:53:10,591 --> 00:53:11,792 line:0
有任何疑问


1207
00:53:11,992 --> 00:53:14,728 line:0
明天上午9点将有一个
分析和调试实验室


1208
00:53:14,962 --> 00:53:15,829 line:0
Chris和我会在那里


1209
00:53:15,896 --> 00:53:17,898 line:0
我们很乐意回答
你可能遇到的任何问题


1210
00:53:18,165 --> 00:53:20,467 line:0
另外如果你对内存调试感兴趣


1211
00:53:20,634 --> 00:53:22,603 line:0
还有一个“iOS内存深潜”演讲


1212
00:53:22,836 --> 00:53:23,770 line:0
它也在明天


1213
00:53:24,905 --> 00:53:27,708 line:0
最后 我希望你在啤酒狂欢节中
度过美妙的时光


1214
00:53:27,774 --> 00:53:29,243 line:0
并享受此次大会的其余部分

