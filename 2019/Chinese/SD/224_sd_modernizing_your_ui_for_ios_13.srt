1
00:00:06,640 --> 00:00:10,744 line:0
（针对iOS 13
现代化你的UI）


2
00:00:14,915 --> 00:00:15,949 line:-1
大家好


3
00:00:16,850 --> 00:00:20,754 line:-2
这是针对iOS 13
现代化你的UI演讲


4
00:00:22,155 --> 00:00:23,624 line:-1
我是David Duncan


5
00:00:23,690 --> 00:00:27,561 line:-2
稍后我的同事
Russell、Kyle、


6
00:00:28,829 --> 00:00:30,597 line:-2
James和Mohammed
会上台来一起演讲


7
00:00:32,933 --> 00:00:35,669 line:-1
在这场演讲中 我们要讲六件事


8
00:00:36,503 --> 00:00:39,106 line:-1
准备好app的灵活性UI


9
00:00:40,207 --> 00:00:42,776 line:-1
我们针对栏和呈现


10
00:00:43,043 --> 00:00:44,178 line:-1
所做的改进


11
00:00:45,145 --> 00:00:47,514 line:-1
app中搜索的新功能


12
00:00:47,881 --> 00:00:51,718 line:-1
让app变得


13
00:00:52,252 --> 00:00:54,388 line:-1
更加多产的新手势


14
00:00:54,755 --> 00:00:58,592 line:-1
一些你之前一直没能做到的示例


15
00:00:59,459 --> 00:01:02,529 line:-1
最后我们要回顾


16
00:01:02,596 --> 00:01:04,031 line:-2
本周稍早些时候
发布的新情境菜单API


17
00:01:05,532 --> 00:01:08,569 line:-1
那么让我们谈谈灵活性UI


18
00:01:10,938 --> 00:01:13,907 line:-1
那么具有灵活性的第一步…


19
00:01:14,708 --> 00:01:18,011 line:-2
是当用户打开app时
他们首先会看到什么


20
00:01:19,313 --> 00:01:21,148 line:-1
自iOS 8以来


21
00:01:21,215 --> 00:01:24,318 line:-1
故事板是表达启动UI的优选方式


22
00:01:25,552 --> 00:01:27,955 line:-1
但自iOS诞生之日起


23
00:01:28,021 --> 00:01:29,323 line:-1
我们还支持另一种可替换的方法


24
00:01:30,724 --> 00:01:31,959 line:-1
就是启动图像


25
00:01:32,826 --> 00:01:35,395 line:-2
启动图像要求你为每一个
你所支持的屏幕尺寸


26
00:01:35,462 --> 00:01:36,930 line:-1
指定一张图像


27
00:01:37,464 --> 00:01:40,133 line:-1
并在产生新的屏幕尺寸时进行修订


28
00:01:41,235 --> 00:01:42,569 line:-1
那样灵活性很低


29
00:01:43,604 --> 00:01:46,073 line:-1
因此明年春季 2020年四月


30
00:01:46,573 --> 00:01:49,576 line:-2
链接了iOS 13 SDK
的app


31
00:01:50,077 --> 00:01:53,780 line:-2
必须提供一个启动故事板
以便被App Store接受


32
00:01:54,314 --> 00:01:57,384 line:-1
你再也不用只提交启动图像了


33
00:01:58,318 --> 00:02:00,354 line:-1
因此 如果你还没有采用启动故事板


34
00:02:00,821 --> 00:02:02,489 line:-1
现在正是时候


35
00:02:03,490 --> 00:02:06,793 line:-2
那会引导你进入下一个变更
你可能已经听说了


36
00:02:08,294 --> 00:02:09,763 line:-1
就是在过去…


37
00:02:10,396 --> 00:02:12,900 line:-2
如果我们引入
拥有新屏幕尺寸的新硬件


38
00:02:13,333 --> 00:02:14,535 line:-1
你的app将会是宽屏幕格式


39
00:02:15,502 --> 00:02:17,905 line:-1
嗯 我们也不再打算那样做了


40
00:02:18,605 --> 00:02:22,075 line:-2
因此 如果你的app采用了
iOS 13 SDK


41
00:02:22,743 --> 00:02:24,344 line:-1
那么它将总是


42
00:02:24,411 --> 00:02:27,281 line:-1
以屏幕的原生全屏分辨率显示


43
00:02:28,182 --> 00:02:31,718 line:-2
因此 我们期待
任何采用iOS 13的app


44
00:02:32,252 --> 00:02:35,022 line:-2
都使用合适的API
来确保正确的布局


45
00:02:35,389 --> 00:02:36,356 line:-1
在任意尺寸的屏幕上


46
00:02:38,525 --> 00:02:41,094 line:-2
对于那些创建iPad app
的开发人员来说


47
00:02:41,528 --> 00:02:44,531 line:-1
这也适用于分屏多任务


48
00:02:45,499 --> 00:02:49,069 line:-1
因此 我们期待绝大多数app


49
00:02:49,336 --> 00:02:51,672 line:-1
除非你需要提供非常拟真的体验


50
00:02:52,472 --> 00:02:54,708 line:-1
都支持分屏多任务功能


51
00:02:55,108 --> 00:02:57,611 line:-1
你的app可以以任意尺寸


52
00:02:57,911 --> 00:02:59,546 line:-1
紧邻其它app显示


53
00:02:59,880 --> 00:03:01,882 line:-1
可能是用户所选择的其它app


54
00:03:03,217 --> 00:03:04,918 line:-1
如果你不确定…


55
00:03:06,153 --> 00:03:08,188 line:-2
如果你可以支持全部这些
重调尺寸模式


56
00:03:08,255 --> 00:03:09,223 line:-1
以及其它一切功能


57
00:03:09,556 --> 00:03:10,991 line:-1
你可能会想尝试另外一件事


58
00:03:11,058 --> 00:03:12,192 line:-1
尤其是当你有iPad app时


59
00:03:12,492 --> 00:03:13,694 line:-1
那就是专门为Mac创建


60
00:03:13,760 --> 00:03:17,231 line:-2
通过我们在macOS Catalina中
添加的新技术支持


61
00:03:17,564 --> 00:03:19,032 line:-1
并且你直接就能在办公桌上实现


62
00:03:19,099 --> 00:03:21,635 line:-2
要确保重调尺寸之后的任意尺寸
看起来都很漂亮


63
00:03:22,636 --> 00:03:25,339 line:-1
那么在此之前


64
00:03:26,139 --> 00:03:27,808 line:-1
要采用启动故事板


65
00:03:28,075 --> 00:03:31,144 line:-1
用户即将看到启动UI


66
00:03:31,211 --> 00:03:33,347 line:-1
当用户首次启动你的app时


67
00:03:34,214 --> 00:03:38,185 line:-2
要确保app的布局
支持任意尺寸的屏幕


68
00:03:38,752 --> 00:03:41,922 line:-2
无论是最小的iPhone
还是最大的iPad


69
00:03:43,090 --> 00:03:45,826 line:-1
最后 确保你的iPad app


70
00:03:45,893 --> 00:03:47,895 line:-1
同样也支持分屏多任务功能


71
00:03:48,595 --> 00:03:51,665 line:-2
因为你必须在
2020年四月之前实现


72
00:03:52,933 --> 00:03:56,770 line:-1
然后让我们再谈谈栏


73
00:03:59,540 --> 00:04:00,440 line:-1
那么…


74
00:04:01,542 --> 00:04:05,078 line:-2
如果你在安装测试版之后
看一下手机


75
00:04:06,046 --> 00:04:09,049 line:-1
你可以看到现在的栏是如何显示的


76
00:04:09,449 --> 00:04:11,185 line:-1
当你持续向上滚动到顶部时


77
00:04:11,518 --> 00:04:12,819 line:-1
我们会退出背景


78
00:04:13,620 --> 00:04:15,255 line:-1
当我们向下滚动时


79
00:04:15,322 --> 00:04:18,024 line:-1
我们把它带回来了 既流畅又透明


80
00:04:19,526 --> 00:04:21,728 line:-1
类似地 在iPad上


81
00:04:22,362 --> 00:04:24,064 line:-1
如果你有分割视图控制器


82
00:04:24,665 --> 00:04:26,834 line:-2
我们分别为两个方向
都执行这样的效果


83
00:04:26,900 --> 00:04:30,571 line:-1
无论细节是否支持大标题


84
00:04:32,039 --> 00:04:33,473 line:-1
并且它们会分别进行响应


85
00:04:33,540 --> 00:04:35,475 line:-1
因此显示哪个背景


86
00:04:35,542 --> 00:04:36,677 line:-1
取决于滚动方向


87
00:04:38,278 --> 00:04:39,580 line:-1
现在你可能会问


88
00:04:40,214 --> 00:04:41,181 line:-1
要如何采用这个？


89
00:04:41,248 --> 00:04:43,717 line:-2
如何确保
它能很好地嵌入我的app中？


90
00:04:44,785 --> 00:04:46,620 line:-1
嗯 采用方法很简单


91
00:04:47,154 --> 00:04:48,922 line:-1
链接iOS 13


92
00:04:49,289 --> 00:04:50,324 line:-1
你会免费获得它


93
00:04:51,625 --> 00:04:54,661 line:-2
但如何让它在你的app中
完美地发挥作用


94
00:04:54,962 --> 00:04:56,096 line:-1
可能需要花点儿时间


95
00:04:56,630 --> 00:04:59,967 line:-1
因此我们引入了新外观自定义API


96
00:05:00,033 --> 00:05:00,968 line:-1
来帮助你实现


97
00:05:02,169 --> 00:05:03,036 line:-1
那么让我们来看一下


98
00:05:03,103 --> 00:05:05,506 line:-1
在新外观API中


99
00:05:05,572 --> 00:05:06,874 line:-1
自定义导航栏是什么样子


100
00:05:06,940 --> 00:05:08,175 line:-1
（新栏外观）


101
00:05:08,976 --> 00:05:10,844 line:-1
那么我们要做的第一件事


102
00:05:12,179 --> 00:05:13,413 line:-1
就是创建对象


103
00:05:13,747 --> 00:05:15,215 line:-1
它实际上表示外观


104
00:05:15,782 --> 00:05:17,284 line:-1
UINavigationBarAppearance


105
00:05:18,051 --> 00:05:20,320 line:-2
是UIBarAppearance
的子类


106
00:05:20,754 --> 00:05:23,290 line:-1
它压缩了


107
00:05:23,557 --> 00:05:24,591 line:-2
UINavigationBar的
全部自定义选项


108
00:05:25,158 --> 00:05:27,327 line:-2
在这种情况下
我们实际上要让导航栏


109
00:05:27,394 --> 00:05:28,795 line:-1
使用一种不透明的颜色


110
00:05:29,396 --> 00:05:31,231 line:-1
因此我们要使用默认值


111
00:05:31,298 --> 00:05:33,567 line:-2
它是由configureWith
OpaqueBackground提供的


112
00:05:34,568 --> 00:05:37,237 line:-1
那会让导航栏的背景遵守


113
00:05:37,304 --> 00:05:40,207 line:-2
明亮和暗黑模式
并显示一种恰当的不透明颜色


114
00:05:41,675 --> 00:05:43,710 line:-1
在这个特例中


115
00:05:43,777 --> 00:05:45,512 line:-1
我们还想改变标签颜色


116
00:05:46,079 --> 00:05:48,882 line:-2
因此我们可以设置
titleTextAttributes


117
00:05:48,949 --> 00:05:50,350 line:-1
和largeTitleTextAttributes


118
00:05:50,884 --> 00:05:53,887 line:-2
我们要给它们设定一个
我们即将使用的自定义颜色


119
00:05:54,354 --> 00:05:55,389 line:-1
另一种动态颜色


120
00:05:55,455 --> 00:05:57,558 line:-2
正因为如此 才能保证
在明亮和暗黑模式中看起来都很棒


121
00:05:58,892 --> 00:06:02,696 line:-2
最后我们要把它应用到
导航栏的标准外观上


122
00:06:03,797 --> 00:06:05,699 line:-2
那么什么是
standardAppearance？


123
00:06:06,400 --> 00:06:07,568 line:-1
嗯 让我们来看看


124
00:06:09,870 --> 00:06:11,038 line:-1
导航栏


125
00:06:11,104 --> 00:06:12,873 line:-1
当它是自己的尺寸时 没有大标题


126
00:06:13,173 --> 00:06:14,374 line:-1
它是标准尺寸


127
00:06:14,942 --> 00:06:16,844 line:-2
这就是standardAppearance
所表达的东西


128
00:06:17,578 --> 00:06:20,981 line:-1
此外 如果你不指定其它外观配置


129
00:06:21,481 --> 00:06:25,085 line:-2
我们会对其它两个配置
使用默认配置


130
00:06:25,152 --> 00:06:26,420 line:-1
我们稍后再谈


131
00:06:29,456 --> 00:06:31,892 line:-2
那么如果你使用
较小屏幕的iPhone横屏模式


132
00:06:32,226 --> 00:06:33,627 line:-2
你会得到
compactAppearance


133
00:06:34,294 --> 00:06:35,762 line:-1
这就是它所表达的东西


134
00:06:36,430 --> 00:06:37,297 line:-1
它的数量


135
00:06:38,665 --> 00:06:41,468 line:-1
之前我们在iOS 13中看到过


136
00:06:42,336 --> 00:06:44,905 line:-1
导航栏把它的背景变成了透明的


137
00:06:44,972 --> 00:06:47,207 line:-1
当你从滚动视图的顶部向下拉动时


138
00:06:47,975 --> 00:06:50,310 line:-2
那就是
scrollEdgeAppearance


139
00:06:51,278 --> 00:06:53,780 line:-2
无论何时
当导航栏与滚动视图相关联时


140
00:06:53,847 --> 00:06:55,249 line:-1
这在app中很常见


141
00:06:55,883 --> 00:06:57,417 line:-1
如果你处于滚动视图的顶部


142
00:06:57,851 --> 00:07:00,554 line:-2
那么我们将使用
scrollEdgeAppearance替换标准外观


143
00:07:01,421 --> 00:07:03,257 line:-1
默认是使用一个透明背景


144
00:07:03,590 --> 00:07:06,426 line:-2
这就是为什么
你会得到无缝外观的原因


145
00:07:06,493 --> 00:07:08,128 line:-2
无缝外观是我们在iOS 13中
新添加的功能


146
00:07:10,397 --> 00:07:12,833 line:-1
此外 你还可以自定义


147
00:07:12,900 --> 00:07:14,001 line:-1
栏按钮项的外观


148
00:07:14,401 --> 00:07:16,170 line:-2
并自定义buttonAppearance
获取plain项的外观


149
00:07:16,737 --> 00:07:19,072 line:-2
以及自定义doneButtonAppearance
获取done项的外观


150
00:07:21,008 --> 00:07:22,543 line:-1
现在我们可以暂停一下


151
00:07:22,809 --> 00:07:24,511 line:-1
你得到了导航栏 它是自定义导航栏


152
00:07:24,578 --> 00:07:25,412 line:-1
很棒


153
00:07:26,413 --> 00:07:29,283 line:-2
但我们决定把它应用到
Toolbar和TabBar


154
00:07:29,716 --> 00:07:32,419 line:-2
以便你可以用非常相似的方法
自定义所有栏


155
00:07:33,053 --> 00:07:35,689 line:-2
每一个类都能使用它们自己的
UIBarAppearance子类


156
00:07:35,756 --> 00:07:39,059 line:-1
来实现它们自己的自定义功能


157
00:07:39,793 --> 00:07:42,262 line:-2
ToolbarAppearance
实际上就是一个


158
00:07:42,329 --> 00:07:43,964 line:-2
与navigationBarAppearance
相关的属性子集


159
00:07:44,031 --> 00:07:46,700 line:-1
因此再进一步也没有多大意思


160
00:07:47,234 --> 00:07:48,969 line:-2
但TabBarAppearance
有点不一样


161
00:07:49,036 --> 00:07:51,138 line:-1
那是因为TabBar也有点不一样


162
00:07:52,906 --> 00:07:54,241 line:-1
那么对于TabBar


163
00:07:54,775 --> 00:07:56,810 line:-1
针对三个布局外观


164
00:07:57,344 --> 00:07:59,046 line:-1
拥有附加的自定义选项


165
00:07:59,112 --> 00:08:00,447 line:-1
stackedLayoutAppearance、


166
00:08:00,948 --> 00:08:02,950 line:-2
你将在iPad上看到的
inlineAppearance


167
00:08:03,817 --> 00:08:06,653 line:-2
以及你将在小屏幕手机上看到的
compactInlineAppearance


168
00:08:08,088 --> 00:08:10,123 line:-1
那么你可以把它们放在一起


169
00:08:11,158 --> 00:08:13,927 line:-1
并获得全部栏的新自定义外观


170
00:08:15,195 --> 00:08:16,230 line:-1
但还有另一件事


171
00:08:18,465 --> 00:08:20,000 line:-2
如果你看一下
新Reminders app


172
00:08:20,400 --> 00:08:21,835 line:-1
当你导航到一个列表时


173
00:08:22,636 --> 00:08:25,239 line:-2
它的标题颜色会发生改变
以匹配列表颜色


174
00:08:26,740 --> 00:08:27,975 line:-1
它的实现方式是


175
00:08:28,408 --> 00:08:31,778 line:-2
对每个导航项都使用
不同的外观自定义


176
00:08:32,546 --> 00:08:35,649 line:-1
那就允许你根据


177
00:08:35,716 --> 00:08:37,351 line:-2
要放到navigationBar
上的导航项指定外观


178
00:08:38,619 --> 00:08:40,354 line:-1
导航项也与导航相关联


179
00:08:40,419 --> 00:08:41,255 line:-1
或与视图控制器相关联


180
00:08:41,321 --> 00:08:43,457 line:-1
因此 放到导航控制器上


181
00:08:43,524 --> 00:08:44,658 line:-1
将会自动使用那个


182
00:08:45,659 --> 00:08:46,760 line:-1
那么它看起来是什么样呢？


183
00:08:48,428 --> 00:08:49,463 line:-1
嗯…


184
00:08:49,997 --> 00:08:52,032 line:-1
导航项拥有


185
00:08:52,499 --> 00:08:53,834 line:-2
与navigationBar
相同的属性


186
00:08:54,401 --> 00:08:56,737 line:-1
因此通常要做的事就是


187
00:08:57,171 --> 00:08:59,072 line:-2
从navigationBar中
获取标准外观


188
00:08:59,840 --> 00:09:03,477 line:-1
并复制 以便与那个外观相分离


189
00:09:04,845 --> 00:09:06,246 line:-1
并做一切你想要做的变更


190
00:09:06,580 --> 00:09:08,081 line:-1
如果你希望它是透明的


191
00:09:08,148 --> 00:09:10,083 line:-1
你可以使用配置透明


192
00:09:10,984 --> 00:09:13,420 line:-1
你可以修改栏按钮项的外观等等


193
00:09:14,922 --> 00:09:16,590 line:-1
然后你再把它分配给导航项


194
00:09:17,424 --> 00:09:20,093 line:-1
一旦完成 无论何时当视图控制器


195
00:09:20,160 --> 00:09:21,361 line:-1
和导航栏项处于当前时


196
00:09:21,828 --> 00:09:25,032 line:-2
我们都将使用那个外观而不是
navigationBar的基本外观


197
00:09:25,465 --> 00:09:28,368 line:-2
从而确保你可以自定义你的
navigationBar


198
00:09:28,435 --> 00:09:30,137 line:-1
无论应用了哪种视图控制器


199
00:09:33,273 --> 00:09:35,576 line:-1
为此我要邀请Russell上台来


200
00:09:35,642 --> 00:09:36,977 line:-1
为大家讲讲呈现


201
00:09:41,315 --> 00:09:42,549 line:-1
（呈现）


202
00:09:44,952 --> 00:09:45,953 line:-1
谢谢David


203
00:09:47,087 --> 00:09:48,055 line:-1
大家好


204
00:09:48,121 --> 00:09:50,691 line:-2
我是Russell
我也刚接触iOS 13


205
00:09:51,058 --> 00:09:53,260 line:-1
对于呈现我们有一个标准设计


206
00:09:53,527 --> 00:09:55,295 line:-2
我今天要跟大家分享一下
我感到非常激动


207
00:09:56,797 --> 00:09:59,199 line:-1
比如说如果我处于通讯录app中


208
00:09:59,766 --> 00:10:01,802 line:-2
并且我轻触了加号
来添加一个新联系人


209
00:10:02,202 --> 00:10:05,205 line:-2
我们有一个新的呈现样式
看起来是这样的


210
00:10:05,539 --> 00:10:07,841 line:-1
而不是之前的全屏呈现


211
00:10:08,675 --> 00:10:10,777 line:-1
你可以看到根视图控制器的视图


212
00:10:10,844 --> 00:10:14,648 line:-2
并没有按比例缩小
也没有从视图等级中移除


213
00:10:15,983 --> 00:10:17,384 line:-1
这个设计的分层


214
00:10:17,718 --> 00:10:21,288 line:-2
给你的用户提供了一种情境
关于他们处于app中的哪个位置


215
00:10:22,022 --> 00:10:24,725 line:-1
并且圆形顶部外观的作用是一个信号


216
00:10:25,158 --> 00:10:28,562 line:-1
表示可以交互式地清除这些呈现


217
00:10:28,929 --> 00:10:30,197 line:-1
在系统的任何地方


218
00:10:32,165 --> 00:10:33,433 line:-1
那么…谢谢


219
00:10:37,671 --> 00:10:39,273 line:-1
那么这个新的呈现样式是什么呢？


220
00:10:40,140 --> 00:10:43,477 line:-1
这些呈现叫做Sheets


221
00:10:43,877 --> 00:10:45,512 line:-1
Sheets也不是什么新东西


222
00:10:45,946 --> 00:10:48,415 line:-1
这些呈现


223
00:10:48,482 --> 00:10:52,252 line:-2
只是当前
UIModalPresentationStylepageSheet


224
00:10:52,586 --> 00:10:54,321 line:-2
以及它兄弟
formSheet的新设计


225
00:10:55,722 --> 00:10:56,590 line:-1
之前


226
00:10:56,657 --> 00:10:59,092 line:-1
这些样式会采用全屏呈现


227
00:10:59,159 --> 00:11:00,494 line:-1
在宽度压缩的环境中


228
00:11:01,061 --> 00:11:04,565 line:-2
现在它们只会保留sheet
以及它们自己的特别布局


229
00:11:04,631 --> 00:11:07,501 line:-2
和压缩宽度
与常规宽度的布局不一样


230
00:11:09,403 --> 00:11:11,305 line:-1
那么让我们通过实际操作看一些例子


231
00:11:12,472 --> 00:11:14,942 line:-2
在手机和竖屏模式中
你会获得你刚看到的外观


232
00:11:15,509 --> 00:11:16,677 line:-1
但在手机的横屏模式中


233
00:11:16,743 --> 00:11:18,345 line:-1
你获得一个与之前一样的全屏布局


234
00:11:20,347 --> 00:11:21,515 line:-1
但我们不能遗忘iPad


235
00:11:21,849 --> 00:11:23,283 line:-2
在这点上我们重新思考了
Sheets


236
00:11:23,917 --> 00:11:26,620 line:-2
页面Sheets悬浮
在屏幕中央的堆栈中


237
00:11:27,521 --> 00:11:29,823 line:-1
并且如果有呈现多重Sheet


238
00:11:30,290 --> 00:11:32,259 line:-1
它们会在检查控制器顶部形成堆栈


239
00:11:34,862 --> 00:11:38,198 line:-1
特别是这个新尺寸要遵从可阅读宽度


240
00:11:38,465 --> 00:11:40,200 line:-1
因此对于文本内容来说很完美


241
00:11:40,968 --> 00:11:42,102 line:-1
并且因为可阅读宽度


242
00:11:42,369 --> 00:11:45,239 line:-2
会随着用户当前所选择的动态类型
尺寸的变更而变更


243
00:11:45,706 --> 00:11:47,774 line:-1
这些页面Sheet的尺寸也会改变


244
00:11:48,141 --> 00:11:50,177 line:-1
像这样或甚至是像这样


245
00:11:50,911 --> 00:11:52,546 line:-1
或者它们会呈现堆叠式外观


246
00:11:52,813 --> 00:11:55,849 line:-2
如果它们的优选宽度
比可用宽度更宽的话


247
00:11:59,319 --> 00:12:01,788 line:-1
要在你的app中获得这个新外观


248
00:12:01,855 --> 00:12:02,689 line:-1
你都需要做哪些操作呢？


249
00:12:03,156 --> 00:12:05,125 line:-2
嗯 你要做的很少
因为你已经做了许多工作


250
00:12:05,192 --> 00:12:08,328 line:-1
让这种转换变得尽可能简单了


251
00:12:10,531 --> 00:12:13,367 line:-2
默认的UIViewController
ModalPresentationStyle


252
00:12:13,433 --> 00:12:16,570 line:-2
变成了一种新样式
叫做Automatic


253
00:12:17,771 --> 00:12:20,440 line:-2
Automatic
是一种动态呈现样式


254
00:12:20,707 --> 00:12:23,010 line:-1
在呈现时使用


255
00:12:23,911 --> 00:12:24,978 line:-1
为了说明它的行为


256
00:12:25,445 --> 00:12:27,181 line:-1
让我们一起来看几个例子


257
00:12:29,650 --> 00:12:32,586 line:-2
那么在这里
我有一个自定义视图控制器


258
00:12:32,886 --> 00:12:35,455 line:-2
它将呈现
UIImagePickerController


259
00:12:35,522 --> 00:12:36,890 line:-1
显示用户的相册


260
00:12:37,224 --> 00:12:40,027 line:-2
请注意那儿并没有设置
任何模型呈现样式


261
00:12:41,228 --> 00:12:43,564 line:-1
在iOS 12中使用的同样的代码


262
00:12:43,630 --> 00:12:45,566 line:-1
会全屏呈现图片选择器


263
00:12:45,632 --> 00:12:46,967 line:-1
现在将以Sheet形式呈现


264
00:12:47,401 --> 00:12:49,169 line:-1
而你不需要修改任何代码


265
00:12:51,872 --> 00:12:52,873 line:-1
另一方面


266
00:12:52,940 --> 00:12:56,043 line:-2
如果我配置UIImagePickerController
以呈现相机模式


267
00:12:56,510 --> 00:12:59,813 line:-2
这段代码将在iOS 13中
全屏呈现相机


268
00:13:00,147 --> 00:13:01,548 line:-1
就像它在iOS 12中那样


269
00:13:02,516 --> 00:13:05,519 line:-1
这是自动的 解决不同的样式


270
00:13:05,819 --> 00:13:09,122 line:-1
根据系统提供视图控制器的配置方式


271
00:13:09,423 --> 00:13:10,958 line:-1
因此你不需要修改任何代码


272
00:13:13,961 --> 00:13:15,963 line:-2
现在如何呈现
我们自己的视图控制器呢？


273
00:13:16,897 --> 00:13:20,067 line:-2
如果我简单地初始化并呈现
UIViewController的自定义子类


274
00:13:20,133 --> 00:13:22,569 line:-1
它将以Sheet形式呈现


275
00:13:23,036 --> 00:13:24,805 line:-1
换句话说 在默认情况下


276
00:13:25,272 --> 00:13:27,374 line:-2
Automatic
决定pageSheet


277
00:13:28,909 --> 00:13:31,879 line:-2
这很棒 因为它对于
绝大多数呈现来说样式很棒


278
00:13:32,946 --> 00:13:34,648 line:-1
再一次 不需要修改任何代码


279
00:13:36,383 --> 00:13:38,418 line:-2
但如果是
最后这个例子的情况会怎样？


280
00:13:39,219 --> 00:13:42,456 line:-2
如果你有一个自定义视图控制器
应该全屏呈现


281
00:13:42,856 --> 00:13:45,792 line:-2
比如你自己的自定义相机
或其它沉浸式体验


282
00:13:46,226 --> 00:13:48,161 line:-1
你可能会发现当你创建这部分代码时


283
00:13:48,495 --> 00:13:50,464 line:-2
你的沉浸式体验就会转变为
一个Sheet


284
00:13:51,131 --> 00:13:53,500 line:-2
但不要担心
要修复这个问题你所要做的就是


285
00:13:54,234 --> 00:13:56,537 line:-2
把这个视图控制器的
modalPresentationStyle


286
00:13:56,603 --> 00:13:58,472 line:-1
明确地设置为全屏


287
00:13:59,773 --> 00:14:02,176 line:-1
通常来说 保留属性的默认值就可以


288
00:14:02,242 --> 00:14:05,712 line:-1
只需要指定一个确切值


289
00:14:05,779 --> 00:14:08,315 line:-1
当你有意偏离默认行为时


290
00:14:11,885 --> 00:14:13,887 line:-1
那么Popovers呢？


291
00:14:14,688 --> 00:14:16,857 line:-1
Popover现在总会适应工作表


292
00:14:17,357 --> 00:14:19,293 line:-2
因此 如果你想要一个
常规宽度的Popover


293
00:14:19,826 --> 00:14:21,862 line:-1
和压缩宽度的Sheet


294
00:14:22,629 --> 00:14:25,465 line:-2
你所要做的就是
把模态呈现样式设置为


295
00:14:25,532 --> 00:14:27,100 line:-1
Popover 然后就完成了


296
00:14:27,434 --> 00:14:28,769 line:-1
然后你将完全获得那种行为


297
00:14:32,172 --> 00:14:33,040 line:-1
现在…


298
00:14:33,774 --> 00:14:37,444 line:-1
要支持下拉清除需要做哪些操作呢？


299
00:14:40,514 --> 00:14:41,849 line:-1
一般来说 什么也不用做


300
00:14:42,482 --> 00:14:43,984 line:-2
如果你把某个东西
以Sheet形式呈现


301
00:14:44,284 --> 00:14:46,687 line:-1
你就可以免费获得下拉功能


302
00:14:47,287 --> 00:14:50,157 line:-2
我们将在你所呈现的整个视图中
加入一个手势识别器


303
00:14:50,490 --> 00:14:54,127 line:-2
因此在任意非交互性区域执行的下拉
都将触发Sheet的下拉


304
00:14:55,195 --> 00:14:59,466 line:-2
如用户在包含scrollView
的任意区域中从顶部以上执行下拉


305
00:14:59,733 --> 00:15:02,803 line:-2
也会下拉sheet
并且这也是免费的


306
00:15:05,372 --> 00:15:08,876 line:-1
然而 有时候下拉sheet


307
00:15:08,942 --> 00:15:09,977 line:-1
可能会不太合适


308
00:15:11,345 --> 00:15:15,115 line:-2
比如 如果我们呈现了与这个
一样的Sheet并输入了一些数据


309
00:15:15,649 --> 00:15:17,451 line:-1
那么就不应该允许下拉Sheet


310
00:15:17,751 --> 00:15:22,456 line:-2
因为不清楚用户
是否要丢弃或保存他们的修改


311
00:15:23,123 --> 00:15:25,092 line:-1
并且如果用户尝试下拉


312
00:15:25,592 --> 00:15:27,094 line:-1
Sheet应该和橡皮筋一样


313
00:15:27,361 --> 00:15:28,896 line:-2
并呈现一个
action sheet


314
00:15:29,196 --> 00:15:32,466 line:-2
显示用户可以进行的各种操作
从而摆脱这种情境


315
00:15:36,236 --> 00:15:37,404 line:-1
因此要创建这种体验


316
00:15:37,704 --> 00:15:39,106 line:-1
我们有两个新API


317
00:15:40,073 --> 00:15:42,576 line:-1
第一个是模态和呈现


318
00:15:43,143 --> 00:15:44,811 line:-2
是pUIViewController上的
一个属性


319
00:15:45,345 --> 00:15:48,015 line:-2
当你在所呈现的视图控制器上
把它设为真时


320
00:15:48,715 --> 00:15:52,953 line:-2
它将使Sheet处于模态状态
它不能被清除


321
00:15:54,388 --> 00:15:56,690 line:-2
并且你将获得橡皮筋效果
就像你刚才看到的那样


322
00:15:57,457 --> 00:16:01,195 line:-2
这个属性取代了现有的
isModal和Popover属性


323
00:16:01,261 --> 00:16:04,031 line:-2
防止Sheets和
Popovers都被清除


324
00:16:06,667 --> 00:16:10,237 line:-2
第二个是一个新
UIAdaptivePresentationController


325
00:16:10,304 --> 00:16:12,072 line:-1
DelegateMethod 叫做


326
00:16:12,139 --> 00:16:15,275 line:-1
presentationControllerDidAttemptToDismiss


327
00:16:15,342 --> 00:16:18,412 line:-2
因此如果你在相关的呈现控制器上
设置委托


328
00:16:19,012 --> 00:16:22,983 line:-2
UIKit将调用这个方法
当用户在模态状态下执行下拉时


329
00:16:23,383 --> 00:16:25,586 line:-2
那时你可以呈现
action sheet


330
00:16:28,922 --> 00:16:31,491 line:-2
在这里你可以看到
这些API之间的关系


331
00:16:32,359 --> 00:16:36,797 line:-2
只有当isModalInPresentation为真时
才会调用DidAttemptToDismiss


332
00:16:37,397 --> 00:16:40,801 line:-1
并且用户下拉和释放的目的是清除


333
00:16:40,868 --> 00:16:42,603 line:-1
有一点儿强迫或暴力


334
00:16:43,570 --> 00:16:44,838 line:-1
我们把它叫做Modal Flow


335
00:16:45,239 --> 00:16:48,108 line:-2
并且我有一个示例项目可以演示
到底如何实施


336
00:16:48,175 --> 00:16:49,376 line:-1
一个像这样的例子


337
00:16:49,743 --> 00:16:52,746 line:-2
但请看一下描述中的链接
了解如何下载它


338
00:16:54,147 --> 00:16:55,349 line:-1
但我们还有更多


339
00:16:56,116 --> 00:16:58,685 line:-1
我们还有几个委托回调函数


340
00:16:59,119 --> 00:17:00,787 line:-1
PresentationControllerShouldDismiss


341
00:17:01,088 --> 00:17:03,290 line:-1
用于从委托中阻止清除


342
00:17:03,824 --> 00:17:06,425 line:-1
WillDismiss用于获取


343
00:17:06,492 --> 00:17:08,595 line:-1
视图控制器的一个转换协调器


344
00:17:08,896 --> 00:17:11,464 line:-1
你可以用它设置周边的动画、


345
00:17:11,531 --> 00:17:14,501 line:-1
交互变更通知和动画完成块


346
00:17:15,135 --> 00:17:16,303 line:-1
以及DidDismiss


347
00:17:16,637 --> 00:17:20,574 line:-2
用于清除状态 因为它只有当用户
实际下拉Sheet


348
00:17:20,641 --> 00:17:23,076 line:-1
并完成转换时才会被调用一次


349
00:17:25,145 --> 00:17:27,446 line:-2
这三种回调函数取代了拥有
相似命名的UI Popover


350
00:17:27,513 --> 00:17:29,983 line:-2
presentationControllerDelegate
回调函数


351
00:17:30,651 --> 00:17:33,720 line:-2
这些API既可在Sheets中
又可在Popovers中调用


352
00:17:35,789 --> 00:17:39,927 line:-1
请记住 如用户重复拉动Sheet


353
00:17:40,327 --> 00:17:41,728 line:-1
而不是下拉


354
00:17:41,795 --> 00:17:43,764 line:-1
委托会多次收到…


355
00:17:44,731 --> 00:17:48,936 line:-2
Should和WillDismiss
在调用DidDismiss之前


356
00:17:49,269 --> 00:17:51,004 line:-1
如果能收到DidDismiss


357
00:17:54,975 --> 00:17:57,377 line:-1
现在让我们暂时转到分享扩展


358
00:17:58,545 --> 00:18:02,282 line:-2
当你用iOS 13 SDK
创建分享扩展时


359
00:18:02,683 --> 00:18:03,884 line:-1
就像这里的邮箱一样


360
00:18:04,751 --> 00:18:08,222 line:-2
它将成为Sheets
并且也会实现下拉清除


361
00:18:09,223 --> 00:18:12,326 line:-1
那么在扩展的主视图控制器上


362
00:18:12,392 --> 00:18:15,295 line:-2
就像你在Info P List中
所指定的主视图控制器一样


363
00:18:15,929 --> 00:18:18,565 line:-2
一定要设置
isModalInPresentation


364
00:18:19,032 --> 00:18:20,901 line:-1
一旦用户开始输入数据


365
00:18:21,568 --> 00:18:23,904 line:-1
并且如果你让主视图控制器


366
00:18:23,971 --> 00:18:27,241 line:-2
遵从UIAdaptivePresentation
ControllerDelegate


367
00:18:27,541 --> 00:18:30,010 line:-2
并实施
DidAttemptToDismiss


368
00:18:30,477 --> 00:18:33,447 line:-2
我们将调用那个方法
当用户在这种情况下执行下拉时


369
00:18:33,981 --> 00:18:36,917 line:-2
请注意 我们不会调用
任何其它委托方法


370
00:18:38,785 --> 00:18:40,821 line:-2
并且你可以在将来的种子中
获得这个行为


371
00:18:43,524 --> 00:18:44,491 line:-1
接下来


372
00:18:44,558 --> 00:18:46,793 line:-1
我想让你思考一些东西


373
00:18:47,661 --> 00:18:50,797 line:-2
第一个与UIViewController
外观回调函数有关


374
00:18:51,765 --> 00:18:54,968 line:-1
尤其是


375
00:18:55,435 --> 00:18:57,337 line:-2
呈现视图控制器
在全屏呈现与sheet呈现时


376
00:18:58,005 --> 00:19:01,542 line:-1
所接收的外观回调函数之间的区别


377
00:19:02,943 --> 00:19:04,478 line:-1
全屏呈现时


378
00:19:04,778 --> 00:19:08,482 line:-2
呈现视图控制器的视图
被从视图等级中移除


379
00:19:09,216 --> 00:19:12,319 line:-2
结果是它会收到
viewWillDisappear


380
00:19:12,586 --> 00:19:15,522 line:-1
当呈现转换开始时


381
00:19:15,889 --> 00:19:18,926 line:-2
然后收到viewDidDisappear
当呈现转换结束时


382
00:19:19,660 --> 00:19:21,995 line:-1
类似地 在清除转换过程中


383
00:19:22,062 --> 00:19:24,031 line:-1
当它的视图移回视图等级中时


384
00:19:24,097 --> 00:19:25,732 line:-2
它会收到
viewWill和DidAppear


385
00:19:27,100 --> 00:19:29,403 line:-1
但对于Sheet呈现


386
00:19:30,137 --> 00:19:31,305 line:-1
呈现视图控制器的视图


387
00:19:31,371 --> 00:19:33,106 line:-1
不会从视图等级中移除


388
00:19:33,507 --> 00:19:35,008 line:-1
因此它的视图


389
00:19:35,075 --> 00:19:38,445 line:-2
或视图控制器
不会收到任何外观回调函数


390
00:19:39,346 --> 00:19:41,014 line:-2
因此
如果你的这些回调函数中有代码


391
00:19:41,315 --> 00:19:43,283 line:-1
你需要在清除Sheet时执行


392
00:19:43,617 --> 00:19:45,652 line:-1
你应该了解一下我们刚讲过的


393
00:19:45,719 --> 00:19:48,021 line:-2
呈现控制器的Will
和DidDismiss方法


394
00:19:51,191 --> 00:19:53,193 line:-1
第二 我希望你们都考虑一下


395
00:19:53,460 --> 00:19:55,829 line:-1
我们插入了一些私有视图


396
00:19:55,896 --> 00:19:58,632 line:-1
在UIWindow之间的视图等级


397
00:19:58,932 --> 00:20:00,300 line:-1
及其rootViewController视图中


398
00:20:01,602 --> 00:20:03,370 line:-1
这个变更应该不会影响你


399
00:20:03,937 --> 00:20:05,372 line:-1
我们只是不希望你太吃惊


400
00:20:05,439 --> 00:20:07,140 line:-2
当你在视图调试器中
看到这些视图时


401
00:20:07,941 --> 00:20:09,543 line:-1
UIWindow之间的关系


402
00:20:09,810 --> 00:20:11,278 line:-2
UIWindow与其
根视图控制器的视图之间的关系


403
00:20:11,345 --> 00:20:13,247 line:-1
是UIKit的一个实施细节


404
00:20:13,714 --> 00:20:16,183 line:-1
因为UIWindow有责任


405
00:20:16,250 --> 00:20:18,952 line:-2
管理这个视图
并把它添加到视图等级中


406
00:20:20,120 --> 00:20:22,389 line:-1
一般来说


407
00:20:22,456 --> 00:20:23,724 line:-1
app没有视图等级结构的所有权


408
00:20:24,024 --> 00:20:26,493 line:-2
这个结构很容易被修改
不需要任何通知


409
00:20:27,361 --> 00:20:30,230 line:-1
因此一定要确保你写代码的方式


410
00:20:30,597 --> 00:20:33,767 line:-1
不会假定私有视图等级


411
00:20:35,536 --> 00:20:36,670 line:-1
（更新你的APP）


412
00:20:36,737 --> 00:20:40,040 line:-2
因此在你的app中
使用Sheet呈现


413
00:20:40,607 --> 00:20:43,777 line:-2
你可以在绝大多数UI中使用它们
极少有例外


414
00:20:44,945 --> 00:20:48,682 line:-2
当下拉请求用户的意图时
实施Modal Flow


415
00:20:49,483 --> 00:20:51,985 line:-1
请记住 有一个示例项目完全阐明了


416
00:20:52,052 --> 00:20:53,820 line:-1
具体如何实现…


417
00:20:54,154 --> 00:20:55,422 line:-1
在演讲的文档中


418
00:20:57,324 --> 00:20:58,225 line:-1
谢谢大家


419
00:20:58,292 --> 00:21:00,694 line:-2
现在我要把舞台交给Kyle
他会和大家谈谈搜索


420
00:21:06,466 --> 00:21:07,434 line:-1
讲得很好


421
00:21:09,803 --> 00:21:10,904 line:-1
谢谢Russell


422
00:21:15,909 --> 00:21:18,645 line:-2
大家好 我是Kyle
我的工作是做UIKit…


423
00:21:18,712 --> 00:21:19,546 line:-1
（搜索）


424
00:21:19,613 --> 00:21:23,684 line:-2
我要和大家分享一下iOS 13中
关于搜索的新功能


425
00:21:25,152 --> 00:21:27,221 line:-1
这并不是新搜索 这是当前的搜索…


426
00:21:27,855 --> 00:21:30,224 line:-1
Mail app中的搜索界面


427
00:21:31,024 --> 00:21:32,993 line:-1
它使用的是UIKit


428
00:21:33,460 --> 00:21:37,731 line:-2
特别是UIViewController的子类
UISearchController


429
00:21:38,765 --> 00:21:40,667 line:-1
我们所有用户都很熟悉它


430
00:21:41,768 --> 00:21:43,470 line:-1
在你的app中也可用


431
00:21:44,137 --> 00:21:46,306 line:-1
它由许多部分组成


432
00:21:47,674 --> 00:21:49,810 line:-2
最大的一部分是
UISearchBar


433
00:21:50,210 --> 00:21:51,912 line:-1
你可以在这里看到 在屏幕顶部


434
00:21:53,413 --> 00:21:55,349 line:-1
搜索栏有很多组件


435
00:21:55,716 --> 00:21:59,019 line:-2
包括取消按钮
以及我们叫做范围栏的东西


436
00:21:59,086 --> 00:22:01,388 line:-1
就是在搜索字段下方的按钮行


437
00:22:03,323 --> 00:22:08,161 line:-1
现在你可能注意到了范围栏


438
00:22:08,228 --> 00:22:09,363 line:-1
在iOS 13中更新了视觉外观


439
00:22:11,932 --> 00:22:17,371 line:-2
但现在我们允许app
隐藏搜索栏的元素


440
00:22:17,804 --> 00:22:20,140 line:-2
即使它由UISearchController
进行管理


441
00:22:21,041 --> 00:22:24,745 line:-2
因此如果你的app
不需要范围栏或取消按钮


442
00:22:25,112 --> 00:22:26,513 line:-1
但你希望它们可用


443
00:22:26,847 --> 00:22:28,649 line:-1
也许取决于UI状态


444
00:22:29,082 --> 00:22:32,886 line:-2
你可以通过UISearchController
上的新属性直接进行控制


445
00:22:35,122 --> 00:22:36,056 line:-1
同时…


446
00:22:37,024 --> 00:22:41,228 line:-2
在UISearchBar上把
SearchTextField作为公共属性进行暴露


447
00:22:41,995 --> 00:22:44,097 line:-1
意思是自定义非常简单


448
00:22:54,208 --> 00:22:56,376 line:-2
那么要自定义
SearchController的外观


449
00:22:58,145 --> 00:23:00,881 line:-2
请在UISearchController上
把这些属性设为假


450
00:23:01,515 --> 00:23:03,851 line:-2
并在UISearchBar上
使用现有属性


451
00:23:03,917 --> 00:23:05,886 line:-1
从而控制取消按钮


452
00:23:06,253 --> 00:23:07,421 line:-1
和范围栏是否可见


453
00:23:08,689 --> 00:23:11,024 line:-1
使用searchTextField属性


454
00:23:11,458 --> 00:23:14,828 line:-2
以引用
UISearchTextField实例


455
00:23:15,395 --> 00:23:17,965 line:-1
并修改文本字段上


456
00:23:18,031 --> 00:23:18,999 line:-1
你想要修改的所有属性


457
00:23:19,266 --> 00:23:20,968 line:-1
它是UITextField的子类


458
00:23:21,034 --> 00:23:23,070 line:-1
你可以在那儿使用所有的样式属性


459
00:23:27,708 --> 00:23:30,711 line:-1
UI搜索控制器行为也扩展到了外观


460
00:23:30,777 --> 00:23:32,179 line:-1
和清除搜索


461
00:23:32,779 --> 00:23:33,914 line:-1
因此标准行为…


462
00:23:34,882 --> 00:23:36,483 line:-1
是当你通过轻触它的搜索字段


463
00:23:36,850 --> 00:23:38,218 line:-1
而激活搜索栏时


464
00:23:39,319 --> 00:23:40,988 line:-1
它会升到屏幕顶部


465
00:23:41,855 --> 00:23:44,224 line:-1
但之前屏幕上的可见内容


466
00:23:44,858 --> 00:23:45,792 line:-1
仍保持可见


467
00:23:48,028 --> 00:23:50,531 line:-2
当你输入时 在这种情况下
手机app


468
00:23:50,864 --> 00:23:53,734 line:-2
会显示与你的局部搜索项
相匹配的结果


469
00:23:55,669 --> 00:23:58,105 line:-2
这是通过你的app提供的
UIViewController实施的


470
00:23:58,172 --> 00:24:01,408 line:-1
它叫做搜索结果控制器


471
00:24:04,178 --> 00:24:05,712 line:-1
并不是每个app都像这样


472
00:24:06,413 --> 00:24:08,015 line:-1
比如 在Mail app中


473
00:24:08,482 --> 00:24:10,250 line:-1
如果你轻触搜索字段


474
00:24:10,984 --> 00:24:12,853 line:-1
它会提供一份推荐搜索列表


475
00:24:15,689 --> 00:24:18,825 line:-2
它仍然是UISearchController的
搜索结果控制器


476
00:24:19,459 --> 00:24:21,695 line:-1
我们在iOS 13中


477
00:24:21,995 --> 00:24:23,330 line:-1
也增加了这个功能


478
00:24:29,903 --> 00:24:32,606 line:-1
只需要在搜索控制器上


479
00:24:33,073 --> 00:24:35,242 line:-2
把showsSearchResultsController
属性设为真


480
00:24:35,976 --> 00:24:37,744 line:-1
然后你就可以管理自动化行为了


481
00:24:38,045 --> 00:24:40,514 line:-1
自动显示搜索结果控制器属性


482
00:24:43,050 --> 00:24:44,585 line:-1
在搜索中还有另一个大功能


483
00:24:46,920 --> 00:24:49,890 line:-2
在Mail和Photos
以及系统上的其它app中


484
00:24:50,591 --> 00:24:55,128 line:-2
这些推荐搜索 结果…
是一个token


485
00:24:55,896 --> 00:24:57,965 line:-1
是对更复杂的


486
00:24:58,565 --> 00:25:00,234 line:-1
搜索查询的可视化陈述


487
00:25:02,603 --> 00:25:05,205 line:-1
你可以在你的app中使用这个功能


488
00:25:05,506 --> 00:25:07,608 line:-2
在UISearchTextField的
任意实例上


489
00:25:08,408 --> 00:25:10,577 line:-2
通过新
UISearchTokenAPI


490
00:25:11,411 --> 00:25:14,815 line:-2
并且这些token支持
复制、粘贴和拖放


491
00:25:15,382 --> 00:25:18,986 line:-2
这与我们在所有app上
所使用的实施一样


492
00:25:25,526 --> 00:25:28,996 line:-1
比如Photos用它提供所保存的


493
00:25:29,062 --> 00:25:33,500 line:-2
或所预测的针对人、
地点和对象的搜索


494
00:25:34,768 --> 00:25:38,205 line:-2
在SearchResultsController中
轻触任意一条


495
00:25:38,972 --> 00:25:42,543 line:-2
Photos把输入转为token
甚至是部分输入也可以


496
00:25:44,411 --> 00:25:45,546 line:-1
（Token和文本）


497
00:25:45,612 --> 00:25:48,182 line:-1
这是UITextField的子类


498
00:25:48,448 --> 00:25:50,584 line:-1
Token会与文本相互作用


499
00:25:51,385 --> 00:25:54,288 line:-1
事实上 它们总是优先于文本


500
00:25:55,756 --> 00:25:58,692 line:-2
比如 如果我把token
放到搜索字段中


501
00:25:59,159 --> 00:26:01,862 line:-1
即使我的插入点位于搜索字段末端


502
00:26:02,596 --> 00:26:04,031 line:-1
Token也会出现在开端


503
00:26:05,432 --> 00:26:07,534 line:-2
正如你在这里所看到的
token现在已被选中


504
00:26:08,836 --> 00:26:12,306 line:-2
我可以扩展选择
使其既包含token


505
00:26:12,706 --> 00:26:13,707 line:-1
又包含一些文本


506
00:26:15,275 --> 00:26:16,210 line:-1
（创建Token）


507
00:26:16,276 --> 00:26:17,878 line:-1
创建token非常简单


508
00:26:20,080 --> 00:26:22,850 line:-1
首先获取所选中文本的范围


509
00:26:23,116 --> 00:26:25,252 line:-2
以便了解你要把哪些文本
转换为token


510
00:26:26,854 --> 00:26:28,789 line:-2
创建一个
UISearchToken对象


511
00:26:30,157 --> 00:26:32,726 line:-2
并在SearchTextField上
调用这个方法


512
00:26:33,227 --> 00:26:36,430 line:-2
用token替换
那个范围的文本部分


513
00:26:37,731 --> 00:26:40,601 line:-2
你的app可以完全控制
token的插入


514
00:26:40,667 --> 00:26:41,835 line:-1
和移除


515
00:26:42,703 --> 00:26:44,738 line:-2
因此你可以赋予它
你所想要的任何意义


516
00:26:47,608 --> 00:26:52,913 line:-2
UITextField换成了一个
叫做UITextInput的协议


517
00:26:53,981 --> 00:26:55,716 line:-1
如果你正在执行程序性选择


518
00:26:56,283 --> 00:26:59,620 line:-2
了解一下UITextInput
非常重要


519
00:27:00,020 --> 00:27:02,656 line:-1
尤其是范围和位置


520
00:27:03,957 --> 00:27:05,192 line:-1
在常规的文本字段中


521
00:27:05,759 --> 00:27:08,762 line:-2
每个字符都被分配了一个
UITextPosition


522
00:27:09,997 --> 00:27:13,600 line:-2
并且这些位置
与两个非常著名的位置相关


523
00:27:13,667 --> 00:27:16,937 line:-1
文档的开端和末端


524
00:27:17,204 --> 00:27:18,605 line:-1
就是搜索字段的内容


525
00:27:21,008 --> 00:27:24,912 line:-2
你可以用这些位置来创建
UITextRanges


526
00:27:25,379 --> 00:27:29,283 line:-2
比如 程序性地选择
字段内容的一部分


527
00:27:32,052 --> 00:27:33,720 line:-1
因为token是可选择的


528
00:27:34,188 --> 00:27:36,557 line:-2
它们也会获得
UITextPositions


529
00:27:39,092 --> 00:27:41,662 line:-1
但搜索字段的文本长度…


530
00:27:42,629 --> 00:27:44,865 line:-2
现在与从文档开端
到最后一个字符的位置


531
00:27:45,399 --> 00:27:49,036 line:-1
之间的距离不一样了


532
00:27:50,103 --> 00:27:51,205 line:-1
如果这对你有影响


533
00:27:51,572 --> 00:27:54,975 line:-1
比如说 程序性地选择文本的一部分


534
00:27:55,676 --> 00:28:00,013 line:-2
UISearchTextField导出
这个新属性textualRange


535
00:28:01,481 --> 00:28:02,916 line:-1
textualRange的开端


536
00:28:03,283 --> 00:28:06,386 line:-2
是字段中的
第一个nontoken字符


537
00:28:07,120 --> 00:28:08,989 line:-1
并且它的末端是文档的末端


538
00:28:09,723 --> 00:28:13,060 line:-1
这些与文本属性中的字符索引相匹配


539
00:28:15,095 --> 00:28:16,997 line:-1
因此为了在你的app中


540
00:28:17,064 --> 00:28:18,098 line:-1
利用全部这些新功能


541
00:28:18,599 --> 00:28:21,368 line:-1
请了解一下


542
00:28:21,435 --> 00:28:22,836 line:-2
UISearchController上
的新属性和新自定义选项


543
00:28:24,271 --> 00:28:25,739 line:-1
使用UISearchTextField


544
00:28:26,106 --> 00:28:29,243 line:-1
无论是在UISearchBar内


545
00:28:29,309 --> 00:28:30,577 line:-2
或任何可以使用
UITextField的地方


546
00:28:31,378 --> 00:28:33,647 line:-1
并对它进行自定义


547
00:28:33,714 --> 00:28:35,616 line:-2
通过UITextField上
所有可用的自定义选项


548
00:28:37,017 --> 00:28:40,387 line:-2
采用UISearchToken
来表达复杂的查询


549
00:28:40,454 --> 00:28:41,955 line:-1
既简明又可编辑


550
00:28:42,422 --> 00:28:44,958 line:-1
它支持复制、粘贴和拖放


551
00:28:46,560 --> 00:28:48,629 line:-1
通过这个你可以实现许多高级技巧


552
00:28:49,029 --> 00:28:51,298 line:-1
我们很快会在本场演讲的网页上


553
00:28:51,565 --> 00:28:52,833 line:-1
添加一个示例项目


554
00:28:53,166 --> 00:28:55,202 line:-1
阐述如何有效地使用token


555
00:28:59,139 --> 00:29:01,942 line:-2
现在我要把舞台交给James
他会跟大家谈谈手势


556
00:29:09,316 --> 00:29:10,284 line:-1
谢谢Kyle


557
00:29:10,784 --> 00:29:11,685 line:-1
大家好


558
00:29:11,752 --> 00:29:12,719 line:-1
我是James McGaran


559
00:29:13,420 --> 00:29:16,857 line:-2
我今天要在这里跟大家分享
我们在iOS 13中添加的新手势


560
00:29:17,224 --> 00:29:19,626 line:-1
主要是选择、组织


561
00:29:19,693 --> 00:29:21,094 line:-1
以及一些常见的编辑快捷方式


562
00:29:21,161 --> 00:29:22,196 line:-1
（手势）


563
00:29:23,463 --> 00:29:25,232 line:-1
那么这就是我今天要讲的全部内容


564
00:29:25,566 --> 00:29:27,000 line:-1
你每天能听到的最棒的消息是


565
00:29:27,067 --> 00:29:29,269 line:-1
又有许多行为是自动实现的了


566
00:29:29,336 --> 00:29:30,604 line:-1
以及哪些东西可以免费使用


567
00:29:31,138 --> 00:29:33,040 line:-1
但我在这里要讲一些不一样的内容


568
00:29:33,106 --> 00:29:34,174 line:-1
以及你需要如何去做


569
00:29:34,474 --> 00:29:36,777 line:-1
从而充分利用这些新功能


570
00:29:36,844 --> 00:29:37,945 line:-1
在你的app内


571
00:29:38,812 --> 00:29:42,216 line:-2
那么让我们从与自定义文本视图中的
文本选择手势


572
00:29:42,282 --> 00:29:43,617 line:-1
相关的新功能开始讲


573
00:29:45,652 --> 00:29:48,255 line:-2
那么正如你所知道的
目前有许多很棒的方式


574
00:29:48,322 --> 00:29:51,058 line:-1
可以使用手势在iOS上选择文本


575
00:29:51,658 --> 00:29:54,695 line:-2
你可以轻触并按住
那会立即开始突出内容


576
00:29:54,761 --> 00:29:56,096 line:-1
这是iOS 13中的新功能


577
00:29:56,797 --> 00:29:58,765 line:-1
你可以长按来获取选择循环


578
00:29:58,832 --> 00:30:00,300 line:-1
并四处移动插入点


579
00:30:00,868 --> 00:30:02,836 line:-1
并且你可以三次轻触某一段内容


580
00:30:02,903 --> 00:30:04,771 line:-1
然后会立即选中整段内容


581
00:30:06,240 --> 00:30:09,243 line:-2
因此这些手势在本地文本小工具中
用起来得心应手


582
00:30:09,543 --> 00:30:11,778 line:-2
比如UITextView
和UITextField


583
00:30:12,112 --> 00:30:13,113 line:-1
你已经拥有这些了


584
00:30:14,381 --> 00:30:16,617 line:-1
但可能会有一些情况


585
00:30:16,917 --> 00:30:19,052 line:-1
当你需要超出TextView


586
00:30:19,386 --> 00:30:20,754 line:-2
和TextField的
力所能及的范围时


587
00:30:21,255 --> 00:30:22,322 line:-1
有些人需要在app中实施


588
00:30:22,456 --> 00:30:24,925 line:-1
高度自定义的文本绘制


589
00:30:26,193 --> 00:30:27,394 line:-1
那么这里以书为例


590
00:30:27,761 --> 00:30:29,863 line:-1
它使用了完全自定义的文本视图


591
00:30:29,930 --> 00:30:32,766 line:-1
来控制边缘、字符间距等


592
00:30:35,102 --> 00:30:37,804 line:-1
因此 目前为了获得这样的选择行为


593
00:30:38,071 --> 00:30:39,473 line:-1
在自定义文本视图中


594
00:30:39,940 --> 00:30:43,577 line:-2
你必须向app中手动添加
全部系统文本选择手势


595
00:30:43,844 --> 00:30:46,580 line:-2
只是为了拥有
与原生文本小工具同样的功能


596
00:30:47,981 --> 00:30:50,884 line:-2
许多人还不得不针对选择
实施自己的UI


597
00:30:51,251 --> 00:30:53,720 line:-1
比如选择长方形 蓝色的选择长方形


598
00:30:53,787 --> 00:30:55,055 line:-1
或选择控点


599
00:30:55,489 --> 00:30:56,790 line:-1
只是为了提供这种行为


600
00:30:58,525 --> 00:31:00,561 line:-2
因此我要很高兴地宣布
在iOS 13中


601
00:31:01,094 --> 00:31:04,831 line:-2
通过UIInteraction的
一种新类型来更简单地实现


602
00:31:04,898 --> 00:31:06,333 line:-2
它叫做
UITextInteraction


603
00:31:07,768 --> 00:31:09,603 line:-2
那么如果你不熟悉
UIInteractions


604
00:31:09,937 --> 00:31:11,638 line:-1
你可以把它看做是一种压缩方式


605
00:31:11,705 --> 00:31:14,074 line:-1
一个行为和手势的集合


606
00:31:14,408 --> 00:31:15,943 line:-1
与UIKit小工具相关


607
00:31:16,410 --> 00:31:18,545 line:-1
想想拖放互动 跟那个类似


608
00:31:19,713 --> 00:31:21,281 line:-1
它只是三行代码


609
00:31:21,882 --> 00:31:24,785 line:-2
用于向app中
添加所有系统测试选择手势


610
00:31:25,185 --> 00:31:26,920 line:-1
你的用户们已经熟悉那些手势了


611
00:31:27,988 --> 00:31:29,590 line:-1
我们提供的是一组手势


612
00:31:29,923 --> 00:31:32,860 line:-1
针对可编辑和不可编辑的文本交互


613
00:31:34,161 --> 00:31:36,463 line:-2
并且你可以使用
UITextInputProtocol


614
00:31:36,763 --> 00:31:40,434 line:-1
获取更精细的控制 在选择UI之上


615
00:31:40,501 --> 00:31:43,537 line:-1
比如我之前提到过的矩形和控点


616
00:31:46,173 --> 00:31:49,376 line:-2
那么这是
如何在你的自定义文本视图中


617
00:31:49,710 --> 00:31:50,878 line:-2
使用
UITextInteraction


618
00:31:51,612 --> 00:31:53,647 line:-2
那么正如我所说过的
只需要三行代码就能实现


619
00:31:53,714 --> 00:31:54,615 line:-1
不包含评论


620
00:31:55,749 --> 00:31:58,752 line:-2
你使用UITextInteraction 4
创建交互


621
00:31:58,819 --> 00:32:01,188 line:-1
并告诉我们你是否想添加


622
00:32:01,255 --> 00:32:02,689 line:-2
适用于可编辑或不可编辑的
文本字段的手势


623
00:32:04,024 --> 00:32:06,727 line:-1
然后把文本输入属性分配给视图


624
00:32:06,793 --> 00:32:09,062 line:-2
实施
UITextInputProtocol


625
00:32:09,663 --> 00:32:10,631 line:-1
我们把这个独立出来


626
00:32:10,898 --> 00:32:13,133 line:-2
万一你想
在容器视图中应用手势的话


627
00:32:13,200 --> 00:32:14,034 line:-1
比如滚动视图


628
00:32:14,401 --> 00:32:17,037 line:-1
但你希望所有文本选择行为


629
00:32:17,404 --> 00:32:19,239 line:-1
都能由某些内含视图进行处理


630
00:32:19,306 --> 00:32:21,008 line:-1
比如绘制文本的那个视图


631
00:32:22,309 --> 00:32:24,244 line:-1
最后只需要向视图中添加交互即可


632
00:32:24,578 --> 00:32:25,679 line:-1
通过添加交互


633
00:32:27,748 --> 00:32:28,749 line:-1
（表和集合中的多选手势）


634
00:32:29,183 --> 00:32:30,217 line:-1
我们将 请跟我一起—


635
00:32:33,487 --> 00:32:35,189 line:-1
请跟我一起来到舞台的这一侧


636
00:32:35,255 --> 00:32:38,058 line:-1
我们谈一下TableViews


637
00:32:38,125 --> 00:32:39,927 line:-2
和CollectionViews中的
多选手势


638
00:32:42,996 --> 00:32:45,432 line:-2
那么一直以来我们在
UICollectionView


639
00:32:45,799 --> 00:32:47,768 line:-2
和UITableView中
都支持多选模式


640
00:32:48,769 --> 00:32:51,238 line:-2
类似Notes这样的app
有一个选择按钮


641
00:32:51,305 --> 00:32:52,406 line:-1
位于右上角


642
00:32:52,940 --> 00:32:55,742 line:-1
用户可以轻触它进入多选模式


643
00:32:56,210 --> 00:32:59,646 line:-2
然后分别选择每一个注释
一个接一个


644
00:32:59,713 --> 00:33:00,781 line:-1
并把它们集合在一起


645
00:33:01,615 --> 00:33:03,350 line:-1
然后通过拖放


646
00:33:03,417 --> 00:33:05,352 line:-1
或底部的那些操作按钮来组织它们


647
00:33:06,820 --> 00:33:08,455 line:-2
嗯 在iOS 13中
我要很高兴地宣布


648
00:33:08,522 --> 00:33:10,457 line:-1
我们引入了一种全新的方式


649
00:33:10,757 --> 00:33:13,560 line:-1
可以快速选择连续的一批项


650
00:33:13,627 --> 00:33:15,195 line:-1
在集合视图和表视图中


651
00:33:15,996 --> 00:33:18,098 line:-2
那么让我在这个巨型iPad上
给你演示一下


652
00:33:19,032 --> 00:33:21,535 line:-1
那么现在用户可以立即进入


653
00:33:21,935 --> 00:33:23,537 line:-1
多选模式


654
00:33:23,604 --> 00:33:26,373 line:-2
只需要把两根手指
放在某个表或集合视图上的任意位置


655
00:33:26,440 --> 00:33:28,542 line:-1
并平移即可


656
00:33:29,510 --> 00:33:30,777 line:-1
立即开始选择


657
00:33:34,348 --> 00:33:35,382 line:-1
谢谢 非常棒


658
00:33:36,316 --> 00:33:38,118 line:-1
那么在这里你可以看到用两根手指


659
00:33:38,185 --> 00:33:39,887 line:-1
在文件中的列表视图中向下滑动


660
00:33:39,953 --> 00:33:42,523 line:-2
将立即进入编辑模式
并开始选择网格


661
00:33:43,957 --> 00:33:46,426 line:-2
更酷的是这在
UICollectionView


662
00:33:46,493 --> 00:33:48,195 line:-1
流程布局中的网格项来说同样适用


663
00:33:48,629 --> 00:33:50,898 line:-1
因此你的用户可以在网格项之间平移


664
00:33:50,964 --> 00:33:53,700 line:-1
并同时选择一批项


665
00:33:54,501 --> 00:33:56,770 line:-1
这对于拖放来说简直是梦想成真


666
00:33:59,840 --> 00:34:02,743 line:-2
更不用说如果你的用户
拥有附加的硬件键盘了


667
00:34:03,110 --> 00:34:05,379 line:-2
他们还能按住Shift
或Command键


668
00:34:05,445 --> 00:34:06,647 line:-1
以轻触其它项


669
00:34:06,713 --> 00:34:09,081 line:-1
和在macOS上的性能一样


670
00:34:10,851 --> 00:34:11,685 line:-1
谢谢


671
00:34:15,155 --> 00:34:18,091 line:-2
特别是你的iPad app
可以在Mac上运行


672
00:34:18,358 --> 00:34:20,159 line:-1
你的表视图就更如鱼得水了


673
00:34:22,629 --> 00:34:25,632 line:-2
那么这些很棒的新行为
目前都是可选的


674
00:34:26,166 --> 00:34:28,735 line:-2
原因就是因为你的app
可能需要适应


675
00:34:28,802 --> 00:34:32,272 line:-2
有一个不争的事实
就是你的用户打算进入多选模式


676
00:34:33,072 --> 00:34:35,641 line:-1
比如你可能希望修改选择或编辑按钮


677
00:34:35,708 --> 00:34:37,411 line:-1
变成取消或完成


678
00:34:38,178 --> 00:34:39,513 line:-1
你可能想显示操作按钮


679
00:34:39,580 --> 00:34:41,380 line:-1
在屏幕底部


680
00:34:41,648 --> 00:34:43,183 line:-1
通过你的用户所选择的内容


681
00:34:43,750 --> 00:34:47,087 line:-2
或你可能要禁用某些UI
比如本例中的添加不按钮


682
00:34:49,389 --> 00:34:51,925 line:-2
因此为了解决这个问题
我们添加了一些新API


683
00:34:51,992 --> 00:34:53,760 line:-1
帮助你适应这些新行为


684
00:34:54,561 --> 00:34:55,429 line:-1
非常简单


685
00:34:55,495 --> 00:34:57,497 line:-1
只需要实施两个委托方法


686
00:34:58,031 --> 00:35:00,834 line:-1
并且在表视图和集合视图上


687
00:35:00,901 --> 00:35:01,869 line:-1
拥有基本相同的版本


688
00:35:04,037 --> 00:35:05,005 line:-1
就是这些


689
00:35:05,639 --> 00:35:06,740 line:-1
第一个要实施的是


690
00:35:06,807 --> 00:35:10,110 line:-1
是否在索引路径中开始多选交互


691
00:35:10,377 --> 00:35:11,278 line:-1
或者你可以返回真


692
00:35:11,678 --> 00:35:13,480 line:-1
如果你允许手势开始的话


693
00:35:14,181 --> 00:35:15,816 line:-1
这里我们在这里提供了索引路径…


694
00:35:16,250 --> 00:35:18,218 line:-1
如果你想阻止在表视图上


695
00:35:18,285 --> 00:35:19,987 line:-1
不可选择的部分开始选择


696
00:35:20,053 --> 00:35:22,656 line:-1
在那种情况下 你只需要返回假即可


697
00:35:24,858 --> 00:35:25,926 line:-1
要实施的第二个方法是


698
00:35:25,993 --> 00:35:27,995 line:-1
是否在索引路径上


699
00:35:28,061 --> 00:35:29,029 line:-1
开始多选交互


700
00:35:29,363 --> 00:35:31,498 line:-1
你可以调整周围的UI


701
00:35:31,565 --> 00:35:34,101 line:-1
考虑到TableView


702
00:35:34,168 --> 00:35:36,436 line:-1
会自动进入多选模式


703
00:35:36,737 --> 00:35:38,705 line:-2
就像我们刚才在上一张幻灯片中
所讲的那样


704
00:35:42,176 --> 00:35:44,244 line:-1
那么继续 我想谈的最后一件事是


705
00:35:44,311 --> 00:35:46,747 line:-1
简要谈谈我们针对某些使用新手势的


706
00:35:47,014 --> 00:35:49,750 line:-1
常见的编辑任务所进行的一些改进


707
00:35:52,119 --> 00:35:55,322 line:-2
那么在iOS 13中
我们引入了一组标准手势


708
00:35:55,389 --> 00:35:57,524 line:-1
使执行某些编辑任务变得更简单


709
00:35:58,358 --> 00:36:00,494 line:-1
比如使用三根手指


710
00:36:00,561 --> 00:36:02,729 line:-1
用户可以滑动并返回到撤销


711
00:36:03,764 --> 00:36:05,332 line:-1
然后反向滑动到恢复


712
00:36:08,235 --> 00:36:10,571 line:-1
缩合三根手指可以复制…


713
00:36:11,905 --> 00:36:13,874 line:-1
然后捏合三根手指可以粘贴


714
00:36:18,111 --> 00:36:21,215 line:-2
那么我们向系统中引入了
这组标准手势


715
00:36:21,281 --> 00:36:24,484 line:-1
因此你就不需要担心


716
00:36:24,551 --> 00:36:25,886 line:-1
对这些常见的编辑命令实施UI了


717
00:36:26,520 --> 00:36:28,322 line:-1
它在整个系统中都是统一的


718
00:36:28,755 --> 00:36:32,025 line:-2
因此你的用户可以在你的app中
立即发现这些手势


719
00:36:32,092 --> 00:36:33,527 line:-1
并且他们会立即熟悉起来


720
00:36:34,194 --> 00:36:35,762 line:-1
这对于绘画app来说非常棒


721
00:36:35,829 --> 00:36:38,632 line:-2
因为你不需要显示
任何浮动的面板或工具栏


722
00:36:38,699 --> 00:36:40,000 line:-1
来实现这一行为


723
00:36:40,634 --> 00:36:42,736 line:-1
最棒的是它完全免费


724
00:36:43,036 --> 00:36:46,206 line:-2
如果你已经拥有撤销管理器
或NS撤销管理器的话


725
00:36:48,041 --> 00:36:51,044 line:-2
那么在这里我呼吁大家在app中
尝试这些新手势


726
00:36:51,411 --> 00:36:53,247 line:-1
如果有机会的话


727
00:36:53,313 --> 00:36:54,848 line:-1
要确保它们用起来很棒


728
00:36:56,083 --> 00:36:57,084 line:-1
但以防万一


729
00:36:57,384 --> 00:36:58,752 line:-1
我知道有些人很紧张


730
00:36:59,186 --> 00:37:02,556 line:-1
因此为了防止它们与你app内


731
00:37:02,623 --> 00:37:03,924 line:-1
可能存在的其它三指手势相冲突


732
00:37:04,491 --> 00:37:07,194 line:-2
我们通过一些新API
提供了一个安全舱


733
00:37:07,928 --> 00:37:12,533 line:-2
只是一个简单的属性 你需要覆盖
在UIResponder上


734
00:37:12,599 --> 00:37:14,501 line:-2
它叫做
EditingInteractionConfiguration


735
00:37:14,935 --> 00:37:16,170 line:-1
你可以返回无


736
00:37:16,236 --> 00:37:18,005 line:-1
如果你想添加这些手势的话


737
00:37:19,439 --> 00:37:21,942 line:-1
那么这就是我今天要讲的要点


738
00:37:22,476 --> 00:37:25,779 line:-1
最后要在你的自定义文本小工具中


739
00:37:26,313 --> 00:37:27,648 line:-1
提供全系统的标准文本选择手势


740
00:37:28,081 --> 00:37:31,585 line:-2
改变用户在你的app中
组织信息的方式


741
00:37:31,952 --> 00:37:33,587 line:-1
使用多选手势


742
00:37:33,654 --> 00:37:34,922 line:-1
我真的希望你们能采用它


743
00:37:36,356 --> 00:37:38,825 line:-2
最后请允许你的用户
停止摇晃他们的iPad


744
00:37:39,193 --> 00:37:40,594 line:-1
并控制撤销堆栈


745
00:37:41,161 --> 00:37:42,563 line:-1
通过一组标准手势


746
00:37:45,699 --> 00:37:46,667 line:-1
是的 的确很痛苦


747
00:37:48,602 --> 00:37:50,537 line:-2
谢谢大家 现在我要把舞台
交给Mohammed


748
00:37:50,604 --> 00:37:51,605 line:-1
他会跟大家谈谈菜单


749
00:37:52,072 --> 00:37:58,178 line:-1
（菜单）


750
00:37:58,245 --> 00:37:59,413 line:-1
好的 谢谢James


751
00:38:01,114 --> 00:38:02,549 line:-1
大家好 我是Mohammed


752
00:38:02,816 --> 00:38:05,986 line:-1
我非常激动 我要跟大家谈谈


753
00:38:06,053 --> 00:38:07,988 line:-2
我们在iOS 13中
引入的一些强大的新API


754
00:38:08,455 --> 00:38:11,892 line:-1
可以让你呈现流动性的交互菜单


755
00:38:11,959 --> 00:38:13,727 line:-1
并带有丰富的预览


756
00:38:16,163 --> 00:38:19,666 line:-2
第一个API是
UIContextMenuInteraction


757
00:38:21,935 --> 00:38:23,871 line:-1
UIContextMenuInteraction


758
00:38:23,937 --> 00:38:25,372 line:-1
是一个UIInteraction


759
00:38:25,806 --> 00:38:28,275 line:-1
可以让你呈现带有丰富预览


760
00:38:28,675 --> 00:38:30,110 line:-1
和复杂等级的菜单


761
00:38:31,078 --> 00:38:33,480 line:-1
这些等级可以拥有嵌套的子菜单


762
00:38:33,780 --> 00:38:34,948 line:-1
和内嵌节段


763
00:38:35,282 --> 00:38:36,617 line:-1
我们稍后再解释


764
00:38:38,752 --> 00:38:41,755 line:-1
由中心操作呈现的菜单高度自适应


765
00:38:42,389 --> 00:38:45,259 line:-1
意思是它会根据它所呈现的情境


766
00:38:45,325 --> 00:38:46,360 line:-1
选择呈现


767
00:38:47,227 --> 00:38:49,730 line:-2
在这里我们看到
在竖屏的iPhone上


768
00:38:49,796 --> 00:38:51,798 line:-1
预览和操作


769
00:38:51,865 --> 00:38:53,867 line:-1
像是一个垂直地堆叠在另一个之上


770
00:38:56,203 --> 00:38:57,371 line:0
在横屏的iPhone上


771
00:38:57,437 --> 00:38:59,840 line:0
预览和操作是一个挨一个


772
00:38:59,907 --> 00:39:02,176 line:0
目的是为了更好地利用可用空间


773
00:39:04,912 --> 00:39:07,614 line:-2
并且在iPad上
它重新进行了自我配置


774
00:39:07,681 --> 00:39:11,518 line:-2
根据可用空间
以及预览和操作列表的尺寸


775
00:39:14,221 --> 00:39:16,490 line:-1
由于这是一个跨平台API


776
00:39:16,557 --> 00:39:18,725 line:-1
如果你的app在Mac上运行


777
00:39:19,326 --> 00:39:22,062 line:-2
它会变成一种
熟悉的macOS情境菜单


778
00:39:25,966 --> 00:39:28,602 line:-1
交互提供了一种一致的体验…


779
00:39:29,269 --> 00:39:34,041 line:-2
通过呈现菜单
在整个iOS中使用同样的手势


780
00:39:35,142 --> 00:39:37,544 line:-1
因此用户会期待这个手势


781
00:39:38,078 --> 00:39:40,214 line:-1
能在系统中的任何地方唤出菜单


782
00:39:41,982 --> 00:39:44,985 line:-1
手势将适应设备的性能


783
00:39:45,586 --> 00:39:47,454 line:-1
因此 在支持3D触摸的手机上


784
00:39:47,921 --> 00:39:50,224 line:-1
我们将使用3D触摸迅速唤出菜单


785
00:39:50,557 --> 00:39:51,758 line:-1
并提供一些很好的反馈


786
00:39:53,560 --> 00:39:55,429 line:-1
在不支持3D触摸的手机上


787
00:39:55,495 --> 00:39:56,530 line:-1
我们将使用触觉触摸


788
00:39:56,997 --> 00:39:59,433 line:-2
我们将保留那种很棒的反馈
无论何时当菜单弹出时


789
00:40:00,901 --> 00:40:03,370 line:-2
在其它iOS设备上
我们将使用长按


790
00:40:04,304 --> 00:40:07,541 line:-2
并且在Mac上
将会是用户的第二个点击设置


791
00:40:07,608 --> 00:40:09,910 line:-1
因此 右击或命令点击…


792
00:40:10,244 --> 00:40:11,979 line:-1
或两指轻触


793
00:40:16,016 --> 00:40:17,818 line:-1
交互与其它系统行为自动整合


794
00:40:17,885 --> 00:40:20,654 line:-1
比如拖放


795
00:40:21,555 --> 00:40:24,324 line:-2
因此如果你已经在app中
采用了UIDragInteraction


796
00:40:24,825 --> 00:40:28,529 line:-2
并且选择采用
UIContextMenuInteraction


797
00:40:29,596 --> 00:40:32,799 line:-1
用户可以在任意点转换为拖拽


798
00:40:33,934 --> 00:40:37,905 line:-2
因此在这里我们看到
只要达到拖拽的初始阈值


799
00:40:38,505 --> 00:40:42,843 line:-2
你就可以移动手指
把图片拖拽到文件app中


800
00:40:44,745 --> 00:40:46,747 line:-1
然而 如果你再等一会儿


801
00:40:46,813 --> 00:40:48,148 line:-1
直到菜单呈现出来


802
00:40:48,749 --> 00:40:52,019 line:-1
你仍然可以流畅地转换到拖拽模式


803
00:40:52,386 --> 00:40:54,488 line:-1
而不需要把手指从屏幕上移开


804
00:40:55,622 --> 00:40:58,458 line:-2
因此用户就会拥有这种
流畅的连续性体验


805
00:41:02,462 --> 00:41:04,965 line:-1
今天要讲的API的第二部分


806
00:41:05,032 --> 00:41:07,167 line:-1
是UIMenu和UIAction


807
00:41:08,869 --> 00:41:11,805 line:-2
UIMenu和
UIAction是一个…


808
00:41:12,206 --> 00:41:14,474 line:-1
等级菜单构建系统


809
00:41:15,442 --> 00:41:19,079 line:-1
允许我们定义并描述菜单等级


810
00:41:19,146 --> 00:41:20,480 line:-1
就是我们想要显示的菜单


811
00:41:22,482 --> 00:41:24,151 line:-1
UIMenus是可编辑的


812
00:41:24,218 --> 00:41:27,087 line:-2
它们就像积木一样
我们可以把它们组合在一起


813
00:41:27,154 --> 00:41:30,324 line:-2
放到不同的配置中
用于描述不同的菜单等级


814
00:41:33,527 --> 00:41:37,731 line:-2
这里有个简单的例子
我创建了一个拥有两个操作的菜单


815
00:41:38,098 --> 00:41:39,633 line:-1
通过创建UIMenu


816
00:41:40,167 --> 00:41:42,503 line:-2
并把它传给
UIAction 的子集实现


817
00:41:43,036 --> 00:41:45,038 line:-1
一个分享操作和一个删除操作


818
00:41:47,007 --> 00:41:49,409 line:-1
如果我想向菜单中添加更多功能


819
00:41:49,476 --> 00:41:50,811 line:-1
通过比如说添加子菜单


820
00:41:51,445 --> 00:41:54,781 line:-2
我所需要做的就是
创建另一个UIMenu


821
00:41:55,516 --> 00:41:59,119 line:-2
给它一些描述性标题
让它显示在等级中的前一个层级


822
00:41:59,453 --> 00:42:02,489 line:-1
并给它传递相应的子集


823
00:42:02,556 --> 00:42:05,726 line:-2
那么在这里我已经选择
包含复制和重复操作


824
00:42:09,329 --> 00:42:11,865 line:-2
因此当我们呈现它时
菜单看起来就像这样


825
00:42:12,599 --> 00:42:15,602 line:-1
顶部有一个分享操作


826
00:42:16,436 --> 00:42:19,940 line:-1
中间有子菜单的编辑操作


827
00:42:20,507 --> 00:42:22,843 line:-1
底部有删除操作


828
00:42:25,078 --> 00:42:26,280 line:-1
当用户轻触编辑时


829
00:42:26,580 --> 00:42:27,781 line:-1
会呈现我们的子菜单


830
00:42:27,848 --> 00:42:30,083 line:-1
然后填充我们的复制和重复操作


831
00:42:33,587 --> 00:42:36,023 line:-2
在你的app中采用交互
非常简单直接


832
00:42:37,291 --> 00:42:40,360 line:-2
如果你已经在app中
采用了其它UIInteractions


833
00:42:40,427 --> 00:42:43,063 line:-1
比如UIDragInteraction


834
00:42:43,130 --> 00:42:44,865 line:-2
或我们今年引入的某些
TextInteractions


835
00:42:44,932 --> 00:42:46,834 line:-1
你一定会非常熟悉这种模式


836
00:42:47,835 --> 00:42:48,869 line:-1
我们需要做的第一件事


837
00:42:48,936 --> 00:42:53,373 line:-2
就是创建UIContextMenuInteraction
用某个对象作为它的委托


838
00:42:53,907 --> 00:42:55,843 line:-1
那么比如说 这是我们的视图控制器


839
00:42:57,177 --> 00:42:59,413 line:-1
然后我们需要把它附加到某个视图上


840
00:42:59,479 --> 00:43:01,715 line:-2
通过UIView的
addInteraction方法


841
00:43:04,418 --> 00:43:06,253 line:-1
一旦这样做了 我们就需要遵守


842
00:43:06,320 --> 00:43:08,021 line:-1
交互的委托协议


843
00:43:09,556 --> 00:43:11,692 line:-1
协议有一个必需方法


844
00:43:11,992 --> 00:43:14,728 line:-1
当交互即将开始时调用


845
00:43:15,896 --> 00:43:19,399 line:-2
然后就交给app吧
要么返回一个配置


846
00:43:19,466 --> 00:43:22,236 line:-1
开始交互 要么返回空


847
00:43:22,636 --> 00:43:26,306 line:-2
表明当前位置
没有任何可以呈现的菜单


848
00:43:30,577 --> 00:43:33,080 line:-2
配置对象是
我们要如何描述我们的菜单


849
00:43:34,248 --> 00:43:36,517 line:-1
它有一个标识符


850
00:43:36,950 --> 00:43:38,118 line:-1
标识符是可选的


851
00:43:38,185 --> 00:43:40,954 line:-1
你可以用于识别…


852
00:43:41,421 --> 00:43:43,824 line:-1
交互 在它的整个周期中


853
00:43:44,758 --> 00:43:47,761 line:-2
通过你可能获得的各种
委托回调函数


854
00:43:49,663 --> 00:43:52,900 line:-2
它还有previewProvider
和actionProvider闭包


855
00:43:53,767 --> 00:43:56,904 line:-1
当即将呈现菜单时会调用它们


856
00:43:57,471 --> 00:44:00,407 line:-2
这会降低我们要在实际创建菜单
和预览过程中


857
00:44:00,474 --> 00:44:02,809 line:-1
所需要付出的潜在的昂贵的代价


858
00:44:03,076 --> 00:44:04,311 line:-1
除非真的需要它们


859
00:44:06,647 --> 00:44:08,482 line:-1
那么在我们刚才看过的示例中


860
00:44:08,549 --> 00:44:11,285 line:-1
菜单没有那个巨大的丰富的预览


861
00:44:11,351 --> 00:44:12,753 line:-1
它只有一些操作


862
00:44:13,287 --> 00:44:16,390 line:-1
因此我们可以主要关注


863
00:44:16,456 --> 00:44:18,225 line:-2
如何在委托方法的实施中
创建actionProvider


864
00:44:21,562 --> 00:44:23,330 line:-2
那么当调用
actionProvider时


865
00:44:24,331 --> 00:44:28,135 line:-2
它有一个推荐操作列表
是系统传给它的


866
00:44:29,903 --> 00:44:33,373 line:-2
可能既有UIMenus
又有UIActions


867
00:44:33,440 --> 00:44:35,976 line:-1
可能是一个构造完整的等级


868
00:44:36,343 --> 00:44:38,145 line:-1
是从系统中选出来的


869
00:44:38,679 --> 00:44:41,448 line:-1
这些可能是你在响应链中定义的东西


870
00:44:41,515 --> 00:44:45,385 line:-2
使用iOS 13中
新引入的UI命令API


871
00:44:46,053 --> 00:44:48,755 line:-1
或由其它系统组件所提供的东西


872
00:44:51,692 --> 00:44:53,193 line:-2
那么我们在这里做了一个
完全自定义的菜单


873
00:44:53,260 --> 00:44:55,329 line:-1
让我们把推荐操作放在旁边


874
00:44:56,797 --> 00:44:58,765 line:-1
首先我们要创建我们的编辑菜单


875
00:44:59,032 --> 00:45:00,501 line:-1
我们只需要创建一个UIMenu


876
00:45:01,068 --> 00:45:02,169 line:-1
标题是Edit


877
00:45:02,603 --> 00:45:05,539 line:-2
并且我们要给它传递
我们希望它拥有的两个子集


878
00:45:05,606 --> 00:45:07,808 line:-2
一个标题是Copy的
UIAction


879
00:45:08,075 --> 00:45:09,843 line:-2
以及一个标题是Duplicate
的UIAction


880
00:45:13,247 --> 00:45:15,849 line:-1
然后我们要定义我们的根菜单


881
00:45:16,884 --> 00:45:20,587 line:-2
通常来说
根目录有没有标题没有意义


882
00:45:20,854 --> 00:45:22,055 line:-1
因此我们可以跳过


883
00:45:22,856 --> 00:45:24,825 line:-2
然而如果你真心希望
给它传递一个标题


884
00:45:24,892 --> 00:45:27,528 line:-1
它将在操作列表上方作为页眉显示


885
00:45:29,730 --> 00:45:31,999 line:-2
在这里我们把三个子集传给它
一个分享操作


886
00:45:32,966 --> 00:45:34,401 line:-1
我们刚刚创建的编辑按钮


887
00:45:34,801 --> 00:45:37,671 line:-2
最后是一个
拥有毁灭性样式的删除操作


888
00:45:37,971 --> 00:45:41,942 line:-2
从而让用户了解
这个操作会导致毁灭性后果


889
00:45:44,478 --> 00:45:47,948 line:-2
最后我们创建了一个
带有某些标识符的配置


890
00:45:48,282 --> 00:45:49,683 line:-1
并把我们的操作提供器传给它


891
00:45:51,084 --> 00:45:52,019 line:-1
就是这样


892
00:45:52,085 --> 00:45:55,556 line:-2
这就是要使用
UIContextMenuInteraction


893
00:45:55,622 --> 00:45:57,691 line:-1
创建和显示菜单所要做的所有操作


894
00:46:00,794 --> 00:46:02,095 line:-1
但还要再花点儿时间


895
00:46:03,564 --> 00:46:06,900 line:-1
我们可以利用交互委托


896
00:46:07,367 --> 00:46:09,069 line:-1
所提供的某些动画自定义API


897
00:46:09,536 --> 00:46:12,573 line:-1
来创建一些非常棒、高度抛光的动画


898
00:46:12,973 --> 00:46:14,975 line:-2
那真的能向我们的用户们
表达我们的意思


899
00:46:18,278 --> 00:46:19,446 line:-1
那么在这个例子中


900
00:46:19,713 --> 00:46:21,648 line:-1
我用了我们刚才用过的同一个菜单


901
00:46:22,149 --> 00:46:26,453 line:-1
并且我用了源呈现自定义API


902
00:46:26,854 --> 00:46:29,990 line:-1
从而在网格的图标中显示菜单


903
00:46:30,057 --> 00:46:32,726 line:-1
而不是在整个网格中


904
00:46:33,360 --> 00:46:36,496 line:-1
并且我甚至自定义了背景颜色


905
00:46:36,763 --> 00:46:39,266 line:-1
甚至为预览做了一个很漂亮的圆形


906
00:46:41,635 --> 00:46:45,439 line:-2
这些自定义API是
在UITargetedPreview上创建的


907
00:46:45,806 --> 00:46:49,409 line:-2
这是在iOS 13中
引入的新API


908
00:46:50,077 --> 00:46:51,912 line:-2
现在如果你已经采用了
UIDragInteraction


909
00:46:51,979 --> 00:46:53,213 line:-1
和UIDropInteraction


910
00:46:53,280 --> 00:46:56,416 line:-2
并且你在app中创建了一些
自定义拖放预览


911
00:46:56,884 --> 00:46:58,318 line:-1
那么你很可能会觉得很熟悉这个


912
00:46:59,353 --> 00:47:01,922 line:-2
我们实质上是把
UITargetedDragPreview通用化


913
00:47:01,989 --> 00:47:04,992 line:-1
使其成为一个更通用的API


914
00:47:05,058 --> 00:47:06,827 line:-1
可以在其它交互中使用


915
00:47:08,295 --> 00:47:11,999 line:-2
UITargetedDragPreview现在是
UITargetedPreview的子类


916
00:47:12,399 --> 00:47:15,969 line:-2
因此如果你已经拥有了
有意义的拖拽预览


917
00:47:16,303 --> 00:47:17,771 line:-1
那对你的菜单来说就有意义


918
00:47:17,838 --> 00:47:20,040 line:-1
因为会从同一个项中触发它们


919
00:47:20,541 --> 00:47:23,143 line:-2
然后你可以重新使用那段代码
而不需要做任何额外的工作


920
00:47:27,514 --> 00:47:30,083 line:-2
为了让你在app中
更简单地采用这个


921
00:47:30,150 --> 00:47:33,320 line:-2
为了让你在某些最常见的情况中
更简单地唤出菜单


922
00:47:33,754 --> 00:47:37,191 line:-2
我们还针对UICollectionView
和UITableView


923
00:47:37,257 --> 00:47:38,392 line:-1
引入了一些便利的API


924
00:47:39,459 --> 00:47:42,162 line:-1
从app中唤出菜单


925
00:47:42,596 --> 00:47:46,834 line:-2
从你的app所运行的全部平台上的
表视图中唤出菜单


926
00:47:46,900 --> 00:47:49,603 line:-2
你所需要做的全部工作就是
在它的委托上实施一个提炼函数


927
00:47:50,571 --> 00:47:52,973 line:-1
在这里你会再一次返回一个配置


928
00:47:53,040 --> 00:47:54,208 line:-1
如果你有要显示的菜单的话


929
00:47:54,708 --> 00:47:57,711 line:-1
或返回空 表示没有要显示的东西


930
00:47:59,813 --> 00:48:01,949 line:-1
那么除此之外 这些便利的API


931
00:48:02,015 --> 00:48:04,284 line:-1
给你提供了一些默认的抛光动画


932
00:48:04,718 --> 00:48:07,788 line:-1
从表或集合视图网格中呈现菜单


933
00:48:07,855 --> 00:48:09,656 line:-1
然后在遣散时再返回给它们


934
00:48:10,224 --> 00:48:12,759 line:-1
但是我们还提供同样的自定义呈现


935
00:48:12,826 --> 00:48:13,927 line:-1
和遣散钩子


936
00:48:13,994 --> 00:48:16,630 line:-1
因此你可以创建你自己的自定义外观


937
00:48:17,231 --> 00:48:18,732 line:-1
和遣散动画


938
00:48:21,401 --> 00:48:22,803 line:-1
现在你很可能正在思考说


939
00:48:22,870 --> 00:48:25,706 line:-1
这听起来有点儿像预览和跳转


940
00:48:26,640 --> 00:48:30,010 line:-1
嗯…我们也注意到了


941
00:48:32,546 --> 00:48:36,383 line:-2
然而 因为这个新API
提供一个更大的功能集


942
00:48:36,450 --> 00:48:38,252 line:-1
并且可以在多个平台上使用


943
00:48:39,086 --> 00:48:42,890 line:-2
我们在iOS 13中忽略了
UIViewController预览


944
00:48:43,690 --> 00:48:46,460 line:-1
因此请你们替换预览和跳转的实施


945
00:48:46,527 --> 00:48:48,328 line:-1
通过UIContextMenuInteraction


946
00:48:48,962 --> 00:48:51,331 line:-1
并为用户提供一种连续性体验…


947
00:48:52,432 --> 00:48:54,234 line:-1
在所有设备上


948
00:48:57,137 --> 00:49:00,641 line:-2
你可能还想考虑
替换所有长按驱动的菜单


949
00:49:00,707 --> 00:49:05,679 line:-2
通过这个新交互
从而利用新的功能集


950
00:49:07,281 --> 00:49:10,517 line:-1
并且如果你当前有菜单


951
00:49:10,584 --> 00:49:12,119 line:-1
与拖拽同时显示


952
00:49:12,519 --> 00:49:14,688 line:-1
这是一个很棒的流动性方案


953
00:49:15,055 --> 00:49:16,857 line:-1
拥有协调一致的手势


954
00:49:16,924 --> 00:49:19,159 line:-1
和完全整合的体验


955
00:49:19,526 --> 00:49:22,362 line:-2
你的用户一定会期待
在iOS 13中使用


956
00:49:25,065 --> 00:49:28,402 line:-2
好的 那么现在你已经了解了
这么多新知识


957
00:49:28,468 --> 00:49:31,038 line:-2
你应该动手把你的app准备好
在iOS 13中使用


958
00:49:31,605 --> 00:49:33,140 line:-1
确保它们为未来做好了准备


959
00:49:33,207 --> 00:49:34,441 line:-1
通过把它们变得有灵活性


960
00:49:35,108 --> 00:49:38,445 line:-1
利用新的栏外观和呈现API


961
00:49:38,512 --> 00:49:41,381 line:-1
给你的app一个抛光的现代化外观


962
00:49:41,448 --> 00:49:42,816 line:-1
用户们一定会非常期待


963
00:49:43,851 --> 00:49:46,854 line:-2
着手创建你们一直以来
都想创建的搜索体验


964
00:49:47,187 --> 00:49:49,056 line:-1
使用很棒的新搜索API


965
00:49:49,690 --> 00:49:51,825 line:-1
并为你的app做一些很棒的功能


966
00:49:52,192 --> 00:49:54,661 line:-1
通过新手势和情境菜单


967
00:49:56,897 --> 00:49:58,665 line:-1
如果你对这些话题有任何疑问


968
00:49:58,999 --> 00:50:01,468 line:-1
或有任何与UIKit相关的疑问


969
00:50:01,835 --> 00:50:03,437 line:-1
请参加我们明天的讨论会


970
00:50:03,804 --> 00:50:05,506 line:-1
要获取关于演讲的附加信息


971
00:50:05,839 --> 00:50:08,008 line:-1
请查看演讲网页


972
00:50:08,976 --> 00:50:11,278 line:-2
谢谢大家的参与 祝大家在会议期间
度过一段愉快的时光

