1
00:00:06,039 --> 00:00:09,910 line:0
（App内购买项目
及使用服务器到服务器通知）


2
00:00:10,377 --> 00:00:11,211 line:-1
早上好！


3
00:00:14,615 --> 00:00:18,519 line:-2
欢迎参加App内购买项目
及使用服务器到服务器通知演讲


4
00:00:18,852 --> 00:00:22,055 line:-2
我是Dana DuBois
我是App Store技术部经理


5
00:00:24,057 --> 00:00:25,726 line:-1
我们今天要谈很多内容


6
00:00:26,126 --> 00:00:29,930 line:-2
首先从StoreKit的新功能
开始谈起


7
00:00:30,330 --> 00:00:32,366 line:-2
自去年的演讲起
我们又进行了哪些变更呢？


8
00:00:33,600 --> 00:00:35,536 line:-2
然后我要把舞台交给
我的同事Tori


9
00:00:35,602 --> 00:00:37,638 line:-1
她将跟大家具体介绍


10
00:00:37,704 --> 00:00:39,940 line:-1
服务器到服务器通知


11
00:00:40,007 --> 00:00:43,544 line:-1
以及如何确保你在后台


12
00:00:43,610 --> 00:00:47,080 line:-1
拥有订阅客户的最新信息？


13
00:00:49,149 --> 00:00:52,386 line:-2
接着Manjeet会上台介绍
一些不一样的内容


14
00:00:52,452 --> 00:00:54,288 line:-1
即订阅周期中的计费事件


15
00:00:55,322 --> 00:00:56,156 line:-1
最后


16
00:00:56,590 --> 00:00:58,358 line:-1
他会跟大家介绍


17
00:00:58,425 --> 00:01:00,060 line:-1
如何减少无意识流失


18
00:01:00,127 --> 00:01:03,497 line:-1
并把订阅客户留在你的服务中


19
00:01:05,432 --> 00:01:06,266 line:-1
那么首先


20
00:01:07,668 --> 00:01:08,769 line:-1
StoreKit中有哪些新功能？


21
00:01:10,270 --> 00:01:13,073 line:-1
嗯 今年春季我们引入了订阅优惠


22
00:01:14,541 --> 00:01:18,078 line:-1
订阅优惠是我们引入的一个新功能


23
00:01:19,246 --> 00:01:23,450 line:-2
为你提供了一个工具
让你保留现有订阅者


24
00:01:23,750 --> 00:01:27,921 line:-1
以及重获曾使用过此服务的订阅者


25
00:01:29,056 --> 00:01:30,357 line:-1
你可以通过给每个订阅


26
00:01:31,124 --> 00:01:36,663 line:-1
设置最多十个不同的激活的优惠实现


27
00:01:36,730 --> 00:01:39,833 line:-1
那将会打折或免费获得服务


28
00:01:39,900 --> 00:01:41,635 line:-1
你可以提供给你的客户们


29
00:01:43,370 --> 00:01:46,340 line:-2
你的app要决定
要呈现什么以及给谁呈现


30
00:01:46,707 --> 00:01:47,975 line:-1
完全由你做主


31
00:01:48,709 --> 00:01:51,178 line:-2
这是一个很棒的功能
也是一个很大的功能


32
00:01:51,245 --> 00:01:54,114 line:-2
实际上今天稍后会有一场
专门的演讲


33
00:01:54,181 --> 00:01:55,516 line:-1
就在这里 下午两点


34
00:01:56,016 --> 00:02:00,621 line:-2
如果你的服务中有订阅功能
我强烈建议你们参加那场演讲


35
00:02:02,122 --> 00:02:03,123 line:-1
（SKStoreFront）


36
00:02:03,190 --> 00:02:04,925 line:-2
StoreKit中还有哪些
新功能？嗯…


37
00:02:05,459 --> 00:02:09,162 line:-2
今年夏季我们要宣布
引入了SKStorefront


38
00:02:09,863 --> 00:02:14,668 line:-2
SKStorefront是我们
展示给你们开发人员的一个商店


39
00:02:15,035 --> 00:02:18,105 line:-2
用户会在这里设置
他们的App Store


40
00:02:21,175 --> 00:02:25,112 line:-1
从而向客户呈现正确的内容


41
00:02:25,179 --> 00:02:27,881 line:-1
你想向全世界的客户们推销什么？


42
00:02:27,948 --> 00:02:32,519 line:-2
你可以用SKStorefront
针对某个客户


43
00:02:32,586 --> 00:02:34,588 line:-1
在他们的设备上获取特定的范围


44
00:02:35,856 --> 00:02:39,459 line:-2
这与App Store内容的
呈现方式一样


45
00:02:39,526 --> 00:02:44,965 line:-2
并且这个API为你提供的是当前
设定了App Store的商店


46
00:02:46,667 --> 00:02:47,634 line:-1
有一件事你要记住


47
00:02:47,701 --> 00:02:53,574 line:-2
就是这个API会为那个商店
返回一个特定设备的缓存值


48
00:02:53,974 --> 00:02:55,409 line:-1
并且它可以随时间发生变更


49
00:02:55,475 --> 00:02:57,444 line:-1
因此你需要思考一些东西


50
00:02:57,511 --> 00:02:59,813 line:-2
当你与
SKStorefront连接时


51
00:03:00,380 --> 00:03:03,016 line:-2
那么让我们打开代码
看看这些是如何运作的


52
00:03:06,119 --> 00:03:08,689 line:-1
如果你现正在连接StoreKit


53
00:03:08,755 --> 00:03:11,925 line:-2
SKPaymentQueue上
已经有委托了


54
00:03:12,593 --> 00:03:15,696 line:-1
我们给那个增加了一个功能


55
00:03:16,196 --> 00:03:20,033 line:-2
即给商店获取一个
返回当前缓存值的参数


56
00:03:20,100 --> 00:03:22,603 line:-2
即.storefront
它将为你提供那个值


57
00:03:23,504 --> 00:03:25,839 line:-2
因为它会发生变更
也因为它是特定设备上的


58
00:03:25,906 --> 00:03:28,976 line:-1
它可以是空值 虽然不太可能


59
00:03:29,042 --> 00:03:31,011 line:-1
那么你需要在你的app中检查一下


60
00:03:31,078 --> 00:03:32,646 line:-1
并确保没问题


61
00:03:34,548 --> 00:03:38,952 line:-2
一旦你拥有那个商店
就在API上 是一个国家代码


62
00:03:39,019 --> 00:03:43,323 line:-1
它是三个字母的代码 ISO标准值


63
00:03:43,390 --> 00:03:44,758 line:-1
适用于全世界的地区及国家


64
00:03:44,825 --> 00:03:47,461 line:-1
并且那将准确地告诉你


65
00:03:47,528 --> 00:03:48,562 line:-2
那台设备上的App Store
被设定为哪里


66
00:03:49,129 --> 00:03:50,097 line:-1
这是真的


67
00:03:50,163 --> 00:03:53,000 line:-1
然后那将允许你获取国家代码


68
00:03:53,066 --> 00:03:56,703 line:-1
并向客户们推销正确的内容


69
00:03:57,237 --> 00:03:59,406 line:-2
但正如我所说过的
它可以随时间发生变更


70
00:03:59,706 --> 00:04:01,508 line:-1
那么让我们再深入查看代码


71
00:04:01,575 --> 00:04:03,110 line:-1
了解你还需要思考什么东西


72
00:04:05,846 --> 00:04:07,681 line:-1
在这里我们有一段示例代码


73
00:04:07,748 --> 00:04:10,784 line:-2
在这里你会获取
从后台取出的产品标识符


74
00:04:11,118 --> 00:04:13,787 line:-1
把它传进来


75
00:04:13,854 --> 00:04:17,791 line:-1
然后尝试决定是否应该取出元数据


76
00:04:18,058 --> 00:04:19,793 line:-1
执行一个SKProduct请求


77
00:04:19,860 --> 00:04:22,362 line:-1
以决定是否应该显示那个内容


78
00:04:22,896 --> 00:04:23,730 line:-1
那么…


79
00:04:23,997 --> 00:04:29,102 line:-2
开发人员所要做的就是
从后台取出那个元数据


80
00:04:29,703 --> 00:04:34,641 line:-2
并执行一个调用
嘿 这个商店对那个代码有效吗？


81
00:04:35,142 --> 00:04:38,178 line:-2
然后你可以在这里看到
在你取出产品信息之前


82
00:04:38,245 --> 00:04:40,080 line:-1
你要调用shouldShow


83
00:04:40,147 --> 00:04:41,381 line:-1
如果它返回真


84
00:04:42,149 --> 00:04:44,585 line:-1
把那个标识符添加到


85
00:04:44,651 --> 00:04:46,787 line:-2
你即将做出SKProduct
请求的项的列表上


86
00:04:47,154 --> 00:04:49,857 line:-2
你应该在执行SKProduct
请求之前做这一步


87
00:04:49,923 --> 00:04:52,626 line:-1
因为如果你不推销那个产品


88
00:04:52,693 --> 00:04:57,197 line:-1
那么不提取产品元数据会更有效率


89
00:05:00,133 --> 00:05:02,436 line:-2
但正如我刚说过的那样
它会随时间发生变更


90
00:05:02,503 --> 00:05:05,305 line:-1
实际上用户可以切换账户


91
00:05:05,372 --> 00:05:08,141 line:-1
或甚至可能会在同一个账户内


92
00:05:08,208 --> 00:05:10,844 line:-2
进入App Store
并浏览不同的商店


93
00:05:10,911 --> 00:05:12,513 line:-1
开发人员们总是会这样做


94
00:05:12,846 --> 00:05:16,517 line:-2
因为他们真的想了解世界不同地区中
他们的app分别是什么样子


95
00:05:16,583 --> 00:05:18,151 line:-2
了解它看起来是什么样子
了解它用起来怎么样


96
00:05:18,218 --> 00:05:19,953 line:-2
在App Store中
有一种方法可以实现


97
00:05:20,020 --> 00:05:22,489 line:-1
因此我们向确保你在运行的app中


98
00:05:22,556 --> 00:05:23,757 line:-1
拥有最新的信息


99
00:05:23,824 --> 00:05:30,163 line:-2
因此在SKPayment
交易观察器上我们添加了一个


100
00:05:30,230 --> 00:05:32,699 line:-2
新的paymentQueueDidChange事件
你可以直接在你的app内监测


101
00:05:33,300 --> 00:05:34,835 line:-1
它会传入付款队列


102
00:05:35,202 --> 00:05:37,271 line:-2
当你得到它之后 进入
queue.storefront


103
00:05:37,337 --> 00:05:39,706 line:-1
并获得一个新值 关于那是哪个商店


104
00:05:40,073 --> 00:05:40,908 line:-1
然后再一次…


105
00:05:41,508 --> 00:05:42,342 line:-1
它是一个新商店


106
00:05:42,409 --> 00:05:44,344 line:-1
那么你想重新加载


107
00:05:45,245 --> 00:05:46,647 line:-1
特定于那个新商店的全部内容


108
00:05:46,713 --> 00:05:48,282 line:-1
实际上你可能拥有不同的内容


109
00:05:48,348 --> 00:05:51,285 line:-1
你想根据用户所在的位置进行推销


110
00:05:54,488 --> 00:05:55,989 line:-2
那么再一次调用
shouldShow


111
00:05:56,056 --> 00:05:59,593 line:-1
决定你是否应该为它提取产品信息


112
00:06:00,661 --> 00:06:03,597 line:-2
那么当你正在执行购买时
会发生什么呢？


113
00:06:04,398 --> 00:06:07,935 line:-1
你推销了一些内容 用户即将购买它


114
00:06:08,202 --> 00:06:09,536 line:-1
然后通常一切都很顺利


115
00:06:09,603 --> 00:06:12,306 line:-1
但是如果用户实际上在一个


116
00:06:12,372 --> 00:06:13,740 line:-2
与他们的设备所设定的地区
不一样的商店中


117
00:06:13,807 --> 00:06:18,178 line:-1
付款队列可能会改变商店


118
00:06:18,245 --> 00:06:19,546 line:-1
在交易中间


119
00:06:20,280 --> 00:06:22,416 line:-2
那么我们为你提供了一个
paymentQueue委托


120
00:06:22,749 --> 00:06:25,485 line:-2
它可以让你监测
paymentQueue:


121
00:06:25,853 --> 00:06:27,988 line:-2
shouldContinue:
in newStorefront


122
00:06:28,355 --> 00:06:30,123 line:-1
这是你进行复查的机会


123
00:06:30,624 --> 00:06:33,560 line:-2
我是否应该允许这次购买
在这个新商店中发生？


124
00:06:33,961 --> 00:06:36,864 line:-2
再一次使用那个
同样的shouldShow功能


125
00:06:36,930 --> 00:06:39,633 line:-1
在那里你监测了全部产品标识符


126
00:06:39,700 --> 00:06:42,870 line:-2
并且你明白那些产品
在哪些地区内可用


127
00:06:43,537 --> 00:06:46,640 line:-1
如果它返回真 就允许付款继续


128
00:06:47,407 --> 00:06:50,310 line:-1
为了确保实现最佳用户体验


129
00:06:51,078 --> 00:06:55,115 line:-2
我们希望它的返回速度要快
因此你不应该执行服务器端调用


130
00:06:55,182 --> 00:06:58,252 line:-2
在paymentQueue:
shouldContinue: newStorefront中间


131
00:06:58,685 --> 00:07:01,288 line:-1
你应该把这个信息缓存到你的设备上


132
00:07:01,355 --> 00:07:05,592 line:-2
地区内可用的产品
当付款发生时可以随时获取


133
00:07:05,659 --> 00:07:09,796 line:-2
那样你可以很快地返回
用户就可以继续他们的购买了


134
00:07:09,863 --> 00:07:11,798 line:-1
或者如果你返回否


135
00:07:11,865 --> 00:07:16,303 line:-2
实际上你可以通知用户
为什么在新商店中购买无效


136
00:07:17,337 --> 00:07:20,807 line:-2
那么正如我所说过的
也许产品在新地区内不可用


137
00:07:22,142 --> 00:07:23,076 line:-1
那么你该怎么做呢？


138
00:07:23,377 --> 00:07:25,045 line:-1
嗯 如果发生这种情况


139
00:07:25,112 --> 00:07:28,282 line:-2
在你的paymentQueue:
updatedTransactions委托调用中


140
00:07:28,749 --> 00:07:32,219 line:-2
我们将返回一个
SKStoreProductNotAvailable报错


141
00:07:32,553 --> 00:07:35,289 line:-1
它会通知你说你刚刚告诉我们


142
00:07:35,355 --> 00:07:38,292 line:-2
你不应该允许此交易
发生在那个新商店中


143
00:07:38,358 --> 00:07:41,161 line:-1
并且在这里你有机会呈现一个对话框


144
00:07:41,495 --> 00:07:42,329 line:-1
或者…


145
00:07:42,696 --> 00:07:44,364 line:-1
推销一些其它


146
00:07:44,431 --> 00:07:46,400 line:-1
可能与新商店中的内容相等值的内容


147
00:07:46,767 --> 00:07:48,936 line:-1
显示一个警告 更新UI


148
00:07:49,002 --> 00:07:50,771 line:-1
做一些此时此刻你需要做的操作


149
00:07:52,739 --> 00:07:54,541 line:-2
那么这就是
SKStorefront


150
00:07:55,008 --> 00:07:56,376 line:-1
（App预定）


151
00:07:56,443 --> 00:07:57,711 line:-1
我们还引入了什么新功能？


152
00:07:58,278 --> 00:07:59,112 line:-1
嗯…


153
00:08:01,048 --> 00:08:06,887 line:-2
在iOS 11/11.2以及tvOS 11.2
和macOS 10.13.2中


154
00:08:06,954 --> 00:08:08,789 line:-1
我们引入了app预定


155
00:08:10,224 --> 00:08:13,660 line:-2
这是一个所有开发人员都会使用的
很棒的功能 你知道的


156
00:08:13,727 --> 00:08:14,628 line:-1
世界各地


157
00:08:14,695 --> 00:08:18,065 line:-2
以便在app在商店内上线之前
吸引用户对他们的app的兴趣


158
00:08:18,732 --> 00:08:19,666 line:-1
我们要很激动地宣布


159
00:08:19,733 --> 00:08:22,636 line:-2
今年我们引入了
watchOS 6.0


160
00:08:22,703 --> 00:08:25,439 line:-2
因此你可以直接在Watch中
销售你的app


161
00:08:25,506 --> 00:08:27,040 line:-1
并提前引起用户们的兴趣


162
00:08:27,107 --> 00:08:30,077 line:-1
比如可以让他们进行预订


163
00:08:30,811 --> 00:08:32,980 line:-1
但我们今年还做了另一件事


164
00:08:33,380 --> 00:08:34,248 line:-1
即将发布


165
00:08:34,313 --> 00:08:37,083 line:-1
我们将在app收据内暗示


166
00:08:37,618 --> 00:08:40,254 line:-1
app是否是作为预订所进行的购买


167
00:08:40,320 --> 00:08:45,259 line:-1
因此你会了解哪些客户预订了app


168
00:08:45,592 --> 00:08:46,927 line:-1
并且你可以用于…


169
00:08:48,562 --> 00:08:51,398 line:-2
给他们发送很棒的信息
比如感谢他们预订我的app


170
00:08:51,465 --> 00:08:53,767 line:-1
或者如果你想解锁一些附加内容


171
00:08:53,834 --> 00:08:56,036 line:-1
作为对某些最佳客户的回馈


172
00:08:56,103 --> 00:08:58,772 line:-1
你也可以使用收据中的那个信息


173
00:08:59,039 --> 00:09:04,378 line:-2
还有一件关于收据的信息 即它将
可以返回到iOS 11/12


174
00:09:04,444 --> 00:09:06,480 line:-1
时光倒流 收据中都可以使用此功能


175
00:09:09,583 --> 00:09:12,319 line:-1
那么这些是自去年演讲以来


176
00:09:12,386 --> 00:09:14,454 line:-2
关于StoreKit和
App内购买项目相关的信息


177
00:09:15,022 --> 00:09:17,858 line:-2
接下来我要把舞台
交给我的同事Tori


178
00:09:17,925 --> 00:09:20,794 line:-2
她将为大家谈谈
服务器到服务器通知的相关内容


179
00:09:21,395 --> 00:09:22,229 line:-1
Tori？


180
00:09:22,296 --> 00:09:27,568 line:-1
（服务器到服务器通知）


181
00:09:30,737 --> 00:09:31,572 line:-1
大家好


182
00:09:31,638 --> 00:09:34,474 line:-2
我叫Tori 今天能来到这里
我感到万分激动


183
00:09:34,541 --> 00:09:37,110 line:-1
我要跟大家分享服务器到服务器通知


184
00:09:38,145 --> 00:09:39,346 line:-1
我们有一些新功能


185
00:09:39,413 --> 00:09:42,149 line:-1
我们想引入服务器到服务器通知中


186
00:09:42,216 --> 00:09:45,519 line:-2
并且我想做一次深入的沟通
关于你要如何使用这些


187
00:09:45,586 --> 00:09:48,155 line:-1
来有效地监控你的订阅事件


188
00:09:48,589 --> 00:09:50,858 line:-1
但在此之前


189
00:09:50,924 --> 00:09:51,992 line:-1
首先让我们来看看


190
00:09:52,059 --> 00:09:54,528 line:-1
什么是服务器到服务器通知


191
00:09:54,595 --> 00:09:57,331 line:-1
以及如何设置服务器来接收这些通知


192
00:09:58,532 --> 00:10:00,834 line:-1
（什么是服务器到服务器通知？）


193
00:10:01,635 --> 00:10:05,205 line:-1
那么服务器到服务器通知


194
00:10:05,272 --> 00:10:09,042 line:-2
是我们通过JSON串从服务器
发送的HTTP POST请求


195
00:10:09,510 --> 00:10:11,812 line:-1
你可以通过它们的曾用名识别它们


196
00:10:11,879 --> 00:10:13,814 line:-1
statusUpdateNotifications


197
00:10:14,314 --> 00:10:17,651 line:-1
服务器到服务器通知对于


198
00:10:17,718 --> 00:10:20,721 line:-2
在你的订阅事件上
获取当前更新来说非常有用


199
00:10:20,988 --> 00:10:25,526 line:-1
用于重获客户 比如订阅优惠


200
00:10:26,460 --> 00:10:28,028 line:-1
一旦你决定了你想在那个终端


201
00:10:28,095 --> 00:10:31,064 line:-1
接收服务器到服务器通知


202
00:10:31,131 --> 00:10:34,301 line:-2
你所要做的就是从那个终端
返回一个200响应


203
00:10:34,368 --> 00:10:38,472 line:-1
表明已成功接收信息


204
00:10:39,139 --> 00:10:42,509 line:-1
然而如果你不返回200响应


205
00:10:42,576 --> 00:10:46,947 line:-2
我们将最多重试三次
重新给你发送通知


206
00:10:48,815 --> 00:10:50,784 line:-1
一旦你已经确定了这个终端


207
00:10:50,851 --> 00:10:53,220 line:-2
你首先要在App Store
连接中把它设置好


208
00:10:53,587 --> 00:10:56,757 line:-2
你可以在你app的app信息页上
找到这个地方


209
00:10:57,024 --> 00:10:59,660 line:-1
在订阅状态URL部分


210
00:10:59,726 --> 00:11:01,895 line:-1
（设置你的终端）


211
00:11:03,096 --> 00:11:06,099 line:-2
除了在App Store
连接中设置终端


212
00:11:06,166 --> 00:11:10,237 line:-1
当然还有连接必须遵从的安全性要求


213
00:11:10,304 --> 00:11:13,473 line:-1
便于你成功地接收这些通知


214
00:11:13,807 --> 00:11:16,043 line:-1
基本上 总的来说就是


215
00:11:16,109 --> 00:11:18,579 line:-1
连接必须遵守app传输安全条款


216
00:11:18,645 --> 00:11:21,014 line:-1
或ATS


217
00:11:21,515 --> 00:11:22,983 line:-1
它意味着很多事


218
00:11:23,550 --> 00:11:27,921 line:-2
首先必须由一个受信任的认证机构
颁发证书


219
00:11:27,988 --> 00:11:29,156 line:-1
（设置服务器）


220
00:11:29,223 --> 00:11:34,661 line:-2
Transport Layer Securit版本
或TLS版本必须是TLS 1.2


221
00:11:35,529 --> 00:11:38,365 line:-2
你必须使用
所提供的对称密码算法中的一种


222
00:11:38,866 --> 00:11:41,702 line:-1
并且证书必须通过


223
00:11:41,768 --> 00:11:45,372 line:-2
SHA-256及以上的算法
来签署和颁发


224
00:11:46,573 --> 00:11:48,141 line:-1
我希望通过全部这些信息


225
00:11:48,208 --> 00:11:49,309 line:-1
你会更好地理解


226
00:11:49,376 --> 00:11:51,778 line:-1
什么是服务器到服务器通知


227
00:11:51,845 --> 00:11:53,280 line:-1
以及如何设置它们


228
00:11:53,947 --> 00:11:55,349 line:-1
如果要了解更多信息


229
00:11:55,415 --> 00:11:58,919 line:-1
请在developer.apple.com上


230
00:11:58,986 --> 00:12:00,954 line:-2
查询statusUpdateNotifications
相关的文档


231
00:12:05,125 --> 00:12:08,362 line:-2
现在我们已经了解了
什么是服务器到服务器通知


232
00:12:08,428 --> 00:12:09,763 line:-1
以及如何接收它们


233
00:12:09,830 --> 00:12:12,399 line:-1
现在我要很激动地分享一些


234
00:12:12,466 --> 00:12:14,101 line:-1
我们引入到服务器到服务器通知中的


235
00:12:14,168 --> 00:12:16,770 line:-1
新功能和新通知类型


236
00:12:17,504 --> 00:12:19,740 line:-1
那么当我们考虑


237
00:12:19,806 --> 00:12:21,642 line:-1
要添加到通知中的一些新功能时


238
00:12:21,708 --> 00:12:23,911 line:-1
我们查看了一下


239
00:12:23,977 --> 00:12:25,479 line:-1
当前通知中的收据字段


240
00:12:25,846 --> 00:12:28,148 line:-1
最新收据和最新收据信息


241
00:12:28,749 --> 00:12:31,518 line:-1
我们注意到这些收据 虽然有用


242
00:12:31,585 --> 00:12:35,088 line:-1
但仅提供了app内最新购买的信息


243
00:12:35,389 --> 00:12:38,158 line:-1
因此我们就思考如何让它变的更有用


244
00:12:38,225 --> 00:12:40,827 line:-1
如果我们可以提供完整的订阅历史


245
00:12:40,894 --> 00:12:43,697 line:-2
当我们给你发送
服务器到服务器通知时


246
00:12:44,231 --> 00:12:47,401 line:-1
为此 我们对服务器到服务器通知


247
00:12:47,467 --> 00:12:49,369 line:-1
引入了统一收据


248
00:12:52,639 --> 00:12:56,677 line:-1
（统一收据）


249
00:12:56,743 --> 00:12:59,746 line:-1
那么回顾一下 统一收据包含


250
00:12:59,813 --> 00:13:02,282 line:-1
从订阅服务中进行订阅购买的历史


251
00:13:02,649 --> 00:13:05,719 line:-1
以前 这个非常有价值的信息


252
00:13:05,786 --> 00:13:08,422 line:-2
只能通过点击
verifyReceipt获取


253
00:13:09,356 --> 00:13:11,892 line:-1
目前通知中的两个收据字段


254
00:13:11,959 --> 00:13:14,228 line:-1
最新收据和最新收据信息


255
00:13:14,294 --> 00:13:17,064 line:-1
提供一个加密和解密交易型收据


256
00:13:17,130 --> 00:13:18,799 line:-1
关于app内的最新购买


257
00:13:19,233 --> 00:13:20,200 line:-1
从秋季开始


258
00:13:20,267 --> 00:13:23,937 line:-2
你将会在服务器到服务器通知中
看到一个新字段


259
00:13:24,605 --> 00:13:27,441 line:-1
我们决定把它叫做统一收据


260
00:13:27,508 --> 00:13:29,343 line:-1
它将包含几乎全部


261
00:13:29,409 --> 00:13:31,678 line:-1
你期待从统一收据中获取的一切信息


262
00:13:33,947 --> 00:13:37,518 line:-2
通过在服务器到服务器通知中
添加统一收据


263
00:13:37,584 --> 00:13:38,519 line:-1
在大多数情况下


264
00:13:38,585 --> 00:13:42,456 line:-2
这将使最新收据和最新收据信息
变得不再需要


265
00:13:43,857 --> 00:13:47,895 line:-2
然而有一个重要警告
我们必须在这里声明


266
00:13:48,395 --> 00:13:50,364 line:-1
我们为你生成的这个收据


267
00:13:50,430 --> 00:13:54,735 line:-1
并没有绑定设备上安装的特定app


268
00:13:54,801 --> 00:13:56,904 line:-1
就和你平时


269
00:13:56,970 --> 00:13:58,205 line:-1
购买之后收到的收据一样


270
00:13:58,739 --> 00:14:02,743 line:-2
为此 收据应该要一直保存在
你的服务器上


271
00:14:02,809 --> 00:14:05,379 line:-1
永远不要保存在本地设备上


272
00:14:05,445 --> 00:14:07,080 line:-2
（未绑定app的特定安装
应该一直保存在服务器上）


273
00:14:08,348 --> 00:14:09,416 line:-1
那么 把它放在一边


274
00:14:09,483 --> 00:14:11,518 line:-1
让我们看看你可以从


275
00:14:11,585 --> 00:14:14,688 line:-2
服务器到服务器通知中的统一收据中
获得哪些信息？


276
00:14:15,422 --> 00:14:18,759 line:-2
你从这个JSON对象中
发现的第一个字段是最新收据


277
00:14:19,159 --> 00:14:22,796 line:-2
这是一个加密统一收据
是我们刚刚为你生成的


278
00:14:22,863 --> 00:14:25,966 line:-1
稍后你可以用它点击验证收据


279
00:14:26,033 --> 00:14:27,000 line:-1
如果你需要的话


280
00:14:27,868 --> 00:14:30,103 line:-1
你还将发现最新收据信息


281
00:14:30,671 --> 00:14:34,474 line:-2
它包含针对你的订阅服务
所做出的订阅购买的数组


282
00:14:34,541 --> 00:14:36,009 line:-1
其中含有与之相关的元数据


283
00:14:36,076 --> 00:14:38,679 line:-2
用于帮助你追踪你的订阅者身上
发生了什么


284
00:14:38,745 --> 00:14:39,646 line:-1
（统一收据）


285
00:14:39,713 --> 00:14:41,849 line:-1
你还将发现待决续订信息


286
00:14:42,115 --> 00:14:43,517 line:-1
它包含


287
00:14:43,584 --> 00:14:46,086 line:-1
针对你的订阅的即将到来的续订信息


288
00:14:46,153 --> 00:14:48,922 line:-1
比如客户是否处于价格上涨的流程中


289
00:14:48,989 --> 00:14:51,091 line:-1
或者他们是否进入了计费重试周期


290
00:14:51,892 --> 00:14:54,161 line:-1
我们还将包含收据状态


291
00:14:54,228 --> 00:14:56,396 line:-1
以及收据所生成的环境


292
00:14:56,463 --> 00:14:58,465 line:-1
要么是沙盒 要么是生成


293
00:14:59,433 --> 00:15:01,235 line:-1
我们选择以此方式命名字段


294
00:15:01,301 --> 00:15:04,438 line:-2
因为这反映了你可以从验证收据中
接收哪些信息


295
00:15:04,771 --> 00:15:07,641 line:-2
希望你可以在那里
重新使用你的解析逻辑


296
00:15:07,708 --> 00:15:10,377 line:-1
从而让交易变得更简单


297
00:15:11,712 --> 00:15:12,546 line:-1
然而…


298
00:15:12,980 --> 00:15:17,751 line:-2
最新收据信息将仅限于
最新的100个App内购买项目


299
00:15:17,818 --> 00:15:20,053 line:-1
那么如果你需要更多信息


300
00:15:20,120 --> 00:15:24,157 line:-2
你可以通过所提供的加密收据
点击验证收据


301
00:15:25,459 --> 00:15:28,095 line:-1
让我们看看当前有哪些通知类型


302
00:15:28,462 --> 00:15:30,797 line:-1
目前有四种现有的通知类型


303
00:15:30,864 --> 00:15:33,133 line:-1
初次购买 交互式续订


304
00:15:33,200 --> 00:15:35,903 line:-1
变更续订偏好以及取消


305
00:15:35,969 --> 00:15:37,538 line:-1
我们又增加了四个


306
00:15:38,405 --> 00:15:42,743 line:0
变更续订状态 续订失败 追回


307
00:15:43,043 --> 00:15:44,511 line:0
以及涨价同意


308
00:15:52,252 --> 00:15:53,387 line:-1
现在让我们快速看看


309
00:15:53,453 --> 00:15:55,289 line:-1
每一个新通知类型


310
00:15:55,355 --> 00:15:57,791 line:-1
以便我们了解为什么要发送它们


311
00:15:59,059 --> 00:16:01,862 line:-1
首先让我们看看变更续订状态


312
00:16:01,929 --> 00:16:05,365 line:-1
当用户变更是否自动续订时发送


313
00:16:05,799 --> 00:16:08,402 line:-1
实际上你应该立即收到这个通知


314
00:16:08,468 --> 00:16:09,803 line:-1
从而确保你正在查找它


315
00:16:09,870 --> 00:16:12,539 line:-2
如果你目前正在使用我们的
服务器到服务器通知的话


316
00:16:12,606 --> 00:16:13,507 line:-1
（新通知类型）


317
00:16:13,574 --> 00:16:16,844 line:-2
我们即将添加一个
叫做续订失败的通知类型


318
00:16:17,144 --> 00:16:20,247 line:-1
当用户在订阅周期中


319
00:16:20,314 --> 00:16:23,050 line:-1
首次尝试续订而自动续订失败时发送


320
00:16:23,984 --> 00:16:26,486 line:-1
你将在秋季看到这个通知


321
00:16:28,322 --> 00:16:31,225 line:-1
和续订失败一起添加的还有追回


322
00:16:31,692 --> 00:16:32,926 line:-1
当我们在账单重新发送周期中


323
00:16:32,993 --> 00:16:35,629 line:-1
追回订阅计费时


324
00:16:35,696 --> 00:16:37,464 line:-1
发送追回通知


325
00:16:37,898 --> 00:16:40,200 line:-1
这也将在秋季上线


326
00:16:40,601 --> 00:16:42,336 line:-1
如果你收到了追回通知


327
00:16:42,402 --> 00:16:45,038 line:-1
你最近一定收到过续订失败通知


328
00:16:45,105 --> 00:16:47,508 line:-1
并且你可以了解订阅计费


329
00:16:47,574 --> 00:16:48,942 line:-1
已被成功追回


330
00:16:49,676 --> 00:16:52,779 line:-2
如果你当前使用了我们的
服务器到服务器通知


331
00:16:52,846 --> 00:16:55,282 line:-1
你可能注意到我们将发送追回通知


332
00:16:55,349 --> 00:16:58,318 line:-1
当我们当前发送续订通知类型时


333
00:16:59,753 --> 00:17:02,923 line:-2
我们计划让追回通知最终取代
续订通知


334
00:17:02,990 --> 00:17:04,858 line:-1
因为它的命名更恰当


335
00:17:05,192 --> 00:17:07,493 line:-2
但在过渡阶段
当我们发送追回通知时


336
00:17:07,560 --> 00:17:10,531 line:-1
我们会同时发送追回和续订通知


337
00:17:10,597 --> 00:17:12,598 line:-1
给你一点适应时间


338
00:17:14,734 --> 00:17:17,337 line:-1
最后 我们添加了第四个通知类型


339
00:17:17,404 --> 00:17:18,739 line:-1
涨价同意


340
00:17:19,205 --> 00:17:21,441 line:-1
当我们检测到你的某个订阅者


341
00:17:21,508 --> 00:17:23,877 line:-1
已经进入涨价流程时


342
00:17:23,944 --> 00:17:27,347 line:-2
给你发送涨价同意
那需要他们的同意


343
00:17:27,414 --> 00:17:30,017 line:-1
以便他们能继续续订


344
00:17:30,717 --> 00:17:34,188 line:-2
针对这个通知 我们在JSON
payload中添加了一个新字段


345
00:17:34,254 --> 00:17:35,956 line:-1
涨价有效日期


346
00:17:36,390 --> 00:17:40,127 line:-1
这是客户必须同意涨价的日期


347
00:17:40,194 --> 00:17:41,929 line:-1
以便他们可以继续续订


348
00:17:42,429 --> 00:17:45,098 line:-1
你也会在秋季看到这个通知


349
00:17:49,636 --> 00:17:51,038 line:-1
那么现在我们已经了解了


350
00:17:51,104 --> 00:17:53,907 line:-1
服务器到服务器通知中的新功能


351
00:17:54,174 --> 00:17:55,642 line:-1
我要很激动地跟大家分享


352
00:17:55,709 --> 00:17:58,612 line:-1
如何处理全部八个通知类型


353
00:17:58,879 --> 00:18:01,481 line:-1
从而最大限度地利用每一种通知


354
00:18:01,548 --> 00:18:02,516 line:-1
当你收到它时


355
00:18:02,583 --> 00:18:03,517 line:-1
（处理通知）


356
00:18:03,584 --> 00:18:08,288 line:-2
那么首先 让我们快速回顾一下
我们现有的通知类型


357
00:18:08,622 --> 00:18:11,124 line:-1
初次购买 交互式续订


358
00:18:11,191 --> 00:18:13,460 line:-1
（现有通知类型概览）


359
00:18:13,527 --> 00:18:16,096 line:-1
变更续订偏好以及取消


360
00:18:17,064 --> 00:18:17,998 line:-1
我们要花点儿时间


361
00:18:18,065 --> 00:18:21,235 line:-1
深入了解每一种通知类型


362
00:18:21,301 --> 00:18:22,536 line:-1
但在此之前


363
00:18:22,603 --> 00:18:27,307 line:-2
我想让你注意一下
这个图表上的一个趋势


364
00:18:27,774 --> 00:18:30,544 line:-2
你会注意到
在JSON payload中


365
00:18:30,611 --> 00:18:33,380 line:-1
我们要求你针对每一种通知类型


366
00:18:33,447 --> 00:18:35,082 line:-1
查找原始交易id


367
00:18:35,649 --> 00:18:38,018 line:-1
这是因为原始交易id


368
00:18:38,085 --> 00:18:41,321 line:-1
被看作是订阅的唯一标识符


369
00:18:41,388 --> 00:18:45,158 line:-2
并且持续追踪这个信息
会帮助你把随后事件链接回


370
00:18:45,225 --> 00:18:47,628 line:-1
订阅的初始购买


371
00:18:49,563 --> 00:18:52,766 line:-2
现在让我们想象一下
如果你有一个潜在订阅者


372
00:18:53,066 --> 00:18:54,201 line:-1
让我们叫他John


373
00:18:54,268 --> 00:18:57,104 line:-1
并且他有兴趣购买你的订阅服务


374
00:18:57,738 --> 00:18:59,506 line:-1
让我们具体操作一下


375
00:18:59,573 --> 00:19:01,975 line:-1
John关于订阅所做出的决定


376
00:19:02,042 --> 00:19:04,845 line:-1
以及在此过程中你会收到哪些通知


377
00:19:05,946 --> 00:19:08,782 line:-1
（当前通知类型概览）


378
00:19:08,849 --> 00:19:09,816 line:-1
（首次购买订阅）


379
00:19:09,883 --> 00:19:12,553 line:-1
那么你期待收到的第一个通知类型


380
00:19:12,619 --> 00:19:14,588 line:-1
是首次购买


381
00:19:15,155 --> 00:19:17,457 line:-1
当John首次购买订阅服务时


382
00:19:17,524 --> 00:19:19,626 line:-1
我们会给你发送初次购买通知


383
00:19:20,027 --> 00:19:24,865 line:-2
收到这个通知之后
你可以在你的服务器上


384
00:19:24,932 --> 00:19:28,001 line:-2
把客户状态更新为
比如“活跃”或“已订阅”


385
00:19:28,068 --> 00:19:30,604 line:-1
并为新购买的订阅提供服务


386
00:19:31,271 --> 00:19:34,174 line:-1
在这个通知类型中


387
00:19:34,241 --> 00:19:36,543 line:-2
让你在JSON payload中
查找四个字段


388
00:19:37,277 --> 00:19:39,213 line:-1
第一个是购买日期


389
00:19:39,680 --> 00:19:41,548 line:-1
它可以精确到毫秒


390
00:19:41,615 --> 00:19:43,750 line:-1
它会告诉你


391
00:19:43,817 --> 00:19:46,186 line:-1
客户购买订阅服务的具体日期和时间


392
00:19:46,954 --> 00:19:49,723 line:-1
接下来你应该查找原始交易id


393
00:19:49,790 --> 00:19:50,657 line:-1
正如我所提到的那样


394
00:19:50,724 --> 00:19:53,727 line:-1
这是订阅服务的唯一标识符


395
00:19:53,794 --> 00:19:55,262 line:-1
持续追踪它


396
00:19:55,329 --> 00:19:58,966 line:-2
会让你把随后的通知
链接回这个初次购买


397
00:20:00,434 --> 00:20:03,437 line:-1
你还应该查找网络订单行排列项id


398
00:20:03,704 --> 00:20:07,708 line:-1
这是每个订阅周期的唯一标识符


399
00:20:07,774 --> 00:20:11,545 line:-2
并且如果你在收到这个通知后
点击验证收据


400
00:20:11,612 --> 00:20:15,716 line:-2
它将把这个通知链接到
verifyReceipt数组中的某个条目


401
00:20:16,884 --> 00:20:19,520 line:-1
最后你应该查找产品id


402
00:20:19,920 --> 00:20:22,055 line:-1
产品id会准确地告诉你


403
00:20:22,122 --> 00:20:25,192 line:-1
你的新客户订阅了哪个产品


404
00:20:26,827 --> 00:20:29,863 line:-2
因此在John使用订阅服务
一段时间之后


405
00:20:29,930 --> 00:20:33,267 line:-1
他决定把服务升级到一个更高的等级


406
00:20:33,934 --> 00:20:36,403 line:-1
我们提前考虑到了这种续订


407
00:20:36,470 --> 00:20:39,673 line:-2
因此我们会给你发送一个
交互式续订通知类型


408
00:20:39,740 --> 00:20:40,974 line:-1
（潜在的续订）


409
00:20:41,041 --> 00:20:42,276 line:-1
因为升级…


410
00:20:43,043 --> 00:20:46,747 line:-1
会立即为客户提供更高等级的权限


411
00:20:46,813 --> 00:20:49,416 line:-2
我们还将针对
已取消的较低等级的订阅


412
00:20:49,483 --> 00:20:52,352 line:-1
给你发送一个取消通知类型


413
00:20:53,086 --> 00:20:56,456 line:-2
然而 如果客户在流失了一段时间后
又重新订阅


414
00:20:56,523 --> 00:21:00,260 line:-1
你只会收到交互式续订通知类型


415
00:21:01,962 --> 00:21:04,364 line:-1
在这个通知中


416
00:21:04,431 --> 00:21:06,667 line:-2
你该在JSON payload中
查找另外四个字段


417
00:21:09,203 --> 00:21:11,405 line:-1
第一个是购买日期


418
00:21:11,471 --> 00:21:13,874 line:-1
这会告诉你


419
00:21:13,941 --> 00:21:17,010 line:-1
客户重新订购这个订阅服务


420
00:21:17,077 --> 00:21:18,612 line:-1
或升级服务的具体日期和时间


421
00:21:19,479 --> 00:21:22,616 line:-1
你应该再一次查找原始交易id


422
00:21:22,883 --> 00:21:25,185 line:-1
从而把它链接回原始订阅


423
00:21:26,720 --> 00:21:28,989 line:-1
以及网络订单行排列项id


424
00:21:29,456 --> 00:21:32,292 line:-2
这对于每个订阅周期来说
是唯一标识符


425
00:21:32,359 --> 00:21:34,661 line:-1
它会帮助你把这个通知链接到


426
00:21:34,728 --> 00:21:36,964 line:-2
verifyReceipt
数组中的某个条目


427
00:21:38,298 --> 00:21:40,434 line:-1
最后查找产品id


428
00:21:40,801 --> 00:21:44,805 line:-2
这会告诉你
客户重新订购的具体产品


429
00:21:44,872 --> 00:21:46,406 line:-1
或升级到了哪个等级的产品


430
00:21:47,474 --> 00:21:48,942 line:-1
不久之后


431
00:21:49,009 --> 00:21:53,413 line:-2
John决定把订阅的等级
降低到更基础的等级


432
00:21:53,881 --> 00:21:55,282 line:-1
在这种情况下 我们会给你发送


433
00:21:55,349 --> 00:21:58,285 line:-1
变更续订偏好通知类型


434
00:21:59,086 --> 00:22:00,921 line:-1
收到这个通知之后


435
00:22:00,988 --> 00:22:03,323 line:-2
你可以在你的服务器上
把客户的订阅状态


436
00:22:03,390 --> 00:22:05,659 line:-1
更新为一个更基础的等级


437
00:22:06,393 --> 00:22:07,761 line:-1
在这个通知类型中


438
00:22:07,828 --> 00:22:10,531 line:-1
我希望你查找两个字段


439
00:22:10,597 --> 00:22:11,999 line:-1
（订阅降级）


440
00:22:12,065 --> 00:22:14,701 line:-1
第一个是自动续订产品id


441
00:22:15,169 --> 00:22:17,804 line:-1
因为续订降级不会发生


442
00:22:17,871 --> 00:22:20,040 line:-1
除非订阅周期结束


443
00:22:20,374 --> 00:22:24,211 line:-1
这会准确地告诉你续订时


444
00:22:24,278 --> 00:22:25,846 line:-1
客户将自动续订哪个产品


445
00:22:27,581 --> 00:22:30,717 line:-1
你应该再次查找原始交易id


446
00:22:30,784 --> 00:22:34,121 line:-1
以便把这个通知链接回原始订阅


447
00:22:36,490 --> 00:22:38,025 line:-1
（客户服务部执行退款）


448
00:22:38,091 --> 00:22:40,227 line:-1
现在很遗憾 不久之后


449
00:22:40,294 --> 00:22:42,396 line:-1
John拨打了客服电话


450
00:22:42,462 --> 00:22:44,665 line:-1
并决定取消订阅


451
00:22:45,465 --> 00:22:48,936 line:-2
在这种情况下 我们会给你发送一个
取消通知类型


452
00:22:49,603 --> 00:22:50,804 line:-1
正如我之前所提到的那样


453
00:22:50,871 --> 00:22:53,106 line:-1
当客户升级订阅时


454
00:22:53,173 --> 00:22:56,343 line:-2
你将收到一个取消
外加交互式续订通知


455
00:22:56,610 --> 00:22:59,546 line:-1
而取消意味着


456
00:22:59,613 --> 00:23:00,614 line:-1
取消较低等级的订阅


457
00:23:01,682 --> 00:23:04,685 line:-1
在这个通知类型中


458
00:23:05,385 --> 00:23:08,355 line:-1
首先你应该查找取消日期


459
00:23:08,422 --> 00:23:10,357 line:-1
这会告诉你


460
00:23:10,424 --> 00:23:13,293 line:-1
客户决定取消订阅的具体日期和时间


461
00:23:14,261 --> 00:23:16,864 line:-1
你仍然要查找原始交易id


462
00:23:16,930 --> 00:23:19,466 line:-1
从而把它链接回原始交易购买


463
00:23:20,767 --> 00:23:22,002 line:-1
以及产品id


464
00:23:22,069 --> 00:23:25,506 line:-2
从而精确地了解
客户取消了哪个产品的订阅


465
00:23:30,878 --> 00:23:33,647 line:-2
那么现在我们已经了解了
全部现有的通知类型


466
00:23:33,714 --> 00:23:37,718 line:-1
让我们同样地来了解一下


467
00:23:37,784 --> 00:23:39,152 line:-1
我刚才介绍的四种新通知类型


468
00:23:40,053 --> 00:23:40,888 line:-1
它们分别是…


469
00:23:42,523 --> 00:23:46,493 line:-1
变更续订状态 续订失败 追回


470
00:23:46,894 --> 00:23:48,295 line:-1
以及涨价同意


471
00:23:48,362 --> 00:23:49,396 line:-1
（新通知类型概览）


472
00:23:49,463 --> 00:23:50,764 line:-1
在这些通知类型中


473
00:23:50,831 --> 00:23:53,934 line:-2
你仍然想在
每个JSON payload中


474
00:23:54,001 --> 00:23:56,036 line:-1
查找原始交易id


475
00:23:56,770 --> 00:23:57,905 line:-1
正如我刚才所提到的那样


476
00:23:57,971 --> 00:24:01,542 line:-1
这是因为它是订阅的唯一标识符


477
00:24:01,608 --> 00:24:04,778 line:-2
它会帮助你把所有的通知
都链接到一起


478
00:24:06,246 --> 00:24:07,648 line:-1
现在让我们再次访问John


479
00:24:07,714 --> 00:24:08,682 line:-1
（自动续订状态变更）


480
00:24:08,749 --> 00:24:11,852 line:-2
有一天他正在滚动浏览
他的订阅管理页面


481
00:24:11,919 --> 00:24:15,322 line:-1
并决定再次自动续订


482
00:24:15,923 --> 00:24:17,457 line:-1
在这种情况下 我们会给你发送


483
00:24:17,524 --> 00:24:20,561 line:-1
一个变更续订状态通知类型


484
00:24:21,261 --> 00:24:23,297 line:-1
你还将在客户决定


485
00:24:23,363 --> 00:24:26,300 line:-1
关闭自动续订时收到这个通知


486
00:24:27,234 --> 00:24:29,102 line:-1
收到这个通知后


487
00:24:29,703 --> 00:24:31,972 line:-1
你可以在你那端更新客户的订阅状态


488
00:24:32,039 --> 00:24:34,741 line:-1
从而响应此次变更


489
00:24:35,776 --> 00:24:39,746 line:-2
或者你还可以部署保留政策
从而留住客户


490
00:24:39,813 --> 00:24:42,015 line:-2
如果你看到他们已经关闭
自动续订的话


491
00:24:43,183 --> 00:24:45,786 line:-1
在这个通知类型中


492
00:24:45,853 --> 00:24:47,621 line:-1
你应该查找并记下另外四个字段


493
00:24:48,455 --> 00:24:51,458 line:-1
第一个是自动续订状态变更日期


494
00:24:51,525 --> 00:24:53,560 line:-1
它会告诉你客户自动续订状态


495
00:24:53,627 --> 00:24:55,896 line:-1
发生变更的具体日期和时间


496
00:24:57,130 --> 00:24:59,032 line:-1
你应该查找自动续订状态


497
00:24:59,399 --> 00:25:02,269 line:-1
它会告诉你是否开启自动续订


498
00:25:02,769 --> 00:25:06,273 line:-2
如果你知道自动续订状态
有一个值为真


499
00:25:06,340 --> 00:25:09,977 line:-2
你就可以了解
客户已经开启了自动续订


500
00:25:10,277 --> 00:25:13,280 line:-1
并打算继续购买你的订阅服务


501
00:25:14,581 --> 00:25:17,618 line:-1
你应该再次查找原始交易id


502
00:25:17,684 --> 00:25:20,420 line:-1
从而把它链接回原始订阅购买


503
00:25:21,288 --> 00:25:24,191 line:-2
以及产品id
从而了解客户针对哪个产品


504
00:25:24,258 --> 00:25:27,995 line:-1
开启或关闭了自动续订


505
00:25:31,598 --> 00:25:34,301 line:-1
当我们在自动续订阶段


506
00:25:34,368 --> 00:25:35,903 line:-1
尝试对John的订阅计费时


507
00:25:35,969 --> 00:25:38,338 line:-1
我们很遗憾地遇到了计费报错


508
00:25:38,739 --> 00:25:41,241 line:-1
在这种情况下 我们将在


509
00:25:41,308 --> 00:25:44,611 line:-2
那个订阅周期中的首次续订尝试时
给你发送续订失败通知


510
00:25:45,345 --> 00:25:47,347 line:-1
收到这个通知后


511
00:25:47,414 --> 00:25:50,984 line:-1
你可以选择推迟对客户的服务


512
00:25:51,852 --> 00:25:54,388 line:-1
你还可以把客户的订阅状态更新为


513
00:25:54,454 --> 00:25:56,990 line:-1
比如“活跃”或“计费重试”


514
00:25:57,057 --> 00:26:00,160 line:-2
取决于JSON payload中
所看到的字段值


515
00:26:00,694 --> 00:26:02,129 line:-1
那么现在 让我们具体看一下


516
00:26:02,696 --> 00:26:04,498 line:-1
在这里你要查找的第一个字段


517
00:26:04,565 --> 00:26:06,967 line:-1
在计费重试周期中


518
00:26:07,367 --> 00:26:10,003 line:-1
它的值为0或1 它会告诉你


519
00:26:10,070 --> 00:26:12,372 line:-1
我们是否正在积极尝试


520
00:26:12,439 --> 00:26:13,974 line:-1
追回订阅计费


521
00:26:14,474 --> 00:26:17,144 line:-1
如果你看到这个字段的值为1


522
00:26:17,211 --> 00:26:20,480 line:-2
你就会了解我们正在尝试
追回订阅计费


523
00:26:20,547 --> 00:26:22,149 line:-1
在计费重试周期中


524
00:26:23,417 --> 00:26:26,653 line:-1
你仍然要查找原始交易id


525
00:26:26,720 --> 00:26:29,022 line:-1
从而把它链接回原始订阅


526
00:26:29,957 --> 00:26:31,758 line:-1
以及截止日期


527
00:26:31,825 --> 00:26:34,361 line:-1
这会表明我们尝试自动续订的


528
00:26:34,695 --> 00:26:37,564 line:-1
具体日期和时间


529
00:26:37,631 --> 00:26:38,465 line:-1
并且它已经失败了


530
00:26:39,099 --> 00:26:40,100 line:-1
（计费重试中的订阅追回）


531
00:26:40,167 --> 00:26:42,736 line:-1
很幸运的是在计费重试阶段


532
00:26:43,270 --> 00:26:46,139 line:-1
John的订阅计费问题已经解决了


533
00:26:46,206 --> 00:26:48,809 line:-2
并且我们可以追回
对他的订阅的计费了


534
00:26:49,142 --> 00:26:49,977 line:-1
在这种情况下


535
00:26:50,043 --> 00:26:52,813 line:-1
我们会给你发送一个追回通知类型


536
00:26:54,014 --> 00:26:55,682 line:-1
提醒一下 追回通知


537
00:26:55,749 --> 00:26:58,418 line:-1
正在取代我们目前


538
00:26:58,485 --> 00:27:00,587 line:-1
正在发送的续订通知类型


539
00:27:01,688 --> 00:27:03,624 line:-1
收到这个通知类型后


540
00:27:03,690 --> 00:27:06,727 line:-1
你可以追回要追回的订阅


541
00:27:07,461 --> 00:27:08,929 line:-1
并把客户状态更新为


542
00:27:08,996 --> 00:27:11,098 line:-1
比如“活跃”或“已订阅”


543
00:27:11,164 --> 00:27:14,168 line:-1
或任何表明是活跃的订阅者的表述


544
00:27:15,068 --> 00:27:17,638 line:-2
在这种通知类型中
我还希望你在payload中


545
00:27:17,704 --> 00:27:19,573 line:-1
查找其它几个字段


546
00:27:20,807 --> 00:27:22,476 line:-1
首先你应该查找购买日期


547
00:27:22,543 --> 00:27:25,879 line:-1
这会告诉你具体何时


548
00:27:25,946 --> 00:27:27,114 line:-1
我们会追回对这个订阅的计费


549
00:27:28,182 --> 00:27:31,318 line:-1
你应该再次查找原始交易id


550
00:27:31,752 --> 00:27:34,521 line:-1
因为它会告诉你


551
00:27:34,588 --> 00:27:35,923 line:-1
我们到底追回了对哪个订阅的计费


552
00:27:35,989 --> 00:27:38,959 line:-1
因为它是订阅的唯一标识符


553
00:27:40,160 --> 00:27:42,496 line:-1
最后查找到期日期


554
00:27:42,563 --> 00:27:44,565 line:-1
它会告诉你


555
00:27:44,631 --> 00:27:47,334 line:-1
新订阅周期的到期日期和时间


556
00:27:47,601 --> 00:27:50,437 line:-1
你可以期待我们再次尝试自动续订


557
00:27:52,706 --> 00:27:54,241 line:-1
（客户进入涨价流程）


558
00:27:54,308 --> 00:27:56,977 line:-1
现在让我们假设你们开发人员


559
00:27:57,044 --> 00:27:59,613 line:-1
决定增加订阅服务的价格


560
00:28:00,047 --> 00:28:02,516 line:-1
我们何时检查某个订阅服务是否涨价


561
00:28:02,583 --> 00:28:05,219 line:-1
在周订阅续订之前七天


562
00:28:05,285 --> 00:28:07,788 line:-1
在月订阅续订之前十天


563
00:28:07,855 --> 00:28:10,757 line:-1
在年订阅续订之前30天


564
00:28:10,824 --> 00:28:12,960 line:-1
我们发现你希望涨价


565
00:28:13,026 --> 00:28:16,630 line:-1
我们将给你发送一个


566
00:28:16,697 --> 00:28:17,831 line:-1
涨价同意通知


567
00:28:18,799 --> 00:28:20,667 line:-1
收到这个通知后


568
00:28:20,734 --> 00:28:24,872 line:-2
你可以在你那端
把用户状态更新为“涨价”


569
00:28:25,339 --> 00:28:28,008 line:-1
或者你可以部署app内消息


570
00:28:28,075 --> 00:28:31,078 line:-1
提醒你的客户同意涨价


571
00:28:31,712 --> 00:28:35,282 line:-2
请注意我们还会给客户发送邮件
及推送通知


572
00:28:35,349 --> 00:28:38,485 line:-1
提醒他们同意涨价


573
00:28:40,053 --> 00:28:41,321 line:-1
在这个通知类型内


574
00:28:41,388 --> 00:28:43,524 line:-1
我还希望你查找其它字段


575
00:28:44,224 --> 00:28:46,827 line:-1
首先你应该查找价格同意状态


576
00:28:46,894 --> 00:28:50,230 line:-1
它将告诉你


577
00:28:50,297 --> 00:28:51,532 line:-1
客户是否已经同意涨价


578
00:28:51,899 --> 00:28:55,269 line:-1
然而因为我们会给你发送这个通知


579
00:28:55,335 --> 00:28:58,172 line:-1
几乎是一检测到涨价就发送通知


580
00:28:58,438 --> 00:29:01,708 line:-2
在绝大部分情况下
你应该期待这个值为零


581
00:29:01,775 --> 00:29:03,911 line:-1
否则就是客户尚未同意


582
00:29:05,712 --> 00:29:08,615 line:-1
你应该再次查找原始交易id


583
00:29:08,682 --> 00:29:12,019 line:-1
从而把这个通知链接回原始订阅


584
00:29:12,819 --> 00:29:15,422 line:-1
最后我希望你查找截止日期


585
00:29:15,756 --> 00:29:20,060 line:-2
这会告诉你这个订阅周期
到期的日期和时间


586
00:29:20,394 --> 00:29:21,595 line:-1
到那时候


587
00:29:21,662 --> 00:29:25,399 line:-1
你的客户将不得不同意涨价


588
00:29:28,669 --> 00:29:29,837 line:0
（订阅周期）


589
00:29:29,903 --> 00:29:31,872 line:0
那么现在我们已经了解了


590
00:29:31,939 --> 00:29:33,607 line:-1
服务器到服务器通知相关的新功能


591
00:29:33,674 --> 00:29:36,143 line:-1
以及你要如何处理这些通知


592
00:29:36,210 --> 00:29:37,344 line:-1
当你收到它们之后


593
00:29:37,644 --> 00:29:40,247 line:-2
我要邀请
Manjeet Chawla上台


594
00:29:40,314 --> 00:29:42,482 line:-1
为大家谈谈订阅周期


595
00:29:42,549 --> 00:29:43,717 line:-1
以及减少流失


596
00:29:54,962 --> 00:29:55,796 line:-1
早上好


597
00:29:56,063 --> 00:29:59,733 line:-2
我是Manjeet Chawla
是App Store商务部的员工


598
00:30:00,667 --> 00:30:03,837 line:0
今天能与大家一起分享
我感到万分激动


599
00:30:03,904 --> 00:30:09,543 line:0
关于如何使用服务器到服务器通知
中的新功能以及改进的功能


600
00:30:09,877 --> 00:30:15,649 line:0
来识别订阅周期中的计费事件


601
00:30:15,716 --> 00:30:18,919 line:0
那可能会影响你客户的订阅状态


602
00:30:20,187 --> 00:30:23,123 line:0
那么订阅周期是什么样的呢？


603
00:30:25,392 --> 00:30:30,264 line:-2
现在你可能通过提供免费试用
来获得新客户


604
00:30:30,330 --> 00:30:34,168 line:-1
或通过推广价吸引他们关注你的服务


605
00:30:34,234 --> 00:30:38,172 line:-2
并允许用户在支付全款之前
试用你的服务


606
00:30:40,641 --> 00:30:43,477 line:-2
接下来你要保持用户
黏附在你的服务中


607
00:30:43,544 --> 00:30:46,680 line:-1
通过为他们提供持续更新的内容


608
00:30:49,516 --> 00:30:55,822 line:-2
最后你尝试通过最小化流失
把他们保留成为活跃的订阅者


609
00:30:59,193 --> 00:31:02,729 line:-1
现在我们都知道在这个周期中


610
00:31:02,796 --> 00:31:04,865 line:-1
对于绝大多数订阅者来说


611
00:31:04,932 --> 00:31:07,434 line:-1
会出现各种各样的计费事件


612
00:31:09,236 --> 00:31:13,340 line:-2
你现在很可能是通过调用
verifyReceipt终端


613
00:31:13,807 --> 00:31:17,978 line:-1
来让订阅者获取这些计费事件变更


614
00:31:19,580 --> 00:31:23,150 line:-2
现在我们知道这样效率不高
并且代价也很大


615
00:31:23,817 --> 00:31:26,186 line:-1
随着订阅业务的增长


616
00:31:27,688 --> 00:31:31,658 line:-2
但是我们之前对服务器到服务器
通知所做出的改进


617
00:31:31,725 --> 00:31:37,631 line:-2
你不再需要依赖于收据
来反映这些计费事件变更了


618
00:31:38,599 --> 00:31:43,203 line:-2
因此让我们更多地谈谈
如何使用新服务器到服务器通知


619
00:31:43,470 --> 00:31:45,339 line:-1
来检测这些计费事件


620
00:31:45,906 --> 00:31:48,942 line:-1
并为你的客户创建最佳订阅体验


621
00:31:51,845 --> 00:31:54,648 line:-1
让我们从初次购买订阅服务开始


622
00:31:55,282 --> 00:31:58,185 line:-1
现在我们都知道这个初次购买


623
00:31:58,252 --> 00:32:02,089 line:-1
是客户可以在某段时间内浏览内容


624
00:32:04,091 --> 00:32:07,261 line:-2
当客户在你的app中
购买了订阅服务


625
00:32:07,694 --> 00:32:11,765 line:-2
你将通过设备上的StoreKit
收到一个交易通知


626
00:32:12,366 --> 00:32:14,735 line:-1
以及与那个交易相关的收据


627
00:32:17,004 --> 00:32:19,206 line:-1
与此同时 你将收到


628
00:32:20,073 --> 00:32:25,245 line:-2
关于新购买的一个新通知
叫做初次购买


629
00:32:25,746 --> 00:32:27,481 line:-1
使用这个通知


630
00:32:27,548 --> 00:32:30,918 line:-1
你可以识别新购买的订阅者


631
00:32:30,984 --> 00:32:33,353 line:-1
之前从未购买过你的订阅服务


632
00:32:36,123 --> 00:32:39,993 line:-2
现在你抓住那个
初次购买通知JSON


633
00:32:40,060 --> 00:32:43,397 line:-1
与此同时你会从设备上发送一张收据


634
00:32:44,097 --> 00:32:46,300 line:-1
到你的服务器上 通过安全连接


635
00:32:46,366 --> 00:32:50,671 line:-2
发送到verifyReceipt
终端以验证收据的内容


636
00:32:54,041 --> 00:32:56,710 line:-1
在App Store返回的响应中


637
00:32:56,977 --> 00:33:00,414 line:-1
你要检查JSON的内容


638
00:33:00,480 --> 00:33:05,152 line:-1
并更新用户数据库 通过查找


639
00:33:05,219 --> 00:33:07,654 line:-1
用户所做出的最后一次购买


640
00:33:09,389 --> 00:33:12,626 line:-1
最后你之前保存的那个通知


641
00:33:12,693 --> 00:33:16,463 line:-2
你可以通过这个
verifyReceipt


642
00:33:16,530 --> 00:33:17,731 line:-2
把来自App Store的
响应链接到


643
00:33:18,131 --> 00:33:21,301 line:-1
初次购买通知


644
00:33:21,368 --> 00:33:26,139 line:-2
通过使用原始交易id
以及网络订单行排列项id


645
00:33:31,144 --> 00:33:33,847 line:-2
现在当订阅服务已经准备好
可以续订之后


646
00:33:34,281 --> 00:33:37,217 line:-1
App Store会在后台


647
00:33:37,284 --> 00:33:38,252 line:-1
自动为你续订


648
00:33:39,086 --> 00:33:42,456 line:-1
当用户下一次在设备上打开app时


649
00:33:42,990 --> 00:33:44,892 line:-1
你将收到一个新交易通知


650
00:33:44,958 --> 00:33:47,928 line:-1
以及一个与该交易相关的收据


651
00:33:50,864 --> 00:33:56,336 line:-2
你再次以base64加密那个收据
并安全地发送到你的服务器上


652
00:33:58,572 --> 00:34:01,208 line:-1
假如你的用户正在一个不同的平台上


653
00:34:01,275 --> 00:34:02,276 line:-1
使用他们的服务


654
00:34:02,342 --> 00:34:07,047 line:-2
并且你不希望依赖于
用户打开app来检测续订


655
00:34:07,447 --> 00:34:11,284 line:-2
你还可以使用你之前
从初次购买中存储的收据数据


656
00:34:11,351 --> 00:34:14,688 line:-1
并将其发送到你的服务器上


657
00:34:20,092 --> 00:34:23,096 line:-2
接下来你要把它发送到
verifyReceipt终端


658
00:34:23,163 --> 00:34:26,766 line:-1
并在JSON响应中检查续订交易


659
00:34:26,833 --> 00:34:28,467 line:-1
（续订）


660
00:34:28,534 --> 00:34:29,503 line:-1
在响应中


661
00:34:29,570 --> 00:34:32,572 line:-1
你可以验证该用户的最新续订


662
00:34:32,639 --> 00:34:36,810 line:-1
并根据那个续订更新最新到期日期


663
00:34:39,279 --> 00:34:41,949 line:-1
最后你要保持对客户的服务


664
00:34:42,014 --> 00:34:44,184 line:-1
因为订阅已成功续订


665
00:34:45,786 --> 00:34:49,755 line:-2
请注意对于这个事件来说
没有服务器到服务器通知


666
00:34:49,822 --> 00:34:54,862 line:-2
因此你必须根据
从初次购买中获得的信息


667
00:34:54,928 --> 00:34:56,096 line:-1
来调用verifyReceipt


668
00:34:56,763 --> 00:34:58,899 line:-1
从而检查续订交易


669
00:35:02,135 --> 00:35:04,872 line:-1
现在假如客户一直喜欢你的服务


670
00:35:04,938 --> 00:35:08,442 line:-1
并且他们觉得基础订阅很不错


671
00:35:08,509 --> 00:35:12,112 line:-1
并且他们决定升级到高级产品


672
00:35:12,179 --> 00:35:13,881 line:-1
也许是高等级的服务


673
00:35:13,947 --> 00:35:15,849 line:-1
（升级）


674
00:35:15,916 --> 00:35:19,920 line:-2
现在对于这个升级
你将在你的服务器上收到取消通知


675
00:35:20,187 --> 00:35:22,089 line:-1
来自于App Store


676
00:35:23,857 --> 00:35:29,162 line:-2
并且JSON内容中
将包含一个取消日期


677
00:35:29,463 --> 00:35:31,832 line:-2
通知你App Store
已经为用户


678
00:35:31,899 --> 00:35:34,701 line:-1
取消之前的订阅


679
00:35:37,938 --> 00:35:40,507 line:-2
取消通知之后
你还将在你的服务器上收到


680
00:35:40,574 --> 00:35:43,310 line:-1
一个交互式续订通知


681
00:35:45,212 --> 00:35:49,016 line:-1
这个通知用于更新用户的数据库


682
00:35:50,417 --> 00:35:51,618 line:-1
更新升级日期


683
00:35:51,685 --> 00:35:55,756 line:-1
那么现在你知道这个用户已经把订阅


684
00:35:55,822 --> 00:35:58,458 line:-2
升级成了一个高等级的服务
或者是高级产品


685
00:36:02,963 --> 00:36:05,933 line:-1
最后你要在app中


686
00:36:05,999 --> 00:36:07,367 line:-1
为用户解锁高级内容


687
00:36:10,571 --> 00:36:11,738 line:-1
（取消）


688
00:36:11,805 --> 00:36:12,639 line:-1
现在…


689
00:36:13,073 --> 00:36:14,041 line:-1
在某种情况下


690
00:36:14,508 --> 00:36:17,678 line:-1
客户觉得这个内容并不适合他


691
00:36:18,011 --> 00:36:19,813 line:-1
并且他想取消订阅


692
00:36:20,681 --> 00:36:25,752 line:-2
他们可以通过
在设备上的管理订阅设置中


693
00:36:25,819 --> 00:36:26,954 line:-1
关闭自动续订来实现


694
00:36:28,589 --> 00:36:29,590 line:-1
现在…


695
00:36:30,190 --> 00:36:32,392 line:-1
你可能想依赖于收据


696
00:36:32,860 --> 00:36:35,329 line:-1
来反映最新续订状态


697
00:36:36,163 --> 00:36:39,867 line:-2
你甚至可能调用全部客户的
verifyReceipt


698
00:36:40,133 --> 00:36:43,203 line:-2
仅仅是为了获取
他们最新的订阅的续订状态


699
00:36:45,472 --> 00:36:47,508 line:-1
我们刚刚讲过了


700
00:36:47,574 --> 00:36:50,043 line:-1
Tori刚刚提到了新通知


701
00:36:50,110 --> 00:36:51,245 line:-1
通过使用新通知


702
00:36:51,311 --> 00:36:54,348 line:-2
你就不需要再依赖于
verifyReceipt


703
00:36:54,414 --> 00:36:56,149 line:-1
来获取续订状态变更了


704
00:36:58,218 --> 00:37:01,421 line:-1
现在每当用户


705
00:37:01,688 --> 00:37:05,459 line:-2
从管理订阅设置中
关闭自动续订状态时


706
00:37:05,526 --> 00:37:07,261 line:-1
你就会获得变更续订状态通知


707
00:37:12,065 --> 00:37:15,502 line:-1
你使用这个事件把续订状态


708
00:37:15,802 --> 00:37:17,471 line:-1
更新为假


709
00:37:17,538 --> 00:37:20,274 line:-2
因为在这个情况下
用户关闭了自动续订


710
00:37:21,642 --> 00:37:24,077 line:-1
并且你还要更新他们的订阅状态


711
00:37:25,812 --> 00:37:30,751 line:-2
现在假如你没有收到
关于这个用户的其它通知


712
00:37:31,185 --> 00:37:33,086 line:-1
直到订阅周期结束


713
00:37:34,188 --> 00:37:38,125 line:-1
你就可以假设


714
00:37:38,592 --> 00:37:40,761 line:-2
在当前订阅周期结束后
流失了这些客户


715
00:37:43,397 --> 00:37:48,969 line:-2
因此你可以把用户的订阅状态
更新为“不活跃”或“已流失”


716
00:37:51,672 --> 00:37:52,873 line:-1
随着时间流逝


717
00:37:53,807 --> 00:37:56,343 line:-1
因为你的订阅者会流失


718
00:37:56,410 --> 00:38:00,514 line:-2
你一定希望试着把他们重新拉回来
通过提供一个很有吸引力的优惠


719
00:38:00,581 --> 00:38:03,917 line:-2
要么是折扣价格
要么也许甚至是免费试用


720
00:38:06,320 --> 00:38:09,890 line:-2
我们最近发布了一个新功能
叫做订阅优惠


721
00:38:09,957 --> 00:38:14,127 line:-1
它允许你提供折扣价格或免费试用


722
00:38:14,194 --> 00:38:16,263 line:-1
从而保留现有订阅者


723
00:38:16,330 --> 00:38:19,166 line:-1
或重获之前流失的订阅者


724
00:38:19,233 --> 00:38:20,234 line:-1
（重获）


725
00:38:20,300 --> 00:38:22,769 line:-2
今天稍后有一场关于
订阅优惠的演讲


726
00:38:22,836 --> 00:38:25,339 line:-1
我的同事们将分享一些最佳范例


727
00:38:25,405 --> 00:38:27,241 line:-1
关于实施订阅优惠


728
00:38:27,608 --> 00:38:31,345 line:-1
以及关于如何使用订阅优惠


729
00:38:31,411 --> 00:38:32,713 line:-1
来增加客户保留数量的不同的用例


730
00:38:36,950 --> 00:38:38,886 line:-2
现在让我们看一个
稍微有点不一样的情况


731
00:38:38,952 --> 00:38:41,688 line:-1
用户没有取消订阅的意图


732
00:38:42,122 --> 00:38:45,459 line:-1
但App Store不能代表用户


733
00:38:45,526 --> 00:38:47,895 line:-1
追回或续订


734
00:38:47,961 --> 00:38:48,896 line:-1
（计费错误）


735
00:38:48,962 --> 00:38:51,064 line:-1
也许是用户的信用卡过期了


736
00:38:51,131 --> 00:38:54,301 line:-1
或也许是他们的账户中资金不足


737
00:38:56,003 --> 00:38:57,004 line:-1
对于这个事件


738
00:38:57,738 --> 00:39:01,575 line:-2
App Store现在会给你发送
续订失败通知


739
00:39:02,376 --> 00:39:04,011 line:-1
使用这个通知


740
00:39:04,578 --> 00:39:09,416 line:-2
你会了解用户的订阅
由于计费问题续订失败了


741
00:39:10,217 --> 00:39:12,686 line:-1
并且你可以把客户的订阅状态


742
00:39:12,753 --> 00:39:15,756 line:-1
更新为“不活跃”或“已流失”


743
00:39:17,925 --> 00:39:19,359 line:-1
你可以使用这个通知


744
00:39:19,993 --> 00:39:22,029 line:-1
在app内给他们显示一条消息


745
00:39:22,095 --> 00:39:24,731 line:-1
让他们知道他们的订阅已经到期


746
00:39:27,367 --> 00:39:28,202 line:-1
（计费重试）


747
00:39:28,268 --> 00:39:30,470 line:-1
现在对于计费相关的问题


748
00:39:31,138 --> 00:39:33,941 line:-2
App Store
会自动做几次尝试


749
00:39:34,374 --> 00:39:36,710 line:-1
尝试续订


750
00:39:37,611 --> 00:39:39,146 line:-1
如果某次尝试成功


751
00:39:39,213 --> 00:39:42,683 line:-1
并且如果你允许客户订阅该服务


752
00:39:43,617 --> 00:39:46,186 line:-1
你将收到一个恢复通知


753
00:39:46,587 --> 00:39:48,222 line:-1
那么使用这个通知


754
00:39:48,822 --> 00:39:51,325 line:-1
你可以把那个客户的用户数据库


755
00:39:52,159 --> 00:39:53,193 line:-1
更新为“已订阅”


756
00:39:54,127 --> 00:39:58,332 line:-2
并且你会注意到那个新续订
有一个新的到期日期


757
00:40:01,134 --> 00:40:03,670 line:-1
然后你就可以为该客户重新启动服务


758
00:40:06,907 --> 00:40:08,442 line:-1
（减少无意识流失）


759
00:40:08,509 --> 00:40:12,813 line:-2
那么现在我们在上一个例子中看到
App Store会在一段时间内


760
00:40:12,880 --> 00:40:15,249 line:-1
数次尝试续订


761
00:40:15,949 --> 00:40:18,919 line:-1
现在这是自动发生的了


762
00:40:20,821 --> 00:40:22,422 line:-1
但你作为开发人员要如何


763
00:40:23,223 --> 00:40:25,058 line:-1
响应这些尝试


764
00:40:25,125 --> 00:40:28,795 line:-2
以及要采取什么措施来减少
无意识流失呢？


765
00:40:32,566 --> 00:40:35,035 line:-1
去年 关于订阅的实施


766
00:40:35,102 --> 00:40:38,305 line:-1
我们谈到了我们扩展的计费重试逻辑


767
00:40:38,372 --> 00:40:42,276 line:-1
那会在一段时间内尝试续订


768
00:40:44,511 --> 00:40:48,582 line:-2
当由于计费问题导致续订失败时
会部署这个逻辑


769
00:40:51,084 --> 00:40:54,221 line:-1
自发布之后 我们一直在持续地更新


770
00:40:54,288 --> 00:40:58,192 line:-1
并使它与优化追回策略相协调


771
00:40:59,159 --> 00:41:02,596 line:-1
我们还查看了先进的机器学习模型


772
00:41:02,896 --> 00:41:06,900 line:-2
用于改进在整个平台内
追回订阅的方式


773
00:41:09,536 --> 00:41:12,039 line:-1
我们查看了一下它自发布之后的性能


774
00:41:12,372 --> 00:41:16,844 line:-1
你可以看到我们可以追回


775
00:41:16,910 --> 00:41:19,746 line:-2
由于计费问题
导致订阅失败的77%的订阅


776
00:41:19,813 --> 00:41:21,448 line:-1
（计费重试性能）


777
00:41:21,515 --> 00:41:24,785 line:-1
通过追回这些订阅


778
00:41:24,852 --> 00:41:29,656 line:-2
我们能把整个平台无意识流失率
降低为不到2%


779
00:41:37,130 --> 00:41:38,665 line:-1
通过我们对计费重试策略


780
00:41:38,932 --> 00:41:42,336 line:-1
所做出的更新和改进


781
00:41:44,137 --> 00:41:48,842 line:-1
我们可以追回4600万次订阅


782
00:41:51,478 --> 00:41:54,748 line:-1
（追回4600万次订阅）


783
00:41:54,815 --> 00:41:57,684 line:-1
否则这些订阅就会流失


784
00:41:57,951 --> 00:42:00,988 line:-1
但是用户却没有要取消服务的意图


785
00:42:01,054 --> 00:42:03,457 line:-1
用户会续订并享受他们的服务


786
00:42:03,524 --> 00:42:05,759 line:-1
并且他们不想取消订阅


787
00:42:06,360 --> 00:42:07,928 line:-1
并且我们看到在整个平台上


788
00:42:07,995 --> 00:42:11,265 line:-1
一半以上的这种订阅仍然是活跃的


789
00:42:13,967 --> 00:42:17,905 line:-2
现在因为我们了解了
我们如何追回这些订阅


790
00:42:17,971 --> 00:42:19,606 line:-1
在一个为期60天的时间段内


791
00:42:19,673 --> 00:42:21,208 line:-1
（追回率）


792
00:42:21,275 --> 00:42:25,179 line:-2
你可以看到
我们在为期60天的时间段内


793
00:42:25,245 --> 00:42:28,182 line:-2
追回了由于计费问题
导致续订失败的77%以上的订阅


794
00:42:31,051 --> 00:42:35,856 line:-2
其中80%以上的追回
发生在前16天


795
00:42:38,258 --> 00:42:41,228 line:-1
当我们追回这些订阅时会发生什么？


796
00:42:43,297 --> 00:42:46,567 line:-2
首先你要再允许服务
正如Tori刚才所提到的那样


797
00:42:46,633 --> 00:42:48,135 line:-1
通过新通知


798
00:42:48,202 --> 00:42:50,404 line:-1
你可以对该客户重新启动服务


799
00:42:50,704 --> 00:42:53,240 line:-1
当他们下一次尝试获取服务时


800
00:42:55,008 --> 00:42:57,811 line:-2
我们就为那个订阅开始了一个
新的计费周期


801
00:42:57,878 --> 00:42:59,646 line:-1
自执行追回操作之日起


802
00:43:02,282 --> 00:43:06,019 line:-2
并且客户朝着
更高的收入分成的目标85/15


803
00:43:06,086 --> 00:43:11,325 line:-2
所累积的付费服务的天数将从
开始执行追回之日起开始恢复计算


804
00:43:13,093 --> 00:43:13,927 line:-1
那么…


805
00:43:14,261 --> 00:43:17,764 line:-1
如果你在此期间为客户提供服务


806
00:43:17,831 --> 00:43:22,603 line:-1
从他们开始计费重试到追回之日


807
00:43:23,070 --> 00:43:26,039 line:-1
你很可能会漏掉这些天的收益


808
00:43:28,575 --> 00:43:29,877 line:-1
我们该如何改进呢？


809
00:43:32,379 --> 00:43:36,116 line:-2
那么今年秋季 我要非常激动地宣布
我们即将发布一个新功能


810
00:43:36,183 --> 00:43:39,720 line:-1
那会允许你提供一个计费宽限期


811
00:43:40,187 --> 00:43:42,823 line:-1
给客户们一些额外时间


812
00:43:43,524 --> 00:43:47,561 line:-2
当他们享受他们的服务时
他们拥有对那些付费内容的权限


813
00:43:48,428 --> 00:43:51,498 line:-1
并且它允许开发人员获得额外的收益


814
00:43:51,565 --> 00:43:54,468 line:-1
针对你在这些天内所提供的所有服务


815
00:43:54,535 --> 00:43:59,873 line:-1
（计费宽限期概览）


816
00:44:01,341 --> 00:44:04,645 line:-2
这为你的所有客户创建了一个
更好的体验


817
00:44:04,711 --> 00:44:07,714 line:-1
他们在一段时间内自然而然地被追回


818
00:44:08,215 --> 00:44:10,484 line:-1
因为他们从未表达过取消服务的意图


819
00:44:11,485 --> 00:44:12,920 line:-1
这还会追回


820
00:44:12,986 --> 00:44:16,790 line:-1
也许账户中有临时信用卡的客户


821
00:44:19,826 --> 00:44:22,696 line:-1
现在让我们看看要如何实施这个功能


822
00:44:23,163 --> 00:44:24,398 line:-1
嗯 非常简单


823
00:44:24,831 --> 00:44:28,669 line:-1
实施计费宽限期需要三个简单的步骤


824
00:44:29,903 --> 00:44:33,040 line:-2
首先通过App Store连接
选择提供宽限期


825
00:44:33,106 --> 00:44:36,643 line:-1
以便提供宽限期的预配置持续时间


826
00:44:37,711 --> 00:44:40,347 line:-1
根据我们之前看到过的追回数据


827
00:44:40,714 --> 00:44:44,518 line:-2
我们要针对周订阅
开始为期六天的宽限期


828
00:44:44,585 --> 00:44:47,421 line:-1
而其它是16天的宽限期


829
00:44:50,257 --> 00:44:54,361 line:-2
接着在verifyReceipt
响应中查找一个新字段


830
00:44:54,428 --> 00:44:55,963 line:-1
或在通知中


831
00:44:56,029 --> 00:44:59,933 line:-1
这将允许你了解


832
00:45:00,000 --> 00:45:01,235 line:-1
服务的最新到期日期


833
00:45:01,301 --> 00:45:04,004 line:-1
（账单宽限期的实施）


834
00:45:04,071 --> 00:45:07,674 line:-2
并且你在这段时间内
要保持对客户的服务


835
00:45:13,146 --> 00:45:14,481 line:-1
现在你可能会想


836
00:45:15,482 --> 00:45:16,550 line:-1
作为开发人员


837
00:45:16,617 --> 00:45:19,853 line:-1
为什么要选择提供计费宽限期？


838
00:45:22,723 --> 00:45:24,091 line:-1
嗯 有许多好处


839
00:45:24,157 --> 00:45:24,992 line:-1
首先…


840
00:45:25,359 --> 00:45:28,562 line:-1
客户从未有过取消订阅的意图


841
00:45:28,629 --> 00:45:32,633 line:-2
因此他们喜欢一直获得你的服务
而不想中断


842
00:45:35,669 --> 00:45:37,037 line:-1
这就允许你


843
00:45:37,471 --> 00:45:40,774 line:-1
或你的客户维持现有的计费周期


844
00:45:40,841 --> 00:45:44,311 line:-2
当我们在这个计费宽限期内
追回他们的订阅时


845
00:45:46,780 --> 00:45:48,549 line:-1
并且它可以让你 作为开发人员


846
00:45:48,916 --> 00:45:49,750 line:-1
可以…


847
00:45:51,318 --> 00:45:54,054 line:-1
赚取额外的收益


848
00:45:54,121 --> 00:45:55,789 line:-1
对于你在计费宽限期内所提供的服务


849
00:45:56,423 --> 00:45:59,993 line:-1
（计费宽限期的好处）


850
00:46:00,060 --> 00:46:01,328 line:-1
并且正如我们之前所看到的那样


851
00:46:01,795 --> 00:46:03,931 line:-1
它允许客户以更快的比率累积


852
00:46:03,997 --> 00:46:08,902 line:-2
成为那些较高的85/15
收益分成的付费天数


853
00:46:11,038 --> 00:46:12,406 line:-1
我非常鼓励你们


854
00:46:12,472 --> 00:46:15,209 line:-1
了解订阅的宽限期


855
00:46:15,275 --> 00:46:17,144 line:-1
当我们稍后在今年秋季发布后


856
00:46:19,513 --> 00:46:20,480 line:-1
现在…


857
00:46:20,547 --> 00:46:22,282 line:-1
除了提供宽限期


858
00:46:22,349 --> 00:46:24,284 line:-1
你还可以做哪些操作


859
00:46:24,351 --> 00:46:28,488 line:-1
减少整体无意识流失和增加追回？


860
00:46:29,523 --> 00:46:33,093 line:-2
在这里让我们看一个例子
在app内


861
00:46:33,160 --> 00:46:36,496 line:-1
通过给计费重试状态的客户


862
00:46:37,064 --> 00:46:38,899 line:-1
显示情境消息


863
00:46:38,966 --> 00:46:40,701 line:-1
你可以让他们了解他们的订阅


864
00:46:40,767 --> 00:46:43,370 line:-1
失败了 因为计费问题


865
00:46:43,437 --> 00:46:46,073 line:-1
（计费重试客户消息）


866
00:46:48,442 --> 00:46:50,444 line:-1
并且如果你提供宽限期


867
00:46:50,511 --> 00:46:52,179 line:-1
你可以让消息侧重于


868
00:46:52,246 --> 00:46:56,283 line:-1
你为客户提供的宽限期服务


869
00:46:56,650 --> 00:47:00,888 line:-2
你可以在设计这条消息方面
发挥你的创造力


870
00:47:01,355 --> 00:47:03,223 line:-1
它要发生在宽限期结束之前


871
00:47:03,290 --> 00:47:05,359 line:-1
也许你正在提供高级内容


872
00:47:05,425 --> 00:47:07,628 line:-2
并且他们会在宽限期结束后
失去对那部分内容的权限


873
00:47:07,694 --> 00:47:08,695 line:-1
那么 突出这一点…


874
00:47:10,097 --> 00:47:12,699 line:-1
宽限期结束后


875
00:47:12,766 --> 00:47:13,967 line:-1
他们会失去对高级内容的权限


876
00:47:14,501 --> 00:47:16,403 line:-1
这将帮助你追回那些订阅


877
00:47:19,806 --> 00:47:22,009 line:-2
在这里让我们看一个app
Foodvisor


878
00:47:22,342 --> 00:47:25,412 line:-2
给计费重试阶段的用户
显示了一条消息


879
00:47:25,812 --> 00:47:29,283 line:-2
并为他们显示
能浏览高级内容的剩余时间


880
00:47:32,419 --> 00:47:34,121 line:-1
在这条消息中


881
00:47:34,821 --> 00:47:38,692 line:-2
你还可以嵌入一个
付款详情页面的深链接


882
00:47:39,126 --> 00:47:42,663 line:-1
然后客户就会去解决计费问题


883
00:47:46,233 --> 00:47:48,702 line:-2
正如你所看到的
我们最近已经更新了


884
00:47:49,636 --> 00:47:52,105 line:-1
这个付款详情页面 允许客户


885
00:47:52,172 --> 00:47:56,076 line:-2
在账户中拥有最多十种
不同的付款方式


886
00:47:57,611 --> 00:47:58,879 line:-1
除了为客户提供


887
00:47:58,946 --> 00:48:02,015 line:-1
更简单的付款管理选项


888
00:48:02,282 --> 00:48:04,218 line:-1
这还帮助App Store


889
00:48:04,818 --> 00:48:08,055 line:-1
减少整体的无意识流失率


890
00:48:08,822 --> 00:48:11,491 line:-1
通过用存档的可替换的付款方式收费


891
00:48:18,565 --> 00:48:21,301 line:-1
我们在这场演讲中涵盖了许多话题


892
00:48:22,035 --> 00:48:23,403 line:-1
但总结一下


893
00:48:24,738 --> 00:48:29,877 line:-2
我们谈到了订阅优惠
我们最近发布的新功能


894
00:48:30,143 --> 00:48:36,083 line:-2
帮助你减少自发流失率
通过为客户提供折扣价格


895
00:48:36,149 --> 00:48:38,719 line:-1
或免费试用 从而保留他们的订阅


896
00:48:39,419 --> 00:48:44,091 line:-2
Dona给我们详细介绍了实施
新API SKStorefront代码


897
00:48:44,157 --> 00:48:47,060 line:-1
用于给世界各地的客户


898
00:48:47,127 --> 00:48:49,029 line:-1
显示正确内容


899
00:48:49,096 --> 00:48:51,298 line:-1
（总结）


900
00:48:52,566 --> 00:48:55,569 line:-1
我们谈了即将发布的一些收据变更


901
00:48:55,636 --> 00:48:58,272 line:-1
允许你回馈


902
00:48:58,338 --> 00:48:59,406 line:-1
预订app的忠实客户


903
00:48:59,473 --> 00:49:02,543 line:-1
也许是给他们提供游戏的初始余额


904
00:49:02,843 --> 00:49:05,612 line:-1
并且如果你还没有这样做 请查看


905
00:49:06,280 --> 00:49:08,415 line:-1
服务器到服务器通知


906
00:49:08,982 --> 00:49:12,419 line:-2
并在App Store连接中
添加那个URL


907
00:49:12,486 --> 00:49:14,521 line:-2
以便获得来自App Store
的计费事件的通知


908
00:49:15,656 --> 00:49:17,124 line:-1
我们讲了宽限期


909
00:49:17,191 --> 00:49:19,793 line:-1
以及如何提供宽限期


910
00:49:19,860 --> 00:49:24,198 line:-1
以便增加由于计费问题


911
00:49:24,264 --> 00:49:25,632 line:-1
导致续订失败的客户的追回率


912
00:49:28,368 --> 00:49:30,404 line:-1
并且我们讲了情境消息


913
00:49:30,470 --> 00:49:34,541 line:-2
你可以在app内显示
用于追回更多的订阅


914
00:49:36,076 --> 00:49:40,380 line:-2
要获取关于本演讲的更多信息
以及本演讲的视频


915
00:49:40,747 --> 00:49:42,482 line:-1
请查看演讲302


916
00:49:43,050 --> 00:49:44,651 line:-1
并且今天下午


917
00:49:44,718 --> 00:49:48,188 line:-2
我的同事们将分享
关于订阅优惠的最佳范例


918
00:49:48,255 --> 00:49:50,657 line:-1
他们将告诉你如何实施订阅优惠


919
00:49:50,724 --> 00:49:54,061 line:-1
以及使用订阅优惠


920
00:49:54,127 --> 00:49:56,129 line:-1
减少自发流失率的不同用例


921
00:49:57,364 --> 00:49:58,899 line:-1
并且我们会在讨论会中


922
00:49:58,966 --> 00:50:02,402 line:-1
解答关于这些功能的任何疑问


923
00:50:04,905 --> 00:50:07,774 line:-1
谢谢大家 祝大家下午愉快

