1
00:00:00,506 --> 00:00:04,500
[音乐]


2
00:00:09,516 --> 00:00:13,766
[掌声]


3
00:00:14,266 --> 00:00:16,026
>> 早上好 欢迎来到


4
00:00:16,026 --> 00:00:17,326
Instruments 入门指南


5
00:00:17,936 --> 00:00:19,356
我的名字叫 Tibet Rooney-Rabdau


6
00:00:19,356 --> 00:00:20,296
今天和我一起的是我的同事


7
00:00:20,436 --> 00:00:21,976
Ben Mitchell 和 Anand Subramanian


8
00:00:25,926 --> 00:00:27,376
要打造优秀的


9
00:00:27,376 --> 00:00:29,266
用户体验


10
00:00:29,266 --> 00:00:30,966
我第一个想到的就是性能


11
00:00:32,106 --> 00:00:33,786
灵敏的响应能让你的用户


12
00:00:34,436 --> 00:00:37,466
更加信任你的 App


13
00:00:37,656 --> 00:00:39,056
无论我多么喜欢某个 App 的 UI


14
00:00:39,056 --> 00:00:40,616
如果我不断看到加载动画


15
00:00:40,616 --> 00:00:43,126
或是电量掉得很快


16
00:00:43,126 --> 00:00:45,476
我获得的体验


17
00:00:45,476 --> 00:00:46,616
都变得不理想了


18
00:00:47,526 --> 00:00:49,156
如果你想在你的 App 中创造


19
00:00:49,156 --> 00:00:50,566
很棒的用户体验


20
00:00:50,566 --> 00:00:54,206
就要时刻注意这些问题


21
00:00:54,206 --> 00:00:55,256
在今天的会议中


22
00:00:55,256 --> 00:00:56,886
我们会与你分享我们


23
00:00:56,886 --> 00:00:58,016
最爱的性能分析工具


24
00:00:58,746 --> 00:00:59,366
Instruments


25
00:00:59,996 --> 00:01:01,956
这对于刚刚接触 Instruments


26
00:01:01,956 --> 00:01:03,226
并且想要在他们的


27
00:01:03,226 --> 00:01:04,096
工作流程中集成


28
00:01:04,096 --> 00:01:05,406
更好的 Instruments 的开发者来说


29
00:01:05,446 --> 00:01:06,456
是非常有帮助的


30
00:01:07,786 --> 00:01:08,916
性能分析不仅要趁早


31
00:01:08,916 --> 00:01:10,836
还要经常进行


32
00:01:11,046 --> 00:01:12,226
因为在开发过程中的


33
00:01:12,226 --> 00:01:13,166
任意阶段都可能


34
00:01:13,166 --> 00:01:14,486
引入回归 并且产生


35
00:01:14,486 --> 00:01:17,036
复合作用


36
00:01:17,036 --> 00:01:18,046
事实上 我把 Xcode Instruments


37
00:01:18,046 --> 00:01:19,616
当成我最好的帮手


38
00:01:19,616 --> 00:01:21,396
所以我会把它放在程序坞


39
00:01:21,396 --> 00:01:23,386
Xcode 的旁边


40
00:01:23,386 --> 00:01:25,076
提醒我从编程早期开始


41
00:01:25,076 --> 00:01:27,786
就要经常进行性能分析


42
00:01:28,516 --> 00:01:30,336
今天我们会从一个简单的介绍开始


43
00:01:30,336 --> 00:01:32,216
了解一下 Instruments 的功能与特性


44
00:01:32,216 --> 00:01:34,366
以及它的用户界面


45
00:01:35,286 --> 00:01:36,176
然后我们会向你展示


46
00:01:36,176 --> 00:01:37,816
如何用多种方式剖析你的 App


47
00:01:37,816 --> 00:01:39,836
来分析它的运行耗时


48
00:01:40,546 --> 00:01:41,786
我们会用一个


49
00:01:41,786 --> 00:01:43,586
叫做 Time Profiler 的工具


50
00:01:43,586 --> 00:01:45,586
来分析你的 App 在做什么


51
00:01:45,586 --> 00:01:46,506
以及做了多少


52
00:01:46,506 --> 00:01:49,126
最后 我们会讨论


53
00:01:49,126 --> 00:01:50,576
在你 App 中添加 Signpost


54
00:01:50,576 --> 00:01:53,486
来获取 App 行为的深度信息


55
00:01:54,136 --> 00:01:55,556
让我们先简要地


56
00:01:55,556 --> 00:01:57,146
了解一下 Instruments


57
00:01:57,686 --> 00:02:00,596
Instruments 是在 Xcode 工具集中的


58
00:02:00,596 --> 00:02:02,336
一个强大的性能分析


59
00:02:02,336 --> 00:02:04,596
与测试工具


60
00:02:05,306 --> 00:02:06,616
Instruments 可以帮助你


61
00:02:06,616 --> 00:02:08,166
在所有平台上分析你的 App


62
00:02:08,566 --> 00:02:10,866
包括 iOS macOS watchOS 和 tvOS


63
00:02:11,516 --> 00:02:13,326
这能让你更好地理解


64
00:02:13,326 --> 00:02:15,006
并优化它们的行为和性能


65
00:02:16,156 --> 00:02:17,356
你可以在开发 测试和调试


66
00:02:17,356 --> 00:02:19,216
过程中使用 Instruments


67
00:02:19,966 --> 00:02:21,176
另外 我有个好消息


68
00:02:21,646 --> 00:02:23,366
如果你有 Xcode 那么你就已经


69
00:02:23,416 --> 00:02:24,816
有 Instruments 了


70
00:02:25,426 --> 00:02:28,096
在 Xcode 的“Product”菜单中选择“Profile”


71
00:02:28,096 --> 00:02:30,406
尽管 Instruments 是内嵌在 Xcode 中


72
00:02:30,436 --> 00:02:32,306
且经常和 Xcode 一起使用的


73
00:02:32,546 --> 00:02:33,856
它还是一个单独的 App


74
00:02:34,046 --> 00:02:34,756
可以在有需要的时候


75
00:02:34,756 --> 00:02:35,956
单独使用


76
00:02:36,496 --> 00:02:37,716
你可以自由选择


77
00:02:37,776 --> 00:02:40,586
如何开始性能分析工作


78
00:02:40,896 --> 00:02:43,196
现在开始 我所说的“Instruments”


79
00:02:43,376 --> 00:02:45,026
会有两种不同的含义


80
00:02:45,886 --> 00:02:48,226
我们已经讨论过 Instruments App 了


81
00:02:48,226 --> 00:02:49,706
为什么取了个这样的名字呢


82
00:02:49,986 --> 00:02:51,576
因为它提供了一系列


83
00:02:51,576 --> 00:02:52,856
被称为 Instrument 的工具


84
00:02:52,856 --> 00:02:54,726
帮助你分析 App 中的错误


85
00:02:55,546 --> 00:02:56,826
在不容易理解


86
00:02:56,826 --> 00:02:58,046
我指的到底是什么的地方


87
00:02:58,046 --> 00:02:59,516
我会用“Instruments App”


88
00:02:59,516 --> 00:03:01,563
来指代这个 App


89
00:03:02,486 --> 00:03:03,846
Instrument 会从插入在


90
00:03:03,846 --> 00:03:05,356
App 进程和操作系统的


91
00:03:05,356 --> 00:03:06,656
重要内部架构中


92
00:03:06,656 --> 00:03:10,596
收集时间序列追踪数据


93
00:03:11,466 --> 00:03:12,766
我们有时候会称


94
00:03:12,766 --> 00:03:14,606
Instrument 收集到的数据为“Treat”


95
00:03:15,766 --> 00:03:17,836
这里展示的是我最喜欢的几个 Instrument


96
00:03:18,436 --> 00:03:19,746
左边的 Time Profiler Instrument


97
00:03:19,746 --> 00:03:21,506
使用操作系统提供的内部架构


98
00:03:21,506 --> 00:03:23,156
以固定的时间间隔


99
00:03:23,156 --> 00:03:24,656
来收集相关线程的


100
00:03:24,656 --> 00:03:26,406
所有呼叫栈


101
00:03:27,276 --> 00:03:28,186
右边的 Points of Interest Instrument


102
00:03:28,186 --> 00:03:29,656
从你 App 中重要的区域收集数据


103
00:03:29,686 --> 00:03:30,886
让你能用多种 API


104
00:03:30,886 --> 00:03:32,406
对其加以强调


105
00:03:32,766 --> 00:03:37,056
比如 Signpost API


106
00:03:37,376 --> 00:03:38,986
当你一开始打开 Instruments 的时候


107
00:03:38,986 --> 00:03:40,196
你会看到一个模板列表


108
00:03:40,196 --> 00:03:41,896
就像在“Pages 文稿”或


109
00:03:41,896 --> 00:03:44,246
“Numbers 表格”中一样


110
00:03:44,646 --> 00:03:46,086
模板会提供一个


111
00:03:46,156 --> 00:03:47,526
预配置的 Instrument 集合


112
00:03:47,526 --> 00:03:49,186
帮你解决特定的性能问题


113
00:03:49,186 --> 00:03:51,536
就像“Pages 文稿”中的


114
00:03:51,536 --> 00:03:52,826
生日贺卡模板一样


115
00:03:52,826 --> 00:03:54,166
它会提供一个文档结构


116
00:03:54,166 --> 00:03:55,786
来帮助你创建生日贺卡


117
00:03:56,106 --> 00:03:57,846
Instruments 中有海量的模板


118
00:03:57,846 --> 00:03:59,336
我们无法再这个短暂的会议中一一介绍


119
00:03:59,336 --> 00:04:00,446
所以我们今天会着重讲讲


120
00:04:00,446 --> 00:04:01,986
Time Profiler 这个模板


121
00:04:01,986 --> 00:04:03,066
它包括我刚刚提到的


122
00:04:03,066 --> 00:04:04,666
Time Profiler 和 Points of Interest


123
00:04:04,666 --> 00:04:06,216
这两个 Instrument 以及其他


124
00:04:07,296 --> 00:04:08,546
这些 Instrument 是


125
00:04:08,546 --> 00:04:09,466
了解响应程度和


126
00:04:09,466 --> 00:04:12,476
你 App 的占用程度的绝佳工具


127
00:04:12,476 --> 00:04:15,106
当你第一次打开 Time Profiler 模板的时候


128
00:04:15,106 --> 00:04:16,586
你会看到这样的


129
00:04:16,586 --> 00:04:17,916
一个空白文档


130
00:04:17,916 --> 00:04:19,586
等着你去进行分析工作


131
00:04:19,646 --> 00:04:22,136
你可以通过点按


132
00:04:22,136 --> 00:04:23,336
右上角的添加 Instrument 按钮


133
00:04:23,336 --> 00:04:26,106
来为你的文档添加额外的 Instrument


134
00:04:27,186 --> 00:04:28,286
然后 Instruments App 就会


135
00:04:28,286 --> 00:04:29,236
展现它的资源库面板


136
00:04:29,236 --> 00:04:30,446
包括了可用 Instrument


137
00:04:30,446 --> 00:04:32,436
的完整清单


138
00:04:33,706 --> 00:04:35,216
从这里 你可以找到新的 Instrument


139
00:04:35,216 --> 00:04:36,506
并将其拖到文档中


140
00:04:36,506 --> 00:04:37,976
来获取更多数据


141
00:04:39,356 --> 00:04:40,916
界面的左上角是


142
00:04:40,916 --> 00:04:42,036
分析控件


143
00:04:42,496 --> 00:04:43,816
这让你能够记录


144
00:04:43,816 --> 00:04:45,746
暂停 或者停止数据收集


145
00:04:46,516 --> 00:04:48,746
分析控件旁边是目标区域


146
00:04:49,416 --> 00:04:50,506
左边的目标设备列表


147
00:04:50,506 --> 00:04:52,166
让你能够选择


148
00:04:52,166 --> 00:04:53,716
你在分析时想用的设备


149
00:04:54,446 --> 00:04:56,216
这与 Xcode 中的目标区域很像


150
00:04:56,216 --> 00:04:57,426
你在那里可以选择


151
00:04:57,426 --> 00:04:59,326
在设备上进行分析时


152
00:04:59,326 --> 00:05:00,226
所用的设备和进程


153
00:05:01,316 --> 00:05:02,666
通常来说 你都会选择


154
00:05:02,666 --> 00:05:04,046
你 App 的进程做为目标进程


155
00:05:04,046 --> 00:05:05,846
但是 举个例子


156
00:05:05,846 --> 00:05:06,836
如果你在分析一个共享的扩展


157
00:05:06,836 --> 00:05:08,236
你可能会选择扩展进程


158
00:05:08,236 --> 00:05:09,846
作为目标进程 


159
00:05:09,846 --> 00:05:12,146
而它和你的 App 是相互独立的


160
00:05:12,406 --> 00:05:13,786
当我在 Time Profiler 模板中


161
00:05:13,786 --> 00:05:15,306
开始记录的时候


162
00:05:15,306 --> 00:05:16,226
文档会逐渐被


163
00:05:16,226 --> 00:05:18,326
追踪数据填充


164
00:05:18,326 --> 00:05:20,036
另外 使用 Instruments 记录


165
00:05:20,036 --> 00:05:21,136
会占用系统资源


166
00:05:21,136 --> 00:05:23,086
像你的 App 一样


167
00:05:23,826 --> 00:05:25,386
为了最小化对你的 App 的影响


168
00:05:25,696 --> 00:05:26,956
Instruments 还提供了一个叫做


169
00:05:26,956 --> 00:05:28,346
Last Few Seconds Mode（最后几秒模式）的功能


170
00:05:28,406 --> 00:05:30,586
有时候也叫做 Windowed Mode（窗口模式）


171
00:05:31,836 --> 00:05:33,436
Windowed Mode 会在记录结束之前


172
00:05:33,436 --> 00:05:34,886
阻止 Instruments 


173
00:05:34,886 --> 00:05:36,566
分析或显示结果


174
00:05:36,916 --> 00:05:38,326
它还会无视记录最后几秒之前


175
00:05:38,366 --> 00:05:39,466
发生的事件


176
00:05:40,256 --> 00:05:41,176
在你想要记录数据


177
00:05:41,176 --> 00:05:42,416
并在发现问题时停止时


178
00:05:42,466 --> 00:05:43,966
这个模式十分实用


179
00:05:44,676 --> 00:05:45,956
有些模板默认使用这个模式


180
00:05:45,956 --> 00:05:47,286
因为它们会在短时间内


181
00:05:47,286 --> 00:05:49,866
收集大量的数据


182
00:05:51,426 --> 00:05:52,406
现在我已经在 Time Profiler 模板中


183
00:05:52,406 --> 00:05:53,576
完成了一次记录


184
00:05:53,676 --> 00:05:55,336
大量的追踪数据


185
00:05:55,336 --> 00:05:56,686
布满了这个窗口的


186
00:05:56,686 --> 00:05:57,416
各个角落


187
00:05:58,096 --> 00:05:59,656
这可能看起来很复杂


188
00:05:59,656 --> 00:06:00,736
所以我们来分别看看


189
00:06:00,736 --> 00:06:01,866
每个部分都在做什么


190
00:06:03,226 --> 00:06:04,786
在窗口顶端的部分


191
00:06:04,786 --> 00:06:06,266
包含了 Track Viewer（轨道查看器）


192
00:06:06,836 --> 00:06:08,516
一个 Track 会展示与某个事件源相关的


193
00:06:08,516 --> 00:06:10,166
时间序列追踪数据


194
00:06:10,166 --> 00:06:13,496
比如进程 线程 或者 CPU 核心


195
00:06:14,126 --> 00:06:15,696
单个的 Instrument


196
00:06:15,696 --> 00:06:16,716
可能会为多个轨道


197
00:06:16,816 --> 00:06:17,896
提供追踪数据


198
00:06:18,396 --> 00:06:20,806
在这个例子中 我们可以看到三个轨道


199
00:06:21,476 --> 00:06:22,846
最上面的轨道是


200
00:06:22,846 --> 00:06:23,846
Time Profiler Instrument 提供的


201
00:06:23,846 --> 00:06:26,796
一份关于我们 App 系统占用的总结


202
00:06:27,626 --> 00:06:29,166
第二个轨道展示了


203
00:06:29,166 --> 00:06:30,376
从 Points of Interest Instrument


204
00:06:30,456 --> 00:06:31,996
收集来的信息 这一点 Anand 稍后


205
00:06:31,996 --> 00:06:32,956
会为大家讲解


206
00:06:33,266 --> 00:06:34,406
下面的额外轨道


207
00:06:34,406 --> 00:06:36,006
把数据进行进一步的细分


208
00:06:36,726 --> 00:06:39,236
一个 Instrument 的追踪会生成


209
00:06:39,236 --> 00:06:40,466
数十个轨道


210
00:06:41,326 --> 00:06:42,876
你可以用 Track Filter


211
00:06:42,876 --> 00:06:44,296
来让它只显示 Instrument


212
00:06:44,296 --> 00:06:46,576
或者按线程或 CPU 核心细分


213
00:06:47,356 --> 00:06:48,636
你也可以获得更详细的数据


214
00:06:48,636 --> 00:06:51,646
或者按名称来搜索轨道


215
00:06:51,646 --> 00:06:52,886
在窗口的底部


216
00:06:52,886 --> 00:06:54,186
详细视图让你能够


217
00:06:54,286 --> 00:06:56,376
探索选定轨道的追踪信息


218
00:06:56,896 --> 00:06:58,546
在这个例子中


219
00:06:58,546 --> 00:07:00,436
我们选中了 Time Profiler 轨道


220
00:07:00,436 --> 00:07:01,826
我们可以探索追踪过程中


221
00:07:01,826 --> 00:07:02,986
每个线程调用的函数


222
00:07:03,726 --> 00:07:06,026
详细视图的右半部分


223
00:07:06,026 --> 00:07:07,526
你可以在检视器中


224
00:07:07,526 --> 00:07:09,016
找到扩展的详细视图


225
00:07:09,836 --> 00:07:11,506
这个视图可能会提供


226
00:07:11,506 --> 00:07:12,586
来自正在使用的 Instrument 的


227
00:07:12,586 --> 00:07:14,186
更详细的信息


228
00:07:14,186 --> 00:07:15,716
取决于当前情境以及所选项


229
00:07:16,416 --> 00:07:17,886
在这个例子中 由于我


230
00:07:17,886 --> 00:07:19,386
在使用 Time Profiler


231
00:07:19,386 --> 00:07:22,266
我会获得一个最“厚”调用栈的总结


232
00:07:22,746 --> 00:07:24,046
另一个及时监控


233
00:07:24,046 --> 00:07:25,806
当前情况的方式是


234
00:07:25,806 --> 00:07:26,886
通过 Inspection Head（探头）


235
00:07:27,686 --> 00:07:28,586
Inspection Head 是一个


236
00:07:28,586 --> 00:07:30,416
可以被放置在追踪中的


237
00:07:30,556 --> 00:07:32,616
一个特定时间点上的选择器


238
00:07:32,616 --> 00:07:33,646
以此来选中所有


239
00:07:33,646 --> 00:07:36,916
在那个时刻正在发生的事件或间隔


240
00:07:37,256 --> 00:07:38,486
被选中事件的额外细节


241
00:07:38,486 --> 00:07:40,686
会在悬浮标签上显示


242
00:07:41,116 --> 00:07:42,976
详细视图和额外详细视图


243
00:07:42,976 --> 00:07:44,856
会持续更新


244
00:07:44,856 --> 00:07:46,156
来在可用时跟踪


245
00:07:46,156 --> 00:07:47,406
选定事件的信息


246
00:07:48,566 --> 00:07:49,976
我们已经把每个部分过了一遍


247
00:07:49,976 --> 00:07:51,296
现在我们对 Instruments 的


248
00:07:51,296 --> 00:07:53,286
用户界面更加了解了


249
00:07:53,336 --> 00:07:54,866
窗口中展示的所有内容都是


250
00:07:55,116 --> 00:07:56,566
追踪文档的一部分


251
00:07:57,286 --> 00:07:59,046
追踪文档包括


252
00:07:59,046 --> 00:08:00,196
任何为分析工作配置好的 Instruments 


253
00:08:00,196 --> 00:08:01,786
也包括收集到的数据


254
00:08:01,786 --> 00:08:04,656
以及你用于分析结果的视图


255
00:08:05,616 --> 00:08:07,746
Instruments App 能存储


256
00:08:07,746 --> 00:08:08,976
并重新打开这些追踪文档


257
00:08:09,226 --> 00:08:10,536
让你能够探索之前的结果


258
00:08:10,536 --> 00:08:12,216
或者把它们分享给同事


259
00:08:12,216 --> 00:08:13,446
以供研究


260
00:08:13,446 --> 00:08:15,926
接下来 我想邀请


261
00:08:15,926 --> 00:08:16,896
我的同事 Ben Mitchell


262
00:08:16,896 --> 00:08:18,056
来到舞台 他会通过实际操作


263
00:08:18,056 --> 00:08:19,616
来向各位展示一下


264
00:08:19,966 --> 00:08:25,416
谢谢 [掌声]


265
00:08:25,916 --> 00:08:26,446
>> 谢谢 Tibet


266
00:08:26,946 --> 00:08:27,536
Hello World


267
00:08:27,536 --> 00:08:29,036
我的名字是 Ben Mitchell


268
00:08:29,036 --> 00:08:29,926
正如 Tibet 所说 我会


269
00:08:29,926 --> 00:08:31,006
向各位展示如何使用


270
00:08:31,006 --> 00:08:32,405
Instruments 来分析你的 App


271
00:08:33,015 --> 00:08:33,686
我们开始吧


272
00:08:37,275 --> 00:08:38,506
对于你们中部分


273
00:08:38,506 --> 00:08:39,666
看过去年的大会


274
00:08:39,666 --> 00:08:42,176
WWDC2018 的人来说


275
00:08:42,176 --> 00:08:43,496
可能会觉得《Solar System》App 很熟悉


276
00:08:44,145 --> 00:08:45,286
我们大概在一年前上架了它


277
00:08:45,286 --> 00:08:46,036
并从我们的顾客那里收获了


278
00:08:46,036 --> 00:08:47,096
一些正面的反馈


279
00:08:47,636 --> 00:08:49,356
但是 也有一些没那么好的反馈


280
00:08:49,356 --> 00:08:51,606
具体来说 是在性能方面的


281
00:08:51,916 --> 00:08:53,676
我们的顾客报告了一些


282
00:08:53,676 --> 00:08:54,716
响应问题


283
00:08:55,436 --> 00:08:57,086
尤其是在较早的设备上


284
00:08:57,406 --> 00:08:59,036
在会议前 我重现了


285
00:08:59,036 --> 00:09:00,376
其中的一个问题


286
00:09:00,376 --> 00:09:01,606
我想要用 Instruments 向各位展示一下


287
00:09:01,606 --> 00:09:02,716
来看看我们是不是


288
00:09:02,756 --> 00:09:03,466
能够修复它


289
00:09:04,096 --> 00:09:04,846
我们现在就开始吧


290
00:09:06,266 --> 00:09:07,166
现在 App 已经在运行了


291
00:09:07,166 --> 00:09:08,676
我们就直接打开 Instruments 吧


292
00:09:10,616 --> 00:09:11,756
Instruments 的模板选择器


293
00:09:11,756 --> 00:09:13,056
默认选中了 Time Profiler


294
00:09:13,056 --> 00:09:15,406
因为我在之前用过它


295
00:09:15,776 --> 00:09:17,006
Time Profiler 是一个


296
00:09:17,076 --> 00:09:18,336
分析在某个时间窗


297
00:09:18,336 --> 00:09:20,166
发生的问题的绝佳工具


298
00:09:20,596 --> 00:09:22,476
我选择 Time Profiler


299
00:09:22,476 --> 00:09:23,916
然后点按“Choose”按钮


300
00:09:23,916 --> 00:09:24,876
打开一个新的追踪文档


301
00:09:25,406 --> 00:09:27,366
由于我没有从 Xcode 打开它


302
00:09:27,366 --> 00:09:28,326
我要做的第一件事情就是


303
00:09:28,326 --> 00:09:30,826
选择我要追踪的进程


304
00:09:31,656 --> 00:09:32,906
使用目标选取区域


305
00:09:33,436 --> 00:09:36,046
我选择“All Processes”


306
00:09:36,046 --> 00:09:37,146
然后选择正在运行的


307
00:09:37,146 --> 00:09:38,286
“Solar System Mac”App


308
00:09:39,076 --> 00:09:40,796
你可以在右边看到一个数字


309
00:09:40,796 --> 00:09:42,136
那是进程标识符


310
00:09:42,136 --> 00:09:44,006
它会在“活动监视器”中显示


311
00:09:44,176 --> 00:09:47,426
我们已经选中了 App


312
00:09:47,426 --> 00:09:49,356
现在我们点按窗口左上角的


313
00:09:49,356 --> 00:09:50,246
记录按钮


314
00:09:52,336 --> 00:09:53,586
来吧 Instruments 开始记录了


315
00:09:54,606 --> 00:09:55,646
切换到 App 界面


316
00:09:56,796 --> 00:09:58,566
《Solar System》App 支持一系列


317
00:09:58,566 --> 00:10:00,516
触控板上的手势


318
00:10:00,606 --> 00:10:01,986
包括点按拖动


319
00:10:02,346 --> 00:10:04,676
平移 缩放 等等


320
00:10:04,676 --> 00:10:06,696
我们的顾客报告说


321
00:10:06,696 --> 00:10:07,406
他们在使用这些操作时


322
00:10:07,406 --> 00:10:09,156
或者使用 Command-R 


323
00:10:09,156 --> 00:10:11,086
重载数据时


324
00:10:11,286 --> 00:10:12,666
用户界面会卡住


325
00:10:12,666 --> 00:10:14,436
并且会出现一个加载动画


326
00:10:15,036 --> 00:10:16,316
它或者有别的叫法


327
00:10:16,646 --> 00:10:17,616
这并不理想


328
00:10:18,126 --> 00:10:20,576
我们能再现这个问题


329
00:10:20,576 --> 00:10:21,666
所以我们切换回 Instruments


330
00:10:21,726 --> 00:10:22,566
然后看看我们能找到什么


331
00:10:23,416 --> 00:10:24,686
当我退出 App


332
00:10:24,686 --> 00:10:26,426
Instruments 会自动停止记录


333
00:10:26,656 --> 00:10:30,416
我们可以看到这里的追踪数据


334
00:10:30,416 --> 00:10:31,576
我要做的第一件事就是


335
00:10:31,576 --> 00:10:33,046
让它变大一点


336
00:10:33,046 --> 00:10:33,946
这样我们就能看到更多细节了


337
00:10:35,236 --> 00:10:36,296
当光标在跟踪区域上时


338
00:10:36,296 --> 00:10:37,816
用一个缩放手势


339
00:10:37,816 --> 00:10:39,736
就可以放大它


340
00:10:39,736 --> 00:10:40,926
让我们更清楚地看到细节


341
00:10:42,376 --> 00:10:43,786
在跟踪区域的左侧


342
00:10:43,786 --> 00:10:45,386
我们能看到几个 Instrument


343
00:10:45,386 --> 00:10:47,546
向我们提供了轨道


344
00:10:47,956 --> 00:10:49,046
Time Profiler 显示着


345
00:10:49,046 --> 00:10:50,626
CPU 占用的总结


346
00:10:50,986 --> 00:10:51,716
Points of Interest Instrument


347
00:10:51,716 --> 00:10:53,076
目前是空的


348
00:10:53,246 --> 00:10:54,256
Anand 稍后会为你展示这一点


349
00:10:54,366 --> 00:10:55,566
还有很多其他的 Instrument


350
00:10:55,566 --> 00:10:56,796
包括 Thermal State


351
00:10:56,796 --> 00:10:58,436
其他细分信息可以在滚动视图


352
00:10:58,436 --> 00:10:59,066
下方看到 


353
00:11:00,426 --> 00:11:01,986
如果我们把光标移动到


354
00:11:01,986 --> 00:11:04,146
CPU 用量总结轨道


355
00:11:04,146 --> 00:11:05,566
我们可以看到一个悬浮的标签


356
00:11:05,566 --> 00:11:07,126
展示当前的占用状态


357
00:11:08,196 --> 00:11:09,716
当我移动到这个大区域时


358
00:11:09,746 --> 00:11:12,526
会发现占用率超过了 100%


359
00:11:13,206 --> 00:11:13,956
这看起来很可疑


360
00:11:13,956 --> 00:11:15,956
我怀疑这就是重新加载操作


361
00:11:15,956 --> 00:11:17,516
发生的时间


362
00:11:18,076 --> 00:11:19,946
我想把它和一些其他的轨道


363
00:11:19,946 --> 00:11:20,806
放到一起比较


364
00:11:21,026 --> 00:11:21,976
我们要用到一个叫做


365
00:11:21,976 --> 00:11:22,786
Track Pinning 的功能


366
00:11:23,336 --> 00:11:25,956
在窗口左侧


367
00:11:25,956 --> 00:11:27,436
当我把鼠标移动到


368
00:11:27,436 --> 00:11:29,516
某个轨道条目上方时


369
00:11:29,516 --> 00:11:30,666
会出现一个加号按钮


370
00:11:31,956 --> 00:11:34,586
点按它 就可以把它固定到


371
00:11:34,586 --> 00:11:35,866
轨道区域底部


372
00:11:36,646 --> 00:11:37,956
现在我们可以


373
00:11:37,956 --> 00:11:39,536
滚动其他轨道


374
00:11:39,536 --> 00:11:41,016
并排看着我们感兴趣的这条轨道


375
00:11:41,496 --> 00:11:42,846
你可以固定多条轨道


376
00:11:44,246 --> 00:11:45,706
在我们向下滚动的同时


377
00:11:45,706 --> 00:11:46,956
我们可以看到系统中的


378
00:11:46,956 --> 00:11:47,746
每个 CPU 核心都在这里出问题了


379
00:11:48,236 --> 00:11:50,716
我们在这里还有一个


380
00:11:51,046 --> 00:11:52,566
针对进程本身的轨道条目


381
00:11:52,566 --> 00:11:54,006
Solar System Mac


382
00:11:54,006 --> 00:11:55,236
除了 CPU 用量总结


383
00:11:55,236 --> 00:11:56,576
这也向我们展示了


384
00:11:56,576 --> 00:11:57,486
App 生命周期事件


385
00:11:57,816 --> 00:11:58,616
我们可以看到在这里


386
00:11:58,616 --> 00:11:59,486
App 来到了前台


387
00:11:59,486 --> 00:12:01,646
因为那时我在程序坞点按了它


388
00:12:02,516 --> 00:12:04,266
还有一个可疑的红色区域


389
00:12:04,266 --> 00:12:06,926
就在 CPU 用量峰值附近这里


390
00:12:07,836 --> 00:12:09,026
把鼠标移动到上面


391
00:12:09,026 --> 00:12:10,416
可以看到标签上写着“Spinning”


392
00:12:11,756 --> 00:12:12,876
“Spinning”在 Instruments 中


393
00:12:12,876 --> 00:12:14,946
指的是 你的主线程卡住了


394
00:12:15,246 --> 00:12:16,266
在 Mac 上 这就是导致出现


395
00:12:16,266 --> 00:12:17,406
加载动画的原因


396
00:12:17,726 --> 00:12:19,496
主线程只有几个


397
00:12:19,496 --> 00:12:20,626
特别的用处


398
00:12:20,886 --> 00:12:21,806
它应该被用来处理


399
00:12:21,806 --> 00:12:24,316
用户的输入或者更新用户界面


400
00:12:24,766 --> 00:12:25,946
显然 这里有点不太对劲


401
00:12:29,186 --> 00:12:30,896
我想看看主线程


402
00:12:32,286 --> 00:12:35,026
我把 Solar System Mac 这个线程展开


403
00:12:35,866 --> 00:12:37,036
现在可以看到 有好多


404
00:12:37,036 --> 00:12:38,846
其他的轨道


405
00:12:38,846 --> 00:12:40,346
分别代表 App 中的每个线程


406
00:12:40,816 --> 00:12:42,776
一直向下滚动


407
00:12:43,406 --> 00:12:44,196
这就是主线程


408
00:12:44,196 --> 00:12:46,856
主线程出现了一个峰


409
00:12:47,466 --> 00:12:51,746
这看起来就是我想要仔细看看的事件


410
00:12:51,746 --> 00:12:52,886
接下来我们要用到的


411
00:12:52,886 --> 00:12:54,296
Instruments 的功能让我们能够


412
00:12:54,296 --> 00:12:56,166
通过在轨道区域点按和拖动


413
00:12:56,166 --> 00:12:57,616
来过滤事件


414
00:12:58,726 --> 00:12:59,576
现在 底部的详细视图


415
00:12:59,576 --> 00:13:00,826
只显示选定时间窗中


416
00:13:00,866 --> 00:13:02,016
发生的事件


417
00:13:02,896 --> 00:13:03,936
我们来深入看看详细视图


418
00:13:04,066 --> 00:13:05,286
来了解更多


419
00:13:05,856 --> 00:13:09,186
详细视图为我们展现了一个调用图


420
00:13:09,186 --> 00:13:10,266
这些都是我们在


421
00:13:10,266 --> 00:13:12,476
分析时所调用的函数


422
00:13:12,636 --> 00:13:13,586
或者 在这个例子中


423
00:13:13,586 --> 00:13:15,106
是在我们从过滤器选中的时间中


424
00:13:15,796 --> 00:13:18,316
理解这是在做什么很重要


425
00:13:18,316 --> 00:13:21,326
我们并不是在追踪


426
00:13:21,326 --> 00:13:22,776
每个函数的进入和推出


427
00:13:23,366 --> 00:13:24,946
其实 Time Profiler 每秒


428
00:13:24,946 --> 00:13:26,526
会捕获许多次快照


429
00:13:26,706 --> 00:13:28,336
并且记录你的进程中


430
00:13:28,336 --> 00:13:29,726
所有正在运行的函数


431
00:13:30,886 --> 00:13:32,536
所以在左侧


432
00:13:32,536 --> 00:13:33,216
我们有一个等待列


433
00:13:34,476 --> 00:13:37,126
Solar System Mac 在 100% 时间都有出现


434
00:13:37,406 --> 00:13:38,726
这意味着 在每次采样中


435
00:13:38,726 --> 00:13:40,016
Solar System Mac 都出现了


436
00:13:40,356 --> 00:13:41,276
这很好 因为这正是我们


437
00:13:41,276 --> 00:13:42,406
要分析的 App


438
00:13:43,266 --> 00:13:44,336
我们向下继续看


439
00:13:44,336 --> 00:13:47,376
可以看到主线程的出现率为 96.7% 等等


440
00:13:47,826 --> 00:13:49,126
我们继续展开这些线程


441
00:13:49,126 --> 00:13:50,476
来看看我们调用的


442
00:13:50,476 --> 00:13:51,436
更深的函数


443
00:13:52,376 --> 00:13:53,356
但是这里有很多函数


444
00:13:53,596 --> 00:13:54,966
我必须点按很多次


445
00:13:54,966 --> 00:13:56,186
才能找到一些有趣的东西


446
00:13:56,726 --> 00:13:58,736
为此 Instruments 提供了另一个实用的技巧


447
00:13:58,736 --> 00:14:00,606
如果你按住 Option 键


448
00:14:00,846 --> 00:14:01,646
在点按关闭三角形


449
00:14:01,646 --> 00:14:03,096
Instruments 就会自动


450
00:14:03,096 --> 00:14:04,696
展开轨道列表


451
00:14:04,696 --> 00:14:06,166
知道出现控制流分支


452
00:14:06,236 --> 00:14:08,506
因为这可能会是我们想要找的事件


453
00:14:08,506 --> 00:14:10,956
可以看到 这里有非常多


454
00:14:10,956 --> 00:14:12,696
要一直深挖并且精确地


455
00:14:12,696 --> 00:14:14,706
找到你的问题 会十分困难


456
00:14:15,016 --> 00:14:16,866
所以 Instruments 也在


457
00:14:17,216 --> 00:14:18,676
Time Profiler 的扩展详细视图


458
00:14:18,676 --> 00:14:20,466
提供了最厚栈追踪


459
00:14:21,746 --> 00:14:23,266
最厚栈追踪是一个


460
00:14:23,676 --> 00:14:24,496
我们在分析过程中


461
00:14:24,496 --> 00:14:26,836
最常调用的函数集合


462
00:14:27,706 --> 00:14:28,756
所以 在最上方


463
00:14:28,756 --> 00:14:30,396
我们可以看到 Solar System Mac


464
00:14:30,396 --> 00:14:31,536
并且部分帧被


465
00:14:31,536 --> 00:14:32,506
高亮为白色了


466
00:14:33,466 --> 00:14:35,606
这些就是你自己的进程的帧


467
00:14:37,636 --> 00:14:38,616
系统框架或库中的帧


468
00:14:38,616 --> 00:14:40,656
会显示为灰色


469
00:14:41,686 --> 00:14:43,186
所以 主线程执行主函数


470
00:14:43,186 --> 00:14:44,506
然后这里有一块是


471
00:14:44,506 --> 00:14:46,706
系统框架提供的函数


472
00:14:47,276 --> 00:14:50,356
在更下面的这里 我们发现了


473
00:14:50,356 --> 00:14:52,636
另一个高亮函数区域


474
00:14:53,656 --> 00:14:55,416
这里的第一项被标记为“thunk”


475
00:14:56,526 --> 00:14:57,206
那么“thunk”是什么呢


476
00:14:58,136 --> 00:15:00,396
这是一段由编译器生成的帮助代码


477
00:15:00,706 --> 00:15:01,876
它与你 App 中的任何代码


478
00:15:01,876 --> 00:15:03,206
都没有关联


479
00:15:03,656 --> 00:15:05,536
所以在这个例子中 我们可以无视它


480
00:15:06,036 --> 00:15:07,666
我们想要看的是这一个


481
00:15:07,666 --> 00:15:09,466
在网络请求调度程序中的


482
00:15:09,466 --> 00:15:10,906
某个方法中的第一个闭包


483
00:15:12,346 --> 00:15:13,996
如果我点按这一行


484
00:15:13,996 --> 00:15:15,046
它就在详细视图中杯选中了


485
00:15:15,966 --> 00:15:17,576
双击它就会直接在这里


486
00:15:17,576 --> 00:15:18,486
显示它的源代码


487
00:15:19,836 --> 00:15:20,586
所以 可以看到我们有


488
00:15:20,586 --> 00:15:22,226
一个方法叫做 scheduleParsingTask


489
00:15:22,766 --> 00:15:24,056
它在主分发队列中做一些事情


490
00:15:24,056 --> 00:15:26,506
包括数据解析 


491
00:15:26,506 --> 00:15:29,506
它看起来很有问题


492
00:15:29,506 --> 00:15:30,576
之前我们提到过


493
00:15:30,576 --> 00:15:31,516
主线程只应该在


494
00:15:31,516 --> 00:15:33,936
用户输入或更新用户界面的时候使用


495
00:15:34,366 --> 00:15:35,476
所以 我想要修复一下这里


496
00:15:36,006 --> 00:15:37,586
在详细视图的右上角


497
00:15:37,586 --> 00:15:39,636
有一个“在 Xcode 中打开”的按钮


498
00:15:40,286 --> 00:15:40,926
我来点一下


499
00:15:45,576 --> 00:15:47,096
然后 Xcode 就出现了


500
00:15:48,126 --> 00:15:49,976
我想要把这个移动到


501
00:15:49,976 --> 00:15:51,226
它自己的分发队列中


502
00:15:51,226 --> 00:15:52,276
这样它就不会阻碍主线程了


503
00:15:53,276 --> 00:15:54,056
我们首先要做的事情是


504
00:15:54,056 --> 00:15:55,226
创建这个分发队列


505
00:15:55,766 --> 00:15:58,406
我们称之为 parsingQueue


506
00:15:58,616 --> 00:16:00,766
然后 我们把工作移到 parsingQueue 中


507
00:16:00,766 --> 00:16:04,106
通过一个异步闭包来实现


508
00:16:05,226 --> 00:16:06,646
把 workItem() 移上来


509
00:16:07,486 --> 00:16:08,536
我们还想在解析完成之后


510
00:16:08,536 --> 00:16:11,406
通知用户界面


511
00:16:11,886 --> 00:16:13,256
所以 我们把这个调用后面接上


512
00:16:13,256 --> 00:16:16,286
DispatchQueue.main


513
00:16:16,836 --> 00:16:18,486
存储 然后试试再一次


514
00:16:18,486 --> 00:16:19,766
复现我们的 Bug


515
00:16:20,606 --> 00:16:22,256
这一次 我在“Product”菜单中


516
00:16:22,256 --> 00:16:24,576
选择“Profile” 就像 Tibet 之前演示的那样


517
00:16:25,136 --> 00:16:28,726
Xcode 开始构建 App


518
00:16:28,726 --> 00:16:29,776
并唤起 Instruments


519
00:16:30,706 --> 00:16:31,466
模板选择器再一次弹出来了


520
00:16:31,466 --> 00:16:33,036
因为这一次我们不是在测试


521
00:16:33,066 --> 00:16:34,196
这个 App 的下载好的副本


522
00:16:34,196 --> 00:16:35,636
我们在测试


523
00:16:35,636 --> 00:16:36,796
Xcode 已经放到硬盘的


524
00:16:36,846 --> 00:16:38,226
数据路径里的那个


525
00:16:39,526 --> 00:16:41,176
选择“Time Profiler” 


526
00:16:41,326 --> 00:16:42,076
然后点按“Choose”


527
00:16:42,586 --> 00:16:45,956
这一次 我们不用选取目标


528
00:16:45,956 --> 00:16:47,536
因为 Xcode 已经通知了 Instruments


529
00:16:47,536 --> 00:16:48,696
我们想要测试的 App


530
00:16:48,696 --> 00:16:50,116
是哪一个


531
00:16:51,306 --> 00:16:52,976
然后 点按左上角的记录按钮


532
00:16:52,976 --> 00:16:58,756
会让它自动开始运行


533
00:16:58,786 --> 00:17:00,426
切换到 App 我们来试试


534
00:17:00,426 --> 00:17:02,856
那个有问题的用户输入序列


535
00:17:03,716 --> 00:17:07,036
点按 拖动 Command-R


536
00:17:07,386 --> 00:17:10,226
看 这一次没有加载动画了


537
00:17:10,945 --> 00:17:12,366
我们再试一次来确认一下


538
00:17:13,356 --> 00:17:15,425
点按 拖动 Command-R


539
00:17:16,106 --> 00:17:17,996
没有加载动画


540
00:17:18,476 --> 00:17:20,266
所以 我们已经处理了响应问题


541
00:17:21,205 --> 00:17:23,986
停止记录 再次用缩放手势


542
00:17:23,986 --> 00:17:25,626
来展开轨道视图


543
00:17:26,376 --> 00:17:27,746
我想要确认这个工作


544
00:17:27,786 --> 00:17:28,766
已经从主线程移除了


545
00:17:28,766 --> 00:17:30,456
所以我会用轨道过滤器区域


546
00:17:30,456 --> 00:17:32,646
在界面的左上角


547
00:17:33,306 --> 00:17:35,436
然后我们搜索主线程


548
00:17:36,956 --> 00:17:37,896
只出现了一个条目


549
00:17:37,896 --> 00:17:39,706
是 Solar System Mac 的


550
00:17:39,706 --> 00:17:41,516
如果我展开它


551
00:17:41,516 --> 00:17:42,366
可以看到主线程是可见的


552
00:17:43,836 --> 00:17:45,716
在这里 我们 CPU 用量到达峰值的地方


553
00:17:45,716 --> 00:17:47,486
主线程做的事情相对较少


554
00:17:47,486 --> 00:17:48,826
并且在第二个时间区间


555
00:17:49,316 --> 00:17:51,966
也是相同的情况


556
00:17:52,806 --> 00:17:54,076
这样看来 我们似乎已经解决了


557
00:17:54,076 --> 00:17:55,206
响应问题 并且把这个工作


558
00:17:55,206 --> 00:17:56,496
从主线程移除了


559
00:17:57,516 --> 00:18:02,026
[掌声]


560
00:18:02,526 --> 00:18:04,956
我想再谈谈几个分析注意事项


561
00:18:05,616 --> 00:18:07,086
首先 Time Profiler 是一个


562
00:18:07,086 --> 00:18:08,376
理解你的 App 是如何使用时间的


563
00:18:08,376 --> 00:18:09,406
绝佳工具


564
00:18:10,456 --> 00:18:11,846
可能会在有响应问题的时候用的上


565
00:18:11,846 --> 00:18:13,216
比如 加载动画


566
00:18:13,486 --> 00:18:14,566
也可能在你想要


567
00:18:14,566 --> 00:18:15,756
加速 App 的启动


568
00:18:15,806 --> 00:18:16,836
来让它更快地显示在


569
00:18:16,836 --> 00:18:18,156
用户眼前的时候用得上


570
00:18:18,756 --> 00:18:20,266
在这些情况中 请使用 Time Profiler


571
00:18:22,296 --> 00:18:23,386
第二点 如果你遇到了响应问题


572
00:18:23,386 --> 00:18:25,086
看看你的主线程


573
00:18:25,646 --> 00:18:26,636
主线程真的只应该被用来


574
00:18:26,636 --> 00:18:27,936
更新用户界面


575
00:18:27,936 --> 00:18:29,366
或者处理用户输入事件


576
00:18:29,616 --> 00:18:31,656
比如 Mac 上的鼠标点按


577
00:18:31,656 --> 00:18:32,996
或是 iOS 设备上的屏幕轻点


578
00:18:34,516 --> 00:18:36,566
第三点 是我之前没有提到过的


579
00:18:37,286 --> 00:18:38,766
你应该在发布模式中进行分析


580
00:18:39,676 --> 00:18:40,846
编译器支持一系列


581
00:18:40,846 --> 00:18:42,156
不同的优化等级


582
00:18:42,286 --> 00:18:43,116
当你在 Xcode 中进行


583
00:18:43,116 --> 00:18:45,436
构建-运行循环的时候


584
00:18:45,436 --> 00:18:46,766
我们会用一个低等级的优化


585
00:18:46,766 --> 00:18:47,866
来让这个过程更快一些


586
00:18:48,446 --> 00:18:49,666
但这个优化等级


587
00:18:49,666 --> 00:18:50,686
并不是当你用 App Store


588
00:18:50,686 --> 00:18:52,526
或 Xcode 的存档功能


589
00:18:52,526 --> 00:18:54,316
把 App 递交给用户时所用的


590
00:18:54,766 --> 00:18:57,736
如果你在使用 Xcode 的默认配置


591
00:18:57,736 --> 00:18:59,756
在你的方法下的分析 


592
00:18:59,756 --> 00:19:02,646
会被设置为发布配置


593
00:19:03,286 --> 00:19:04,316
然而 如果你在用


594
00:19:04,316 --> 00:19:05,936
自定义编译选项 请确保


595
00:19:05,936 --> 00:19:07,476
你在分析的 App 正在使用


596
00:19:07,476 --> 00:19:08,916
编译选项的发布工具集


597
00:19:10,596 --> 00:19:12,116
最后 使用不同负荷


598
00:19:12,116 --> 00:19:13,426
或在较早设备上进行分析


599
00:19:13,426 --> 00:19:14,416
十分重要


600
00:19:14,876 --> 00:19:16,236
在这个例子中


601
00:19:16,236 --> 00:19:18,566
我们没有在我们的设备上发现这个 Bug


602
00:19:18,566 --> 00:19:19,766
但是拥有不同性能特征设备的用户


603
00:19:19,766 --> 00:19:22,226
确实遇到了这个 Bug


604
00:19:22,866 --> 00:19:24,216
所以 如果你有较早的设备


605
00:19:24,216 --> 00:19:27,226
请确保在它们上面也进行测试


606
00:19:27,916 --> 00:19:29,696
Tibet 之前提到过


607
00:19:29,816 --> 00:19:31,456
Instruments 支持所有平台


608
00:19:31,776 --> 00:19:33,396
我们用 Mac 进行了展示


609
00:19:33,396 --> 00:19:35,496
但是在 iOS watchOS 和 tvOS 上


610
00:19:35,626 --> 00:19:37,016
也同样可以使用它


611
00:19:37,766 --> 00:19:39,496
它也支持模拟器


612
00:19:39,686 --> 00:19:41,116
但是说到模拟器


613
00:19:41,116 --> 00:19:42,256
有一点请大家务必了解


614
00:19:43,266 --> 00:19:45,596
它是在你的 Mac 上运行的


615
00:19:45,596 --> 00:19:47,906
这意味着它有着你的 Mac 的资源


616
00:19:48,856 --> 00:19:51,636
它有你 Mac 的 CPU 和内存的性能特征


617
00:19:51,926 --> 00:19:54,876
它有着你 Mac 的文件系统行为和硬盘行为


618
00:19:55,216 --> 00:19:56,776
它还有这你 Mac 的散热限制


619
00:19:57,046 --> 00:19:58,186
这一点当然会和


620
00:19:58,186 --> 00:19:59,326
轻巧的一体化设备


621
00:19:59,326 --> 00:20:00,996
有重大差异


622
00:20:01,956 --> 00:20:03,066
在这个例子中 Instruments 非常适合用来


623
00:20:03,066 --> 00:20:04,276
观测趋势 比如


624
00:20:04,366 --> 00:20:06,256
有没有什么东西变快了或者变慢了


625
00:20:06,876 --> 00:20:08,306
但是它不会给你提供


626
00:20:08,306 --> 00:20:10,106
精确到秒的模拟


627
00:20:10,106 --> 00:20:11,836
来告诉你 App 会怎样运行


628
00:20:12,366 --> 00:20:13,626
在把 App 递交到你顾客手上之前


629
00:20:13,626 --> 00:20:15,406
请确保在实体硬件上进行测试


630
00:20:16,516 --> 00:20:17,866
所以 我们刚刚解决了响应问题


631
00:20:17,866 --> 00:20:20,206
但是这并不是全部的问题


632
00:20:20,526 --> 00:20:21,646
我们的 CPU 用量还有一个很大的峰


633
00:20:21,686 --> 00:20:24,326
看起来是我们应该能削减它


634
00:20:25,536 --> 00:20:27,186
CPU 用量会榨干电池容量


635
00:20:27,526 --> 00:20:29,106
它会升高设备的温度


636
00:20:29,106 --> 00:20:30,766
在很多 Mac 上 会导致


637
00:20:30,766 --> 00:20:32,406
风扇加速运转 让你的用户感到烦躁


638
00:20:33,206 --> 00:20:34,856
所以 现在我想邀请


639
00:20:34,956 --> 00:20:36,836
Anand 用 Signpost 功能


640
00:20:36,836 --> 00:20:38,206
来帮助我们深入了解


641
00:20:38,206 --> 00:20:39,326
我们的 App 到底在做什么


642
00:20:41,516 --> 00:20:44,376
[掌声]


643
00:20:44,876 --> 00:20:45,376
>> 谢谢 Ben


644
00:20:46,446 --> 00:20:47,186
大家早上好


645
00:20:48,236 --> 00:20:49,786
今天我想向你们展示如何在


646
00:20:49,786 --> 00:20:52,496
代码中使用 Signpost 


647
00:20:52,496 --> 00:20:53,786
来增强 Instruments


648
00:20:53,786 --> 00:20:55,706
从中收集的追踪 并更好地理解


649
00:20:55,816 --> 00:20:58,626
你的代码时如何使用系统资源的


650
00:21:01,016 --> 00:21:03,206
我们首先通过与


651
00:21:03,206 --> 00:21:05,776
我们用 Time Profiler 所做的事情


652
00:21:05,806 --> 00:21:07,916
进行对比 来更好地理解 Signpost


653
00:21:08,836 --> 00:21:10,176
Time Profiler 构建了一个


654
00:21:10,506 --> 00:21:12,686
你的代码的统计分析


655
00:21:12,686 --> 00:21:15,396
它是通过在一个固定时间间隔内


656
00:21:15,396 --> 00:21:16,786
观测你的 App 中所有的线程


657
00:21:16,786 --> 00:21:18,756
并且构建出时间和调用栈的相关分析


658
00:21:18,756 --> 00:21:21,526
来实现这一点的


659
00:21:22,336 --> 00:21:23,796
但是 相关分析并不能


660
00:21:23,796 --> 00:21:25,636
取代精准评估


661
00:21:25,746 --> 00:21:26,876
告诉你你的代码


662
00:21:26,986 --> 00:21:28,946
是怎样执行的 以及为什么会执行


663
00:21:30,116 --> 00:21:31,326
可能会有一块代码


664
00:21:31,636 --> 00:21:33,746
在几个时间点爆发性地执行


665
00:21:34,456 --> 00:21:37,066
或者 它在几个更长的时间段内


666
00:21:37,066 --> 00:21:37,916
持续执行


667
00:21:38,736 --> 00:21:39,986
在某些特定 Argument 上


668
00:21:39,986 --> 00:21:41,636
调用的某个函数


669
00:21:42,056 --> 00:21:44,096
也可能会让 CPU 持续繁忙


670
00:21:45,136 --> 00:21:46,386
为了区分这几种


671
00:21:46,386 --> 00:21:48,326
执行模式 你需要记录


672
00:21:48,326 --> 00:21:50,686
代码的精确评估


673
00:21:50,896 --> 00:21:53,316
这就引出了一个问题


674
00:21:53,856 --> 00:21:55,276
你能操作的


675
00:21:55,276 --> 00:21:57,156
记录性能测量的最好方式是什么


676
00:21:58,236 --> 00:21:59,946
我很开心地告诉你


677
00:21:59,946 --> 00:22:00,906
你不需要担心


678
00:22:00,906 --> 00:22:02,496
要去打印代码


679
00:22:02,496 --> 00:22:04,506
并教会 Instruments 如何读取你的打印命令


680
00:22:05,096 --> 00:22:06,736
你只需要使用 Signpost


681
00:22:08,236 --> 00:22:10,036
Signpost 有大量在这个用例下


682
00:22:10,036 --> 00:22:12,166
十分理想的功能


683
00:22:12,646 --> 00:22:17,346
它是专门为记录有结构的性能数据打造的


684
00:22:17,766 --> 00:22:19,286
所以 在这种情况下


685
00:22:19,286 --> 00:22:21,136
它甚至比打印还要简单高效


686
00:22:21,716 --> 00:22:25,706
它提供了对评估时间的内建支持


687
00:22:26,036 --> 00:22:26,966
所以 你不需要担心


688
00:22:26,966 --> 00:22:28,516
你在读取的时钟源


689
00:22:28,516 --> 00:22:30,016
或是你正在使用什么时钟基准


690
00:22:30,016 --> 00:22:30,596
来进行评估


691
00:22:31,546 --> 00:22:33,666
关于 Signpost 我最喜欢的部分是


692
00:22:33,776 --> 00:22:36,656
Instruments 知道如何追踪它


693
00:22:37,056 --> 00:22:38,186
让我来给你一个简单的预览


694
00:22:38,186 --> 00:22:39,706
看看在代码中加入 Signpost 间隔后


695
00:22:39,706 --> 00:22:41,666
我收集到的 Instruments 的追踪


696
00:22:41,666 --> 00:22:44,756
是什么样子的


697
00:22:44,946 --> 00:22:46,236
这里高亮的是


698
00:22:46,236 --> 00:22:47,836
“Points of Interest”轨道


699
00:22:47,836 --> 00:22:49,516
它展示了与某个


700
00:22:49,516 --> 00:22:52,076
我在代码中加入的 Signpost


701
00:22:52,076 --> 00:22:53,226
相关的重点区域


702
00:22:54,226 --> 00:22:55,736
让我来给你们


703
00:22:55,736 --> 00:22:57,996
具体演示一下 接着刚刚


704
00:22:57,996 --> 00:23:03,686
Ben 对《Solar System》App 的研究


705
00:23:04,056 --> 00:23:06,996
这是刚才的 Instruments 追踪


706
00:23:06,996 --> 00:23:11,036
我们看到了这一块


707
00:23:14,176 --> 00:23:17,086
熟悉的高 CPU 占用区域


708
00:23:17,656 --> 00:23:20,536
我们想弄清楚为什么


709
00:23:20,596 --> 00:23:22,566
我们用了这么多 CPU 时间


710
00:23:22,566 --> 00:23:23,976
所以我们来向代码中使用最多


711
00:23:24,056 --> 00:23:26,066
CPU 时间的部分添加一些 Signpost


712
00:23:26,856 --> 00:23:28,726
让我来看看厚栈的追踪


713
00:23:32,576 --> 00:23:34,676
之前 Ben 从上往下


714
00:23:34,676 --> 00:23:36,676
看了这个厚栈


715
00:23:36,676 --> 00:23:39,746
所以我们发现了


716
00:23:39,746 --> 00:23:41,896
代码是如何在主线程开始执行的


717
00:23:42,826 --> 00:23:44,276
这一次 我想要从


718
00:23:44,276 --> 00:23:45,716
叶级函数开始


719
00:23:45,716 --> 00:23:51,046
来了解这个负载中最耗资源


720
00:23:51,046 --> 00:23:53,416
或是最常被调用的函数是什么


721
00:23:54,366 --> 00:23:55,366
这里有一个叫做 setupScene() 的东西


722
00:23:55,366 --> 00:23:58,416
看起来在处理很多数组


723
00:23:58,736 --> 00:24:00,236
它是这个重新加载的操作中的一部分


724
00:24:00,566 --> 00:24:02,636
我想要看看


725
00:24:02,636 --> 00:24:05,246
它究竟使用了多少时间


726
00:24:05,926 --> 00:24:11,906
所以我们去 Xcode 里看看这段代码吧


727
00:24:12,086 --> 00:24:13,306
这里是 setupScene() 函数


728
00:24:13,956 --> 00:24:15,466
你可以在这里看到


729
00:24:15,466 --> 00:24:17,326
我之前尝试记录


730
00:24:17,326 --> 00:24:18,456
性能评估的痕迹


731
00:24:18,786 --> 00:24:19,806
这里有一个打印命令


732
00:24:20,056 --> 00:24:21,606
在函数的开始发出


733
00:24:21,606 --> 00:24:22,816
mach_absolute_time()


734
00:24:23,376 --> 00:24:24,806
我们滚动到函数底部


735
00:24:24,806 --> 00:24:25,796
可以看到另一个打印命令


736
00:24:26,546 --> 00:24:28,086
在结束的时候


737
00:24:28,086 --> 00:24:30,836
再一次显示 mach_absolute_time()


738
00:24:31,526 --> 00:24:32,726
正如我之前提到过的


739
00:24:33,416 --> 00:24:35,366
Instruments 并不知道如何


740
00:24:35,366 --> 00:24:36,156
读取打印命令


741
00:24:36,346 --> 00:24:40,136
所以我们首先需要创建一个


742
00:24:40,136 --> 00:24:41,226
记录句柄 让我们能够


743
00:24:41,226 --> 00:24:42,386
与 Instruments 进行通讯


744
00:24:43,106 --> 00:24:45,046
我们来创建吧


745
00:24:46,316 --> 00:24:48,026
我用一个叫做


746
00:24:48,026 --> 00:24:49,326
pointsOfInterest 的类别


747
00:24:49,326 --> 00:24:49,726
创建这个记录句柄


748
00:24:50,186 --> 00:24:51,826
这个名字与


749
00:24:51,826 --> 00:24:53,546
Points of Interest 这个 Instrument 相关


750
00:24:55,166 --> 00:24:58,306
我们来用一个对


751
00:24:58,306 --> 00:25:00,046
os_signpost API 的调用


752
00:25:00,046 --> 00:25:03,106
来取代我们的第一个打印命令


753
00:25:03,106 --> 00:25:03,536
它会开启一个间隔


754
00:25:04,556 --> 00:25:05,616
每次你开启一个间隔的时候


755
00:25:05,616 --> 00:25:07,686
都要记得结束它


756
00:25:08,876 --> 00:25:10,196
与其一直向下滚动到


757
00:25:10,196 --> 00:25:11,706
函数的结尾


758
00:25:11,986 --> 00:25:13,376
我会选择利用 Swift 的 defer 代码块


759
00:25:13,486 --> 00:25:16,166
来结束这个间隔


760
00:25:16,756 --> 00:25:17,876
defer 代码块中的内容


761
00:25:17,876 --> 00:25:23,026
会在当前函数结尾执行


762
00:25:23,226 --> 00:25:24,716
在进行了这些修改之后


763
00:25:24,716 --> 00:25:26,196
我们来构建我们的 App


764
00:25:26,196 --> 00:25:27,606
并在菜单中使用“Profile”命令


765
00:25:27,606 --> 00:25:28,466
在 Instruments 中对它进行分析


766
00:25:33,056 --> 00:25:34,666
我们再一次选择


767
00:25:34,666 --> 00:25:37,736
Time Profiler 模板


768
00:25:37,896 --> 00:25:39,096
目标选择区域


769
00:25:39,096 --> 00:25:40,726
已经被 Xcode 用当前的


770
00:25:40,726 --> 00:25:41,486
《Solar System》App 的


771
00:25:41,486 --> 00:25:42,826
构建版本填充了


772
00:25:43,106 --> 00:25:43,966
我们开始记录吧


773
00:25:48,856 --> 00:25:51,256
我会和 App 进行交互


774
00:25:51,476 --> 00:25:52,716
并且再一次采用那个


775
00:25:52,716 --> 00:25:54,236
会引发问题的操作序列


776
00:25:54,236 --> 00:25:54,826
重新加载


777
00:25:57,766 --> 00:25:59,646
然后我们收集到了一些数据


778
00:25:59,686 --> 00:26:00,746
停止记录


779
00:26:01,266 --> 00:26:04,676
我们来放大看看那个


780
00:26:04,676 --> 00:26:06,856
高 CPU 占用区域


781
00:26:10,186 --> 00:26:11,756
在 Time Profiler 下面


782
00:26:12,136 --> 00:26:13,656
Points of Interest 轨道


783
00:26:13,956 --> 00:26:16,156
现在已经被


784
00:26:16,156 --> 00:26:17,546
我们在代码中加入的


785
00:26:17,546 --> 00:26:18,346
重点区域填充了


786
00:26:18,856 --> 00:26:20,096
有一行叫做 setupScene


787
00:26:20,096 --> 00:26:21,836
这与我们的 Signpost 间隔相关


788
00:26:21,836 --> 00:26:23,596
并且这里还有几个


789
00:26:23,596 --> 00:26:25,976
相邻的重点区域


790
00:26:25,976 --> 00:26:28,286
在轨道中被记录了下来


791
00:26:29,486 --> 00:26:32,016
我预期不会有这么多 而是几个


792
00:26:32,886 --> 00:26:34,926
我可以把鼠标悬浮在它们上面


793
00:26:34,926 --> 00:26:37,086
并且数一数有多少个重点区域


794
00:26:37,456 --> 00:26:39,486
或者我可以利用详细视图


795
00:26:40,876 --> 00:26:41,966
让我来点按并拖动来


796
00:26:41,966 --> 00:26:43,836
选择这一个区域


797
00:26:44,656 --> 00:26:45,906
然后在 Points of Interest 轨道中


798
00:26:45,906 --> 00:26:47,766
点按来重新以


799
00:26:47,766 --> 00:26:50,646
Points of Interest 轨道的总结


800
00:26:50,646 --> 00:26:54,186
填充详细视图


801
00:26:54,376 --> 00:26:55,966
仔细看看 我发现


802
00:26:55,966 --> 00:26:57,406
setupScene 在这个区域


803
00:26:57,406 --> 00:26:59,596
一共发生了 8 次


804
00:27:00,156 --> 00:27:05,606
每次耗时大概 200 毫秒


805
00:27:05,806 --> 00:27:07,726
详细视图中有更多可用的信息


806
00:27:08,006 --> 00:27:09,956
我们来点按跳转栏


807
00:27:09,956 --> 00:27:12,226
并选择一个重点区域的列表


808
00:27:12,226 --> 00:27:13,946
来看看在这个追踪中


809
00:27:13,946 --> 00:27:15,706
录制的每个重点区域的


810
00:27:15,706 --> 00:27:17,466
完整时间序列


811
00:27:18,016 --> 00:27:21,446
“Duration”列展示了


812
00:27:21,446 --> 00:27:24,216
它们中每一个的持续时间


813
00:27:24,216 --> 00:27:27,776
我可以看到每一个间隔


814
00:27:27,776 --> 00:27:28,986
都花费了差不多的时间来完成


815
00:27:28,986 --> 00:27:34,756
大概 210 到 220 毫秒


816
00:27:35,576 --> 00:27:37,046
这有些让人头大


817
00:27:37,196 --> 00:27:39,306
难道我们在不断重复一个


818
00:27:39,306 --> 00:27:43,336
工作量差不多的事情


819
00:27:43,526 --> 00:27:45,306
我们看看是谁在调用 setupScene


820
00:27:45,306 --> 00:27:46,596
判断一下是不是出于某种原因


821
00:27:46,596 --> 00:27:48,296
它被多余地调用了


822
00:27:48,436 --> 00:27:50,726
做这件事情最好的方式就是


823
00:27:50,726 --> 00:27:51,926
查看 Time Profiler


824
00:27:51,926 --> 00:27:53,716
记录的调用图中的信息


825
00:27:54,266 --> 00:27:57,216
我们再来看看窗口右下角的


826
00:27:57,216 --> 00:27:59,476
厚栈的视图


827
00:27:59,476 --> 00:28:01,446
这一次我们要关注


828
00:28:01,446 --> 00:28:03,156
setupScene() 的调用者


829
00:28:03,156 --> 00:28:04,476
是一个叫做 prepareScene() 的函数


830
00:28:05,486 --> 00:28:07,536
双击它来显示源代码


831
00:28:08,946 --> 00:28:10,946
看起来 prepareScene()


832
00:28:10,946 --> 00:28:12,776
Scene called Setup Scene


833
00:28:12,776 --> 00:28:13,276
只调用了 setupScene() 一次


834
00:28:13,476 --> 00:28:15,786
所以这不是造成重复调用的根本原因


835
00:28:16,626 --> 00:28:17,996
要复现完成的调用图


836
00:28:17,996 --> 00:28:20,746
我们来点按跳转区域的“Root”


837
00:28:20,746 --> 00:28:22,956
这会把我们带到调用图的根


838
00:28:24,326 --> 00:28:28,506
我们继续在厚栈上向上看


839
00:28:29,096 --> 00:28:34,086
选择下一个调用者


840
00:28:34,266 --> 00:28:35,766
这里我们可以看到一个 for 循环


841
00:28:35,766 --> 00:28:37,136
它很可能就是我们看到的


842
00:28:37,136 --> 00:28:38,336
重复调用的罪魁祸首


843
00:28:39,176 --> 00:28:40,296
我们在 Xcode 中打开这段代码


844
00:28:40,326 --> 00:28:43,176
仔细看看


845
00:28:43,526 --> 00:28:47,006
点按这个按钮来跳转到 Xcode 中的文件


846
00:28:51,716 --> 00:28:55,366
现在我们能在 Xcode 中看到这个 for 循环了


847
00:28:56,486 --> 00:28:57,526
我记得这个函数


848
00:28:58,116 --> 00:28:59,306
updateWithPlanets() 的目的是


849
00:28:59,366 --> 00:29:03,166
接受服务器发送给我们的数据


850
00:29:03,166 --> 00:29:04,516
它是重新加载操作的一部分


851
00:29:05,156 --> 00:29:07,516
然后 当有更新需求的时候


852
00:29:07,516 --> 00:29:12,246
对于每个有新数据的行星


853
00:29:12,246 --> 00:29:14,026
在 App 中更新它的内部模型


854
00:29:15,486 --> 00:29:17,816
然而 我们可能会收到


855
00:29:17,816 --> 00:29:19,246
一包对于多个行星的


856
00:29:19,246 --> 00:29:20,526
更新信息数据


857
00:29:20,526 --> 00:29:22,596
看起来我们在


858
00:29:22,596 --> 00:29:24,266
遇到每个需要更新的行星时


859
00:29:24,266 --> 00:29:26,156
都会调用 prepareScene()


860
00:29:26,156 --> 00:29:28,726
来重绘整个视图


861
00:29:30,256 --> 00:29:32,586
追踪向我们展示了


862
00:29:32,776 --> 00:29:35,316
如果我们只更新


863
00:29:35,316 --> 00:29:39,326
行星的内部模型


864
00:29:39,326 --> 00:29:40,576
那么消耗的资源会大大降低


865
00:29:40,986 --> 00:29:42,606
所以 我们在这里应该做的事情是


866
00:29:42,866 --> 00:29:44,316
把我们所有的更新打包


867
00:29:44,316 --> 00:29:46,806
放到内部模型中


868
00:29:47,136 --> 00:29:49,016
并且只在所有更新完成后


869
00:29:49,206 --> 00:29:50,846
重绘一次场景


870
00:29:51,976 --> 00:29:53,266
这看起来是一个非常简单的修复


871
00:29:53,266 --> 00:29:56,076
但是以我们的经验来看


872
00:29:56,076 --> 00:29:57,616
在我们添加新功能


873
00:29:57,616 --> 00:29:59,166
或者修复不相关的 Bug 的时候


874
00:29:59,376 --> 00:30:01,166
大量这种类型的性能问题


875
00:30:01,166 --> 00:30:03,146
都可能会溜进我们的代码中


876
00:30:03,606 --> 00:30:05,536
要避免这种 Bug


877
00:30:05,536 --> 00:30:07,016
呈现在我们的顾客面前


878
00:30:07,016 --> 00:30:09,156
一个很好的办法是写一个


879
00:30:09,156 --> 00:30:10,856
能够周期性地检查它们的功能的测试


880
00:30:11,846 --> 00:30:12,836
为了节约时间


881
00:30:12,836 --> 00:30:15,406
我已经写好了一个 XCTest


882
00:30:15,406 --> 00:30:17,206
它会检查 App 的重新加载功能


883
00:30:18,666 --> 00:30:19,926
如果我们点按测试左边的这个按钮


884
00:30:19,926 --> 00:30:23,296
通常它会直接运行测试


885
00:30:23,416 --> 00:30:24,886
但是我想通过辅助点按


886
00:30:24,886 --> 00:30:26,526
来显示 Profile 动作


887
00:30:27,266 --> 00:30:29,106
这会命令 Xcode 去在


888
00:30:29,106 --> 00:30:31,326
Instruments 中构建并运行测试


889
00:30:36,256 --> 00:30:37,746
我们来选择 Time Profiler 模板


890
00:30:37,746 --> 00:30:40,456
并开始记录追踪


891
00:30:41,016 --> 00:30:45,706
在这个测试中 我已经把重新加载操作


892
00:30:45,706 --> 00:30:48,946
放到了一个对 Measure API 的调用各种


893
00:30:49,706 --> 00:30:51,566
Measure API 会多次运行工作负载


894
00:30:51,566 --> 00:30:55,376
来收集一些重复的评估


895
00:30:56,186 --> 00:30:57,356
这非常有帮助


896
00:30:57,356 --> 00:30:58,866
可以让你知道你的评估


897
00:30:58,866 --> 00:31:00,296
是可重复且一致的


898
00:31:00,296 --> 00:31:02,996
还是每次运行都会得到不同的结果


899
00:31:04,466 --> 00:31:05,496
看起来所有的重复都停止了


900
00:31:05,496 --> 00:31:08,396
所以我可以停止追踪了


901
00:31:08,936 --> 00:31:11,926
我来放大看看


902
00:31:11,926 --> 00:31:13,616
重点轨道的内容


903
00:31:14,256 --> 00:31:17,446
我们可以看到这里有一个额外的行


904
00:31:21,046 --> 00:31:21,976
最底下是我之前在代码中加入的


905
00:31:21,976 --> 00:31:24,056
setupScene 间隔


906
00:31:24,106 --> 00:31:27,386
在它上面是


907
00:31:27,386 --> 00:31:28,516
另一个我们感兴趣的部分


908
00:31:28,516 --> 00:31:30,056
由 Measure API 提供


909
00:31:30,676 --> 00:31:32,976
这向我们展示了


910
00:31:32,976 --> 00:31:34,526
与每次运行工作负载的迭代


911
00:31:34,906 --> 00:31:36,106
相关联的间隔


912
00:31:38,146 --> 00:31:39,246
一眼扫过去


913
00:31:39,246 --> 00:31:41,606
我觉得工作负载


914
00:31:41,606 --> 00:31:42,976
在每次运行时的行为


915
00:31:42,976 --> 00:31:44,226
都差不多


916
00:31:44,626 --> 00:31:45,806
所以 我只想知道


917
00:31:45,806 --> 00:31:49,136
每次测试的迭代都发生了什么


918
00:31:50,146 --> 00:31:51,186
除了点按并拖动


919
00:31:51,186 --> 00:31:52,616
其实还有一个方便的快捷键


920
00:31:52,616 --> 00:31:53,746
让你能够精确地选中


921
00:31:53,746 --> 00:31:55,606
与一个轨道中的事件或间隔


922
00:31:55,606 --> 00:31:58,246
相关的区域


923
00:31:58,716 --> 00:31:59,546
只需要三次点按即可


924
00:32:00,106 --> 00:32:02,456
这会把详细视图


925
00:32:02,456 --> 00:32:04,396
用选中的特定信息填充


926
00:32:06,156 --> 00:32:09,336
仔细看看 现在似乎


927
00:32:09,936 --> 00:32:13,566
只有一次对 setupScene() 的调用了


928
00:32:13,566 --> 00:32:14,256
这意味着什么呢？


929
00:32:14,726 --> 00:32:19,276
我们使用从 Signpost 获取的信息


930
00:32:19,276 --> 00:32:21,876
把我们所用的 CPU 时间减少了几个数量级


931
00:32:23,516 --> 00:32:27,500
[掌声]


932
00:32:31,796 --> 00:32:32,926
让我们来复习一下


933
00:32:32,926 --> 00:32:34,176
我们刚刚遇到的概念


934
00:32:34,766 --> 00:32:38,496
从 Time Profiler 或者其他地方


935
00:32:38,496 --> 00:32:41,556
收集到的统计分析十分有用


936
00:32:41,556 --> 00:32:43,936
它能展示那些代码被最频繁地执行


937
00:32:44,496 --> 00:32:46,286
但是这并不能替代


938
00:32:46,286 --> 00:32:48,756
类似我们用 Signpost API 记录的评估


939
00:32:48,756 --> 00:32:51,746
因为它能告诉你 你的代码


940
00:32:51,746 --> 00:32:53,756
是怎样被执行的 以及为什么会被执行


941
00:32:54,946 --> 00:32:56,546
我们还看到了


942
00:32:56,546 --> 00:32:59,456
运行测试是多么有帮助


943
00:32:59,456 --> 00:33:00,906
它能稳定且反复地复现


944
00:33:00,906 --> 00:33:03,156
我们的工作负载


945
00:33:03,446 --> 00:33:04,646
并在开发循环的早期


946
00:33:04,646 --> 00:33:05,456
就经常分析它


947
00:33:07,256 --> 00:33:09,076
今天 我们深入探索了


948
00:33:09,076 --> 00:33:10,656
会导致很高


949
00:33:10,656 --> 00:33:12,036
或不合理的系统占用的


950
00:33:12,036 --> 00:33:15,276
性能问题


951
00:33:16,016 --> 00:33:17,506
Instruments 还有大量的模板


952
00:33:17,506 --> 00:33:19,276
可以解决其他


953
00:33:19,276 --> 00:33:20,516
关于资源占用的


954
00:33:20,516 --> 00:33:22,016
性能问题


955
00:33:22,746 --> 00:33:25,456
我们有为文件和磁盘占用而设计的模板


956
00:33:26,286 --> 00:33:29,106
我们还有为网络占用设计的模板


957
00:33:29,306 --> 00:33:30,336
还有一个模板


958
00:33:30,826 --> 00:33:32,036
可以帮助你理解


959
00:33:32,036 --> 00:33:33,006
你的 App 和操作系统或


960
00:33:33,006 --> 00:33:34,506
其他系统中运行的进程


961
00:33:34,506 --> 00:33:37,136
之间的关系


962
00:33:37,796 --> 00:33:38,876
这还不是全部


963
00:33:39,806 --> 00:33:40,776
Instruments 还有一些


964
00:33:40,776 --> 00:33:42,726
十分高级的功能


965
00:33:42,726 --> 00:33:43,176
自定义 Instruments


966
00:33:43,426 --> 00:33:45,076
如果你是一个框架开发者


967
00:33:45,076 --> 00:33:46,386
想要你使用你 API 的客户


968
00:33:46,956 --> 00:33:49,006
能够解决关于性能问题


969
00:33:49,006 --> 00:33:50,116
他们使用你的框架时的


970
00:33:50,116 --> 00:33:51,126
性能问题


971
00:33:51,126 --> 00:33:53,946
那么你可以向他们


972
00:33:53,946 --> 00:33:57,176
提供一个自定义 Instruments 包


973
00:33:57,716 --> 00:34:00,566
你也可以创建自定义 Instruments 模板


974
00:34:00,606 --> 00:34:03,806
来在 Instruments App 中构造


975
00:34:03,806 --> 00:34:08,436
一个独特的 Instruments 集合


976
00:34:08,436 --> 00:34:10,326
来帮助解决某个特定的性能问题


977
00:34:12,456 --> 00:34:13,966
在这个演示之后


978
00:34:14,326 --> 00:34:15,556
我真的希望你们开始


979
00:34:15,556 --> 00:34:17,676
在开发循环的早期


980
00:34:17,676 --> 00:34:19,176
就经常分析你的代码


981
00:34:19,716 --> 00:34:22,476
请在今天就去试试我们的 Instruments 11 吧


982
00:34:22,835 --> 00:34:24,235
它附带了一些很棒的新功能


983
00:34:24,235 --> 00:34:26,496
比如轨道固定


984
00:34:26,775 --> 00:34:28,255
和结构视图


985
00:34:28,255 --> 00:34:29,835
我相信它们用起来会十分有趣


986
00:34:30,416 --> 00:34:33,306
在会议笔记中


987
00:34:33,306 --> 00:34:34,516
我们有关于进阶功能和


988
00:34:34,516 --> 00:34:36,025
针对特定事件的


989
00:34:36,025 --> 00:34:38,116
Instruments 工作流的详细文档


990
00:34:38,116 --> 00:34:39,706
还有一些前几年大会中的


991
00:34:39,706 --> 00:34:42,735
很棒的讲解 非常感谢


992
00:34:43,516 --> 00:34:49,505
[掌声]

