1
00:00:01,176 --> 00:00:06,516
[音乐]


2
00:00:07,516 --> 00:00:11,906
[掌声和欢呼]


3
00:00:12,406 --> 00:00:13,346
>> 大家下午好


4
00:00:14,286 --> 00:00:15,266
我叫 Harlan


5
00:00:15,266 --> 00:00:16,966
我非常高兴能和


6
00:00:16,966 --> 00:00:19,296
你们讨论 Xcode 11 是如何允许


7
00:00:19,296 --> 00:00:20,886
你们在 Swift 中创建和分发


8
00:00:21,156 --> 00:00:22,896
二进制框架的


9
00:00:24,126 --> 00:00:25,376
在讨论二进制框架之前


10
00:00:25,376 --> 00:00:26,856
我想先花点时间


11
00:00:26,856 --> 00:00:29,106
谈谈 Swift 包


12
00:00:30,196 --> 00:00:31,386
借助 Xcode 11 中


13
00:00:31,386 --> 00:00:33,926
对 Swift 包的新支持


14
00:00:33,926 --> 00:00:35,616
你们可以轻松地在项目中


15
00:00:35,616 --> 00:00:38,136
创建和使用它们并将其分发给其他人


16
00:00:38,586 --> 00:00:41,196
Swift 包是


17
00:00:41,196 --> 00:00:42,416
分发代码的好方法


18
00:00:42,756 --> 00:00:43,956
因为 Xcode 知道如何


19
00:00:43,956 --> 00:00:45,746
管理它们的依赖关系


20
00:00:45,746 --> 00:00:47,696
它会自动找出


21
00:00:47,696 --> 00:00:49,626
要使用的包版本


22
00:00:50,236 --> 00:00:52,346
由于它们是以


23
00:00:52,346 --> 00:00:54,716
源代码形式进行分发的


24
00:00:54,716 --> 00:00:56,396
因此无需保持


25
00:00:56,396 --> 00:00:57,946
与客户端的二进制兼容性


26
00:00:58,676 --> 00:01:00,536
如果你有能力


27
00:01:00,716 --> 00:01:02,146
提供项目的源代码


28
00:01:02,746 --> 00:01:04,775
那么 Swift 包


29
00:01:04,936 --> 00:01:06,266
真的很棒


30
00:01:07,496 --> 00:01:09,166
但并不是每个人都有能力


31
00:01:09,166 --> 00:01:10,226
发布其库的源代码


32
00:01:10,226 --> 00:01:12,366
如果你没有这个能力


33
00:01:13,376 --> 00:01:14,646
那么 Xcode 11 支持使用


34
00:01:14,646 --> 00:01:16,386
新的 XC 框架格式


35
00:01:16,456 --> 00:01:18,616
分发二进制库


36
00:01:19,516 --> 00:01:24,186
[掌声]


37
00:01:24,686 --> 00:01:25,766
因此在这次演讲中


38
00:01:25,766 --> 00:01:27,766
我将向你介绍 XC 框架


39
00:01:28,106 --> 00:01:29,486
这是一种受支持的


40
00:01:29,486 --> 00:01:31,116
分发二进制框架的新方法


41
00:01:31,856 --> 00:01:33,156
我还将讨论一些


42
00:01:33,156 --> 00:01:34,566
客户在选择


43
00:01:34,566 --> 00:01:36,096
使用第三方代码时


44
00:01:36,096 --> 00:01:38,956
应该考虑的事情


45
00:01:39,166 --> 00:01:40,756
接下来


46
00:01:40,816 --> 00:01:43,026
我将讨论 XC 框中的内容


47
00:01:43,026 --> 00:01:44,346
以及如何为项目


48
00:01:44,346 --> 00:01:45,116
创建一个 XC 框架


49
00:01:46,476 --> 00:01:48,466
最后我的同事


50
00:01:48,466 --> 00:01:50,126
Jordan 会来和你们讨论


51
00:01:50,126 --> 00:01:51,106
一些框架作者


52
00:01:51,106 --> 00:01:52,176
应该考虑的事情


53
00:01:52,176 --> 00:01:53,996
以便让他们的


54
00:01:53,996 --> 00:01:55,926
框架尽可能的顺畅


55
00:01:58,476 --> 00:02:02,056
XC 框架是一种新的方法


56
00:02:02,056 --> 00:02:04,186
这个方法可以将


57
00:02:04,186 --> 00:02:06,876
框架的多个变体捆绑在一起


58
00:02:06,876 --> 00:02:08,786
使其能够在以后的


59
00:02:08,786 --> 00:02:09,526
Xcode 版本中工作


60
00:02:10,166 --> 00:02:13,836
单个 XC 框架可以


61
00:02:13,836 --> 00:02:16,776
包含模拟器和设备的变体


62
00:02:17,516 --> 00:02:21,606
[掌声]


63
00:02:22,106 --> 00:02:24,856
还没有结束 因为单个 XC 框架 


64
00:02:24,856 --> 00:02:26,866
也可以包含


65
00:02:26,866 --> 00:02:28,926
Xcode 支持的任何平台的变体


66
00:02:29,516 --> 00:02:33,546
[掌声]


67
00:02:34,046 --> 00:02:35,376
对于使用 AppKit 的 Mac App


68
00:02:35,376 --> 00:02:37,676
你也可以有一个变体


69
00:02:37,676 --> 00:02:38,866
对于使用 UIKit 的 Mac App


70
00:02:38,866 --> 00:02:39,406
你也可以有一个变体


71
00:02:39,806 --> 00:02:41,136
因此无论你的客户端


72
00:02:41,136 --> 00:02:42,986
想要使用哪种 API


73
00:02:42,986 --> 00:02:44,256
他们都能够有效地


74
00:02:44,256 --> 00:02:44,876
使用你的框架


75
00:02:45,406 --> 00:02:48,396
你不仅可以捆绑框架


76
00:02:48,396 --> 00:02:50,556
还可以使用


77
00:02:50,556 --> 00:02:53,656
XC 框架捆绑静态库及其


78
00:02:53,656 --> 00:02:54,746
相应的头文件


79
00:02:54,956 --> 00:02:56,096
Xcode 将自动设置


80
00:02:56,096 --> 00:02:57,806
客户端的搜索板


81
00:02:59,046 --> 00:02:59,936
而且当然 - 


82
00:03:00,516 --> 00:03:03,576
[掌声]


83
00:03:04,076 --> 00:03:05,636
XC 框架支持


84
00:03:05,636 --> 00:03:07,356
基于 Swift 和 C 代码的


85
00:03:07,426 --> 00:03:10,306
二进制分发


86
00:03:10,516 --> 00:03:11,706
现在我想向


87
00:03:11,706 --> 00:03:13,126
你们展示使用


88
00:03:13,126 --> 00:03:14,926
XC 框架是多么容易


89
00:03:17,936 --> 00:03:19,576
这里我有一个


90
00:03:19,606 --> 00:03:20,646
非常简单的 iOS App


91
00:03:20,646 --> 00:03:22,906
我将继续并单击


92
00:03:22,906 --> 00:03:24,916
Run 以在 iPad


93
00:03:24,916 --> 00:03:25,436
模拟器上运行它


94
00:03:25,616 --> 00:03:27,096
你可以看到


95
00:03:27,096 --> 00:03:28,266
它有一个很大的蓝色启动按钮


96
00:03:28,296 --> 00:03:30,336
当你点击它时它什么都不做


97
00:03:30,336 --> 00:03:32,516
这是因为它


98
00:03:32,516 --> 00:03:33,956
连接到这个发射方法


99
00:03:33,956 --> 00:03:36,246
它的主体是空的


100
00:03:37,466 --> 00:03:39,046
我有一个很棒的 XC 框架


101
00:03:39,166 --> 00:03:40,766
我想使用它


102
00:03:40,766 --> 00:03:42,666
它的名字是 FlightKit


103
00:03:44,646 --> 00:03:46,106
FlightKit 给了我


104
00:03:46,306 --> 00:03:47,416
一些我想要在我


105
00:03:47,416 --> 00:03:48,156
App 中呈现的 UI


106
00:03:49,136 --> 00:03:50,706
因此为了能够实际使用


107
00:03:50,736 --> 00:03:52,976
FlightKit XC 框架


108
00:03:52,976 --> 00:03:54,496
我只需单击


109
00:03:54,496 --> 00:03:55,566
项目导航栏中的项目


110
00:03:55,566 --> 00:03:58,396
选择我的 Target


111
00:03:58,396 --> 00:04:00,006
并确保选择了 General 选项卡


112
00:04:01,286 --> 00:04:02,576
然后我将向下


113
00:04:02,576 --> 00:04:04,996
滚动到
Frameworks, Libraries and Embedded Content


114
00:04:07,176 --> 00:04:10,916
然后我将只是拖入我的 XC 框架


115
00:04:10,916 --> 00:04:12,276
并且已经自动连接


116
00:04:12,276 --> 00:04:13,766
为我的 Target 的依赖项


117
00:04:15,076 --> 00:04:16,226
让我们回到代码


118
00:04:16,226 --> 00:04:17,486
并开始使用它


119
00:04:18,516 --> 00:04:20,576
就像你已经习惯


120
00:04:20,576 --> 00:04:21,696
使用的任何框架一样


121
00:04:21,875 --> 00:04:23,766
你要做的第一件事就是导入它


122
00:04:25,196 --> 00:04:26,356
现在我想继续


123
00:04:26,356 --> 00:04:27,556
使用 FlightKit


124
00:04:27,556 --> 00:04:28,816
的一些 API


125
00:04:29,366 --> 00:04:30,456
所以要么我可以


126
00:04:30,456 --> 00:04:33,446
去查看文档


127
00:04:33,446 --> 00:04:34,376
要么我可以按住 Command 单击


128
00:04:34,376 --> 00:04:35,546
名称 FlightKit


129
00:04:35,546 --> 00:04:36,166
然后单击 Jump to Definition


130
00:04:37,146 --> 00:04:38,106
这会把我带到为


131
00:04:38,106 --> 00:04:41,156
FlightKit 生成的接口


132
00:04:42,136 --> 00:04:44,146
这显示了所有公共 API


133
00:04:44,146 --> 00:04:47,626
每个公共类型 公共方法


134
00:04:47,626 --> 00:04:49,116
我导入 FlightKit 时可以使用的所有内容


135
00:04:49,856 --> 00:04:52,006
我可以看到


136
00:04:52,126 --> 00:04:53,606
这有一个 LaunchViewController


137
00:04:53,606 --> 00:04:55,116
它是 UIViewController 的子类


138
00:04:55,976 --> 00:04:57,226
这似乎是我可能


139
00:04:57,226 --> 00:04:58,786
希望展示的一小部分 UI


140
00:05:00,026 --> 00:05:02,386
太好了


141
00:05:02,386 --> 00:05:03,406
所以现在我需要知道


142
00:05:03,406 --> 00:05:05,026
如何创建这些


143
00:05:05,026 --> 00:05:06,176
我可以看到在界面


144
00:05:06,176 --> 00:05:07,606
有一个初始化程序


145
00:05:07,606 --> 00:05:08,256
需要构造一个 Spaceship


146
00:05:08,846 --> 00:05:10,216
Spaceship 也是 


147
00:05:10,216 --> 00:05:10,766
FlightKit 的一部分


148
00:05:12,196 --> 00:05:13,666
如果我跳转到它的定义


149
00:05:13,776 --> 00:05:15,106
它将进一步将我


150
00:05:15,106 --> 00:05:16,816
代入到生成的界面中


151
00:05:16,816 --> 00:05:17,946
并向我展示所有我可以


152
00:05:17,946 --> 00:05:19,456
在 Spaceship 中使用的内容


153
00:05:20,006 --> 00:05:23,746
我可以看到


154
00:05:23,746 --> 00:05:26,926
有一个称为 name 的公共存储属性


155
00:05:26,926 --> 00:05:28,396
并且还有一个输入 name 的公共 init 程序


156
00:05:29,836 --> 00:05:31,246
好吧这样我就可以创建


157
00:05:31,246 --> 00:05:32,766
一个太空船


158
00:05:32,766 --> 00:05:34,166
并且我可以创建一个 LaunchViewController


159
00:05:34,166 --> 00:05:34,796
然后我可以呈现它


160
00:05:36,186 --> 00:05:37,396
那么让我们回到代码中


161
00:05:37,396 --> 00:05:38,346
并准确地做到这一点


162
00:05:39,376 --> 00:05:40,576
首先我要创建一个船


163
00:05:41,576 --> 00:05:42,566
我可以看到


164
00:05:42,566 --> 00:05:43,886
自动补全已经向我


165
00:05:43,886 --> 00:05:45,446
暗示了所有在


166
00:05:45,446 --> 00:05:47,326
FlightKit 中的成分


167
00:05:47,326 --> 00:05:48,306
就像你已经习惯


168
00:05:48,306 --> 00:05:49,336
使用的框架一样


169
00:05:50,276 --> 00:05:51,186
我可以接受自动补全


170
00:05:51,186 --> 00:05:53,086
然后我将为我的船


171
00:05:53,086 --> 00:05:53,866
选择一个名字


172
00:05:54,506 --> 00:05:55,456
好吧我已经有了


173
00:05:55,456 --> 00:05:57,066
这一数组的船名


174
00:05:57,066 --> 00:05:58,186
其中任何一个


175
00:05:58,186 --> 00:05:58,696
都将是这艘船的好名字


176
00:05:59,646 --> 00:06:02,896
我将从船名数组中


177
00:06:02,896 --> 00:06:03,716
随机抽取一个元素


178
00:06:04,306 --> 00:06:07,206
现在我将创建


179
00:06:07,206 --> 00:06:10,506
一个 LaunchViewController


180
00:06:10,676 --> 00:06:12,416
并将它传递给我刚刚创建的船


181
00:06:12,956 --> 00:06:15,776
最后并显示


182
00:06:15,776 --> 00:06:18,136
控制器自己作为发送者


183
00:06:18,706 --> 00:06:21,866
在创建了一艘船和一些 UI 之后


184
00:06:21,866 --> 00:06:23,666
我现在将进行展示


185
00:06:24,706 --> 00:06:26,866
我将构建并在模拟器中运行我的程序


186
00:06:26,866 --> 00:06:28,776
当我点击启 Launch 时


187
00:06:28,776 --> 00:06:30,416
它会随机选择一个名字


188
00:06:30,416 --> 00:06:31,466
然后启动 UI


189
00:06:31,466 --> 00:06:34,586
如果我再次点击它


190
00:06:34,586 --> 00:06:37,896
它会选择一个名字和另一个名字 你懂了吧


191
00:06:39,186 --> 00:06:41,636
这就是如何在一个平台上


192
00:06:41,636 --> 00:06:43,136
使用 XC 框架


193
00:06:43,136 --> 00:06:44,436
但 XC 框架的一大优点是


194
00:06:44,546 --> 00:06:47,526
可以将多个变体


195
00:06:47,526 --> 00:06:48,916
放在同一个包中


196
00:06:49,606 --> 00:06:50,996
因此只需将一个


197
00:06:50,996 --> 00:06:52,956
XC 框架拖入其中


198
00:06:52,956 --> 00:06:54,036
我不仅能够为


199
00:06:54,036 --> 00:06:57,196
模拟器构建和运行


200
00:06:57,196 --> 00:07:00,356
而且如果我选择 Generic iOS Device


201
00:07:00,356 --> 00:07:02,326
那么我可以转到


202
00:07:02,326 --> 00:07:03,686
Product Archive


203
00:07:03,686 --> 00:07:04,006
并为 App Store 构建存档


204
00:07:04,676 --> 00:07:10,036
从代码中使用 XC 框架


205
00:07:10,036 --> 00:07:11,456
是多么容易啊


206
00:07:12,516 --> 00:07:18,546
[掌声]


207
00:07:19,046 --> 00:07:20,206
因此当你选择


208
00:07:20,206 --> 00:07:23,346
使用框架时


209
00:07:23,386 --> 00:07:24,766
了解你向第三方代码


210
00:07:24,766 --> 00:07:27,046
提供哪些内容非常重要


211
00:07:28,426 --> 00:07:30,196
重要的是


212
00:07:30,196 --> 00:07:33,156
你希望确保信任框架的来源


213
00:07:34,156 --> 00:07:35,226
你相信他们不会


214
00:07:35,226 --> 00:07:36,986
给你的 App 带来漏洞或不稳定


215
00:07:36,986 --> 00:07:38,946
你相信他们


216
00:07:38,946 --> 00:07:40,806
会尊重你用户的隐私


217
00:07:41,346 --> 00:07:44,366
例如如果你


218
00:07:44,366 --> 00:07:47,546
已经为你的 App 授予了权限


219
00:07:47,546 --> 00:07:49,626
并且你使用了一个框架


220
00:07:49,696 --> 00:07:51,276
那么该框架也将被授予这些权限


221
00:07:51,806 --> 00:07:53,416
以及那些许可也是一样


222
00:07:53,416 --> 00:07:54,766
如果你的用户给了许可的话


223
00:07:56,736 --> 00:07:58,716
此外如果你采用的框架


224
00:07:58,716 --> 00:08:00,256
需要某种权限才能使用


225
00:08:00,256 --> 00:08:01,246
那么你需要负责


226
00:08:01,246 --> 00:08:06,186
将该权限添加到你的 App 中


227
00:08:07,836 --> 00:08:09,786
关于使用框架


228
00:08:09,786 --> 00:08:11,036
需要考虑的另一件事是


229
00:08:11,586 --> 00:08:12,436
有时你会使用


230
00:08:12,436 --> 00:08:16,466
一个带有自己依赖项的框架


231
00:08:16,466 --> 00:08:20,396
这些依赖项可能也有自己的依赖项


232
00:08:20,396 --> 00:08:21,966
你不仅有义务要


233
00:08:21,966 --> 00:08:23,276
将所有这些添加到项目中


234
00:08:23,966 --> 00:08:25,836
还要对它们每个部分


235
00:08:25,836 --> 00:08:27,966
扩展同样的信任


236
00:08:27,966 --> 00:08:30,896
现在值得注意的是


237
00:08:30,966 --> 00:08:34,086
这种信任也扩展到了


238
00:08:34,086 --> 00:08:35,186
使用 Swift 包


239
00:08:36,126 --> 00:08:38,525
包相对于二进制框架的一个优点是


240
00:08:38,525 --> 00:08:40,116
你可以检查代码


241
00:08:40,116 --> 00:08:41,676
并且可以在调试时深入查看


242
00:08:42,285 --> 00:08:43,716
如果你想了解


243
00:08:43,716 --> 00:08:45,006
更多关于在 Xcode


244
00:08:45,046 --> 00:08:47,066
中使用 Swift 包的信息


245
00:08:47,066 --> 00:08:48,066
我向你推荐本周早些时候的会议


246
00:08:48,666 --> 00:08:52,126
但无论你使用的


247
00:08:52,126 --> 00:08:54,096
是包还是二进制框架


248
00:08:54,516 --> 00:08:56,606
Xcode 11 都可以让你


249
00:08:56,606 --> 00:09:00,686
轻松使用你信任的第三方代码


250
00:09:02,206 --> 00:09:03,846
现在我想谈谈


251
00:09:03,846 --> 00:09:05,706
如何创建一个 XC 框架


252
00:09:06,846 --> 00:09:08,226
你要做的第一件事


253
00:09:08,226 --> 00:09:10,086
就是有一些你


254
00:09:10,086 --> 00:09:11,386
想要发布的源代码


255
00:09:11,386 --> 00:09:14,196
让我们来看一下


256
00:09:14,196 --> 00:09:16,826
早前 FlightKit 的一些源代码


257
00:09:18,056 --> 00:09:21,666
这只是 FlightKit 中对象的子集 仅仅用来举例


258
00:09:22,346 --> 00:09:24,886
但是你可以


259
00:09:24,916 --> 00:09:26,686
看到我们之前看过的 Spaceship 类型


260
00:09:28,136 --> 00:09:29,806
你还可以看到


261
00:09:29,806 --> 00:09:31,606
一个名为 Speed 的枚举


262
00:09:31,606 --> 00:09:32,716
它描述了事物在太空中移动的速度


263
00:09:34,066 --> 00:09:35,296
你还会看到一个名为


264
00:09:35,296 --> 00:09:36,926
Location 的结构体


265
00:09:36,926 --> 00:09:38,676
用于描述对象在空间中的位置


266
00:09:40,156 --> 00:09:42,566
太好了 我们有这个代码


267
00:09:43,196 --> 00:09:44,336
现在我们将如何确保


268
00:09:44,336 --> 00:09:45,736
我们构建此库


269
00:09:45,736 --> 00:09:46,496
是用于分发？


270
00:09:47,446 --> 00:09:49,436
在 Xcode 11 中


271
00:09:49,436 --> 00:09:51,046
有一个新的构建设置


272
00:09:51,046 --> 00:09:52,576
称为 Build Libraries for Distribution


273
00:09:53,556 --> 00:09:54,786
它做的确实是这件事


274
00:09:54,966 --> 00:09:58,116
它开启了所有构建库所需的特性


275
00:09:58,116 --> 00:10:00,496
以便以一种可分发的方式构建库


276
00:10:02,046 --> 00:10:04,166
现在我们来谈谈


277
00:10:04,166 --> 00:10:05,386
其中一个特性


278
00:10:06,906 --> 00:10:08,536
如果你以前尝试过


279
00:10:08,756 --> 00:10:10,586
向某人发送已构建的 Swift 框架


280
00:10:11,286 --> 00:10:13,536
那么你可能已经看到了这种错误的变体


281
00:10:14,956 --> 00:10:17,126
已编译模块是由


282
00:10:17,126 --> 00:10:18,446
较新版本的编译器创建的


283
00:10:18,986 --> 00:10:21,976
这个错误到底意味着什么


284
00:10:23,506 --> 00:10:24,626
当 Swift 编译器


285
00:10:24,626 --> 00:10:26,656
导入一个模块时


286
00:10:26,656 --> 00:10:27,956
它会为这个库


287
00:10:27,956 --> 00:10:30,156
查找一个名为 Compiled Module 的文件


288
00:10:31,676 --> 00:10:33,286
如果找到其中一个文件


289
00:10:33,646 --> 00:10:35,206
它将读取可以调用的


290
00:10:35,246 --> 00:10:36,946
公共 API 的 Manifest


291
00:10:36,946 --> 00:10:39,996
并让你使用它们


292
00:10:40,326 --> 00:10:45,746
现在这个已编译模块格式是二进制格式


293
00:10:45,746 --> 00:10:47,876
基本上包含


294
00:10:47,876 --> 00:10:49,236
内部编译器数据结构


295
00:10:50,096 --> 00:10:52,996
由于它们只是内部数据结构


296
00:10:52,996 --> 00:10:55,116
所以随着 Swift 编译器的每个版本


297
00:10:55,116 --> 00:10:58,986
它们都可能发生变化 这意味着


298
00:10:59,216 --> 00:11:00,756
如果一个人试图


299
00:11:00,756 --> 00:11:02,566
用一个版本的 Swift 


300
00:11:02,566 --> 00:11:04,436
导入一个模块


301
00:11:04,496 --> 00:11:05,596
而这个模块是由


302
00:11:05,596 --> 00:11:07,666
另一个版本的 Swift 创建的


303
00:11:07,666 --> 00:11:08,806
他们的编译器将无法理解这个模块


304
00:11:08,806 --> 00:11:10,126
他们也无法使用这个模块


305
00:11:11,176 --> 00:11:13,516
为了解决


306
00:11:13,516 --> 00:11:16,406
这个版本锁定问题


307
00:11:16,406 --> 00:11:17,916
Xcode 11 为 Swift 模块


308
00:11:17,916 --> 00:11:19,586
引入了一种新的格式


309
00:11:19,586 --> 00:11:20,746
称为 Swift 模块接口


310
00:11:21,886 --> 00:11:23,186
就像已编译模块格式一样


311
00:11:23,186 --> 00:11:27,756
它们列出了模块的所有公共 API


312
00:11:27,756 --> 00:11:29,956
但使用的是


313
00:11:29,956 --> 00:11:30,966
更像源代码的文本形式


314
00:11:32,086 --> 00:11:33,356
由于它们的行为


315
00:11:33,356 --> 00:11:35,546
类似于源代码


316
00:11:35,546 --> 00:11:37,006
那么 Swift 编译器的未来版本


317
00:11:37,436 --> 00:11:39,026
将能够导入


318
00:11:39,026 --> 00:11:41,066
使用旧版本创建的模块接口


319
00:11:41,716 --> 00:11:46,696
当你启用 Build Libraries for Distribution 时


320
00:11:47,416 --> 00:11:48,606
你是在告诉编译器


321
00:11:48,606 --> 00:11:50,076
在编译器构建框架时


322
00:11:50,076 --> 00:11:52,926
去生成一个稳定的接口


323
00:11:53,606 --> 00:11:57,406
那么这些接口


324
00:11:57,406 --> 00:11:58,836
实际上是什么样的呢？


325
00:11:59,586 --> 00:12:01,176
让我们再次看看


326
00:12:01,176 --> 00:12:02,566
FlightKit 的源代码


327
00:12:03,716 --> 00:12:05,326
这就是来自 FlightKit 的源代码


328
00:12:05,326 --> 00:12:08,116
在右侧你将


329
00:12:08,116 --> 00:12:09,606
看到 FlightKit 的模块接口


330
00:12:10,286 --> 00:12:11,546
现在这有点多


331
00:12:11,546 --> 00:12:12,816
而且它从屏幕上消失了


332
00:12:12,816 --> 00:12:15,206
所以我们要一块一块地看


333
00:12:15,416 --> 00:12:17,916
首先你会看到这部分元数据


334
00:12:18,826 --> 00:12:22,116
这包括生成这个接口的编译器版本


335
00:12:22,116 --> 00:12:24,276
但它也包含


336
00:12:24,306 --> 00:12:26,026
命令行标记的子集


337
00:12:26,316 --> 00:12:27,696
Swift 编译器需要


338
00:12:27,696 --> 00:12:29,256
将其作为模块导入


339
00:12:32,156 --> 00:12:34,636
接下来你将看到


340
00:12:34,636 --> 00:12:36,986
这个框架导入的所有模块


341
00:12:37,836 --> 00:12:39,306
然后我们将开始


342
00:12:39,306 --> 00:12:41,096
查看作为该接口一部分的一些类型


343
00:12:42,356 --> 00:12:44,846
这是 Spaceship 类的公共 API


344
00:12:44,976 --> 00:12:46,926
现在我希望


345
00:12:46,926 --> 00:12:48,126
你注意到这三件事


346
00:12:48,766 --> 00:12:50,516
第一


347
00:12:50,516 --> 00:12:52,706
公共 name 属性


348
00:12:52,706 --> 00:12:54,806
包含在接口中


349
00:12:54,806 --> 00:12:56,706
但是私有 currentLocation 属性不包含


350
00:12:57,896 --> 00:13:00,686
它不是公共 API 的一部分


351
00:13:01,426 --> 00:13:04,176
接下来


352
00:13:04,216 --> 00:13:06,356
请注意接口中包含了公共初始化器


353
00:13:06,496 --> 00:13:07,876
和 fly 方法


354
00:13:09,006 --> 00:13:10,796
但是它们的主体


355
00:13:10,796 --> 00:13:11,986
没有被包括进去


356
00:13:11,986 --> 00:13:14,116
同样也是因为它们不是公共 API 的一部分


357
00:13:15,276 --> 00:13:16,656
最后请注意


358
00:13:16,656 --> 00:13:18,596
该类在接口中


359
00:13:18,596 --> 00:13:20,286
有一个取消初始化程序


360
00:13:20,286 --> 00:13:21,416
但是在原始源代码中


361
00:13:21,416 --> 00:13:22,626
却没有进行写入


362
00:13:23,186 --> 00:13:27,676
现在当你在 Swift 中编写类


363
00:13:27,676 --> 00:13:29,456
并且没有提供显式取消初始化程序时


364
00:13:29,456 --> 00:13:31,086
编译器将为你生成一个


365
00:13:31,616 --> 00:13:35,666
这强调了模块接口


366
00:13:35,666 --> 00:13:36,606
的一个基本原则


367
00:13:37,146 --> 00:13:38,416
如果这种格式


368
00:13:38,416 --> 00:13:42,156
在编译器的不同版本之间


369
00:13:42,156 --> 00:13:43,976
应该是稳定的


370
00:13:44,196 --> 00:13:45,886
那么编译器不应该对底层源代码做任何假设


371
00:13:46,786 --> 00:13:48,926
因此我们将其包含在模块接口中


372
00:13:49,506 --> 00:13:53,516
接下来让我们看一下 Speed 枚举


373
00:13:54,466 --> 00:13:55,666
首先要看到的是


374
00:13:55,666 --> 00:13:58,316
两个枚举都被包含了


375
00:13:58,506 --> 00:14:02,086
这些是公共 API 的一部分


376
00:14:02,086 --> 00:14:03,956
然而在接口中


377
00:14:03,956 --> 00:14:06,316
对于哈希需要明确的遵守


378
00:14:07,116 --> 00:14:08,876
我们列出了


379
00:14:08,876 --> 00:14:11,476
遵循哈希和相等


380
00:14:11,476 --> 00:14:12,566
所需的方法


381
00:14:13,396 --> 00:14:14,846
这是因为在 Swift 中


382
00:14:15,146 --> 00:14:16,666
如果你生成了一个


383
00:14:16,666 --> 00:14:19,496
没有任何关联值的枚举


384
00:14:19,496 --> 00:14:22,626
那么编译器就会隐式地


385
00:14:22,626 --> 00:14:24,546
使其符合哈希和相等


386
00:14:24,546 --> 00:14:26,276
并自动派生出所需的方法


387
00:14:26,916 --> 00:14:29,306
因此本着明确的精神


388
00:14:29,306 --> 00:14:32,576
它被包含在模块接口中


389
00:14:33,956 --> 00:14:36,476
最后 Location 结构体


390
00:14:36,656 --> 00:14:38,746
以现在方式包含在内


391
00:14:38,746 --> 00:14:39,876
因为它只有


392
00:14:39,876 --> 00:14:41,626
公共存储的属性


393
00:14:41,626 --> 00:14:42,696
并且不声明任何遵循


394
00:14:43,326 --> 00:14:46,976
以上就是 FlightKit 的模块接口


395
00:14:51,496 --> 00:14:54,966
现在你已经了解了框架内部的内容


396
00:14:54,966 --> 00:14:56,296
接下来让我们


397
00:14:56,336 --> 00:14:58,766
讨论如何自己构建一个


398
00:14:58,766 --> 00:14:59,156
可分发的二进制 XC 框架


399
00:14:59,746 --> 00:15:03,936
构建框架的第一步


400
00:15:03,936 --> 00:15:04,406
是构建存档


401
00:15:05,326 --> 00:15:06,626
归档你的框架


402
00:15:06,626 --> 00:15:08,656
将在发布模式下构建它


403
00:15:08,656 --> 00:15:09,576
并将其打包以进行分发


404
00:15:09,576 --> 00:15:12,716
你可以在管理器窗口中看到它


405
00:15:13,746 --> 00:15:15,636
此外作为附加优势


406
00:15:15,686 --> 00:15:17,376
此存档还将包含


407
00:15:17,376 --> 00:15:18,776
与框架的该版本


408
00:15:18,776 --> 00:15:20,196
对应的调试信息


409
00:15:20,196 --> 00:15:21,906
这意味着


410
00:15:21,906 --> 00:15:23,776
如果客户端有任何崩溃


411
00:15:26,526 --> 00:15:27,936
他们将能够将其


412
00:15:27,936 --> 00:15:29,056
发送给你


413
00:15:29,146 --> 00:15:31,606
而你将能够查看符号并调试它


414
00:15:32,336 --> 00:15:34,626
要存档框架


415
00:15:34,626 --> 00:15:36,776
你可以使用 xcodebuild 存档命令


416
00:15:37,836 --> 00:15:39,166
你将输入项目中


417
00:15:39,166 --> 00:15:40,596
框架的 scheme


418
00:15:41,606 --> 00:15:44,406
并列出要为其编译的目标


419
00:15:45,186 --> 00:15:46,606
因此如果你正在为 iOS 构建


420
00:15:46,976 --> 00:15:47,836
可以是一个用于模拟器


421
00:15:47,836 --> 00:15:49,676
一个用于设备以及


422
00:15:50,266 --> 00:15:52,216
一个用于运行 UIKit 的 Mac


423
00:15:52,836 --> 00:15:55,486
你还需要通过


424
00:15:55,486 --> 00:15:57,416
Skip Install 生成设置


425
00:15:57,416 --> 00:15:58,276
并将其设置为 No


426
00:15:59,096 --> 00:16:01,316
这告诉 xcodebuild 存档


427
00:16:01,316 --> 00:16:04,286
在生成的存档中安装框架


428
00:16:04,926 --> 00:16:09,276
因此通过执行此操作


429
00:16:09,276 --> 00:16:11,636
你将构建框架的


430
00:16:11,636 --> 00:16:13,666
每个变体的存档


431
00:16:13,666 --> 00:16:15,056
这些存档


432
00:16:15,056 --> 00:16:17,186
将在 Preference 窗口中的


433
00:16:17,186 --> 00:16:20,096
Location 选项卡中的 Archive 目录可用


434
00:16:20,606 --> 00:16:24,186
构建这些存档后


435
00:16:24,186 --> 00:16:25,966
你可以提取框架


436
00:16:25,966 --> 00:16:27,456
并将它们捆绑在


437
00:16:27,456 --> 00:16:29,546
一个 XC 框架中


438
00:16:30,056 --> 00:16:32,486
为此你将运行 


439
00:16:32,486 --> 00:16:35,366
xcodebuild -create-xcframework 命令


440
00:16:36,456 --> 00:16:40,186
你将输入磁盘上每个框架的路径


441
00:16:40,186 --> 00:16:41,956
然后提供你希望


442
00:16:42,006 --> 00:16:46,456
输出 XC 框架输出到的路径


443
00:16:46,696 --> 00:16:49,526
以上就是如何构建 XC 框架


444
00:16:49,526 --> 00:16:51,946
总而言之请记住


445
00:16:51,946 --> 00:16:53,916
你需要启用


446
00:16:53,916 --> 00:16:55,626
Build Libraries for Distribution


447
00:16:55,626 --> 00:16:57,356
以确保你的库是为了分发而构建的


448
00:16:57,436 --> 00:17:00,996
你将运行 xcodebuild 归档


449
00:17:01,536 --> 00:17:02,536
以构建框架的归档


450
00:17:02,536 --> 00:17:05,576
最后运行 


451
00:17:05,576 --> 00:17:06,536
xcodebuild -create-xcframework


452
00:17:06,566 --> 00:17:10,705
将其打包以便分发


453
00:17:11,146 --> 00:17:12,165
然后你可以开始


454
00:17:12,165 --> 00:17:13,205
将其发送给你的客户


455
00:17:13,205 --> 00:17:14,586
然后他们可以开始采用它


456
00:17:15,195 --> 00:17:16,925
这就是 XC 框架


457
00:17:18,326 --> 00:17:19,846
现在我的同事 Jordan 


458
00:17:19,846 --> 00:17:21,026
将向你介绍作为一个框架作者


459
00:17:21,026 --> 00:17:22,656
你应该考虑哪些内容


460
00:17:22,656 --> 00:17:26,185
以使你的框架尽可能


461
00:17:26,185 --> 00:17:26,685
顺畅地使用


462
00:17:28,516 --> 00:17:34,546
[掌声和欢呼]


463
00:17:35,046 --> 00:17:35,736
>> 谢谢 Harlan


464
00:17:36,006 --> 00:17:38,086
好的 我们看到


465
00:17:38,376 --> 00:17:39,876
将这些 XC 框架中的一个


466
00:17:40,066 --> 00:17:42,256
引入作为框架客户端的 App


467
00:17:42,256 --> 00:17:43,906
是多么容易


468
00:17:43,906 --> 00:17:45,556
我们看到了生成


469
00:17:45,586 --> 00:17:46,276
XC 框架所需的步骤


470
00:17:47,016 --> 00:17:48,316
但这只是第一步


471
00:17:48,576 --> 00:17:49,476
因为你是框架作者


472
00:17:49,476 --> 00:17:53,326
并且你每年都在开发新功能


473
00:17:53,326 --> 00:17:55,446
并为客户端做得更好


474
00:17:56,236 --> 00:17:57,296
因此在这一节中


475
00:17:57,296 --> 00:17:58,926
我将讨论


476
00:17:58,926 --> 00:17:59,456
三件主要的事情


477
00:18:00,386 --> 00:18:01,556
从不断的发布中


478
00:18:01,556 --> 00:18:02,556
逐步发展你的框架


479
00:18:03,366 --> 00:18:05,936
利用 Swift 提供的一些灵活性


480
00:18:05,936 --> 00:18:07,546
来优化客户端


481
00:18:08,296 --> 00:18:09,536
并帮助客户端


482
00:18:09,536 --> 00:18:10,606
获得尽可能


483
00:18:10,606 --> 00:18:11,196
平稳流畅的体验


484
00:18:11,736 --> 00:18:14,596
因此请从发展你的框架开始


485
00:18:15,196 --> 00:18:17,186
当我说要发展你的框架时


486
00:18:17,186 --> 00:18:18,456
我是什么意思呢


487
00:18:19,496 --> 00:18:22,966
好吧就像我说的


488
00:18:22,966 --> 00:18:24,366
每次你发布新版本的框架时


489
00:18:24,366 --> 00:18:25,736
它都会有新的功能


490
00:18:25,736 --> 00:18:27,746
新的 API


491
00:18:27,746 --> 00:18:29,936
可能还有一些漏洞修复


492
00:18:29,936 --> 00:18:31,866
我们希望能够


493
00:18:31,866 --> 00:18:33,736
在不破坏源代码


494
00:18:33,736 --> 00:18:34,726
或二进制兼容性的情况下做到这一点


495
00:18:35,586 --> 00:18:37,776
那么为什么二进制兼容性


496
00:18:37,776 --> 00:18:38,686
在这里很重要呢


497
00:18:39,876 --> 00:18:41,156
这是因为你


498
00:18:41,156 --> 00:18:42,766
不一定知道


499
00:18:42,766 --> 00:18:44,256
你的客户是谁


500
00:18:44,746 --> 00:18:47,266
很多时候它只是一个 App Target


501
00:18:47,576 --> 00:18:48,526
它们会使用你的框架


502
00:18:48,766 --> 00:18:50,956
打包然后送到商店


503
00:18:52,246 --> 00:18:53,806
但有时你的客户


504
00:18:53,836 --> 00:18:55,396
本身就是二进制框架


505
00:18:55,476 --> 00:18:57,246
要么来自你的公司


506
00:18:57,246 --> 00:18:59,846
要么完全来自另一家公司


507
00:18:59,896 --> 00:19:02,756
在这种情况下


508
00:19:02,836 --> 00:19:04,396
你们两个可能


509
00:19:04,396 --> 00:19:04,926
有不同的发布时间表


510
00:19:05,576 --> 00:19:06,596
他们可能会


511
00:19:06,596 --> 00:19:08,896
一直升级到 2.1 版


512
00:19:08,896 --> 00:19:10,816
而你还在开发最新的版本


513
00:19:10,816 --> 00:19:16,246
当你最终发布 1.1 版本时


514
00:19:16,246 --> 00:19:17,566
他们不应该再为采用它


515
00:19:17,566 --> 00:19:18,636
而付出任何额外的努力


516
00:19:19,116 --> 00:19:19,906
你不希望陷入


517
00:19:19,906 --> 00:19:21,946
两个二进制框架


518
00:19:21,946 --> 00:19:23,436
彼此版本锁定的情况


519
00:19:23,436 --> 00:19:26,506
因为使用它们的 App 可能


520
00:19:26,506 --> 00:19:30,766
决定不更新


521
00:19:30,976 --> 00:19:32,266
所以我在这里说


522
00:19:32,266 --> 00:19:33,426
你的框架版本很重要


523
00:19:33,426 --> 00:19:35,366
你不仅想


524
00:19:35,366 --> 00:19:38,556
把它放在你的网站和你的文档上


525
00:19:38,806 --> 00:19:40,066
而且你还应该


526
00:19:40,066 --> 00:19:41,686
把它放在框架本身里


527
00:19:41,686 --> 00:19:43,736
并且能这样做的地方是


528
00:19:43,736 --> 00:19:45,426
框架的 Info.plist 中的


529
00:19:45,426 --> 00:19:46,636
Bundle 版本字符串设置


530
00:19:47,486 --> 00:19:49,326
这是人类可读版本号


531
00:19:49,326 --> 00:19:52,886
你可以在这里与客户交流


532
00:19:52,886 --> 00:19:55,396
自上次发布以来所做的更改


533
00:19:55,986 --> 00:19:58,576
我们推荐的方法


534
00:19:58,576 --> 00:20:00,966
是使用语义版本控制


535
00:20:01,616 --> 00:20:02,416
如果你之前


536
00:20:02,416 --> 00:20:04,156
没参加包讨论的话


537
00:20:04,246 --> 00:20:05,446
我现在将快速回顾一下


538
00:20:05,446 --> 00:20:06,866
什么是语义版本控制


539
00:20:07,676 --> 00:20:09,326
最小的组成部分是


540
00:20:09,326 --> 00:20:11,306
补丁版本


541
00:20:11,456 --> 00:20:12,856
它表示何时对框架进行漏洞修复


542
00:20:12,856 --> 00:20:14,156
或实现更改


543
00:20:14,156 --> 00:20:15,886
而这些更改


544
00:20:15,886 --> 00:20:17,266
不应该影响客户


545
00:20:18,076 --> 00:20:20,216
中间组成部分用于


546
00:20:20,416 --> 00:20:22,106
向后兼容的版本


547
00:20:22,466 --> 00:20:24,746
新 API 或新功能


548
00:20:25,386 --> 00:20:28,796
而主要的组成部分


549
00:20:28,796 --> 00:20:30,416
是你必须做的


550
00:20:30,416 --> 00:20:32,356
任何中断更改


551
00:20:32,436 --> 00:20:34,486
不管是源代码中断


552
00:20:34,486 --> 00:20:37,016
二进制中断


553
00:20:37,506 --> 00:20:38,986
还是语义中断


554
00:20:39,046 --> 00:20:41,916
在某种程度上


555
00:20:41,916 --> 00:20:43,606
客户将不得不重新构建


556
00:20:43,606 --> 00:20:45,216
甚至可能重做一些客户端代码


557
00:20:45,216 --> 00:20:46,156
以采用新版本的框架


558
00:20:46,586 --> 00:20:49,036
让我们看一下 


559
00:20:49,036 --> 00:20:50,746
FlightKit 模型对象


560
00:20:50,746 --> 00:20:51,676
在实践中的效果


561
00:20:52,586 --> 00:20:53,826
所以左边的情况


562
00:20:53,826 --> 00:20:56,096
与我们之前的情况相同


563
00:20:57,366 --> 00:20:59,136
现在在右边


564
00:20:59,136 --> 00:21:00,946
我对这个框架进行了一系列更改


565
00:21:02,096 --> 00:21:03,406
让我们逐个讨论它们


566
00:21:03,476 --> 00:21:06,526
看看每个更改如何影响


567
00:21:06,526 --> 00:21:07,246
框架的版本号


568
00:21:08,506 --> 00:21:09,446
我们将从顶部开始


569
00:21:10,466 --> 00:21:12,286
我已经为 Spaceship 船类


570
00:21:12,286 --> 00:21:13,896
添加了一个新的私有属性


571
00:21:14,396 --> 00:21:15,966
而我正在 Spaceship 的


572
00:21:15,966 --> 00:21:17,226
初始化器中使用它


573
00:21:18,556 --> 00:21:20,996
目前这些东西


574
00:21:20,996 --> 00:21:22,506
都不会出现


575
00:21:22,506 --> 00:21:23,156
在模块界面中


576
00:21:23,466 --> 00:21:24,446
它们并不是你框架


577
00:21:24,446 --> 00:21:25,696
的公共 API 的一部分


578
00:21:26,976 --> 00:21:28,796
因此这种更改


579
00:21:28,796 --> 00:21:30,556
只需要更新次要部分


580
00:21:30,556 --> 00:21:32,116
或补丁版本部分


581
00:21:33,916 --> 00:21:36,086
请记住


582
00:21:36,146 --> 00:21:37,786
虽然我确实改变了


583
00:21:37,786 --> 00:21:39,776
初始化程序的行为


584
00:21:39,776 --> 00:21:42,536
如果之前记录了这种行为


585
00:21:42,536 --> 00:21:43,806
那么这将是


586
00:21:43,856 --> 00:21:45,826
一个语义突破的变化


587
00:21:45,826 --> 00:21:48,866
客户必须考虑是否更新


588
00:21:48,866 --> 00:21:50,386
因此我应该


589
00:21:50,386 --> 00:21:51,356
更改主版本号


590
00:21:51,986 --> 00:21:55,206
现在我在这里


591
00:21:55,206 --> 00:21:57,376
做的下一个更改


592
00:21:57,376 --> 00:21:58,496
是向 Spaceship 类添加一个新方法


593
00:21:58,796 --> 00:22:00,616
这是一个新的公共方法


594
00:22:00,616 --> 00:22:01,926
这意味着客户


595
00:22:01,926 --> 00:22:02,886
将开始使用它并依赖它


596
00:22:03,846 --> 00:22:05,566
因此正确的做法


597
00:22:05,566 --> 00:22:07,636
是增加次要版本号


598
00:22:08,146 --> 00:22:09,676
你会注意到


599
00:22:09,676 --> 00:22:13,846
我还将补丁版本重置为零


600
00:22:13,966 --> 00:22:16,516
最后我还在 fly 方法


601
00:22:16,516 --> 00:22:18,406
中添加了一个新参数


602
00:22:19,356 --> 00:22:21,486
我已经给了它一个默认值


603
00:22:21,486 --> 00:22:23,536
这样大多数的使用站点


604
00:22:23,586 --> 00:22:24,206
就不必更改了


605
00:22:24,986 --> 00:22:27,126
但在 Swift 中


606
00:22:27,126 --> 00:22:29,686
函数的名称和参数


607
00:22:30,216 --> 00:22:31,466
是唯一标识的


608
00:22:31,466 --> 00:22:33,616
参数标签和类型


609
00:22:34,286 --> 00:22:36,626
所以这里我已经破坏了


610
00:22:36,966 --> 00:22:39,726
源代码和二进制兼容性


611
00:22:39,726 --> 00:22:41,706
所以这需要


612
00:22:41,706 --> 00:22:43,636
更新主版本号


613
00:22:43,636 --> 00:22:44,926
并要求任何客户端重新编译


614
00:22:45,616 --> 00:22:46,696
也许我应该


615
00:22:46,696 --> 00:22:47,686
做一个新的过载


616
00:22:48,286 --> 00:22:51,426
现在这些都是


617
00:22:51,426 --> 00:22:52,856
对 Spaceship 类的更改


618
00:22:52,856 --> 00:22:54,266
但我也更改了


619
00:22:54,266 --> 00:22:55,796
FlightKit 中的一些值类型


620
00:22:55,796 --> 00:22:58,786
我在 Speed 枚举中添加了一个新案例


621
00:23:00,256 --> 00:23:02,516
我已经使 Loacation 变得可哈希


622
00:23:02,516 --> 00:23:03,836
这样客户端就可以拥有它们的集合


623
00:23:03,836 --> 00:23:06,436
这是我最喜欢的更改


624
00:23:06,436 --> 00:23:08,726
我在不破坏源代码


625
00:23:08,726 --> 00:23:10,626
或二进制兼容性的情况下


626
00:23:10,896 --> 00:23:12,516
向 Location 结构添加了


627
00:23:12,516 --> 00:23:13,816
一个新的存储属性


628
00:23:14,516 --> 00:23:19,546
[掌声]


629
00:23:20,046 --> 00:23:21,706
现在在 Swift 中


630
00:23:21,706 --> 00:23:23,126
所有这些更改


631
00:23:23,166 --> 00:23:24,866
都是向后兼容的


632
00:23:24,866 --> 00:23:26,606
所以我只需要修改次要版本号


633
00:23:27,186 --> 00:23:30,266
现在这种灵活性


634
00:23:30,266 --> 00:23:31,866
对如何设计框架的


635
00:23:31,866 --> 00:23:33,906
API 有一些影响


636
00:23:34,616 --> 00:23:36,426
最重要的是


637
00:23:36,426 --> 00:23:37,536
从小处着手


638
00:23:38,086 --> 00:23:39,436
如果你发现


639
00:23:39,436 --> 00:23:41,026
你需要新功能


640
00:23:41,026 --> 00:23:42,736
或者你的客户文件


641
00:23:42,736 --> 00:23:44,896
反馈说需要更多的功能


642
00:23:44,896 --> 00:23:46,526
那么添加新功能是很容易的


643
00:23:47,086 --> 00:23:48,576
但是很难


644
00:23:48,626 --> 00:23:50,296
删除某些东西


645
00:23:50,296 --> 00:23:51,946
因为它很可能会破坏


646
00:23:51,946 --> 00:23:53,816
至少一个客户的源代码


647
00:23:53,816 --> 00:23:55,326
或二进制兼容性


648
00:23:56,316 --> 00:23:57,866
对于那些你在事后


649
00:23:57,866 --> 00:23:59,016
无法更改的东西


650
00:23:59,526 --> 00:24:00,906
比如你的类型的名称


651
00:24:01,276 --> 00:24:02,366
请确保你


652
00:24:02,366 --> 00:24:04,136
预先仔细考虑过它们


653
00:24:04,136 --> 00:24:05,286
这些名称不仅在


654
00:24:05,286 --> 00:24:07,666
这个版本中有意义


655
00:24:07,666 --> 00:24:09,076
而且在所有将来的版本中都有意义


656
00:24:09,616 --> 00:24:13,386
最后不要过早地


657
00:24:13,386 --> 00:24:15,026
添加可扩展性


658
00:24:15,606 --> 00:24:16,556
你不需要在框架的


659
00:24:16,556 --> 00:24:18,406
第一个版本中


660
00:24:18,406 --> 00:24:20,476
将类设为开放


661
00:24:20,476 --> 00:24:21,756
提供任意的回调


662
00:24:22,666 --> 00:24:23,706
为什么这很重要


663
00:24:24,386 --> 00:24:25,806
因为当你必须


664
00:24:25,876 --> 00:24:27,926
考虑客户可能


665
00:24:27,996 --> 00:24:29,986
同时在做什么时


666
00:24:29,986 --> 00:24:31,526
对框架行为的推理


667
00:24:31,526 --> 00:24:32,516
会变得更加困难


668
00:24:33,666 --> 00:24:35,776
你总是可以在


669
00:24:35,776 --> 00:24:37,226
将来开放类


670
00:24:37,826 --> 00:24:39,196
你总是可以添加


671
00:24:39,196 --> 00:24:40,146
表示额外回调的属性


672
00:24:40,146 --> 00:24:42,696
但在默认情况下


673
00:24:42,696 --> 00:24:44,396
不能删除


674
00:24:44,396 --> 00:24:45,036
所添加的灵活性


675
00:24:45,706 --> 00:24:49,336
那么这一切是如何运作的呢


676
00:24:50,546 --> 00:24:53,906
间接 这仅仅只是一个单词而已


677
00:24:53,906 --> 00:24:55,226
让我们现在来看一个例子


678
00:24:55,356 --> 00:24:58,166
在左边这里


679
00:24:58,446 --> 00:24:59,796
我有 Spaceship 类


680
00:24:59,796 --> 00:25:03,206
这次剥离到它的模块接口


681
00:25:03,206 --> 00:25:04,806
在右边我使用了 fly 方法


682
00:25:06,106 --> 00:25:07,396
这是来自 FlightKit 


683
00:25:07,516 --> 00:25:09,456
框架外部的客户代码


684
00:25:10,536 --> 00:25:11,936
运行时


685
00:25:11,936 --> 00:25:13,616
客户端会问


686
00:25:13,616 --> 00:25:15,526
哪个方法


687
00:25:15,526 --> 00:25:17,266
是 fly 方法


688
00:25:17,786 --> 00:25:20,176
框架会回应


689
00:25:20,756 --> 00:25:22,326
是第二个


690
00:25:23,076 --> 00:25:25,556
这就是 Swift 


691
00:25:25,556 --> 00:25:27,766
确保二进制兼容性的方式


692
00:25:27,766 --> 00:25:28,866
即使在向类添加新方法时也是如此


693
00:25:30,156 --> 00:25:31,826
它基本上


694
00:25:32,026 --> 00:25:33,526
与 Objective-C


695
00:25:33,566 --> 00:25:35,776
进行消息调度的方式相同


696
00:25:36,046 --> 00:25:40,156
在从一个库到另一个库的调用中执行它


697
00:25:40,196 --> 00:25:43,766
但 Swift 仅在你跨越此客户框架边界时执行此操作


698
00:25:45,716 --> 00:25:46,876
还有另一种


699
00:25:46,876 --> 00:25:48,396
间接的形式


700
00:25:48,796 --> 00:25:51,786
当客户使用框架中


701
00:25:52,086 --> 00:25:53,466
定义的结构体或枚举时


702
00:25:54,536 --> 00:25:55,826
在本例中


703
00:25:55,826 --> 00:25:57,906
fly 方法的一个参数


704
00:25:57,906 --> 00:26:00,546
是来自 speed 枚举的 fast case


705
00:26:01,176 --> 00:26:03,506
我之前说过


706
00:26:03,506 --> 00:26:05,046
枚举可以在


707
00:26:05,326 --> 00:26:06,316
不破坏二进制兼容性的情况下


708
00:26:06,316 --> 00:26:07,106
添加新 case


709
00:26:08,576 --> 00:26:10,296
这意味着


710
00:26:10,296 --> 00:26:12,906
客户端不能假设


711
00:26:12,906 --> 00:26:14,936
它知道枚举在内存中的大小


712
00:26:16,026 --> 00:26:18,286
因此枚举的这种使用


713
00:26:18,286 --> 00:26:19,836
要求客户端


714
00:26:20,586 --> 00:26:21,396
询问框架有多大


715
00:26:22,236 --> 00:26:25,546
框架回应它只有一个字节


716
00:26:26,976 --> 00:26:29,386
这里的另一种可能性是


717
00:26:29,386 --> 00:26:30,876
将来添加的新 case 之一


718
00:26:30,876 --> 00:26:33,316
可能具有相关的值


719
00:26:34,156 --> 00:26:35,636
那些相关的值


720
00:26:35,636 --> 00:26:37,396
可能需要一些清理


721
00:26:38,606 --> 00:26:40,376
因此客户端也会


722
00:26:40,376 --> 00:26:41,906
要求框架在完成时


723
00:26:41,906 --> 00:26:43,606
清除枚举值


724
00:26:43,606 --> 00:26:45,526
并且框架也将这样做


725
00:26:46,106 --> 00:26:48,986
此时观众中


726
00:26:48,986 --> 00:26:50,596
的一些人


727
00:26:50,596 --> 00:26:52,206
可能会变得有些烦躁


728
00:26:52,766 --> 00:26:54,446
因为我们谈论的


729
00:26:54,446 --> 00:26:56,436
是客户端和框架之间的


730
00:26:56,436 --> 00:26:57,716
所有这些额外的通信


731
00:26:58,766 --> 00:26:59,796
那是因为你有


732
00:26:59,986 --> 00:27:01,076
对性能敏感的框架


733
00:27:01,076 --> 00:27:02,636
这就是为什么下一节 


734
00:27:02,636 --> 00:27:04,086
是关于牺牲


735
00:27:04,086 --> 00:27:05,506
Swift 提供的灵活性


736
00:27:05,506 --> 00:27:07,206
来换取


737
00:27:07,206 --> 00:27:12,966
给客户的优化


738
00:27:14,416 --> 00:27:16,696
这是一个权衡


739
00:27:17,386 --> 00:27:19,156
作为框架的作者


740
00:27:19,156 --> 00:27:20,586
我们希望


741
00:27:20,586 --> 00:27:22,046
能够在不破坏源代码


742
00:27:22,046 --> 00:27:24,626
或二进制兼容性的情况下


743
00:27:24,626 --> 00:27:26,556
灵活地更改 添加和改进


744
00:27:27,976 --> 00:27:29,616
但是为了让编译器


745
00:27:29,616 --> 00:27:31,356
尽可能快地


746
00:27:31,356 --> 00:27:33,356
生成客户代码


747
00:27:33,356 --> 00:27:35,556
它需要对框架中的内容做出假设


748
00:27:35,996 --> 00:27:40,146
所以 Swift 需要同时


749
00:27:40,146 --> 00:27:42,656
处理这两方面的问题


750
00:27:43,066 --> 00:27:45,646
它的工作方式是


751
00:27:45,676 --> 00:27:46,866
通过 Build Libraries for Distribution


752
00:27:46,866 --> 00:27:48,186
的构建设置


753
00:27:48,826 --> 00:27:50,046
Harlan 之前说过


754
00:27:50,046 --> 00:27:53,426
除了生成模块接口文件之外


755
00:27:53,426 --> 00:27:55,576
它还有多种效果


756
00:27:55,886 --> 00:27:57,446
其中一种效果是


757
00:27:57,446 --> 00:27:59,426
将默认值设置为偏向灵活性


758
00:28:00,736 --> 00:28:02,736
但同样 Swift 需要


759
00:28:02,736 --> 00:28:04,576
能够处理所有这些用例


760
00:28:04,576 --> 00:28:06,646
因此在本节中


761
00:28:06,816 --> 00:28:07,966
我将讨论一下


762
00:28:07,966 --> 00:28:10,306
一旦你从外部


763
00:28:10,506 --> 00:28:11,906
分析了框架的行为


764
00:28:11,906 --> 00:28:13,466
并且看到你需要额外的性能


765
00:28:13,466 --> 00:28:14,956
你可以做些什么


766
00:28:15,046 --> 00:28:16,346
有三种方法


767
00:28:16,346 --> 00:28:18,206
可以做到这一点


768
00:28:18,876 --> 00:28:20,756
内联函数


769
00:28:20,756 --> 00:28:21,326
冻结枚举和冻结结构


770
00:28:21,926 --> 00:28:24,836
因此我们将从


771
00:28:24,836 --> 00:28:26,576
内联函数开始


772
00:28:26,576 --> 00:28:28,536
这是去年在 Swift 4.2 中引入的一个特性


773
00:28:29,426 --> 00:28:31,526
在这个例子中


774
00:28:31,526 --> 00:28:33,326
我有一个 cargoship 子类


775
00:28:33,326 --> 00:28:35,286
这是我们之前看到


776
00:28:35,286 --> 00:28:37,376
的 Spaceship 类的一个子类


777
00:28:37,376 --> 00:28:39,466
它有一个方法 canCarry


778
00:28:39,826 --> 00:28:41,606
它只决定货船


779
00:28:41,606 --> 00:28:42,076
是否能够装载一些货物


780
00:28:43,376 --> 00:28:45,046
我把它变成了内联的


781
00:28:45,416 --> 00:28:46,426
因为我认为


782
00:28:46,426 --> 00:28:47,726
这对我的客户


783
00:28:47,726 --> 00:28:48,576
表现很重要


784
00:28:49,736 --> 00:28:51,986
这将使这个方法


785
00:28:51,986 --> 00:28:54,056
成为我的公共接口的一部分


786
00:28:54,056 --> 00:28:55,906
不仅是它的声明


787
00:28:55,906 --> 00:28:57,806
而且是它的主体


788
00:28:58,916 --> 00:29:00,486
这样做的效果是


789
00:29:00,486 --> 00:29:02,636
将主体复制到


790
00:29:02,636 --> 00:29:03,646
模块接口文件中


791
00:29:04,236 --> 00:29:07,076
如果你看得比较快


792
00:29:07,366 --> 00:29:08,876
你还会看到这个方法


793
00:29:08,946 --> 00:29:10,836
引用 CargoShip 类


794
00:29:11,026 --> 00:29:12,356
的一个内部属性


795
00:29:13,766 --> 00:29:15,326
这是可能的


796
00:29:15,326 --> 00:29:16,936
因为我已将


797
00:29:16,936 --> 00:29:18,296
该属性标记为可从内联使用


798
00:29:19,386 --> 00:29:20,786
这可以让你


799
00:29:20,786 --> 00:29:21,516
充分利用这两个世界


800
00:29:22,246 --> 00:29:24,046
作为框架的公共接口的一部分


801
00:29:24,096 --> 00:29:25,446
该属性是可用的


802
00:29:25,446 --> 00:29:27,526
但仅对


803
00:29:27,526 --> 00:29:29,656
可内联代码可用


804
00:29:29,956 --> 00:29:31,476
它仍然受到保护


805
00:29:31,476 --> 00:29:33,736
不受外部客户端


806
00:29:33,736 --> 00:29:34,866
任意读取或写入


807
00:29:35,426 --> 00:29:37,556
所以它仍然是内部的


808
00:29:37,556 --> 00:29:38,556
但可以从内联中使用


809
00:29:39,876 --> 00:29:41,866
值得注意的是


810
00:29:41,866 --> 00:29:43,906
这是一个声明决定


811
00:29:44,486 --> 00:29:46,016
此处的 currentCargo 属性


812
00:29:46,016 --> 00:29:47,986
也是内部的


813
00:29:47,986 --> 00:29:49,476
不包含在模块界面中


814
00:29:51,936 --> 00:29:54,336
我们在模块接口中


815
00:29:54,336 --> 00:29:56,676
有 canCarry 方法的主体


816
00:29:57,366 --> 00:29:59,046
当客户端根据


817
00:29:59,046 --> 00:30:00,746
该接口进行编译时


818
00:30:00,746 --> 00:30:02,146
他们将能够将


819
00:30:02,296 --> 00:30:03,916
该主体直接复制到自己的代码中


820
00:30:04,326 --> 00:30:05,896
如果他们了解


821
00:30:05,966 --> 00:30:07,486
正在检查的


822
00:30:07,486 --> 00:30:08,676
货物的一些信息


823
00:30:09,706 --> 00:30:09,826
还可能进一步优化它


824
00:30:10,376 --> 00:30:12,046
但是如果框架所有者


825
00:30:12,046 --> 00:30:14,126
更改了方法的主体


826
00:30:14,126 --> 00:30:15,926
而客户没有重新编译


827
00:30:15,986 --> 00:30:17,136
会发生什么呢


828
00:30:17,826 --> 00:30:21,466
例如


829
00:30:21,466 --> 00:30:22,756
如果有一条新规定说


830
00:30:22,756 --> 00:30:24,116
货船不允许


831
00:30:24,116 --> 00:30:25,686
装载放射性物质怎么办


832
00:30:26,936 --> 00:30:28,556
在这种情况下


833
00:30:28,556 --> 00:30:29,476
我们会遇到麻烦


834
00:30:29,906 --> 00:30:31,266
因为现在程序的


835
00:30:31,266 --> 00:30:32,516
两个不同部分


836
00:30:32,516 --> 00:30:34,216
对这个方法应该做什么


837
00:30:34,216 --> 00:30:34,976
有不同的想法


838
00:30:35,946 --> 00:30:37,296
对于一些输入


839
00:30:37,296 --> 00:30:39,766
它们仍然会同意


840
00:30:39,766 --> 00:30:42,196
对于一些常规的货物


841
00:30:42,976 --> 00:30:46,166
客户端和框架


842
00:30:46,706 --> 00:30:47,076
都会说没问题


843
00:30:47,076 --> 00:30:48,196
但是如果


844
00:30:48,196 --> 00:30:50,616
我们试图测试放射性货物


845
00:30:50,616 --> 00:30:52,426
那么客户端代码会说没问题


846
00:30:52,426 --> 00:30:54,336
因为这是


847
00:30:54,336 --> 00:30:55,566
它在编译模块


848
00:30:55,566 --> 00:30:56,326
接口时看到的


849
00:30:57,376 --> 00:30:58,846
虽然框架


850
00:30:58,846 --> 00:31:00,706
具有该方法的新版本


851
00:31:00,706 --> 00:31:01,556
但仍然将不允许它


852
00:31:02,216 --> 00:31:03,946
这可能表明


853
00:31:03,946 --> 00:31:05,456
程序中存在严重的逻辑错误


854
00:31:06,526 --> 00:31:08,566
因此作为一个经验法则


855
00:31:08,566 --> 00:31:09,646
如果你是一个框架作者


856
00:31:09,646 --> 00:31:11,116
并且使一个函数可以内联


857
00:31:11,666 --> 00:31:13,236
那么请确保


858
00:31:13,236 --> 00:31:14,976
不要更改输出或可观察的行为


859
00:31:16,176 --> 00:31:17,606
你可以添加


860
00:31:17,606 --> 00:31:19,966
一个更好的算法


861
00:31:20,036 --> 00:31:21,866
或者一些额外的快速填充


862
00:31:21,866 --> 00:31:23,166
但是如果你


863
00:31:23,166 --> 00:31:25,286
改变了函数的可观察行为


864
00:31:25,286 --> 00:31:26,256
那么你最终


865
00:31:26,256 --> 00:31:27,836
可能会遇到这些非常微妙的问题


866
00:31:27,836 --> 00:31:29,776
这些问题只在运行时可见


867
00:31:29,776 --> 00:31:30,796
而且可能只在某些输入下可见


868
00:31:31,096 --> 00:31:32,556
如果你需要这样做


869
00:31:32,556 --> 00:31:34,096
则需要重新编译所有客户端


870
00:31:34,686 --> 00:31:39,836
接下来我想谈谈枚举


871
00:31:40,946 --> 00:31:43,756
Swift 枚举很棒 我爱它们


872
00:31:44,556 --> 00:31:45,496
我们在这里谈到的一件事是


873
00:31:45,496 --> 00:31:47,036
你可以在


874
00:31:47,036 --> 00:31:48,946
不破坏源代码或


875
00:31:48,976 --> 00:31:50,236
二进制兼容性的情况下


876
00:31:50,236 --> 00:31:51,096
将新 case 添加到枚举中


877
00:31:51,946 --> 00:31:53,796
这对客户端意味着


878
00:31:53,796 --> 00:31:54,996
当切换枚举时


879
00:31:54,996 --> 00:31:57,566
它们总是必须有一个默认情况


880
00:31:58,346 --> 00:31:59,976
在这个客户端中


881
00:31:59,976 --> 00:32:03,276
他们决定使用 Swift 4.2 中引入的


882
00:32:03,276 --> 00:32:06,276
未知默认语法


883
00:32:06,516 --> 00:32:08,466
这意味着它们已经处理了


884
00:32:08,466 --> 00:32:10,766
枚举中所有已知的情况


885
00:32:10,766 --> 00:32:13,506
但是仍然会


886
00:32:13,506 --> 00:32:15,146
处理将来添加的任何情况


887
00:32:15,616 --> 00:32:16,906
这在切换 C 枚举


888
00:32:16,906 --> 00:32:22,906
和构建在二进制框架中的枚举时是必要的


889
00:32:23,456 --> 00:32:26,346
这就是我之前


890
00:32:26,576 --> 00:32:28,026
谈到的另一个影响


891
00:32:28,376 --> 00:32:30,026
客户端和框架


892
00:32:30,026 --> 00:32:31,286
之间的这种交流


893
00:32:31,586 --> 00:32:33,446
关于枚举的大小


894
00:32:33,446 --> 00:32:34,866
以及是否需要进行任何清理


895
00:32:35,306 --> 00:32:37,826
但我在这里选择


896
00:32:37,826 --> 00:32:38,946
的例子是飞行计划


897
00:32:39,746 --> 00:32:41,666
你只能乘坐单程


898
00:32:41,666 --> 00:32:43,446
或往返航班


899
00:32:44,826 --> 00:32:46,666
因此通过使用


900
00:32:46,666 --> 00:32:49,336
冻结属性标记此枚举


901
00:32:49,336 --> 00:32:50,786
我作为框架作者


902
00:32:51,906 --> 00:32:53,286
可以保证


903
00:32:53,286 --> 00:32:55,526
在框架的未来版本中不会添加新 case


904
00:32:56,956 --> 00:32:58,796
这样做的第一个影响是


905
00:32:58,796 --> 00:33:00,436
客户端不再需要


906
00:33:00,436 --> 00:33:01,406
编写该默认情况


907
00:33:01,596 --> 00:33:02,686
它可以自行消失


908
00:33:04,276 --> 00:33:07,316
接下来编译器


909
00:33:07,316 --> 00:33:09,226
可以更有效地编译它


910
00:33:09,946 --> 00:33:12,476
客户端可以假设


911
00:33:12,976 --> 00:33:14,266
这个枚举不会


912
00:33:14,266 --> 00:33:16,236
有任何额外的情况


913
00:33:16,236 --> 00:33:17,436
也不需要进行任何清理


914
00:33:18,756 --> 00:33:22,346
这太好了 只是我忘了一件事


915
00:33:22,996 --> 00:33:24,786
还有另一种飞行计划


916
00:33:24,786 --> 00:33:26,026
多程航班


917
00:33:27,186 --> 00:33:28,246
现在我们遇到了麻烦


918
00:33:28,746 --> 00:33:30,546
因为客户端代码


919
00:33:30,546 --> 00:33:32,956
不再具有默认情况


920
00:33:32,956 --> 00:33:35,206
因此在冻结枚举


921
00:33:35,206 --> 00:33:37,946
中添加新 case


922
00:33:37,946 --> 00:33:39,476
既包括源代码


923
00:33:39,476 --> 00:33:41,006
和二进制代码中断


924
00:33:41,326 --> 00:33:42,706
并且需要迭代主要版本


925
00:33:42,706 --> 00:33:48,296
并要求所有客户端重新编译 现在在冷冻枚举后


926
00:33:48,296 --> 00:33:49,946
冷冻结构大致相同


927
00:33:50,516 --> 00:33:52,886
默认情况下


928
00:33:52,886 --> 00:33:54,646
二进制框架中的结构


929
00:33:54,646 --> 00:33:55,756
可以添加新的存储属性


930
00:33:55,756 --> 00:33:57,686
或者对现有的属性


931
00:33:57,686 --> 00:33:59,856
进行重新排序


932
00:33:59,916 --> 00:34:01,716
而不会有任何问题


933
00:34:02,096 --> 00:34:03,066
但这确实会导致


934
00:34:03,066 --> 00:34:04,856
相同类型的交流


935
00:34:05,136 --> 00:34:06,036
以及客户端和框架之间的额外通信


936
00:34:06,746 --> 00:34:10,485
因此为了避免这种情况


937
00:34:10,485 --> 00:34:12,386
对于已知


938
00:34:12,386 --> 00:34:14,956
具有冻结布局的结构


939
00:34:14,956 --> 00:34:16,926
可以使用冻结属性


940
00:34:17,216 --> 00:34:19,306
来保证存储的属性不会更改


941
00:34:19,616 --> 00:34:20,936
它们不会被添加


942
00:34:20,936 --> 00:34:22,166
重新排序或删除


943
00:34:22,835 --> 00:34:25,596
这样做的另一件事是


944
00:34:25,656 --> 00:34:27,726
要求存储的属性


945
00:34:27,726 --> 00:34:30,126
都具有公共的类型


946
00:34:30,126 --> 00:34:32,315
或者内联的可用类型


947
00:34:32,876 --> 00:34:34,775
因为记住这里的目标是什么


948
00:34:35,156 --> 00:34:37,146
我们希望编译器


949
00:34:37,146 --> 00:34:39,505
在处理客户端代码时


950
00:34:39,505 --> 00:34:40,846
能够直接操作


951
00:34:40,846 --> 00:34:42,045
这个结构的存储属性


952
00:34:42,045 --> 00:34:43,616
以便在客户端


953
00:34:43,616 --> 00:34:46,926
生成更有效的代码


954
00:34:47,815 --> 00:34:49,966
这还具有语义效应


955
00:34:50,386 --> 00:34:51,416
即框架作者


956
00:34:51,416 --> 00:34:53,936
现在可以编写可内联的初始化器


957
00:34:54,525 --> 00:34:55,996
设置结构中的


958
00:34:55,996 --> 00:34:57,836
所有存储属性


959
00:34:57,836 --> 00:34:59,256
已经需要一个初始化器


960
00:34:59,826 --> 00:35:01,866
但是现在编译器


961
00:35:02,066 --> 00:35:03,726
可以确保


962
00:35:03,726 --> 00:35:04,816
在框架的未来版本


963
00:35:04,816 --> 00:35:05,236
中也会这样做


964
00:35:05,326 --> 00:35:11,156
现在我想提醒你


965
00:35:11,156 --> 00:35:13,036
出于某些原因灵活性是默认的


966
00:35:13,036 --> 00:35:13,736
来结束这部分话题


967
00:35:14,536 --> 00:35:15,896
其中最主要的一点是


968
00:35:15,896 --> 00:35:17,656
中断更改对客户


969
00:35:17,656 --> 00:35:19,226
来说非常不方便


970
00:35:20,136 --> 00:35:21,926
客户可能会


971
00:35:21,926 --> 00:35:23,516
重新考虑是否


972
00:35:23,516 --> 00:35:25,026
采用新版本的框架


973
00:35:25,026 --> 00:35:26,606
因为框架可能会以


974
00:35:26,606 --> 00:35:27,686
某种方式破坏它们自身


975
00:35:28,366 --> 00:35:29,446
当一个二进制框架


976
00:35:29,446 --> 00:35:31,316
依赖于另一个二进制框架时


977
00:35:31,316 --> 00:35:32,706
你也可能会遇到麻烦


978
00:35:34,136 --> 00:35:35,666
同样值得提醒的是


979
00:35:36,836 --> 00:35:39,286
这些属性只影响客户端代码


980
00:35:39,696 --> 00:35:41,196
在你的框架中


981
00:35:41,196 --> 00:35:44,186
你仍然可以获得编译器优化的全部功能


982
00:35:45,586 --> 00:35:47,856
因此在使用冻结


983
00:35:47,856 --> 00:35:49,716
或内联之前


984
00:35:49,716 --> 00:35:51,156
请确保你已经


985
00:35:51,156 --> 00:35:52,826
从外部描述了框架的行为


986
00:35:53,256 --> 00:35:54,636
并证明你需要


987
00:35:54,636 --> 00:35:56,216
额外的性能


988
00:35:56,796 --> 00:35:58,936
否则保持灵活性


989
00:35:58,936 --> 00:36:00,546
因为你可能需要它


990
00:36:02,696 --> 00:36:04,106
现在我想谈的最后一部分


991
00:36:04,106 --> 00:36:05,836
是确保客户的


992
00:36:05,836 --> 00:36:08,516
体验是最好的


993
00:36:09,266 --> 00:36:11,086
这与 Harlan 


994
00:36:11,086 --> 00:36:12,826
前半部分的


995
00:36:12,826 --> 00:36:13,916
内容非常相似


996
00:36:14,496 --> 00:36:16,726
我们将从授权开始


997
00:36:17,636 --> 00:36:19,036
如果你的框架


998
00:36:19,036 --> 00:36:20,276
具有完成其工作


999
00:36:20,276 --> 00:36:22,316
所需的某些权利


1000
00:36:22,316 --> 00:36:23,216
那么让我们从基础开始


1001
00:36:23,456 --> 00:36:24,636
请你确保记录它们


1002
00:36:24,636 --> 00:36:26,226
以便任何潜在客户知道


1003
00:36:26,226 --> 00:36:28,146
成功采用你的框架


1004
00:36:28,456 --> 00:36:30,096
需要做什么


1005
00:36:30,606 --> 00:36:34,536
此外尽量减少


1006
00:36:34,536 --> 00:36:38,486
特定框架的授权请求


1007
00:36:38,486 --> 00:36:39,676
因为这意味着


1008
00:36:39,676 --> 00:36:41,676
它将适用于更多的上下文


1009
00:36:42,126 --> 00:36:43,816
你可以使用你的框架


1010
00:36:44,086 --> 00:36:45,056
获得更多客户


1011
00:36:45,516 --> 00:36:49,636
最后请记住


1012
00:36:49,636 --> 00:36:51,486
虽然框架和 App 


1013
00:36:51,486 --> 00:36:53,036
都可以向用户


1014
00:36:53,096 --> 00:36:54,656
请求权限


1015
00:36:54,726 --> 00:36:56,686
但最终是否


1016
00:36:57,286 --> 00:36:58,446
授予权限是用户的选择


1017
00:36:59,606 --> 00:37:00,976
因此如果你被


1018
00:37:00,976 --> 00:37:02,746
拒绝了某个特定的权限


1019
00:37:02,746 --> 00:37:04,016
请确保你的框架


1020
00:37:04,016 --> 00:37:05,026
能够优雅地处理该拒绝


1021
00:37:05,316 --> 00:37:07,026
它不应该使 App 崩溃


1022
00:37:07,026 --> 00:37:08,156
也不应该停止工作


1023
00:37:08,646 --> 00:37:09,716
确保它仍然做


1024
00:37:09,756 --> 00:37:11,456
一些有用的事情


1025
00:37:11,456 --> 00:37:12,916
以便你的客户


1026
00:37:13,236 --> 00:37:15,166
可以使用框架而不必放弃


1027
00:37:16,996 --> 00:37:19,186
现在依赖关系


1028
00:37:19,186 --> 00:37:20,416
与权限有很多


1029
00:37:20,416 --> 00:37:21,176
相同的问题


1030
00:37:21,926 --> 00:37:23,506
因为就像权限一样


1031
00:37:23,506 --> 00:37:25,416
框架的依赖关系


1032
00:37:25,416 --> 00:37:26,986
变成了 App 的依赖关系


1033
00:37:27,986 --> 00:37:30,136
因此你应该


1034
00:37:30,136 --> 00:37:31,906
首先记录它们


1035
00:37:31,906 --> 00:37:33,816
以便潜在客户


1036
00:37:33,816 --> 00:37:34,826
知道他们注册了什么


1037
00:37:35,486 --> 00:37:36,776
而且你应该尽量


1038
00:37:36,776 --> 00:37:38,156
减少你的依赖关系


1039
00:37:38,156 --> 00:37:39,796
这样你对客户的要求就会更少


1040
00:37:40,106 --> 00:37:42,036
在扩展信任方面


1041
00:37:42,036 --> 00:37:43,986
你对客户的要求也要更少


1042
00:37:43,986 --> 00:37:45,696
甚至在实际问题上


1043
00:37:45,696 --> 00:37:46,346
比如依赖项占用的代码大小方面


1044
00:37:48,006 --> 00:37:51,876
最后 所有的依赖项都必须使用


1045
00:37:52,106 --> 00:37:53,216
Build Libraries for Distribution


1046
00:37:53,216 --> 00:37:55,096
构建设置来构建


1047
00:37:55,096 --> 00:37:56,416
以便获得我们


1048
00:37:56,416 --> 00:37:59,926
所讨论的二进制兼容性保证


1049
00:38:00,476 --> 00:38:02,096
这确实有一个特殊含义


1050
00:38:02,096 --> 00:38:04,156
即二进制


1051
00:38:04,156 --> 00:38:06,436
框架不能依赖于包


1052
00:38:07,446 --> 00:38:08,936
让我们看一个依赖关系图


1053
00:38:10,366 --> 00:38:11,946
几分钟前我说过


1054
00:38:12,276 --> 00:38:14,706
框架的依赖关系


1055
00:38:14,706 --> 00:38:15,746
成为 App 的依赖关系


1056
00:38:15,976 --> 00:38:18,326
但是当一个 


1057
00:38:18,326 --> 00:38:19,926
App 构建一个包时


1058
00:38:19,926 --> 00:38:21,586
它必须选择一个特定的标签来执行此操作


1059
00:38:22,416 --> 00:38:23,496
这可能与你


1060
00:38:23,496 --> 00:38:25,746
构建框架的版本不匹配


1061
00:38:26,076 --> 00:38:27,686
它可能根本不兼容


1062
00:38:28,596 --> 00:38:30,806
除此之外


1063
00:38:30,806 --> 00:38:32,666
并非所有框架都必须


1064
00:38:32,666 --> 00:38:34,036
以与 Build Libraries for Distribution


1065
00:38:34,036 --> 00:38:36,406
兼容的模式构建


1066
00:38:37,246 --> 00:38:39,626
所以我们不支持这种配置


1067
00:38:39,626 --> 00:38:42,776
现在我想谈的最后一件事


1068
00:38:42,776 --> 00:38:45,216
是你们的 Objective-C 接口


1069
00:38:45,986 --> 00:38:47,546
是的你


1070
00:38:47,546 --> 00:38:49,416
Swift 框架的作者


1071
00:38:49,416 --> 00:38:51,546
你有一个 Objective-C 接口


1072
00:38:51,546 --> 00:38:53,216
很有可能因为 Xcode 的默认模板


1073
00:38:53,216 --> 00:38:54,906
是为一个混合源框架设置的


1074
00:38:55,096 --> 00:38:56,346
它有一个 


1075
00:38:56,346 --> 00:38:58,616
Objective-C Umbrella Header


1076
00:38:58,616 --> 00:38:59,486
和一个生成的 Header


1077
00:38:59,486 --> 00:39:01,206
位于你的框架中 Swift 包含


1078
00:39:01,206 --> 00:39:01,926
的 Objective-C 部分


1079
00:39:02,566 --> 00:39:05,456
但是如果你的 


1080
00:39:05,456 --> 00:39:07,326
Swift 代码没有任何它


1081
00:39:07,566 --> 00:39:09,716
试图发布的 Objective-C API


1082
00:39:09,916 --> 00:39:12,116
那么你根本不需要安装第二个 Header


1083
00:39:12,476 --> 00:39:14,066
这里有一个你可以直接关闭的


1084
00:39:14,066 --> 00:39:17,156
Install Objective-C Compatibility Header


1085
00:39:17,156 --> 00:39:20,686
构建设置 如果你的框架


1086
00:39:20,686 --> 00:39:23,386
没有提供任何 Objective-C API


1087
00:39:23,386 --> 00:39:24,216
那就没有理由


1088
00:39:24,216 --> 00:39:25,866
支持 Objective-C 导入语法


1089
00:39:25,866 --> 00:39:27,596
你也可以通过


1090
00:39:27,596 --> 00:39:29,186
Defines Module Build


1091
00:39:29,186 --> 00:39:30,186
设置关闭它


1092
00:39:30,846 --> 00:39:32,666
将其设置为 No


1093
00:39:32,666 --> 00:39:33,976
这将不再支持有效


1094
00:39:33,976 --> 00:39:34,306
的 Objective-C 代码


1095
00:39:35,386 --> 00:39:36,856
在你完成此操作后


1096
00:39:36,856 --> 00:39:38,886
你可以删除 Xcode 


1097
00:39:38,886 --> 00:39:40,716
为你生成的 Umbrella Header


1098
00:39:42,376 --> 00:39:43,966
所以让我们总结一下


1099
00:39:44,576 --> 00:39:45,756
我们今天谈了很多


1100
00:39:45,756 --> 00:39:49,046
但最重要的是 XC 框架


1101
00:39:49,376 --> 00:39:50,516
它们是一种新的捆绑包格式


1102
00:39:50,516 --> 00:39:51,606
用于以一种用户


1103
00:39:51,606 --> 00:39:53,496
非常容易使用的方式


1104
00:39:53,496 --> 00:39:55,376
分发多个框架变体


1105
00:39:56,606 --> 00:39:57,506
为了构建 XC 框架


1106
00:39:57,506 --> 00:39:58,996
你需要打开


1107
00:39:58,996 --> 00:40:00,076
Build Libraries for Distribution


1108
00:40:00,076 --> 00:40:01,176
构建设置


1109
00:40:01,476 --> 00:40:02,656
这将激活你获得


1110
00:40:02,656 --> 00:40:04,896
正确的二进制兼容


1111
00:40:04,896 --> 00:40:05,886
框架所需的一切


1112
00:40:06,426 --> 00:40:08,876
作为框架所有者


1113
00:40:08,876 --> 00:40:11,186
请确保你了解你对客户的责任


1114
00:40:11,186 --> 00:40:12,676
以便你可以


1115
00:40:12,676 --> 00:40:14,826
为他们提供最好的服务


1116
00:40:14,996 --> 00:40:16,096
Harlan 和我将在


1117
00:40:16,096 --> 00:40:17,536
本节会议结束后


1118
00:40:17,536 --> 00:40:19,376
立即进入实验室


1119
00:40:19,376 --> 00:40:20,656
对于所有来到这里参会的人


1120
00:40:20,716 --> 00:40:21,506
非常感谢你们


1121
00:40:21,506 --> 00:40:21,966
让我们看看这些很棒的框架


1122
00:40:22,516 --> 00:40:25,500
[掌声和欢呼]

