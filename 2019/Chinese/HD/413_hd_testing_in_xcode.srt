1
00:00:06,039 --> 00:00:09,443 line:0
（Xcode测试）


2
00:00:14,248 --> 00:00:16,583 line:-2
早上好 欢迎参加
Xcode测试演讲


3
00:00:17,217 --> 00:00:18,552 line:-1
我是Ana Calinov


4
00:00:18,619 --> 00:00:20,687 line:-1
我将与我的同事


5
00:00:20,988 --> 00:00:22,689 line:-2
Stuart Montgomery
和Ethan Vaughan一起演讲


6
00:00:24,124 --> 00:00:25,359 line:-1
在今天的演讲中


7
00:00:25,425 --> 00:00:28,729 line:-2
我们先介绍用XCTest
在Xcode中进行测试


8
00:00:29,396 --> 00:00:32,299 line:-1
然后Stuart会讲测试计划功能


9
00:00:32,966 --> 00:00:38,005 line:-2
最后Ethan会讲
持续集成的XCTest app


10
00:00:38,071 --> 00:00:39,373 line:-1
（XCTEST入门）


11
00:00:39,439 --> 00:00:41,108 line:-1
让我们先讲XCTest


12
00:00:42,643 --> 00:00:47,147 line:-2
XCTest是Xcode提供的
一种自动测试框架


13
00:00:47,447 --> 00:00:51,251 line:-2
配备内置支持可以帮助你
设置并执行测试


14
00:00:52,286 --> 00:00:55,389 line:-2
测试对于开发任何项目来说
都是非常重要的步骤


15
00:00:55,789 --> 00:00:58,325 line:-1
测试可以帮助你找到源代码中的错误


16
00:00:59,359 --> 00:01:01,795 line:-1
你还可以使用测试来编纂需求


17
00:01:02,262 --> 00:01:05,933 line:-1
意思是测试你所预期的行为


18
00:01:06,400 --> 00:01:08,569 line:-1
并且你和你的团队之后的工作


19
00:01:08,936 --> 00:01:10,904 line:-1
也可以通过这些预期得到保证


20
00:01:12,673 --> 00:01:14,041 line:-1
我们先看一个概述


21
00:01:14,308 --> 00:01:17,344 line:-1
关于你应该如何考虑规划


22
00:01:17,411 --> 00:01:18,245 line:-1
任意项目的自动化测试套件


23
00:01:19,146 --> 00:01:21,448 line:-1
用于测试的金字塔模型


24
00:01:21,849 --> 00:01:24,218 line:-1
有助于在彻底性、


25
00:01:24,785 --> 00:01:26,720 line:-1
质量和执行速度之间取得平衡


26
00:01:26,787 --> 00:01:28,188 line:-1
（测试金字塔）


27
00:01:28,255 --> 00:01:30,224 line:-1
单元测试是金字塔的基础


28
00:01:31,325 --> 00:01:33,994 line:-1
单元测试用于验证某一段代码


29
00:01:34,328 --> 00:01:35,395 line:-1
通常是个函数


30
00:01:36,496 --> 00:01:39,333 line:-1
这是通过给函数输入变量


31
00:01:39,833 --> 00:01:42,002 line:-2
并检查它们是否返回预期的输出
实现的


32
00:01:43,003 --> 00:01:45,472 line:-1
单元测试很短 很简单


33
00:01:45,839 --> 00:01:46,974 line:-1
并且运行速度也很快


34
00:01:47,975 --> 00:01:49,977 line:-1
这是我们所有测试的基础


35
00:01:50,277 --> 00:01:53,113 line:-2
因此你要写很多单元测试
来测试你的所有函数


36
00:01:55,015 --> 00:01:56,683 line:-1
接下来我们有集成测试


37
00:01:57,518 --> 00:02:01,221 line:-1
集成测试用于验证较大的一部分代码


38
00:02:02,122 --> 00:02:06,226 line:-2
这些测试的目标是
离散子系统或类群集


39
00:02:06,660 --> 00:02:09,963 line:-2
用于确保不同组件可以在一起
正常运作


40
00:02:11,832 --> 00:02:14,334 line:-1
集成测试位于单元测试之上


41
00:02:14,401 --> 00:02:17,971 line:-2
因为你要确保
在测试较大的代码段之前


42
00:02:18,038 --> 00:02:20,140 line:-1
先确保单一函数正常运行


43
00:02:21,275 --> 00:02:24,845 line:-2
一般来说 你不需要有与单元测试
数量相同的集成测试


44
00:02:25,546 --> 00:02:27,181 line:-1
集成测试的运行时间稍长


45
00:02:27,514 --> 00:02:29,683 line:-1
但它们却可以一次测试很多东西


46
00:02:31,118 --> 00:02:34,188 line:-1
最后是用户界面或UI测试


47
00:02:34,621 --> 00:02:37,291 line:-1
用于观察app的用户端行为


48
00:02:38,158 --> 00:02:41,628 line:-2
这会确保你的app
确实实现了你所预期的功能


49
00:02:42,596 --> 00:02:44,665 line:-1
UI测试的运行时间最长


50
00:02:45,065 --> 00:02:48,035 line:-2
但它们对于表明
一切都正常运行来说至关重要


51
00:02:49,536 --> 00:02:51,939 line:-1
UI测试还要求更多的维护


52
00:02:52,005 --> 00:02:54,641 line:-2
因为你app的UI可能会发生
比较频繁的改变


53
00:02:55,576 --> 00:02:58,745 line:-1
完整的测试金字塔可以帮助你


54
00:02:58,812 --> 00:03:00,747 line:-1
在三种不同的测试类型之间进行平衡


55
00:03:01,114 --> 00:03:04,151 line:-2
并确保测试套件
覆盖了你所需要的功能


56
00:03:05,686 --> 00:03:08,155 line:-1
那么我们刚讲了如何平衡测试套件


57
00:03:08,655 --> 00:03:11,491 line:-2
现在让我们讲一下XCTest
所提供的工具


58
00:03:11,558 --> 00:03:12,659 line:-1
用于帮助你实施测试


59
00:03:15,362 --> 00:03:17,030 line:-1
XCTest中的单元测试


60
00:03:17,798 --> 00:03:20,067 line:-1
是针对源代码的所有测试


61
00:03:21,001 --> 00:03:23,170 line:-1
这包含标准单元测试


62
00:03:23,504 --> 00:03:25,038 line:-1
以及集成测试


63
00:03:26,907 --> 00:03:29,543 line:-1
UI测试在app的UI上执行


64
00:03:29,843 --> 00:03:32,479 line:-1
用于提供app的端对端认证


65
00:03:33,647 --> 00:03:35,916 line:-1
UI测试也是黑箱测试


66
00:03:35,983 --> 00:03:38,819 line:-1
因为它们不依赖于


67
00:03:38,886 --> 00:03:40,921 line:-1
实际支撑你app的任何函数或类


68
00:03:41,989 --> 00:03:44,758 line:-1
UI测试可以确保


69
00:03:44,825 --> 00:03:47,094 line:-1
一切都在最末端正常运行


70
00:03:48,695 --> 00:03:51,865 line:-1
最后性能测试在指定测试中多次运行


71
00:03:51,932 --> 00:03:55,035 line:-1
用于查看平均时间、


72
00:03:55,369 --> 00:03:58,172 line:-1
内存使用或给定的其它度量


73
00:03:58,539 --> 00:04:01,241 line:-1
从而确保你不会在这些区域引入回归


74
00:04:02,142 --> 00:04:05,112 line:-1
今天我们主要讲单元测试和UI测试


75
00:04:06,513 --> 00:04:09,716 line:-2
开始测试Xcode项目的
最简单方式是


76
00:04:10,150 --> 00:04:14,755 line:-2
当开始新项目时选择既包含单元测试
又包含UI测试


77
00:04:16,490 --> 00:04:17,724 line:-1
在我们的全新的项目中


78
00:04:18,225 --> 00:04:20,594 line:-1
你可以看到单元测试的目标类


79
00:04:20,961 --> 00:04:22,796 line:-1
和UI测试的目标类


80
00:04:23,130 --> 00:04:26,400 line:-1
都在项目导航器中自动创建和显示


81
00:04:28,001 --> 00:04:29,970 line:-1
还为你提供了模板


82
00:04:30,437 --> 00:04:32,673 line:-1
用于编写每个测试类


83
00:04:32,739 --> 00:04:34,274 line:-1
以及其中的测试用例


84
00:04:35,709 --> 00:04:39,580 line:-2
现在让我们具体看一下
使用XCTest的测试类


85
00:04:40,647 --> 00:04:44,618 line:-2
类导入XCTest框架时也导入了
要测试的目标


86
00:04:45,953 --> 00:04:48,956 line:-2
类自身是XCTest用例的
一个子类


87
00:04:49,389 --> 00:04:53,093 line:-2
从而Xcode可以使用类的方法
执行测试


88
00:04:54,528 --> 00:04:56,930 line:-1
我们想用作测试用例的每个方法


89
00:04:57,197 --> 00:05:00,367 line:-1
都必须以测试这个词开头


90
00:05:00,434 --> 00:05:02,002 line:-1
然后命名最好是暗示它的功能


91
00:05:03,904 --> 00:05:06,740 line:-1
你还将看到测试左侧有测试菱形


92
00:05:07,407 --> 00:05:09,409 line:-1
用于显示Xcode可以执行它


93
00:05:10,644 --> 00:05:11,745 line:-1
在测试内部


94
00:05:12,479 --> 00:05:16,283 line:-1
断言API用于评估和验证源代码


95
00:05:17,184 --> 00:05:19,453 line:-2
在这个例子中
XCTAssertEqual


96
00:05:19,720 --> 00:05:21,955 line:-1
会比较给定它的前两个值


97
00:05:22,022 --> 00:05:23,257 line:-1
并确保它们相等


98
00:05:23,891 --> 00:05:26,627 line:-1
如果不等 将导致测试失败


99
00:05:27,961 --> 00:05:29,630 line:-1
现在一旦我们运行这个测试


100
00:05:30,497 --> 00:05:31,798 line:-1
我们希望测试通过


101
00:05:31,865 --> 00:05:34,568 line:-2
那样测试菱形会变成绿色
并且里边会有对勾


102
00:05:35,569 --> 00:05:37,437 line:-1
我们知道情况并非总是如此


103
00:05:38,272 --> 00:05:41,775 line:0
如果测试失败 测试菱形将变成一个
带x的红色菱形


104
00:05:42,109 --> 00:05:43,710 line:0
并且会凸显相关代码行


105
00:05:44,778 --> 00:05:48,015 line:0
我们还会得到一个报错信息
显示测试中出现了什么错误


106
00:05:49,183 --> 00:05:51,618 line:0
我们传给
XCTAssertEqual的字符串


107
00:05:51,685 --> 00:05:55,422 line:0
也会显示出来 为我们提供
用于调试问题的更多信息


108
00:05:56,523 --> 00:06:00,294 line:0
在这个例子中
我们的源代码可能有一个错误


109
00:06:00,794 --> 00:06:03,530 line:0
或你可能初始化为一个错误的值


110
00:06:04,498 --> 00:06:07,234 line:0
我们可以返回源代码 修复这个问题


111
00:06:07,768 --> 00:06:10,070 line:0
并再次运行我们的测试
直到测试通过


112
00:06:12,739 --> 00:06:16,810 line:-2
每个测试类模板包含一个setUp
方法和一个tearDown方法


113
00:06:17,711 --> 00:06:20,981 line:-2
这些代码块可以让你围绕测试
执行任何你需要执行的操作


114
00:06:21,048 --> 00:06:24,885 line:-1
从而保持测试的特定目的


115
00:06:26,520 --> 00:06:29,556 line:-2
SetUp在每个测试用例
执行之前调用


116
00:06:30,324 --> 00:06:33,260 line:-1
在UI测试中 它用于确保


117
00:06:33,327 --> 00:06:34,761 line:-2
在尝试与app交互
之前app已启动


118
00:06:36,129 --> 00:06:38,098 line:-2
然后XCTest
会运行你的测试方法


119
00:06:38,599 --> 00:06:41,034 line:-1
然后tearDown用于


120
00:06:41,101 --> 00:06:43,770 line:-1
清理你对app的数据


121
00:06:44,137 --> 00:06:45,973 line:-1
或全局状态所做的任何修改


122
00:06:46,406 --> 00:06:50,010 line:-2
从而确保测试不会留下任何可能影响
后续测试的东西


123
00:06:51,411 --> 00:06:55,315 line:-2
现在让我们看一个演示
了解如何给app


124
00:06:55,582 --> 00:06:56,717 line:-1
编写单元测试和UI测试


125
00:06:56,783 --> 00:06:57,985 line:-1
（演示）


126
00:07:03,423 --> 00:07:05,392 line:-1
我们一直在开发一款旅游app


127
00:07:05,993 --> 00:07:08,295 line:-1
这显示了世界各地不同的目的地


128
00:07:08,362 --> 00:07:09,763 line:-1
可以帮助你制定度假计划


129
00:07:10,764 --> 00:07:12,866 line:-1
我想给app添加一个新功能


130
00:07:13,200 --> 00:07:16,136 line:-1
显示每个目的地


131
00:07:16,203 --> 00:07:18,172 line:-1
距离我们当前所在的圣何塞有多远


132
00:07:19,339 --> 00:07:22,843 line:-2
为此我写了一个新类
叫做DistanceCalculator


133
00:07:23,944 --> 00:07:25,679 line:-1
这个类定义一个城市结构


134
00:07:26,079 --> 00:07:28,549 line:-1
包含一个带有城市名称的字符串


135
00:07:28,949 --> 00:07:30,384 line:-1
和一个城市坐标的元组


136
00:07:32,252 --> 00:07:35,122 line:-1
我当前在字典中存储了城市列表


137
00:07:35,522 --> 00:07:37,758 line:-1
我计划稍后再迁移这两个数据库


138
00:07:39,193 --> 00:07:40,627 line:-1
我有一个函数叫做city


139
00:07:40,961 --> 00:07:43,230 line:-1
它会返回一个可选的城市结构类型


140
00:07:43,931 --> 00:07:46,633 line:-1
用于在字典中搜索城市


141
00:07:48,135 --> 00:07:50,804 line:-1
我打算从这个类中使用的主函数


142
00:07:50,871 --> 00:07:52,172 line:-1
是distanceInMiles


143
00:07:53,006 --> 00:07:55,509 line:-1
它接受两个城市名称的字符串


144
00:07:55,576 --> 00:07:58,078 line:-2
并以double返回
两个城市之间的距离


145
00:07:58,879 --> 00:08:01,415 line:-1
如果词典中找不到其中任意一个城市


146
00:08:01,949 --> 00:08:03,483 line:-1
将引发报错


147
00:08:05,219 --> 00:08:08,989 line:-2
最后我有另一个帮助函数
也叫作distanceInMiles


148
00:08:09,857 --> 00:08:12,960 line:-2
它接受城市结构
并返回城市之间的距离


149
00:08:13,927 --> 00:08:16,330 line:-1
这个函数使用核心位置框架


150
00:08:16,797 --> 00:08:18,599 line:-1
因此它替我分担了大部分繁重的工作


151
00:08:20,033 --> 00:08:22,269 line:-1
要开始编写这个类的单元测试


152
00:08:22,736 --> 00:08:26,340 line:-2
我已经创建了一个新的测试类
叫做DistanceCalculatorTests


153
00:08:27,574 --> 00:08:28,909 line:-1
当我开始编写测试时


154
00:08:28,976 --> 00:08:30,544 line:-1
我希望看到我的源代码


155
00:08:30,611 --> 00:08:32,880 line:-1
因此我要在下边打开另一个编辑器


156
00:08:33,547 --> 00:08:36,149 line:-2
然后导航到我的
DistanceCalculator类


157
00:08:39,620 --> 00:08:42,688 line:-2
我要编写的第一个测试是
测试我的城市函数


158
00:08:44,358 --> 00:08:46,326 line:-1
因此我要开始编写一个单元测试


159
00:08:47,261 --> 00:08:49,429 line:-2
并把它命名为
testCoordinatesOfSeattle


160
00:08:50,497 --> 00:08:52,299 line:-1
对于每个单元测试类


161
00:08:52,366 --> 00:08:54,735 line:-1
我都将选择一个特定的测试用例


162
00:08:54,801 --> 00:08:56,236 line:-1
从而确保函数能用


163
00:08:57,337 --> 00:09:00,674 line:-2
在这个例子中 我要在city
函数中输入Seattle


164
00:09:00,974 --> 00:09:03,243 line:-1
并确保返回了它的正确坐标


165
00:09:04,378 --> 00:09:05,579 line:-1
我要做的第一件事


166
00:09:05,646 --> 00:09:09,516 line:-2
就是通过初始化我的
DistanceCalculator查找计算器


167
00:09:11,285 --> 00:09:15,589 line:-1
现在我可以开始编写并调用函数了


168
00:09:16,623 --> 00:09:21,428 line:-2
但有一点要记住
city返回一个可选的城市结构


169
00:09:22,296 --> 00:09:25,566 line:-1
因此我想确保我得到的返回值不是无


170
00:09:26,667 --> 00:09:28,936 line:-1
为此 我可以使用这个API


171
00:09:29,536 --> 00:09:34,274 line:-2
并尝试使用XCTUnwrap
来确保返回值有效


172
00:09:39,146 --> 00:09:41,481 line:-2
然后我可以对
Seattle调用计算器


173
00:09:42,683 --> 00:09:44,685 line:-1
现在我得到了一个报错信息


174
00:09:45,018 --> 00:09:47,154 line:-1
因为看起来出现了一个报错


175
00:09:47,454 --> 00:09:48,889 line:-1
但没有被处理


176
00:09:50,057 --> 00:09:51,959 line:-1
如果city的返回值为无


177
00:09:52,659 --> 00:09:55,696 line:-1
然后我必须确保我的测试用例


178
00:09:55,762 --> 00:09:57,931 line:-1
也适当地显示出了这个问题


179
00:10:00,100 --> 00:10:01,969 line:-1
现在我的city变量


180
00:10:02,503 --> 00:10:04,404 line:-1
用于返回Seattle的值


181
00:10:05,038 --> 00:10:09,176 line:-1
我可以使用我的断言API来确保


182
00:10:09,243 --> 00:10:11,111 line:-1
经度和维度值都正确


183
00:10:12,646 --> 00:10:15,215 line:-1
现在我要点击测试菱形运行测试


184
00:10:17,484 --> 00:10:18,619 line:-1
这将会启动app


185
00:10:18,952 --> 00:10:21,188 line:-1
运行测试 并告诉我们发生了什么


186
00:10:23,223 --> 00:10:25,359 line:-1
看起来测试成功了 太棒了


187
00:10:27,661 --> 00:10:29,796 line:-1
我现在可以给类编写另一个测试了


188
00:10:30,063 --> 00:10:32,399 line:-2
我要测试我的
distanceInMiles类


189
00:10:35,302 --> 00:10:38,372 line:-2
我要把函数命名为
testSanFranciscoToNewYork


190
00:10:38,772 --> 00:10:42,242 line:-1
具体看看我的功能性返回


191
00:10:43,510 --> 00:10:45,546 line:-1
在这里我要做的第一件事


192
00:10:45,612 --> 00:10:48,916 line:-2
就是通过初始化DistanceCalculator
查找另一个计算器


193
00:10:50,017 --> 00:10:51,985 line:-1
但在这一点上 我的代码产生了重复


194
00:10:52,052 --> 00:10:55,255 line:-2
因为我必须在每个测试用例的开始
都执行这个初始化


195
00:10:56,390 --> 00:10:57,491 line:-1
因此


196
00:10:57,558 --> 00:10:59,526 line:-1
我要声明一个类变量…


197
00:11:00,894 --> 00:11:05,332 line:-2
叫做calculator
从而确保在每个测试开始之前


198
00:11:05,399 --> 00:11:06,834 line:-2
我的setUp函数
可以对它进行初始化


199
00:11:13,006 --> 00:11:14,441 line:-1
现在我可以开始编写我的测试了


200
00:11:19,413 --> 00:11:22,816 line:-2
我要以英里为单位定义距离
通过尝试从函数中


201
00:11:22,883 --> 00:11:25,219 line:-2
调用distanceInMiles
实现从San Francisco到New York


202
00:11:26,620 --> 00:11:30,724 line:-2
然后我要使用我的断言API来确保
距离是正确的


203
00:11:32,492 --> 00:11:34,294 line:-1
我要运行从测试菱形中运行测试


204
00:11:37,865 --> 00:11:39,700 line:-1
看起来这个测试失败了


205
00:11:41,034 --> 00:11:42,569 line:-1
我可以查看报错信息


206
00:11:43,303 --> 00:11:45,806 line:-1
从问题导航器中查看失败信息


207
00:11:49,776 --> 00:11:52,513 line:-2
这一次我们的测试运行了
并且我们得到了报错信息


208
00:11:52,579 --> 00:11:53,881 line:-1
实际测试失败了


209
00:11:55,115 --> 00:11:59,052 line:-1
看起来我们所期待的和用于对比的值


210
00:11:59,119 --> 00:12:02,422 line:-1
比我们实际上所查找的值要精确得多


211
00:12:04,291 --> 00:12:06,793 line:-1
在这个例子中 我不关心这个精确度


212
00:12:07,160 --> 00:12:10,464 line:-1
因为我只想给用户显示


213
00:12:10,531 --> 00:12:11,498 line:-1
两个城市之间的距离的整数


214
00:12:12,266 --> 00:12:14,635 line:-1
因此我可以添加一个精确度参数…


215
00:12:17,804 --> 00:12:19,106 line:-1
替换等于一


216
00:12:19,773 --> 00:12:21,975 line:-2
这将允许
XCTAssertEqual


217
00:12:22,042 --> 00:12:26,547 line:-2
宽松处理并允许数值加减一
但仍能通过测试


218
00:12:27,748 --> 00:12:30,050 line:-2
我要再次编写我的测试
并确保测试通过


219
00:12:33,120 --> 00:12:33,954 line:-1
太棒了


220
00:12:38,959 --> 00:12:42,062 line:-2
目前我已经给单元测试类
写了两个测试


221
00:12:42,496 --> 00:12:45,933 line:-2
但这两个测试都接受
对函数的有效输入


222
00:12:46,600 --> 00:12:48,335 line:-1
并检查是否返回了有效输出


223
00:12:49,069 --> 00:12:51,905 line:-2
但我还想检查函数的一些
其它测试用例


224
00:12:52,673 --> 00:12:56,577 line:-2
我还想确保在我的类中
正确地处理了报错


225
00:12:57,711 --> 00:13:01,215 line:-2
因此我要编写的下一个函数
将是一个负面的测试用例


226
00:13:02,249 --> 00:13:05,252 line:-2
我不希望Cupertino
包含在城市数据库中


227
00:13:05,319 --> 00:13:07,521 line:-1
因为我只考虑大城市


228
00:13:07,888 --> 00:13:09,723 line:-1
而Cupertino并不是大城市


229
00:13:12,693 --> 00:13:14,561 line:-1
因此当我调用Cupertino时


230
00:13:14,628 --> 00:13:16,230 line:-1
我希望能产生报错


231
00:13:16,763 --> 00:13:19,166 line:-1
表明城市在数据库中未知


232
00:13:22,469 --> 00:13:25,572 line:-2
我可以使用XCTAssertThrowsError
实现


233
00:13:27,241 --> 00:13:30,744 line:-2
然后我可以使用一个闭包
来查看具体的报错


234
00:13:31,945 --> 00:13:35,349 line:-2
并把它与XCTAssertEqual
相比较 从而确保它们是正确的


235
00:13:36,617 --> 00:13:38,385 line:-1
现在我已经编写了三个测试


236
00:13:38,819 --> 00:13:40,420 line:-1
我想一次运行三个测试


237
00:13:40,487 --> 00:13:42,523 line:-1
从而确保一切都运行无误


238
00:13:43,323 --> 00:13:45,058 line:-1
我可以进入测试导航器


239
00:13:45,692 --> 00:13:49,830 line:-2
这将给我按行显示我项目中的
所有不同的测试目标


240
00:13:49,897 --> 00:13:52,699 line:-1
测试类和测试用例


241
00:13:53,767 --> 00:13:57,237 line:-2
我可以任意选择一个级别
并在此之下运行所有测试


242
00:13:58,071 --> 00:14:01,608 line:-2
因此如果点击DistanceCalculatorTest
旁边的播放按钮


243
00:14:01,909 --> 00:14:03,644 line:-1
它将运行全部三个测试


244
00:14:04,611 --> 00:14:08,182 line:-2
我的Apple启动运行它们
并且所有的绿色对勾


245
00:14:08,248 --> 00:14:09,349 line:-1
意味着测试都通过了


246
00:14:10,918 --> 00:14:13,687 line:-1
我还可以命令点击不同的行


247
00:14:15,289 --> 00:14:17,424 line:-1
从而选择运行不同的值


248
00:14:18,091 --> 00:14:19,960 line:-1
或运行不同的测试类别


249
00:14:20,794 --> 00:14:22,496 line:-1
如果你不想一次运行所有测试的话


250
00:14:23,497 --> 00:14:24,531 line:-1
通过情景点击


251
00:14:24,598 --> 00:14:25,632 line:-1
我可以选择运行它们


252
00:14:27,568 --> 00:14:29,469 line:-1
如果我选择运行一个子集


253
00:14:29,736 --> 00:14:33,073 line:-2
然后稍后在我修复一些问题之后
我想重新运行同一个子集


254
00:14:33,607 --> 00:14:35,442 line:-1
我还可以进入产品菜单


255
00:14:35,976 --> 00:14:37,244 line:-1
点击实施动作


256
00:14:37,544 --> 00:14:40,147 line:-1
并选择重新运行上一次运行的测试


257
00:14:41,148 --> 00:14:43,951 line:-2
现在我已经给我的类编写了一些
单元测试


258
00:14:44,318 --> 00:14:45,986 line:-1
我想在UI中实施它


259
00:14:46,854 --> 00:14:48,956 line:-2
我要通过显示
distanceText


260
00:14:49,823 --> 00:14:50,824 line:-1
并运行我的类来实现


261
00:14:52,726 --> 00:14:54,294 line:-1
在城市名称下面


262
00:14:54,361 --> 00:14:57,097 line:-1
我们有用于显示这些城市


263
00:14:57,164 --> 00:14:58,332 line:-1
距离我们当前位置有多远的距离


264
00:15:01,001 --> 00:15:06,106 line:-2
我们创建了一个新的UITest类
叫做DiscoverUITest


265
00:15:07,274 --> 00:15:10,544 line:-2
我们的UITest类
需要两个东西来填充


266
00:15:11,512 --> 00:15:13,347 line:-1
失败后继续被设为假


267
00:15:14,047 --> 00:15:15,682 line:-1
一旦UI测试失败


268
00:15:16,016 --> 00:15:18,986 line:-2
通常意味着我们进入了一个
非预期的UI状态


269
00:15:19,820 --> 00:15:23,357 line:-2
我们有可能不能再与任何东西
进行进一步交互了


270
00:15:23,423 --> 00:15:25,158 line:-2
因为我们不知道屏幕上
实际发生了什么


271
00:15:26,860 --> 00:15:29,096 line:-1
我们还想确保app


272
00:15:29,162 --> 00:15:30,497 line:-2
在我们尝试与之进行交互之前
已经启动了


273
00:15:32,232 --> 00:15:35,836 line:-2
我们可以开始编写我们的UI测试了
就跟我们编写单元测试一样


274
00:15:37,070 --> 00:15:39,139 line:-2
我要编写
testMilesToParis


275
00:15:39,573 --> 00:15:41,742 line:-1
目标是打开app


276
00:15:42,342 --> 00:15:44,611 line:-1
滑动到Paris图标…


277
00:15:45,012 --> 00:15:47,781 line:-1
然后确保所显示的距离是正确的


278
00:15:50,484 --> 00:15:52,019 line:-1
我要做的第一件事


279
00:15:52,286 --> 00:15:55,622 line:-2
是实际确保当我们开始测试时
我们处于Discover标签中


280
00:15:56,557 --> 00:16:00,194 line:-2
我可以通过查找app的
UI中的元素


281
00:16:00,260 --> 00:16:01,428 line:-1
并与之进行交互来编写UI测试


282
00:16:01,995 --> 00:16:06,366 line:-2
在这个例子中我要查找一个叫做
Discover的标签栏按钮


283
00:16:07,701 --> 00:16:09,136 line:-1
然后我要轻触它


284
00:16:09,536 --> 00:16:10,838 line:-1
从而确保我们处于正确的标签上


285
00:16:12,039 --> 00:16:14,107 line:-1
在我们执行的每个UI动作之后


286
00:16:14,641 --> 00:16:17,878 line:-1
我们想验证现在显示正确的屏幕


287
00:16:18,478 --> 00:16:20,480 line:-1
因此我要确保


288
00:16:20,547 --> 00:16:23,016 line:-1
San Francisco在屏幕上可见


289
00:16:23,083 --> 00:16:25,319 line:-1
从而确保我们处于所预期的状态中


290
00:16:28,822 --> 00:16:32,492 line:-2
我要使用XCTAssert语句
来确保San Francisco


291
00:16:32,759 --> 00:16:34,661 line:-2
一个静态文本
isHittable


292
00:16:35,362 --> 00:16:38,165 line:-2
isHittable
将确保元素存在


293
00:16:38,599 --> 00:16:40,968 line:-2
并确保它在屏幕上显示
从而我们可以与它进行交互


294
00:16:42,836 --> 00:16:46,139 line:-2
现在我要做的下一件事就是向左滑动
这张图片


295
00:16:46,206 --> 00:16:47,708 line:-1
到达Paris


296
00:16:49,276 --> 00:16:52,179 line:-2
我实际上不确定如何与这张图片
进行交互


297
00:16:52,479 --> 00:16:55,649 line:-2
因为它们可能有一个自定义标签
我不确定如何定义它


298
00:16:56,416 --> 00:17:00,120 line:-2
因此我可以使用调试器来获得
关于app的UI的更多信息


299
00:17:01,288 --> 00:17:04,958 line:-1
我要在第26行设置一个断点


300
00:17:05,025 --> 00:17:06,093 line:-1
然后从测试菱形运行我的测试


301
00:17:07,794 --> 00:17:09,930 line:-2
Apple启动点击
Discover


302
00:17:10,263 --> 00:17:13,700 line:-2
确保San Francisco可见
然后在调试器中暂停


303
00:17:18,939 --> 00:17:19,940 line:-1
在调试器中


304
00:17:20,007 --> 00:17:22,009 line:-1
我们可以获取关于app的更多信息


305
00:17:22,876 --> 00:17:27,114 line:-2
我们可以通过使用po app
来打印具体的视图等级


306
00:17:27,580 --> 00:17:28,649 line:-1
从而获得这些信息


307
00:17:31,185 --> 00:17:34,188 line:-2
在这里我们有一个app中的
所有UI元素的列表


308
00:17:35,055 --> 00:17:36,623 line:-1
但是这有点多


309
00:17:36,890 --> 00:17:39,993 line:-1
因此我要进一步指明我只想打印


310
00:17:40,594 --> 00:17:42,462 line:-1
我app中的所有图片


311
00:17:44,331 --> 00:17:46,667 line:-2
太棒了 现在我们有一个
所有图片的列表了


312
00:17:47,134 --> 00:17:49,269 line:-2
看起来San Francisco
就是我想要的那个


313
00:17:50,170 --> 00:17:53,473 line:-1
我要复制字符串并关闭调试器


314
00:17:57,744 --> 00:18:02,883 line:-2
然后把我的sfImage定义为
带这个标识符的图片


315
00:18:07,688 --> 00:18:11,191 line:-2
现在我可以调用这个查询
来实施向左滑动


316
00:18:12,593 --> 00:18:16,129 line:-2
一旦我完成这个操作
我想确认Paris实际在屏幕上可见


317
00:18:16,196 --> 00:18:20,000 line:-2
从而UI中没有任何变更
会中断这个测试


318
00:18:23,470 --> 00:18:26,773 line:-2
因此我可以使用XCTAssert
来确保Paris可点击


319
00:18:27,941 --> 00:18:31,612 line:-1
最后我想确保显示了正确的距离


320
00:18:32,012 --> 00:18:38,051 line:-2
因此我要使用另一个
XCTAssert语句来确保5586英里


321
00:18:38,385 --> 00:18:39,920 line:-1
一个静态文本 可见


322
00:18:40,954 --> 00:18:44,258 line:-2
现在我们可以从测试菱形
运行我们的测试了


323
00:18:45,626 --> 00:18:48,962 line:-1
我们会看到一旦我移除断点之后


324
00:18:51,832 --> 00:18:52,933 line:-1
app启动并执行每一个步骤


325
00:18:59,239 --> 00:19:02,009 line:-2
我们将看到app启动
我们按Discover


326
00:19:02,309 --> 00:19:04,545 line:-1
查找文本 向左滑动


327
00:19:04,845 --> 00:19:07,381 line:-1
然后确保正确显示了所有字符串


328
00:19:13,921 --> 00:19:15,822 line:-1
在这个测试中还有另一件事要考虑


329
00:19:15,889 --> 00:19:17,991 line:-1
即我们正在查找一个静态文本


330
00:19:18,058 --> 00:19:21,361 line:-1
恰好是5586英里


331
00:19:22,095 --> 00:19:24,731 line:-1
无论何时当你运行这个测试时


332
00:19:24,798 --> 00:19:27,935 line:-1
你可能要假装或模拟你的位置


333
00:19:28,001 --> 00:19:29,303 line:-1
正好位于San Jose


334
00:19:29,736 --> 00:19:33,006 line:-2
否则距离会根据你的实际位置
而发生改变


335
00:19:34,274 --> 00:19:37,444 line:-1
现在我们要返回到幻灯片中


336
00:19:37,511 --> 00:19:38,679 line:-1
讲一下项目中的测试组织


337
00:19:49,156 --> 00:19:51,024 line:-1
当开始编写测试类时


338
00:19:51,658 --> 00:19:53,527 line:-1
你要从两个测试目标开始


339
00:19:53,994 --> 00:19:57,030 line:-2
一般来说 一个用于单元测试
一个用于UI测试


340
00:19:58,065 --> 00:20:01,235 line:-1
单元测试和UI测试必须按类型分开


341
00:20:01,535 --> 00:20:04,471 line:-1
因为它们在app上的执行方式不同


342
00:20:05,472 --> 00:20:06,840 line:-1
每个测试类…


343
00:20:07,274 --> 00:20:09,943 line:-1
测试目标将包含测试类


344
00:20:11,111 --> 00:20:15,182 line:-2
你的测试目标可以拥有许多
必要的测试类来测试你的app


345
00:20:16,750 --> 00:20:20,320 line:-1
然后你的测试类包含每个测试用例


346
00:20:21,288 --> 00:20:23,557 line:-1
同时你的单元测试目标


347
00:20:23,624 --> 00:20:25,993 line:-2
和UI测试目标
可以完全测试你的app


348
00:20:27,127 --> 00:20:29,863 line:-1
但有一些情况你需要更多的测试目标


349
00:20:30,731 --> 00:20:32,666 line:-1
你的项目变得越来越复杂


350
00:20:33,133 --> 00:20:35,769 line:-2
你可能想要一个新…
创建一个新框架


351
00:20:36,470 --> 00:20:40,040 line:-2
这个框架应该有自己的单元测试目标
其中包含它自己的测试


352
00:20:41,375 --> 00:20:45,679 line:-2
此外 你用于在Xcode中创建
和编写测试的Swift程序包


353
00:20:46,113 --> 00:20:47,514 line:-1
已经定义了测试目标


354
00:20:48,448 --> 00:20:51,718 line:-1
这些测试目标在Xcode中


355
00:20:51,785 --> 00:20:53,654 line:-1
与任何其它单元测试目标的用法一样


356
00:20:55,122 --> 00:20:58,125 line:-1
最后 一旦你对每个测试目标


357
00:20:58,192 --> 00:20:59,593 line:-1
都重写了一个完整的测试


358
00:21:00,093 --> 00:21:03,964 line:-2
你可能会考虑测试实际上是否
会覆盖所有的源代码


359
00:21:04,865 --> 00:21:06,667 line:-1
为此你可以使用代码覆盖率


360
00:21:06,733 --> 00:21:07,701 line:-1
（代码覆盖率）


361
00:21:07,768 --> 00:21:10,904 line:-2
代码覆盖率是Xcode
XCTest中的一个功能


362
00:21:11,305 --> 00:21:14,308 line:-1
它会测量并显示在测试运行过程中


363
00:21:14,374 --> 00:21:18,145 line:-1
每行源代码被执行的次数


364
00:21:19,680 --> 00:21:22,316 line:-1
在启动这个功能并运行测试后


365
00:21:22,983 --> 00:21:26,386 line:-1
你可以进入报告导航器并选择


366
00:21:26,453 --> 00:21:27,454 line:-1
所运行测试的覆盖率数据


367
00:21:29,489 --> 00:21:33,393 line:-2
你可以在那里看到一个列表
包含每个测试目标和测试类


368
00:21:33,827 --> 00:21:37,798 line:-1
以及表示该部分


369
00:21:37,865 --> 00:21:40,434 line:-1
实际执行了多少源代码的百分比


370
00:21:41,435 --> 00:21:44,571 line:-1
你可以选择每个测试类切换到文件


371
00:21:45,906 --> 00:21:48,108 line:-1
当在源文件中打开覆盖率数据时


372
00:21:48,642 --> 00:21:50,477 line:-1
源代码编辑器槽位于右侧


373
00:21:51,078 --> 00:21:55,282 line:-1
显示当你运行测试时


374
00:21:55,349 --> 00:21:56,483 line:-1
表示该行被执行了多少次的一个数字


375
00:21:57,451 --> 00:21:59,219 line:-1
你还可以悬浮在数字上


376
00:21:59,486 --> 00:22:01,788 line:-1
直接在源代码编辑器中查看信息


377
00:22:03,257 --> 00:22:05,325 line:-1
被执行了的代码行将变成绿色


378
00:22:06,293 --> 00:22:09,329 line:-2
在测试过程中没有被击中的代码部分
将以红色突显


379
00:22:10,464 --> 00:22:12,566 line:-1
你还可以查看综合信息


380
00:22:12,900 --> 00:22:17,204 line:-2
显示在测试过程中
没有被击中的单一代码路径


381
00:22:17,571 --> 00:22:19,573 line:-1
比如从未被选中的条件句


382
00:22:20,507 --> 00:22:21,909 line:-1
代码覆盖率工具


383
00:22:21,975 --> 00:22:24,745 line:-2
总的来说给你提供关于测试的
更多信息


384
00:22:25,145 --> 00:22:28,749 line:-2
可以帮助你识别你可能想为之编写
更多测试的区域


385
00:22:30,617 --> 00:22:32,753 line:-1
当向版本库提交新工作时


386
00:22:33,187 --> 00:22:35,422 line:-1
请包含代码以及对代码的测试


387
00:22:35,956 --> 00:22:38,258 line:-1
确保一切都有品质保障


388
00:22:38,892 --> 00:22:42,529 line:-2
并检查代码覆盖率
从而确保你没有遗漏任何东西


389
00:22:43,797 --> 00:22:46,400 line:-2
如果你感觉测试没有完全覆盖
你所做的修改


390
00:22:46,867 --> 00:22:49,636 line:-1
可能是时候返回并编写更多的测试了


391
00:22:51,371 --> 00:22:54,608 line:-2
你将通过提早编写测试来最大化地
利用测试


392
00:22:55,342 --> 00:22:58,378 line:-2
通过拥有与你的源代码配套的
测试套件


393
00:22:58,946 --> 00:23:02,449 line:-2
你可以确保你所编写的每个新功能
都可靠


394
00:23:02,516 --> 00:23:03,817 line:-1
并且按预期的那样实现功能


395
00:23:04,718 --> 00:23:07,621 line:-1
请记住 测试是一个持续的过程


396
00:23:07,955 --> 00:23:09,556 line:-2
对于维持app的正常运行来说
至关重要


397
00:23:10,524 --> 00:23:12,893 line:-1
现在我要邀请Stuart上台来


398
00:23:13,260 --> 00:23:16,930 line:-2
讲一下如何充分利用
Xcode中的测试


399
00:23:26,507 --> 00:23:27,407 line:-1
谢谢Ana


400
00:23:27,674 --> 00:23:30,544 line:-2
现在你已经了解了Xcode中的
测试的基本信息


401
00:23:30,978 --> 00:23:34,548 line:-2
我想讲一下Xcode 11中的
一个新功能叫做测试计划


402
00:23:34,615 --> 00:23:36,583 line:-1
它会帮助你最大限度地利用测试


403
00:23:38,785 --> 00:23:40,921 line:-1
无论你是否刚开始编写测试


404
00:23:41,522 --> 00:23:44,458 line:-2
或如果你的项目已经有一套很大
并且很强健的测试套件了


405
00:23:45,058 --> 00:23:46,860 line:-1
我们要跟你们分享一个建议


406
00:23:46,927 --> 00:23:48,462 line:-1
可以帮助你们最大限度地利用测试


407
00:23:49,363 --> 00:23:52,432 line:-2
我们实际上推荐你们以不同方式
多次运行测试


408
00:23:53,834 --> 00:23:55,702 line:-1
现在即使你没有对测试进行任何修改


409
00:23:56,236 --> 00:23:59,406 line:-2
如果你在测试选项中更多地利用
Xcode的创建


410
00:23:59,473 --> 00:24:00,874 line:-1
及其高级功能


411
00:24:01,441 --> 00:24:04,111 line:-2
你可以获得从测试中得到更多信息
并捕捉更多报错


412
00:24:05,179 --> 00:24:06,680 line:-1
让我们一起来看一个例子


413
00:24:08,382 --> 00:24:10,384 line:-1
假如我们一直在开发的app


414
00:24:10,651 --> 00:24:12,920 line:-1
针对许多不同语种进行了本地化


415
00:24:13,954 --> 00:24:15,088 line:-1
现在我们已经了解了


416
00:24:15,556 --> 00:24:17,591 line:-1
如何给app编写UI测试


417
00:24:18,992 --> 00:24:20,294 line:-1
现在一旦我们进行UI测试


418
00:24:21,061 --> 00:24:22,829 line:-2
当我们以我们开发app的语言
运行测试时


419
00:24:22,896 --> 00:24:24,665 line:-1
测试很有可能会成功


420
00:24:24,932 --> 00:24:26,266 line:-1
在这个例子中是英语


421
00:24:27,668 --> 00:24:29,970 line:-2
但想象一下有一天我们发现了一个
报错


422
00:24:30,270 --> 00:24:32,539 line:-1
只存在于特定语种之中


423
00:24:33,140 --> 00:24:35,609 line:-1
那个语种的本地化字符串丢失了


424
00:24:36,443 --> 00:24:38,278 line:-1
并使用了一个占位符字符串替代


425
00:24:38,345 --> 00:24:39,580 line:-1
那就破坏了UI布局


426
00:24:40,948 --> 00:24:42,449 line:-1
现在一旦我们意识到这个问题


427
00:24:42,916 --> 00:24:44,451 line:-1
我们可以调整Xcode设置


428
00:24:44,785 --> 00:24:47,321 line:-1
从而手动运行该语种的UI测试


429
00:24:47,821 --> 00:24:50,424 line:-2
如果我们这样做了
我们可能会看到UI测试失败


430
00:24:51,391 --> 00:24:52,593 line:-1
当然 如果我们没有那么做


431
00:24:52,659 --> 00:24:55,028 line:-2
我们就有一个很好的机会
来编写一个新测试


432
00:24:55,095 --> 00:24:58,098 line:-2
用于重现问题和失败
直到我们修复了报错


433
00:24:59,566 --> 00:25:02,035 line:-2
但一旦我们修复了那个问题
并且我们有一个覆盖这个问题的测试


434
00:25:02,636 --> 00:25:05,405 line:-2
理想情况下 我们应该总能运行
这个语种的测试


435
00:25:05,772 --> 00:25:08,709 line:-2
除我们开发app的语言之外
从而确保app不会再次发生中断


436
00:25:11,111 --> 00:25:12,579 line:-1
这只是其中一个例子


437
00:25:12,646 --> 00:25:16,216 line:-2
但还有其它情况
只有当你每次以不同方式多次


438
00:25:16,483 --> 00:25:19,486 line:-1
运行测试时才可能捕捉到那些报错


439
00:25:20,821 --> 00:25:23,423 line:-1
比如你可能选择按字母顺序


440
00:25:23,490 --> 00:25:25,459 line:-1
和随机顺序运行测试


441
00:25:26,026 --> 00:25:27,895 line:-1
因为按字母顺序运行测试


442
00:25:27,961 --> 00:25:31,131 line:-2
对于查找测试方法之间
隐藏的依赖关系来说很有帮助


443
00:25:32,599 --> 00:25:35,435 line:-2
或你可能想使用一个以上的
Sanitizer来运行测试


444
00:25:36,003 --> 00:25:39,106 line:-2
比如Address Sanitizer
和Thread Sanitizer


445
00:25:40,107 --> 00:25:41,942 line:-1
如果你不熟悉的话


446
00:25:42,009 --> 00:25:42,943 line:-1
我稍后会解释这些是什么东西


447
00:25:43,977 --> 00:25:47,014 line:-2
或你甚至可以在每次测试时
改变任意命令行参数


448
00:25:47,381 --> 00:25:49,249 line:-1
或环境变量


449
00:25:50,050 --> 00:25:52,085 line:-1
如果测试时你要测试的代码


450
00:25:52,486 --> 00:25:55,355 line:-2
需要修改或模拟特定的东西的话
这会很有帮助


451
00:25:55,422 --> 00:25:58,225 line:-1
比如使用网络服务器的测试版


452
00:25:58,559 --> 00:25:59,893 line:-1
或也许模拟数据集


453
00:26:02,062 --> 00:26:04,698 line:-1
Xcode允许你配置各种选项


454
00:26:04,765 --> 00:26:07,067 line:-1
关于app如何使用方案编辑器运行


455
00:26:08,302 --> 00:26:09,536 line:-1
你可以访问参数


456
00:26:09,603 --> 00:26:11,605 line:-1
选项或诊断标签


457
00:26:11,672 --> 00:26:14,308 line:-1
从而控制如何启动app的各种东西


458
00:26:15,776 --> 00:26:18,312 line:-1
但这只允许你使用你所选择的


459
00:26:18,378 --> 00:26:20,514 line:-2
设置来交互性的运行一次app
无论你选择了何种设置


460
00:26:21,882 --> 00:26:23,917 line:-1
我们真正想要的并且我们一直在讲的


461
00:26:23,984 --> 00:26:26,453 line:-1
是能多次运行测试的能力


462
00:26:27,354 --> 00:26:30,357 line:-2
为此 我们在Xcode 11中
引入了一个新功能


463
00:26:30,424 --> 00:26:31,491 line:-1
叫做测试计划


464
00:26:31,558 --> 00:26:32,860 line:-1
（测试计划）


465
00:26:32,926 --> 00:26:35,395 line:-1
测试计划允许你以不同设置


466
00:26:35,462 --> 00:26:37,097 line:-1
多次运行测试


467
00:26:38,599 --> 00:26:42,202 line:-2
使用测试计划 你可以在一个地方
定义你所有的测试变化


468
00:26:43,036 --> 00:26:45,072 line:-1
然后你可以在多个方案中进行共享


469
00:26:46,340 --> 00:26:48,509 line:-1
现在如果你之前复制了方案


470
00:26:48,909 --> 00:26:51,044 line:-1
从而你可以多次运行测试


471
00:26:51,678 --> 00:26:53,080 line:-1
你可能想撤销它


472
00:26:53,447 --> 00:26:56,950 line:-2
并使用一个测试计划
把多个方案合并为一个方案


473
00:26:58,552 --> 00:27:01,622 line:-2
Xcode中以及xcodebuild中
都支持测试计划


474
00:27:01,922 --> 00:27:05,359 line:-2
可以在持续集成服务器
和Xcode服务器中使用


475
00:27:06,326 --> 00:27:08,662 line:-1
在现有项目中采用测试计划非常简单


476
00:27:09,897 --> 00:27:11,431 line:-1
我们别一直讲这么多了


477
00:27:11,498 --> 00:27:13,867 line:-2
让我们返回到演示项目中
给你演示它是如何运作的


478
00:27:17,704 --> 00:27:19,006 line:-2
（演示
使用测试计划）


479
00:27:27,814 --> 00:27:28,649 line:-1
好的


480
00:27:29,116 --> 00:27:30,884 line:-1
返回到我一直在做的项目中


481
00:27:31,618 --> 00:27:33,053 line:-1
我先给你展示一下测试计划


482
00:27:33,120 --> 00:27:35,656 line:-1
点击我项目中的新测试计划文件


483
00:27:36,657 --> 00:27:39,126 line:-2
在这里我可以看到
有关我的测试计划的所有详情


484
00:27:40,294 --> 00:27:41,962 line:-1
我可以看到所有的测试


485
00:27:42,429 --> 00:27:44,064 line:-1
首先是测试目标


486
00:27:44,998 --> 00:27:46,200 line:-1
然后是测试类


487
00:27:46,767 --> 00:27:49,069 line:-2
然后是每个类中所包含的
全部测试方法


488
00:27:50,504 --> 00:27:52,639 line:-2
现在使用这个视图
我可以了解一些不同的信息


489
00:27:53,140 --> 00:27:55,542 line:-2
我可以看到包含所有测试的完整列表
当然了


490
00:27:56,276 --> 00:27:58,078 line:-1
或如果我想查找特定的测试


491
00:27:58,145 --> 00:27:59,880 line:-2
我可以使用它…
筛选字段来进行搜索


492
00:28:01,114 --> 00:28:04,184 line:-2
或如果我出于某种原因
需要暂时禁用一个测试


493
00:28:04,818 --> 00:28:06,787 line:-1
比如说 如果这个测试目前不起作用


494
00:28:06,854 --> 00:28:08,822 line:-2
我只需要在已启用栏中
取消选中它即可


495
00:28:10,657 --> 00:28:13,193 line:-1
我还可以修改与测试目标相关的设置


496
00:28:14,094 --> 00:28:15,596 line:-1
点击右侧的选项按钮即可实现


497
00:28:17,197 --> 00:28:19,766 line:-2
在这个例子中
我恰好知道这个测试目标


498
00:28:20,167 --> 00:28:21,468 line:-1
是我的UI测试目标


499
00:28:21,535 --> 00:28:24,304 line:-2
并且它确实会受益于
在多个克隆模拟器上


500
00:28:24,371 --> 00:28:27,641 line:-2
并行运行它的所有测试
那样测试的运行速度会快的多


501
00:28:28,141 --> 00:28:29,943 line:-1
我要在这里启用它


502
00:28:31,879 --> 00:28:34,448 line:-1
接下来我要进入测试计划的配置标签


503
00:28:35,349 --> 00:28:36,650 line:-1
我可以在这里控制


504
00:28:36,917 --> 00:28:39,019 line:-1
测试如何运行以及运行多少次


505
00:28:40,220 --> 00:28:43,056 line:-1
左侧有一个列表 叫作测试配置列表


506
00:28:43,957 --> 00:28:46,560 line:-1
顶部还有一个标签叫做共享设置


507
00:28:47,761 --> 00:28:50,430 line:-1
我可以在共享设置中控制…


508
00:28:50,697 --> 00:28:52,900 line:-1
测试运行中每次测试都通用的选项


509
00:28:54,268 --> 00:28:57,571 line:-2
如果我们看一下
我能控制测试计划中的哪些东西


510
00:28:57,638 --> 00:28:58,805 line:-1
我可以设置许多东西


511
00:29:00,007 --> 00:29:03,277 line:-2
我可以修改不同参数
关于测试程序应该如何被启动


512
00:29:04,344 --> 00:29:06,346 line:-1
我可以修改关于本地化的设置


513
00:29:07,481 --> 00:29:11,552 line:-1
或改变UI测试截图要保存多长时间


514
00:29:12,719 --> 00:29:14,755 line:-1
我可以修改测试执行顺序


515
00:29:15,189 --> 00:29:16,256 line:-1
启用代码覆盖率


516
00:29:16,823 --> 00:29:20,260 line:-2
或启动比如运行时间Sanitizer
或内存诊断这样的东西


517
00:29:22,062 --> 00:29:25,132 line:-2
现在你可能注意到这里其中某些是
粗体文本


518
00:29:25,799 --> 00:29:27,367 line:-1
比如环境变量这一行


519
00:29:28,268 --> 00:29:30,037 line:-1
那表示我已经给定它一个自定义值


520
00:29:30,904 --> 00:29:33,640 line:-2
在这里我提供了一个运行测试时的
自定义环境变量


521
00:29:35,008 --> 00:29:38,312 line:-2
我把测试自定义为
总是按随机顺序运行自定义环境变量


522
00:29:38,846 --> 00:29:40,247 line:-1
而不是按字母顺序


523
00:29:42,049 --> 00:29:45,586 line:-2
在这个测试计划中
我真正想要做的是修改它


524
00:29:45,652 --> 00:29:48,488 line:-1
使它像我刚才提供的例子那样运行


525
00:29:48,922 --> 00:29:51,191 line:-1
从而它会使用不同语种运行两次


526
00:29:52,426 --> 00:29:54,561 line:-1
我可以通过添加第二个配置实现


527
00:29:55,529 --> 00:29:57,064 line:-1
因为我要以不同语种运行它


528
00:29:57,130 --> 00:29:59,733 line:-2
我要给我所要使用的语言提供一个
自定义名称 即德语


529
00:30:01,535 --> 00:30:03,904 line:-2
既然到这儿了
我要把第一个配置的名称


530
00:30:04,304 --> 00:30:05,672 line:-1
自定义为美语


531
00:30:07,541 --> 00:30:09,543 line:-1
在美语配置中


532
00:30:09,943 --> 00:30:11,411 line:-1
我实际上不修改任何东西


533
00:30:11,478 --> 00:30:14,214 line:-1
它拥有所有默认值外加共享设置


534
00:30:15,282 --> 00:30:16,917 line:-1
但在德语配置中


535
00:30:16,984 --> 00:30:20,754 line:-1
我要自定义语种和地区


536
00:30:23,924 --> 00:30:26,460 line:-1
我想指出因为我刚才编辑了


537
00:30:26,760 --> 00:30:28,161 line:-1
配置


538
00:30:29,029 --> 00:30:30,030 line:-1
在弹出菜单中


539
00:30:30,097 --> 00:30:33,600 line:-2
我在顶部看到了一个额外的标签
是计划默认值


540
00:30:34,568 --> 00:30:37,871 line:-1
这个标签表示


541
00:30:37,938 --> 00:30:39,473 line:-2
它要从测试计划的共享设置层级
继承的值


542
00:30:40,174 --> 00:30:42,209 line:-1
因此如果我想恢复这个自定义


543
00:30:42,276 --> 00:30:43,944 line:-1
并返回到它所继承的值


544
00:30:44,011 --> 00:30:45,012 line:-1
我只需要选中这个即可


545
00:30:47,181 --> 00:30:49,049 line:-1
好的 现在我按我的意愿


546
00:30:49,116 --> 00:30:49,983 line:-1
配置好了测试计划


547
00:30:50,317 --> 00:30:52,753 line:-2
接下来我要介绍
可以在余下的Xcode中


548
00:30:52,819 --> 00:30:54,021 line:-1
使用测试计划的几种方式


549
00:30:56,023 --> 00:30:58,258 line:-1
我要进入我一直在做的一个事件…


550
00:30:58,325 --> 00:31:00,360 line:-2
一个单元测试文件
叫做EventTests


551
00:31:00,694 --> 00:31:02,462 line:-1
它测试我app中的事件结构


552
00:31:03,697 --> 00:31:06,400 line:-1
它只对结构进行几次小的单元测试


553
00:31:07,601 --> 00:31:12,306 line:-2
如果我点击这个测试文件中的
任意测试菱形


554
00:31:13,106 --> 00:31:15,742 line:-2
因为我已经给测试计划
配置了两个配置


555
00:31:16,376 --> 00:31:18,579 line:-1
那将总共运行两次测试


556
00:31:19,513 --> 00:31:22,549 line:-2
如果我想运行所有测试的话
这特别棒


557
00:31:22,616 --> 00:31:25,719 line:-2
特别是在我的持续继承服务器上
运行测试时


558
00:31:26,553 --> 00:31:28,255 line:-1
但当我开发测试时


559
00:31:28,322 --> 00:31:30,457 line:-1
我可能不运行…不运行这么多次


560
00:31:31,258 --> 00:31:33,994 line:-1
因此我可以选择只运行一个配置


561
00:31:34,328 --> 00:31:36,230 line:-1
通过选择点击测试菱形即可实现


562
00:31:36,530 --> 00:31:39,766 line:-2
在这里我看到一个菜单只有…
那么我可以选择一个配置


563
00:31:41,802 --> 00:31:43,003 line:-1
我可以…是的 谢谢


564
00:31:46,607 --> 00:31:48,742 line:-1
我还可以在测试导航器中实现


565
00:31:49,409 --> 00:31:52,179 line:-2
如果我在测试导航器中控制点击
任意测试


566
00:31:52,446 --> 00:31:56,884 line:-2
我可以看到一个类似的菜单 可让我
运行所有配置或只运行一个配置


567
00:31:58,685 --> 00:32:00,654 line:-1
既然到这儿了 我还想提一下


568
00:32:00,721 --> 00:32:03,090 line:-1
测试导航器现在显示…


569
00:32:03,156 --> 00:32:05,893 line:-1
当前哪个测试计划是活跃的


570
00:32:06,593 --> 00:32:08,795 line:-1
我的方案中只有一个测试计划


571
00:32:09,196 --> 00:32:10,430 line:-1
但你可以有许多测试计划


572
00:32:10,497 --> 00:32:12,900 line:-2
我们稍后再讲
拥有多个测试计划的好处


573
00:32:14,902 --> 00:32:17,404 line:-1
好的 现在我只想运行


574
00:32:17,471 --> 00:32:18,772 line:-1
全部配置的单元测试


575
00:32:20,207 --> 00:32:23,343 line:-2
现在我们看到Xcode快速创建了
我的整个项目


576
00:32:23,877 --> 00:32:26,680 line:-1
然后在模拟器中两次运行我的测试


577
00:32:27,548 --> 00:32:28,515 line:-1
已经完成了


578
00:32:29,383 --> 00:32:31,752 line:-1
看起来至少存在一个问题


579
00:32:32,286 --> 00:32:34,021 line:-1
让我们去看看具体信息


580
00:32:35,389 --> 00:32:37,691 line:-1
我可以通过点击报告导航器


581
00:32:38,792 --> 00:32:40,527 line:-1
并进入最新测试动作查看测试详情


582
00:32:41,828 --> 00:32:45,732 line:-2
在这里我们可以看到大部分测试
都成功了


583
00:32:46,166 --> 00:32:47,434 line:-1
因此它们有绿色对勾标记…


584
00:32:48,702 --> 00:32:51,672 line:-1
其中一个测试出现了某种问题


585
00:32:51,738 --> 00:32:53,674 line:-1
它有一个红色图标 图标上有横杠


586
00:32:54,942 --> 00:32:57,544 line:-1
测试报告给我显示了所有详情


587
00:32:57,611 --> 00:33:00,113 line:-1
关于测试会话中发生的一切


588
00:33:00,614 --> 00:33:02,216 line:-1
如果我展开这个 我可以看到…


589
00:33:03,083 --> 00:33:06,119 line:-2
看起来这个测试方法
在一个配置中成功了


590
00:33:06,186 --> 00:33:07,254 line:-1
而在另一个配置中失败了


591
00:33:08,422 --> 00:33:09,389 line:-1
如果我进一步打开它


592
00:33:09,456 --> 00:33:10,824 line:-1
我可以看到具体问题


593
00:33:11,658 --> 00:33:12,693 line:-1
看起来这个测试方法


594
00:33:13,293 --> 00:33:15,896 line:-2
接收了英语文本
但它应该接收德语文本


595
00:33:16,797 --> 00:33:19,633 line:-2
看起来这是个问题
我需要返回到我的…


596
00:33:19,700 --> 00:33:22,903 line:-2
app代码或测试中
并进行相应的调整 我稍后再做


597
00:33:23,971 --> 00:33:24,805 line:-1
在我完成之前


598
00:33:25,072 --> 00:33:28,175 line:-2
我想讲一下我们对这里的测试报告
所做的一些其它改进


599
00:33:29,042 --> 00:33:31,812 line:-1
如果我只想查看在两个配置中


600
00:33:32,145 --> 00:33:35,215 line:-1
拥有混合状态的测试方法 比如这个


601
00:33:35,682 --> 00:33:39,019 line:-2
我只需要点击
范围栏中的混合按钮即可


602
00:33:40,721 --> 00:33:44,825 line:-1
或如果我只想查看特定配置中的结果


603
00:33:45,292 --> 00:33:47,861 line:-1
我只需要点击测试配置弹出框


604
00:33:48,295 --> 00:33:49,730 line:-1
并选择其中一个配置即可


605
00:33:53,867 --> 00:33:56,236 line:-2
好的
这就是Xcode中的测试计划


606
00:33:56,537 --> 00:33:57,938 line:-1
现在让我们返回到幻灯片中


607
00:34:07,281 --> 00:34:09,416 line:-1
现在你已经实际了解了测试计划


608
00:34:09,716 --> 00:34:11,618 line:-2
我想提一下关于测试计划
是如何运作的一些细节


609
00:34:13,020 --> 00:34:15,589 line:-2
测试计划文件实际上就是个
JSON文件


610
00:34:16,023 --> 00:34:18,158 line:-2
以.xctestplan
为文件扩展名


611
00:34:19,359 --> 00:34:21,328 line:-1
它包含你要运行的所有测试


612
00:34:21,862 --> 00:34:25,699 line:-2
以及描述测试如何运行的
所有测试配置


613
00:34:27,367 --> 00:34:30,170 line:-2
测试计划文件包含在你的常规项目
结构中


614
00:34:30,704 --> 00:34:32,940 line:-1
并且它可以被一个或多个方案引用


615
00:34:36,976 --> 00:34:38,911 line:-1
现在测试配置


616
00:34:38,978 --> 00:34:41,949 line:-2
还描述整个测试计划的测试的
单一运行


617
00:34:43,183 --> 00:34:46,053 line:-2
每个测试配置都有一个
可自定义唯一名称


618
00:34:46,652 --> 00:34:49,356 line:-1
给项目中的每个测试配置


619
00:34:49,422 --> 00:34:50,891 line:-2
都命名一个有意义的名称
是个很不错的主意


620
00:34:51,358 --> 00:34:54,460 line:-2
因为我们将在比如我们之前看到过的
测试菱形弹出菜单


621
00:34:55,094 --> 00:34:56,463 line:-1
和测试报告这样的地方看到那个名称


622
00:34:58,398 --> 00:35:00,934 line:-1
现在每个测试配置都包含


623
00:35:01,001 --> 00:35:02,769 line:-1
关于如何创建并运行测试的所有选项


624
00:35:03,670 --> 00:35:06,006 line:-1
它们可以从测试计划的共享设置层级


625
00:35:06,073 --> 00:35:07,808 line:-1
继承任意通用选项


626
00:35:08,542 --> 00:35:10,577 line:-1
因此如果任何设置


627
00:35:10,644 --> 00:35:11,812 line:-1
在每次运行测试时设置都相同


628
00:35:12,112 --> 00:35:14,648 line:-2
你可以在一个地方定义它们
而不需要重复定义


629
00:35:17,518 --> 00:35:18,385 line:-1
因此如果你好奇的话


630
00:35:18,452 --> 00:35:20,888 line:-1
这是你可以在每个测试配置上


631
00:35:20,954 --> 00:35:22,389 line:-1
进行设置的所有选项的完整列表


632
00:35:23,490 --> 00:35:24,458 line:-1
你可以从我刚才所展示的


633
00:35:24,525 --> 00:35:27,327 line:-2
测试计划编辑器的配置标签中
找到这个列表


634
00:35:29,630 --> 00:35:30,697 line:-1
那么你可能在想


635
00:35:30,964 --> 00:35:32,399 line:-1
我要如何开始使用测试计划呢


636
00:35:33,834 --> 00:35:34,968 line:-1
如果你有现有项目


637
00:35:35,035 --> 00:35:36,203 line:-1
你首先需要把它转换为…


638
00:35:36,837 --> 00:35:38,572 line:-1
把方案转换为使用测试计划


639
00:35:39,640 --> 00:35:41,642 line:-1
为此 首先要编辑方案


640
00:35:43,577 --> 00:35:45,445 line:-1
然后进入方案测试动作


641
00:35:47,147 --> 00:35:49,883 line:-2
在那里你可以看到一个按钮是
转换为使用测试计划


642
00:35:51,518 --> 00:35:53,053 line:-1
点击这个按钮将显示一个表单


643
00:35:53,487 --> 00:35:55,856 line:-1
提供你可以转换方案的不同方式


644
00:35:57,758 --> 00:36:00,294 line:-1
第一个选项是从方案的现有设置中


645
00:36:00,661 --> 00:36:02,296 line:-1
创建一个全新的测试计划文件


646
00:36:03,397 --> 00:36:05,732 line:-2
如果这是你要转换的第一个
或唯一的方案


647
00:36:05,999 --> 00:36:07,234 line:-1
你很可能会选择这个方式


648
00:36:09,069 --> 00:36:11,772 line:-2
但另一个选项是选择项目中的
现有测试计划


649
00:36:13,040 --> 00:36:14,074 line:-1
如果你选择这个


650
00:36:14,141 --> 00:36:16,743 line:-2
它会给你显示一个表单
让你在工作空间中


651
00:36:16,810 --> 00:36:17,811 line:-1
选择一个现有测试计划


652
00:36:18,579 --> 00:36:22,449 line:-1
如果你正在转换的方案…


653
00:36:22,816 --> 00:36:25,085 line:-2
如果你已经把一个方案转换为
使用测试计划了


654
00:36:25,152 --> 00:36:27,588 line:-2
并且你想以不同方案分享同一个计划
这是个不错的选择


655
00:36:28,722 --> 00:36:31,325 line:-2
且如果你已经从零开始创建了一个
测试计划文件 你也可使用这个选项


656
00:36:34,428 --> 00:36:36,797 line:-2
好的现在我们已经了解了
什么是测试计划


657
00:36:37,231 --> 00:36:38,632 line:-2
并且你已经了解如何开始使用
测试计划


658
00:36:39,132 --> 00:36:40,868 line:-1
我想提供一些你可以在自己的项目中


659
00:36:40,934 --> 00:36:42,736 line:-1
使用测试计划的潜在方式


660
00:36:44,838 --> 00:36:47,174 line:-2
这是一个你可以创建的测试计划的
一个基本示例


661
00:36:47,241 --> 00:36:48,609 line:-1
（潜在用例）


662
00:36:48,675 --> 00:36:51,578 line:-1
每个红色方框代表计划中的一个配置


663
00:36:52,546 --> 00:36:54,681 line:-2
第一个启用了
Address Sanitizer


664
00:36:55,048 --> 00:36:56,416 line:-2
另一个启用了
Thread Sanitizer


665
00:36:57,551 --> 00:36:59,052 line:-1
现在如果你不熟悉这些的话


666
00:36:59,119 --> 00:37:01,221 line:-2
Sanitizer
是潜在Xcode中的工具


667
00:37:01,688 --> 00:37:02,823 line:-1
用于输入你的代码


668
00:37:02,890 --> 00:37:05,792 line:-1
并帮助你识别手动难以重现的错误


669
00:37:06,827 --> 00:37:08,729 line:-2
有些sanitizer
比如这两个


670
00:37:09,129 --> 00:37:10,430 line:-1
可以合并使用


671
00:37:10,898 --> 00:37:13,333 line:-1
如果你以这样的方式构造测试计划


672
00:37:13,734 --> 00:37:16,670 line:-2
你仍可用这两个sanitizer
来运行测试并从中受益


673
00:37:19,373 --> 00:37:21,475 line:-1
要从这个测试计划中获得更多价值


674
00:37:22,075 --> 00:37:24,411 line:-2
如果你的项目包含C
或Objective-C代码的话


675
00:37:25,112 --> 00:37:28,148 line:-1
你还可以通过在每个配置中


676
00:37:28,215 --> 00:37:29,650 line:-2
启用未定义的Behavior Sanitizer
来扩展计划


677
00:37:31,251 --> 00:37:34,421 line:-2
你可能注意到未定义的
Behavior Sanitizer


678
00:37:34,488 --> 00:37:35,622 line:-1
在两个地方进行了设置


679
00:37:36,056 --> 00:37:37,824 line:-1
它在每个配置中进行了重复设置


680
00:37:39,927 --> 00:37:41,628 line:0
把这个设置向上移到


681
00:37:41,695 --> 00:37:43,931 line:0
计划的共享设置层级更好


682
00:37:44,932 --> 00:37:46,967 line:0
然后计划中的每个配置


683
00:37:47,034 --> 00:37:48,836 line:0
将自动继承这个设置


684
00:37:50,537 --> 00:37:53,674 line:0
现在有一件事要注意
如果你配置了这样一个测试计划


685
00:37:53,740 --> 00:37:55,876 line:0
带有手动不兼容sanitizer


686
00:37:56,710 --> 00:37:59,213 line:0
如果你运行计划中的两个配置


687
00:37:59,947 --> 00:38:03,350 line:-2
Xcode需要创建两次项目
为每组sanitizer分别创建一次项目


688
00:38:04,718 --> 00:38:07,087 line:-1
这对于持续继承环境来说很棒


689
00:38:07,521 --> 00:38:10,390 line:-1
你不用担心需要较长时间来创建测试


690
00:38:10,691 --> 00:38:12,593 line:-1
因为它们执行的是更彻底的测试


691
00:38:15,462 --> 00:38:18,165 line:-2
但测试计划并不只是选择不同的
sanitizer


692
00:38:18,932 --> 00:38:20,267 line:-1
正如我在之前的演示中所展示的那样


693
00:38:20,334 --> 00:38:22,636 line:-1
你还可以配置附带配置的计划


694
00:38:22,703 --> 00:38:24,872 line:-1
配置可以代表不同的语种或区域


695
00:38:25,739 --> 00:38:29,042 line:-2
比如我在这里选择了美国、韩国
和意大利


696
00:38:29,710 --> 00:38:32,079 line:-1
并没有可以拥有多少配置的限制


697
00:38:34,147 --> 00:38:35,582 line:-1
现在如果你配置了一个像这样的计划


698
00:38:36,183 --> 00:38:37,751 line:-1
你可以用它来运行你的UI测试


699
00:38:38,352 --> 00:38:40,754 line:-1
然后你可以从这些测试中收集截图


700
00:38:41,221 --> 00:38:44,525 line:-2
通过在共享设置中启用新的
本地化屏幕截图功能即可实现


701
00:38:45,959 --> 00:38:48,629 line:-2
本地化截图时
Xcode 11中的新功能


702
00:38:49,029 --> 00:38:52,466 line:-1
可以让你的UI测试保存所有截图


703
00:38:53,033 --> 00:38:54,201 line:-1
甚至还会保存测试成功的测试的截图


704
00:38:55,369 --> 00:38:57,971 line:-2
它会收集关于你app所使用的
本地化字符串的数据


705
00:38:59,540 --> 00:39:02,009 line:-1
这就可以让你引用截图作为情境


706
00:39:02,075 --> 00:39:05,679 line:-2
当你本地化app时
或如果你已经完成了本地化


707
00:39:05,946 --> 00:39:08,515 line:-2
你可以在App Store中列出
世界各地的截图


708
00:39:15,689 --> 00:39:16,890 line:-1
要获取更多此类信息


709
00:39:16,957 --> 00:39:18,725 line:-1
以及其它本地化改进


710
00:39:19,293 --> 00:39:20,761 line:-1
请在WWDC网站上查看我们的…


711
00:39:20,827 --> 00:39:24,298 line:-1
创建优秀的本地化体验演讲


712
00:39:26,800 --> 00:39:28,268 line:-1
最后我想强调一下


713
00:39:28,335 --> 00:39:30,571 line:-2
你可以在一个测试计划中混合并匹配
这些设置


714
00:39:30,637 --> 00:39:32,372 line:-1
只要对你的项目有意义就可以


715
00:39:33,507 --> 00:39:35,509 line:-1
比如你可以以三种截然不同的配置


716
00:39:35,576 --> 00:39:38,378 line:-1
构造这样一个测试计划


717
00:39:39,880 --> 00:39:41,815 line:-1
第一个配置主要关注内存安全性


718
00:39:42,216 --> 00:39:43,851 line:-2
因此它有
Address Sanitizer


719
00:39:44,218 --> 00:39:45,853 line:-2
以及Zombie Objects
内存设置


720
00:39:47,754 --> 00:39:49,857 line:-1
第二个配置是关于并发性


721
00:39:50,224 --> 00:39:53,794 line:-2
它有Thread Sanitizer
和Undefined Behavior Sanitizer


722
00:39:54,361 --> 00:39:56,463 line:-1
并且它每次都以随机顺序运行测试


723
00:39:58,432 --> 00:40:01,535 line:-1
然后最后一个配置是当运行测试时


724
00:40:01,602 --> 00:40:02,603 line:-1
收集额外的诊断


725
00:40:03,270 --> 00:40:05,539 line:-1
它通过给被测试的代码


726
00:40:05,839 --> 00:40:07,875 line:-1
设置自定义环境变量实现


727
00:40:07,941 --> 00:40:09,643 line:-1
从而可以出发更多的日志采集


728
00:40:10,644 --> 00:40:12,880 line:-2
它还会启用
保留所有自定义文件附件的选项


729
00:40:12,946 --> 00:40:15,749 line:-2
甚至会保留测试成功的测试的
自定义文件附件


730
00:40:17,551 --> 00:40:20,354 line:-2
这是一个非常复杂的例子
但它却展示了


731
00:40:20,420 --> 00:40:22,289 line:-1
测试计划的能力和灵活性


732
00:40:22,356 --> 00:40:23,891 line:-1
你可以按照你的意愿来运行测试


733
00:40:26,560 --> 00:40:29,363 line:-2
那么这就是测试计划
是Xcode 11中的新功能


734
00:40:29,429 --> 00:40:31,265 line:-1
通过以不同方式多次运行测试


735
00:40:31,665 --> 00:40:33,534 line:-2
可以让你最大限度地利用测试
获得更多利益


736
00:40:34,468 --> 00:40:35,802 line:-1
现在我要把舞台交给Ethan


737
00:40:35,869 --> 00:40:38,272 line:-2
他会分享使用Xcode
进行持续集成的一些方式


738
00:40:38,705 --> 00:40:39,540 line:-1
谢谢


739
00:40:42,776 --> 00:40:44,444 line:-1
（持续集成流程）


740
00:40:46,013 --> 00:40:46,847 line:-1
谢谢Stuart


741
00:40:47,381 --> 00:40:49,383 line:-1
要利用测试计划的全部能量


742
00:40:49,683 --> 00:40:52,920 line:-2
你很可能想在许多不同配置下
运行测试


743
00:40:53,720 --> 00:40:56,290 line:-2
有一个很不错的地方可以实现
这个功能 即在持续集成中


744
00:40:56,557 --> 00:40:59,493 line:-1
这会自动化创建和运行测试的过程


745
00:41:00,227 --> 00:41:01,228 line:-1
当你坐在办公桌前


746
00:41:01,295 --> 00:41:03,630 line:-1
你主要关注的是让测试成功


747
00:41:04,131 --> 00:41:07,968 line:-2
持续集成会在所有设备上
运行所有测试


748
00:41:08,335 --> 00:41:09,570 line:-1
为你提供最大程度的覆盖率


749
00:41:10,637 --> 00:41:12,873 line:-1
Xcode的持续集成


750
00:41:12,940 --> 00:41:15,142 line:-1
有两个主要的可选方案


751
00:41:15,976 --> 00:41:19,446 line:-2
第一个方案是Xcode服务器
它是直接嵌入到Xcode中的


752
00:41:20,414 --> 00:41:22,916 line:-2
通过Xcode服务器
你可以轻松地设置一个框


753
00:41:22,983 --> 00:41:25,419 line:-1
使用最少量的配置创建并测试app


754
00:41:26,787 --> 00:41:30,057 line:-2
第二个选项是创建你自己的
持续集成设置


755
00:41:31,058 --> 00:41:32,092 line:-1
这个选项更高级一些


756
00:41:32,159 --> 00:41:35,162 line:-1
如果你有自定义需求


757
00:41:35,229 --> 00:41:37,397 line:-2
或需要与现有基础结构进行集成的话
适合采用这种方案


758
00:41:38,599 --> 00:41:40,367 line:-1
如果你确实需要进行自定义设置


759
00:41:40,667 --> 00:41:41,602 line:-1
你是幸运的


760
00:41:41,869 --> 00:41:45,606 line:-2
Xcode配备强大的工具
你可以用于创建自己的自动化操作


761
00:41:47,875 --> 00:41:49,109 line:-1
在这个部分中


762
00:41:49,176 --> 00:41:50,911 line:-1
我们主要讲第二种方案


763
00:41:51,245 --> 00:41:54,548 line:-2
并了解如何创建一个完全自定义的
持续集成管道


764
00:41:55,883 --> 00:41:58,685 line:-1
端对端 我们的管道由四个步骤组成


765
00:41:59,086 --> 00:42:01,388 line:-1
每一步都包含不同工具的使用


766
00:42:02,823 --> 00:42:04,124 line:-1
第一步


767
00:42:04,591 --> 00:42:07,294 line:-2
我们要在专用的创建器机器上
创建我们的测试


768
00:42:09,429 --> 00:42:10,531 line:-1
第二步


769
00:42:10,597 --> 00:42:14,401 line:-2
我们要在一套设备上执行
我们所创建的测试


770
00:42:15,602 --> 00:42:18,071 line:-1
这些设备将与第二台机器相连接


771
00:42:18,138 --> 00:42:20,007 line:-1
我们留出第二台机器用于运行测试


772
00:42:21,675 --> 00:42:24,978 line:-2
前两个步骤将生成一些创建
和测试结果


773
00:42:25,946 --> 00:42:29,416 line:-1
这些结果将作为下两个步骤的数据源


774
00:42:31,552 --> 00:42:34,988 line:-2
第三步 我们主要关注
测试失败的创建和测试结果


775
00:42:35,389 --> 00:42:37,524 line:-1
从而填充我们最喜欢的问题追踪器


776
00:42:39,560 --> 00:42:41,295 line:-1
最后第四步


777
00:42:41,662 --> 00:42:43,330 line:-1
我们要随时间追踪我们的代码覆盖率


778
00:42:43,630 --> 00:42:47,000 line:-2
从而了解我们在整体测试覆盖率方面
做得怎么样


779
00:42:50,070 --> 00:42:52,139 line:-1
让我们从前两个步骤开始


780
00:42:52,206 --> 00:42:53,774 line:-1
创建并运行测试


781
00:42:55,409 --> 00:42:57,578 line:-2
对于这些任务
我们将使用xcodebuild


782
00:42:58,278 --> 00:43:00,914 line:-2
Xcodebuild是
Xcode的命令行界面


783
00:43:01,248 --> 00:43:02,950 line:-1
它是整个流程的核心力量


784
00:43:03,951 --> 00:43:06,720 line:-2
在xcodebuild背后是
xcodebuild系统


785
00:43:07,020 --> 00:43:08,989 line:-1
和XCTest


786
00:43:10,958 --> 00:43:13,627 line:-2
通过xcodebuild
有两种方式可以运行测试


787
00:43:14,328 --> 00:43:17,064 line:-1
第一种是在同一个调用中创建并测试


788
00:43:18,165 --> 00:43:19,900 line:-1
为此你要使用测试动作


789
00:43:20,334 --> 00:43:22,936 line:-1
传入你要测试的项目的名称和方案


790
00:43:23,403 --> 00:43:26,039 line:-1
以及测试运行的目的地


791
00:43:26,106 --> 00:43:27,708 line:-2
（用XCODEBUILD
运行测试）


792
00:43:28,542 --> 00:43:30,511 line:-1
第二种是创建然后测试


793
00:43:31,078 --> 00:43:33,213 line:-2
这会在xcodebuild的
两个独立的调用中


794
00:43:33,280 --> 00:43:35,582 line:-1
实施创建和测试动作


795
00:43:36,683 --> 00:43:39,319 line:-1
这个功能的一个很重要的用例是


796
00:43:39,386 --> 00:43:41,588 line:-1
让一台机器专用于创建


797
00:43:41,889 --> 00:43:43,957 line:-1
另一台机器专用于运行测试


798
00:43:44,024 --> 00:43:45,792 line:-1
这是我们尝试要实现的流程


799
00:43:47,127 --> 00:43:50,330 line:-2
要实现这个流程
你首先要调用用于测试动作的创建


800
00:43:50,764 --> 00:43:52,766 line:-1
并传入与之前一样的参数


801
00:43:53,901 --> 00:43:57,337 line:-1
这既会产生用于测试的创建产品


802
00:43:57,771 --> 00:43:59,506 line:-2
还会产生一个
xctestrun文件


803
00:44:00,474 --> 00:44:02,609 line:-1
Xctestrun文件是一个清单


804
00:44:02,676 --> 00:44:04,111 line:-1
描述创建产品


805
00:44:04,511 --> 00:44:07,014 line:-2
并说明xctestrun
在测试时要做什么


806
00:44:09,216 --> 00:44:11,652 line:-1
接下来 不通过创建动作调用测试


807
00:44:12,119 --> 00:44:14,755 line:-2
传入之前生成的
xctestrun文件


808
00:44:16,123 --> 00:44:18,091 line:-1
这将会实际上执行测试


809
00:44:20,627 --> 00:44:23,664 line:-2
实际上你可以构建自己的
xctestrun文件


810
00:44:24,097 --> 00:44:27,134 line:-2
可以让你更容易控制在测试过程中
所发生的事 而不需要创建


811
00:44:28,302 --> 00:44:30,838 line:-2
如果你想了解更多
关于这些文件的格式


812
00:44:30,904 --> 00:44:32,039 line:-1
请查看主页


813
00:44:33,073 --> 00:44:36,043 line:-2
同时请注意 Xcode版本不同
格式可能也不同


814
00:44:36,844 --> 00:44:39,279 line:-2
一般来说 请使用
Xcode的同一版本


815
00:44:39,346 --> 00:44:41,415 line:-1
来创建和运行测试


816
00:44:43,917 --> 00:44:44,918 line:-1
提到运行测试


817
00:44:45,385 --> 00:44:46,987 line:-1
xcodebuild支持同时


818
00:44:47,054 --> 00:44:49,823 line:-1
在多台设备或模拟器上运行测试


819
00:44:50,824 --> 00:44:55,028 line:-2
这可以最大范围的覆盖各种设备类型
和尺寸


820
00:44:56,196 --> 00:44:58,498 line:-1
这对于UI测试来说尤其有用


821
00:44:58,899 --> 00:45:01,635 line:-2
因为app的UI很可能
因为尺寸不同而不同


822
00:45:03,270 --> 00:45:04,471 line:-1
如果你想了解更多


823
00:45:04,538 --> 00:45:07,074 line:-2
关于xcodebuild
支持多个目的地的信息


824
00:45:07,508 --> 00:45:10,477 line:-2
请查看2018年的
测试中的新功能演讲


825
00:45:13,280 --> 00:45:15,549 line:-2
目前我们已经讲了
xcodebuild的基础知识


826
00:45:15,616 --> 00:45:16,917 line:-1
以及如何创建并运行测试


827
00:45:17,384 --> 00:45:20,787 line:-2
现在我想讲一下
测试计划特有的一些选项


828
00:45:22,489 --> 00:45:24,691 line:-1
如果你有一个方案是有多个测试计划


829
00:45:24,758 --> 00:45:27,761 line:-2
你可以使用显示测试计划选项
把所有测试计划列出来


830
00:45:29,630 --> 00:45:31,632 line:-1
如果你有一个方案有多个测试计划


831
00:45:31,698 --> 00:45:33,200 line:-1
可以开启一些引人注目的流程


832
00:45:33,867 --> 00:45:36,170 line:-2
比如你可以有一个
运行时间长的测试计划


833
00:45:36,236 --> 00:45:38,038 line:-1
包含一整套测试


834
00:45:38,405 --> 00:45:41,275 line:-2
以及一个运行时间短的测试计划
只有几个冒烟测试


835
00:45:42,276 --> 00:45:43,911 line:-1
如果你选择有多个测试计划


836
00:45:44,278 --> 00:45:46,580 line:-2
其中一个测试计划将被作为
默认测试计划


837
00:45:46,914 --> 00:45:49,683 line:-2
你可以给它配置
方案编辑器的测试动作


838
00:45:50,584 --> 00:45:53,120 line:-2
默认计划是xcodebuild
将运行的计划


839
00:45:53,187 --> 00:45:54,521 line:-1
除非你另有说明


840
00:45:56,957 --> 00:45:59,159 line:-1
要覆盖默认的测试计划


841
00:45:59,226 --> 00:46:00,727 line:-1
可以使用测试计划选项


842
00:46:01,161 --> 00:46:04,031 line:-1
传入你想要运行的计划的名称


843
00:46:07,301 --> 00:46:09,469 line:-2
通过以上这些
我们了解了xcodebuild


844
00:46:09,837 --> 00:46:11,939 line:-2
我们可以开始在我们的管道中填写
一些空白了


845
00:46:13,540 --> 00:46:15,108 line:-1
从创建器机器开始


846
00:46:15,375 --> 00:46:17,711 line:-2
我们使用xcodebuild
build-for-testing


847
00:46:17,778 --> 00:46:20,747 line:-2
来产生我们所需要的build产品
和xctestrun文件


848
00:46:22,149 --> 00:46:24,084 line:-1
这将被传到运行器机器上


849
00:46:24,451 --> 00:46:26,820 line:-2
运行器机器将调用xcodebuild
test-without-building


850
00:46:27,187 --> 00:46:29,389 line:-1
在我们的设备上执行测试


851
00:46:32,426 --> 00:46:34,862 line:-2
这两个步骤产生
build和测试结果


852
00:46:35,562 --> 00:46:37,397 line:-1
这是我接下来要讲的内容


853
00:46:38,832 --> 00:46:40,033 line:-1
即结果捆绑包


854
00:46:40,767 --> 00:46:42,669 line:-1
今年关于结果捆绑包


855
00:46:42,736 --> 00:46:43,804 line:-1
我们有一些很棒的东西要与你们分享


856
00:46:43,871 --> 00:46:45,105 line:-1
（结果捆绑包）


857
00:46:45,806 --> 00:46:48,075 line:-1
首先 什么是结果捆绑包？


858
00:46:49,042 --> 00:46:51,378 line:-2
结果捆绑包是由Xcode
生成的一个文件


859
00:46:51,712 --> 00:46:53,113 line:-1
包含结构化数据


860
00:46:53,180 --> 00:46:55,616 line:-1
描述创建和运行测试的结果


861
00:46:56,650 --> 00:46:58,785 line:-1
它包含资产比如创建日志


862
00:46:59,186 --> 00:47:01,688 line:-1
显示编译了哪些目标和源文件


863
00:47:03,223 --> 00:47:05,959 line:-2
测试报告显示哪些测试通过了
以及哪些测试失败了


864
00:47:07,828 --> 00:47:10,130 line:-1
代码覆盖率报告显示所运行的测试


865
00:47:10,197 --> 00:47:11,532 line:-1
覆盖了哪些代码


866
00:47:13,300 --> 00:47:16,170 line:-2
以及由测试使用
XCTest附件API


867
00:47:16,470 --> 00:47:18,472 line:-1
所创建的所有测试附件


868
00:47:21,141 --> 00:47:22,576 line:-1
要如何生成结果捆绑包呢？


869
00:47:23,343 --> 00:47:26,180 line:-2
只需要给xcodebuild传递
结果捆绑包路径选项即可


870
00:47:29,149 --> 00:47:31,084 line:-1
现在我们知道如何生成结果捆绑包了


871
00:47:31,385 --> 00:47:33,320 line:-1
我们还可以填充另一个遗漏的东西


872
00:47:34,421 --> 00:47:37,925 line:-2
我们要给Xcode创建调用
添加结果捆绑包路径选项


873
00:47:38,525 --> 00:47:40,327 line:-1
从而开始生成这些创建和测试结果


874
00:47:43,397 --> 00:47:45,365 line:-1
结果捆绑包已经存在一段时间了


875
00:47:45,732 --> 00:47:49,369 line:-2
但在Xcode 11中 我们彻底
重新设计了底层的文件格式


876
00:47:49,436 --> 00:47:50,637 line:-1
这带来了一些好处


877
00:47:52,139 --> 00:47:55,742 line:-2
首先 新格式经过高度优化
可以在磁盘上高效运行


878
00:47:56,577 --> 00:47:59,613 line:-2
在我们自己的测试中
我们发现结果捆绑包


879
00:47:59,680 --> 00:48:01,682 line:-1
与之前的格式相比平均缩小了四倍


880
00:48:02,716 --> 00:48:04,918 line:-1
这在持续集成中尤其有用


881
00:48:05,385 --> 00:48:08,288 line:-2
在持续集成中 结果捆绑包可以
以非常高的速率生成和存储


882
00:48:10,457 --> 00:48:13,927 line:-2
第二 现在可以直接在Xcode中
打开结果捆绑包了


883
00:48:14,361 --> 00:48:16,930 line:-2
这就可以让你轻松地深入查看
集成的结果


884
00:48:19,132 --> 00:48:21,468 line:-1
第三 我们第一次提供一种


885
00:48:21,535 --> 00:48:23,937 line:-2
以编程方式访问结果捆绑包的
内容的方式


886
00:48:24,438 --> 00:48:27,241 line:-2
我们可以在自己的持续集成设置中
利用结果捆绑包的内容


887
00:48:29,843 --> 00:48:31,411 line:-1
要在Xcode中打开结果捆绑包


888
00:48:31,778 --> 00:48:33,180 line:-1
双击文件


889
00:48:33,247 --> 00:48:36,116 line:-2
即可使用你已经很熟悉的UI
来浏览它的内容


890
00:48:37,084 --> 00:48:39,386 line:-1
请看测试报告中失败和成功的测试


891
00:48:39,920 --> 00:48:41,555 line:-1
在创建日志中深入了解创建失败


892
00:48:42,155 --> 00:48:44,658 line:-2
并在代码覆盖率报告中了解
在覆盖率方面做得怎么样


893
00:48:51,465 --> 00:48:52,299 line:-1
谢谢


894
00:48:53,133 --> 00:48:55,335 line:-1
要以编程方式访问结果捆绑包的内容


895
00:48:55,669 --> 00:48:59,006 line:-2
你可使用Xcode 11的新命令行工具
叫做xcresulttool


896
00:49:00,674 --> 00:49:03,677 line:-2
Xcresulttool
给你提供结果捆绑包中


897
00:49:03,744 --> 00:49:04,978 line:-1
所含结构数据的完全权限


898
00:49:06,246 --> 00:49:07,848 line:-1
它把这个数据作为JSON提交


899
00:49:08,148 --> 00:49:10,984 line:-2
而JSON的格式已经被公开记录
和版本控制了


900
00:49:13,187 --> 00:49:15,756 line:-2
我们要在下一步中
利用xcresulttool


901
00:49:16,156 --> 00:49:19,159 line:-1
给问题追踪器填充


902
00:49:19,226 --> 00:49:20,260 line:-2
在创建和测试过程中所发生的
所有失败


903
00:49:22,696 --> 00:49:24,164 line:-1
要提取创建失败


904
00:49:24,731 --> 00:49:27,100 line:-2
使用get命令调用
xcresulttool


905
00:49:27,634 --> 00:49:29,236 line:-1
传入ResultBundle路径


906
00:49:30,771 --> 00:49:32,339 line:-1
在接下来的JSON输出中


907
00:49:33,006 --> 00:49:35,943 line:-2
你可以发现创建失败嵌套在
其中一个对象中


908
00:49:37,311 --> 00:49:39,780 line:-1
每个创建失败都包含失败信息


909
00:49:40,147 --> 00:49:42,716 line:-1
以及源文件和创建失败的行编号


910
00:49:42,783 --> 00:49:44,384 line:-1
（提取创建失败和测试失败）


911
00:49:45,185 --> 00:49:47,588 line:-1
测试失败也嵌套在JSON内


912
00:49:48,088 --> 00:49:49,790 line:-1
其中包含失败的测试的名称


913
00:49:49,857 --> 00:49:51,291 line:-1
以及断言信息


914
00:49:54,761 --> 00:49:56,830 line:-2
如果你没有100%按这些步骤进行
也不要担心


915
00:49:57,297 --> 00:49:58,599 line:-1
就像我之前提到的那样


916
00:49:58,665 --> 00:50:00,334 line:-2
xcresulttool的
一个最大的好处是


917
00:50:00,400 --> 00:50:03,136 line:-1
它生成的JSON是公开记录的


918
00:50:03,904 --> 00:50:07,140 line:-2
事实上 工具自身可以使用格式
描述命令


919
00:50:07,441 --> 00:50:09,042 line:-1
描述JSON的架构


920
00:50:10,210 --> 00:50:12,646 line:-1
架构列出了可以在输出中呈现的


921
00:50:12,713 --> 00:50:14,114 line:-1
所有可能的对象类型


922
00:50:14,581 --> 00:50:17,351 line:-2
因此我鼓励你们当你们编写自己的
自动化测试时


923
00:50:17,618 --> 00:50:18,619 line:-1
参考一下这个列表


924
00:50:20,888 --> 00:50:21,855 line:-1
最后但并不是最不重要的


925
00:50:21,922 --> 00:50:24,157 line:-1
请查看工具的主页获取更多信息


926
00:50:26,860 --> 00:50:28,729 line:-2
通过我们新开发的
xcresulttool


927
00:50:28,795 --> 00:50:30,264 line:-1
我们现在可以进入第三步了


928
00:50:31,164 --> 00:50:34,735 line:-2
我们要用xcresulttool
get从结果捆绑包中


929
00:50:34,801 --> 00:50:37,004 line:-2
提取那些创建失败和测试失败
并把它们放到我们的问题追踪器中


930
00:50:40,007 --> 00:50:41,408 line:-1
目前我们已经做了很多操作了


931
00:50:41,475 --> 00:50:43,210 line:-1
但我们还有最后一个步骤要完成


932
00:50:43,877 --> 00:50:45,646 line:-1
我们想随时间追踪我们的代码覆盖率


933
00:50:45,712 --> 00:50:47,014 line:-1
用于了解覆盖率是否有所下降


934
00:50:48,849 --> 00:50:51,785 line:-2
为此 我们要使用另一个命令行工具
叫做xccov


935
00:50:53,020 --> 00:50:56,056 line:-2
Xccov可以让你以编程方式
访问代码覆盖率报告


936
00:50:56,123 --> 00:50:58,058 line:-1
可以是人可读的文本或JSON


937
00:50:59,359 --> 00:51:01,295 line:-1
要使用xccov浏览覆盖率报告


938
00:51:01,361 --> 00:51:03,931 line:-2
就要调用浏览命令
并给它传递结果捆绑包


939
00:51:03,997 --> 00:51:05,132 line:-2
（用XCCOV
浏览代码覆盖率报告）


940
00:51:05,599 --> 00:51:06,834 line:-1
在随后的输出中


941
00:51:06,900 --> 00:51:09,303 line:-1
你可以看到每个目标的行覆盖率


942
00:51:09,970 --> 00:51:13,040 line:-1
源文件和项目中的函数或方法


943
00:51:15,342 --> 00:51:17,277 line:-1
现在简单地浏览覆盖率报告


944
00:51:17,344 --> 00:51:18,812 line:-1
可能并不完全是你想要实现的功能


945
00:51:19,580 --> 00:51:22,783 line:-1
如果你还想比较两个报告


946
00:51:22,850 --> 00:51:24,218 line:-1
用于了解覆盖率是否增加了或减少了


947
00:51:24,618 --> 00:51:25,886 line:-1
你可以使用diff命令


948
00:51:26,920 --> 00:51:29,156 line:-1
把路径传给工具的两个结果捆绑包


949
00:51:29,523 --> 00:51:31,258 line:-1
这将生成类似这样的输出


950
00:51:32,492 --> 00:51:35,863 line:-2
在这个例子中 我们可以看到
AppDelegate文件的代码覆盖率


951
00:51:36,330 --> 00:51:39,466 line:-1
在两个结果捆绑包之间增加了50%


952
00:51:42,569 --> 00:51:45,372 line:-2
跟xcresulttool一样
xccov也有一个主页


953
00:51:45,672 --> 00:51:46,907 line:-1
请查看xccov主页获取更多信息


954
00:51:50,143 --> 00:51:51,945 line:-1
这样我们终于完成了最后一步


955
00:51:52,846 --> 00:51:55,616 line:-2
我们将使用xccov
从捆绑包中提取代码覆盖率


956
00:51:56,149 --> 00:51:57,518 line:-1
用于追踪我们的进度


957
00:52:00,854 --> 00:52:03,490 line:-1
太棒了 我们的持续集成流程完成了


958
00:52:04,091 --> 00:52:06,360 line:-2
使用xcodebuild
创建并运行测试


959
00:52:06,860 --> 00:52:09,263 line:-2
用xcresulttool
来提取创建失败和测试失败


960
00:52:09,830 --> 00:52:11,431 line:-1
并使用xccov来浏览代码覆盖率


961
00:52:11,765 --> 00:52:14,067 line:-2
我们创建了一个完全功能性的
端对端管道


962
00:52:14,134 --> 00:52:15,669 line:-1
自动化我们的app的测试流程


963
00:52:16,770 --> 00:52:19,806 line:-1
希望这能让你们了解了一些


964
00:52:19,873 --> 00:52:22,376 line:-2
使用Xcode配套工具
有多大的能力和灵活性


965
00:52:23,243 --> 00:52:25,045 line:-1
我们只讲了其中一种可能的流程


966
00:52:25,412 --> 00:52:27,748 line:-2
但通过这些创建代码块
天空才是真正的极限


967
00:52:30,150 --> 00:52:32,085 line:-1
今天我们讲了很多内容


968
00:52:32,152 --> 00:52:33,921 line:-2
让我们快速回顾一下
我们讲了哪些内容


969
00:52:35,088 --> 00:52:38,492 line:-1
我们先介绍了Xcode中的测试


970
00:52:39,426 --> 00:52:42,229 line:-2
了解了如何用XCTest
编写单元测试和UI测试


971
00:52:42,496 --> 00:52:43,730 line:-1
以及如何运行它们以捕捉错误


972
00:52:45,432 --> 00:52:47,334 line:-1
接下来我们了解了测试计划


973
00:52:47,401 --> 00:52:49,970 line:-2
这是一个新功能
可以让我们更好地管理我们的测试


974
00:52:50,337 --> 00:52:53,073 line:-1
以及在不同配置下多次运行测试


975
00:52:54,708 --> 00:52:56,877 line:-1
最后我们了解了我们可以用于


976
00:52:56,944 --> 00:52:59,213 line:-1
创建自定义持续集成管道的工具


977
00:53:01,215 --> 00:53:03,650 line:-2
如果你想了解更多
请从developer.apple.com中


978
00:53:03,717 --> 00:53:05,052 line:-1
复制这几张幻灯片


979
00:53:05,519 --> 00:53:07,688 line:0
请一定要查看
Xcode 11的版本注释


980
00:53:08,956 --> 00:53:12,125 line:0
最后如果你有兴趣了解
XCTest中


981
00:53:12,192 --> 00:53:13,994 line:0
用于测量代码的性能的新API


982
00:53:14,261 --> 00:53:16,930 line:0
请查看今天稍后举办的
延长电池寿命和改善电池性能演讲


983
00:53:18,131 --> 00:53:20,167 line:-2
请参加我们的演讲
祝你们度过一个愉快的WWDC

