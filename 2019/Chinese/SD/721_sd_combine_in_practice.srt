1
00:00:01,176 --> 00:00:04,500
[音乐]


2
00:00:10,286 --> 00:00:10,636
>> 大家好


3
00:00:11,516 --> 00:00:16,546
[掌声]


4
00:00:17,046 --> 00:00:18,896
大家好 我是 Michael LeHew


5
00:00:19,376 --> 00:00:21,046
在 Apple Foundation 团队工作


6
00:00:21,326 --> 00:00:23,286
今天 我很激动地


7
00:00:23,286 --> 00:00:24,656
向大家介绍


8
00:00:24,656 --> 00:00:25,756
今年即将发布的


9
00:00:25,756 --> 00:00:26,776
Combine 框架


10
00:00:27,686 --> 00:00:28,796
先澄清一点


11
00:00:28,796 --> 00:00:29,976
我们要说的不是联合收割机


12
00:00:32,136 --> 00:00:33,336
深入探讨之前 我想


13
00:00:33,336 --> 00:00:35,056
先总体简单介绍一下


14
00:00:35,166 --> 00:00:36,606
Combine 是什么


15
00:00:36,606 --> 00:00:40,446
代码中 常见的


16
00:00:40,476 --> 00:00:41,536
情况是 我们有


17
00:00:41,536 --> 00:00:44,866
值或事件的发布者


18
00:00:44,866 --> 00:00:46,236
还有想要从发布者处


19
00:00:46,236 --> 00:00:49,796
接收值的订阅者


20
00:00:50,386 --> 00:00:51,946
有一些相关方


21
00:00:51,946 --> 00:00:52,956
会在这两者


22
00:00:52,956 --> 00:00:54,706
之间建立连接


23
00:00:56,336 --> 00:00:58,626
连接建立后 订阅者


24
00:00:59,006 --> 00:01:00,676
会声明


25
00:01:00,676 --> 00:01:02,176
想要从发布者处


26
00:01:02,176 --> 00:01:05,135
接收值 之后


27
00:01:05,135 --> 00:01:06,946
发布者便可以


28
00:01:07,276 --> 00:01:08,736
向下游发送值


29
00:01:09,726 --> 00:01:12,196
这一过程会持续下去


30
00:01:12,196 --> 00:01:13,546
直到发布者因为值发送完毕


31
00:01:13,546 --> 00:01:15,326
或出现发送失败


32
00:01:15,326 --> 00:01:16,826
决定停止发送值


33
00:01:16,826 --> 00:01:18,826
或者有人


34
00:01:18,826 --> 00:01:20,726
选择取消订阅


35
00:01:22,276 --> 00:01:23,916
如大家所见


36
00:01:23,916 --> 00:01:26,006
这样的通信模式在我们的


37
00:01:26,006 --> 00:01:27,826
软件中随处可见


38
00:01:27,826 --> 00:01:30,126
形式可以是回调 闭包


39
00:01:30,126 --> 00:01:31,976
或者其他出现异步通信的情况


40
00:01:34,046 --> 00:01:35,266
Combine 正与这种模式


41
00:01:35,266 --> 00:01:36,676
密切相关


42
00:01:39,046 --> 00:01:41,166
Combine 定义了一个


43
00:01:41,166 --> 00:01:42,856
统一的抽象


44
00:01:42,856 --> 00:01:44,316
用来描述 API


45
00:01:44,316 --> 00:01:45,326
这类 API 可以在一段时间内处理值


46
00:01:45,986 --> 00:01:48,476
我们来看看


47
00:01:48,476 --> 00:01:50,736
值发布者有哪些具体特征


48
00:01:53,046 --> 00:01:53,876
我们已经在介绍会议中


49
00:01:53,876 --> 00:01:55,096
谈论过这方面的内容


50
00:01:55,096 --> 00:01:58,286
但我们再回顾一下


51
00:01:58,286 --> 00:02:00,296
Combine 中的值发布者遵循


52
00:02:01,376 --> 00:02:02,426
Publisher 协议


53
00:02:02,986 --> 00:02:06,586
协议规定了两种 associatedtype


54
00:02:06,586 --> 00:02:09,606
即发布者


55
00:02:09,606 --> 00:02:10,716
发布的值


56
00:02:10,716 --> 00:02:13,166
以及发布能否失败


57
00:02:13,756 --> 00:02:15,976
稍后 我会详细介绍失败


58
00:02:18,156 --> 00:02:20,626
Publisher 也要描述


59
00:02:20,626 --> 00:02:22,326
如何将 Subscriber


60
00:02:22,846 --> 00:02:23,736
附加于自身


61
00:02:23,736 --> 00:02:25,346
限制条件是 associatedtype 必须匹配


62
00:02:26,766 --> 00:02:28,706
就是这样


63
00:02:28,946 --> 00:02:31,506
好了 我觉得理论部分足够了


64
00:02:31,806 --> 00:02:34,556
此次会议名为 Combine in Practice


65
00:02:34,556 --> 00:02:39,076
我们就来关注实践 我有一个巫师朋友


66
00:02:39,296 --> 00:02:41,596
他非常酷


67
00:02:41,706 --> 00:02:43,786
想跟我一起


68
00:02:43,966 --> 00:02:45,516
为他正在筹办的新巫师学校开发一款 App


69
00:02:45,516 --> 00:02:49,986
App 中有一项功能是


70
00:02:49,986 --> 00:02:51,446
提供法术下载


71
00:02:51,446 --> 00:02:52,366
这些法术


72
00:02:52,366 --> 00:02:54,046
是由和他一样的巫师分享的


73
00:02:54,436 --> 00:02:55,526
他不是 App 开发者


74
00:02:55,526 --> 00:02:57,346
他是个巫师 所以他给了我


75
00:02:57,346 --> 00:03:00,376
一张草图 这就是我要使用的 UI 组件


76
00:03:01,826 --> 00:03:03,496
虽然他是个巫师


77
00:03:03,496 --> 00:03:04,566
但他确实会写代码


78
00:03:04,566 --> 00:03:07,396
起码足够帮我下载法术


79
00:03:07,396 --> 00:03:08,586
于是 他就开始忙自己的


80
00:03:08,586 --> 00:03:09,546
我要做的则是


81
00:03:09,546 --> 00:03:10,716
讨论我们要如何


82
00:03:10,716 --> 00:03:13,596
使用 Combine 获取


83
00:03:13,596 --> 00:03:15,076
必要的 App 值


84
00:03:15,426 --> 00:03:17,976
在这个标签中填充法术名


85
00:03:21,366 --> 00:03:23,166
Combine 中 NotificationCenter


86
00:03:23,166 --> 00:03:24,646
支持将通知


87
00:03:24,646 --> 00:03:26,316
提供给发布者


88
00:03:26,606 --> 00:03:28,166
我们就来创建


89
00:03:28,166 --> 00:03:29,976
一个 Publisher


90
00:03:29,976 --> 00:03:31,806
让我的巫师朋友传递通知


91
00:03:32,396 --> 00:03:35,056
这个函数的


92
00:03:35,056 --> 00:03:36,096
返回类型将是 Publisher


93
00:03:36,096 --> 00:03:38,426
但 Combine 中


94
00:03:38,426 --> 00:03:39,716
对发布者重要的是


95
00:03:39,936 --> 00:03:41,876
它的输出和失败类型


96
00:03:44,046 --> 00:03:45,596
NotificationCenter Publisher


97
00:03:45,656 --> 00:03:47,436
传递通知


98
00:03:47,436 --> 00:03:48,166
并且不可以失败


99
00:03:48,166 --> 00:03:50,046
既然我们要


100
00:03:50,046 --> 00:03:51,876
详细探讨发布者


101
00:03:52,286 --> 00:03:53,446
接下来的讨论中 


102
00:03:53,446 --> 00:03:54,536
我就会一直


103
00:03:54,536 --> 00:03:56,516
把发布者的输出


104
00:03:56,516 --> 00:03:57,836
放在上面


105
00:03:57,836 --> 00:04:01,726
把失败放在下面 那么我们就有了一个


106
00:04:01,726 --> 00:04:04,056
通知发布者


107
00:04:04,056 --> 00:04:06,096
但我们真正想要的是


108
00:04:06,096 --> 00:04:07,976
其中描述刚刚下载的法术的数据


109
00:04:10,216 --> 00:04:11,836
我的朋友告诉我


110
00:04:11,836 --> 00:04:13,296
他把数据放在了 userInfo 字典中


111
00:04:13,496 --> 00:04:15,536
幸运的是 Combine 提供了


112
00:04:15,536 --> 00:04:17,016
很有帮助的 map 函数


113
00:04:17,016 --> 00:04:19,206
让我们可以深入内部


114
00:04:19,866 --> 00:04:21,866
将通知转换为我们需要的形式


115
00:04:22,096 --> 00:04:23,246
这与 Sequence 中


116
00:04:23,246 --> 00:04:25,946
已有的操作很相似


117
00:04:26,766 --> 00:04:28,906
可以看到 我们使用的发布者


118
00:04:28,906 --> 00:04:30,606
输出是数据


119
00:04:30,606 --> 00:04:36,956
不会产生错误 我们调用 map 这样的函数


120
00:04:36,956 --> 00:04:38,936
作用于 Publisher 且返回


121
00:04:38,936 --> 00:04:40,426
新 Publisher 操作符


122
00:04:40,956 --> 00:04:42,526
它们在 Combine 中会经常那个出现


123
00:04:43,186 --> 00:04:45,866
我的朋友还告诉我


124
00:04:45,866 --> 00:04:47,826
JSON 负载 或者将要


125
00:04:47,826 --> 00:04:49,926
成为 JSON 负载类型的数据


126
00:04:49,926 --> 00:04:51,706
已经在我们的 App 中定义了


127
00:04:52,256 --> 00:04:53,656
所以 我就可以用另一个 Combine 操作符


128
00:04:53,656 --> 00:04:55,196
尝试解码数据


129
00:04:55,196 --> 00:04:56,746
我们调用这个


130
00:04:56,746 --> 00:04:57,596
tryMap 操作符


131
00:04:58,626 --> 00:05:00,716
它和 map 很类似


132
00:05:00,716 --> 00:05:02,106
但它多了一个功能


133
00:05:02,156 --> 00:05:05,116
可以将错误抛出转换为流中的失败


134
00:05:06,146 --> 00:05:07,926
确实 这个操作符的输出


135
00:05:08,016 --> 00:05:09,926
是 MagicTrick 的发布者


136
00:05:09,926 --> 00:05:12,246
它的失败


137
00:05:12,246 --> 00:05:13,976
遵循 Swift Error 协议


138
00:05:16,566 --> 00:05:18,476
从数据中解码自定义类型


139
00:05:18,476 --> 00:05:20,246
是常见任务


140
00:05:20,286 --> 00:05:21,606
我们也提供了一个操作符


141
00:05:21,606 --> 00:05:22,836
专门帮你处理


142
00:05:23,966 --> 00:05:25,356
仅需要简单的调用 .decode


143
00:05:28,076 --> 00:05:28,736
发布者的输出


144
00:05:29,516 --> 00:05:32,546
[掌声]


145
00:05:33,046 --> 00:05:33,916
发布者的输出和


146
00:05:33,916 --> 00:05:35,856
失败类型没有变化


147
00:05:36,916 --> 00:05:38,246
既然我们有了可以


148
00:05:38,246 --> 00:05:39,546
失败的发布者


149
00:05:39,546 --> 00:05:40,576
我想多谈一谈我们


150
00:05:40,576 --> 00:05:43,116
能做的事情


151
00:05:43,356 --> 00:05:45,616
Combine 中 对潜在的失败


152
00:05:45,616 --> 00:05:48,326
作出反应至关重要


153
00:05:48,886 --> 00:05:50,536
每个发布者和订阅者


154
00:05:50,536 --> 00:05:51,836
都有机会描述


155
00:05:51,836 --> 00:05:53,096
它们生成或允许的


156
00:05:53,096 --> 00:05:54,486
失败类型


157
00:05:55,096 --> 00:05:56,896
我们将其内置于 Combine


158
00:05:57,456 --> 00:05:58,986
因为就像 Swift 一样


159
00:05:58,986 --> 00:06:00,176
我们不想让错误处理


160
00:06:00,176 --> 00:06:01,116
成为一件完全


161
00:06:01,116 --> 00:06:02,666
基于惯例的事情


162
00:06:03,636 --> 00:06:05,216
我们在其他语言中进行了尝试


163
00:06:05,216 --> 00:06:06,236
效果不太好


164
00:06:06,986 --> 00:06:08,846
所以 许多类型会将其


165
00:06:08,846 --> 00:06:10,256
失败类型描述为 never


166
00:06:10,256 --> 00:06:11,496
这就表明


167
00:06:11,496 --> 00:06:12,966
它们可能失败


168
00:06:12,966 --> 00:06:15,166
或预期失败在上游得到解决


169
00:06:15,686 --> 00:06:18,546
但除此之外


170
00:06:18,546 --> 00:06:20,906
我们还提供了许多操作符


171
00:06:20,906 --> 00:06:23,456
失败发生时


172
00:06:23,456 --> 00:06:24,836
你可以借助它们作出反应或恢复


173
00:06:25,336 --> 00:06:28,186
其中最简单的 就是


174
00:06:28,186 --> 00:06:29,726
预设失败永远不会发生


175
00:06:30,816 --> 00:06:32,646
自然 此时返回的发布者


176
00:06:32,646 --> 00:06:33,816
失败类型


177
00:06:33,816 --> 00:06:34,696
就是 never


178
00:06:35,426 --> 00:06:38,006
但我们来看看为什么


179
00:06:38,226 --> 00:06:39,426
想象一下


180
00:06:39,426 --> 00:06:40,576
我们有一个上游的发布者


181
00:06:41,216 --> 00:06:42,686
它与下游的


182
00:06:42,856 --> 00:06:44,906
订阅者通过中间的


183
00:06:44,906 --> 00:06:46,766
assertNoFailure 这一操作符连接


184
00:06:47,706 --> 00:06:49,496
这个操作符只会


185
00:06:49,496 --> 00:06:51,576
在收到值时直接将其向下传递


186
00:06:52,616 --> 00:06:54,676
但假如上游


187
00:06:54,676 --> 00:06:56,766
传来错误 我们的程序


188
00:06:56,766 --> 00:06:58,636
就会卡住


189
00:06:58,636 --> 00:07:00,956
这对于我们的巫师用户来说 不是理想中的结果


190
00:07:04,046 --> 00:07:05,666
幸运的是 我们在 Combine 中


191
00:07:05,666 --> 00:07:06,906
有许多其他操作符


192
00:07:06,906 --> 00:07:07,736
来处理失败


193
00:07:08,586 --> 00:07:10,256
除了预设之外


194
00:07:10,256 --> 00:07:11,506
你还可以尝试


195
00:07:11,506 --> 00:07:13,626
重新连接至上游


196
00:07:13,626 --> 00:07:15,086
发布者或将错误


197
00:07:15,086 --> 00:07:16,276
转换为其他类型


198
00:07:16,276 --> 00:07:19,476
有一个操作符特别有用


199
00:07:19,476 --> 00:07:20,146
那就是 catch


200
00:07:20,756 --> 00:07:23,126
catch 允许你提供一个闭包


201
00:07:23,126 --> 00:07:24,386
其中定义一个恢复性


202
00:07:24,386 --> 00:07:26,476
发布者 它适用于


203
00:07:26,476 --> 00:07:29,506
原先的上游发布者发生失败的情形


204
00:07:29,926 --> 00:07:32,146
我们来看看它如何生效


205
00:07:32,966 --> 00:07:33,806
我们先来看看与之前


206
00:07:33,806 --> 00:07:35,176
类似的情形


207
00:07:35,176 --> 00:07:36,806
这次我们不用 assertNoFailure 而是


208
00:07:36,806 --> 00:07:37,916
使用 catch 操作符


209
00:07:38,876 --> 00:07:41,326
和先前一样


210
00:07:41,326 --> 00:07:42,406
值会无障碍转发至


211
00:07:42,406 --> 00:07:43,586
下游的订阅者


212
00:07:44,096 --> 00:07:46,756
但错误抵达时


213
00:07:47,516 --> 00:07:50,206
现有的上游连接将被终止


214
00:07:52,266 --> 00:07:53,286
我们之后会调用提供的


215
00:07:53,286 --> 00:07:54,716
恢复性闭包 它可以


216
00:07:54,716 --> 00:07:56,566
产生一个新的发布者


217
00:07:56,566 --> 00:07:58,446
供我们订阅 之后也可以


218
00:07:58,446 --> 00:07:59,866
从它那里接收值


219
00:08:01,076 --> 00:08:03,146
这样一来 catch 这个操作符


220
00:08:03,146 --> 00:08:04,406
就可以用新的发布者


221
00:08:04,406 --> 00:08:05,846
替换原有的发布者


222
00:08:05,846 --> 00:08:06,476
让我们从错误中恢复


223
00:08:07,436 --> 00:08:08,386
我们这就把它用在


224
00:08:08,386 --> 00:08:09,596
我们的代码里


225
00:08:11,046 --> 00:08:12,256
catch 的使用和


226
00:08:12,256 --> 00:08:13,516
其他操作符很类似


227
00:08:13,916 --> 00:08:14,736
但这里的闭包


228
00:08:14,736 --> 00:08:16,266
希望我们返回一个发布者


229
00:08:17,636 --> 00:08:19,136
Combine 定义了一种特殊


230
00:08:19,136 --> 00:08:20,656
发布者供已有


231
00:08:20,656 --> 00:08:22,116
想要发布的值时使用


232
00:08:22,426 --> 00:08:25,576
我们称其为 Just 意为直接发布这个值


233
00:08:25,706 --> 00:08:26,466
这是 Combine 初始


234
00:08:26,466 --> 00:08:28,346
自带的诸多发布者


235
00:08:28,346 --> 00:08:31,186
中的一个例子


236
00:08:32,626 --> 00:08:34,395
使用它的时候 


237
00:08:34,395 --> 00:08:36,336
返回的发布者类型不能失败


238
00:08:39,046 --> 00:08:40,616
现在 我来回顾一下我们


239
00:08:40,616 --> 00:08:41,936
执行过的各种转换


240
00:08:42,486 --> 00:08:45,016
最开始 我们有通知发布者


241
00:08:45,016 --> 00:08:47,536
之后 我们对其映射


242
00:08:47,536 --> 00:08:49,206
获取我们


243
00:08:49,206 --> 00:08:50,786
想要解码的数据


244
00:08:52,136 --> 00:08:53,786
之后 我们利用


245
00:08:53,786 --> 00:08:56,346
.decode 操作符将数据


246
00:08:56,346 --> 00:08:57,996
转换成用户定义的类型


247
00:08:59,366 --> 00:09:00,756
但由于各种原因


248
00:09:00,876 --> 00:09:03,926
解码可能失败


249
00:09:03,926 --> 00:09:05,086
我们就要在失败发生时


250
00:09:05,086 --> 00:09:06,576
将上游替换成占位符


251
00:09:06,736 --> 00:09:07,966
来解决问题


252
00:09:10,276 --> 00:09:13,496
但等一下 如果我们改用


253
00:09:13,496 --> 00:09:15,106
恢复性发布者的话


254
00:09:15,106 --> 00:09:15,696
我们就再也看不到


255
00:09:15,696 --> 00:09:16,606
另一个通知了


256
00:09:16,976 --> 00:09:18,416
我们终止了订阅


257
00:09:18,416 --> 00:09:20,916
我们真正想要的


258
00:09:20,916 --> 00:09:22,456
是能够尝试解码


259
00:09:22,456 --> 00:09:23,786
并在失败时使用占位符


260
00:09:23,946 --> 00:09:25,086
且同时与先前的上游


261
00:09:25,086 --> 00:09:26,236
保持联系


262
00:09:26,716 --> 00:09:29,586
自然 Combine 为此


263
00:09:29,586 --> 00:09:30,916
也提供了一个操作符


264
00:09:30,996 --> 00:09:32,046
它叫做 flatMap


265
00:09:33,836 --> 00:09:35,626
flatMap 和 map 原理很像


266
00:09:36,076 --> 00:09:36,666
名称也类似


267
00:09:37,696 --> 00:09:38,646
你从上游发布者


268
00:09:38,646 --> 00:09:40,226
获得值


269
00:09:40,226 --> 00:09:41,376
但同时预期为获得的值


270
00:09:41,376 --> 00:09:44,196
生成新的发布者


271
00:09:45,226 --> 00:09:46,356
flatMap 便可处理


272
00:09:46,356 --> 00:09:47,876
订阅这个嵌套


273
00:09:47,876 --> 00:09:49,866
发布者的细节


274
00:09:49,866 --> 00:09:50,896
并将值传递给下游


275
00:09:52,346 --> 00:09:53,366
我们先来看看它的工作原理


276
00:09:53,366 --> 00:09:55,926
之后再看代码


277
00:09:58,176 --> 00:09:59,656
和以前一样


278
00:09:59,656 --> 00:10:00,906
值从上游进入我们的


279
00:10:00,906 --> 00:10:01,936
flatMap 操作符


280
00:10:03,246 --> 00:10:04,856
值到达后 flatMap 会调用


281
00:10:04,856 --> 00:10:07,136
一个闭包 将值转换为


282
00:10:07,466 --> 00:10:09,416
一个新的发布者


283
00:10:09,416 --> 00:10:10,896
此时 这个新的发布者是


284
00:10:10,896 --> 00:10:14,886
一个 Just 一个 decode 以及一个 catch


285
00:10:15,176 --> 00:10:16,056
和之前相似


286
00:10:17,206 --> 00:10:18,946
flatMap 之后会订阅


287
00:10:18,946 --> 00:10:20,576
这个新发布者将


288
00:10:20,576 --> 00:10:21,906
结果值传到下游


289
00:10:25,046 --> 00:10:25,686
我想在这个 flatMap 中


290
00:10:25,686 --> 00:10:27,356
追溯另一个值


291
00:10:27,866 --> 00:10:31,116
但这次 请想象


292
00:10:31,116 --> 00:10:32,706
解码在运行中生成


293
00:10:32,706 --> 00:10:33,326
一个错误


294
00:10:33,906 --> 00:10:35,926
当失败抵达


295
00:10:35,926 --> 00:10:37,656
catch 时 它会被


296
00:10:37,656 --> 00:10:38,656
恢复性发布者取代


297
00:10:39,466 --> 00:10:41,086
这个发布者


298
00:10:41,086 --> 00:10:42,206
会被返回至 flatMap


299
00:10:43,276 --> 00:10:44,976
这就可以确保


300
00:10:44,976 --> 00:10:45,976
该操作永远不会失败


301
00:10:49,046 --> 00:10:50,116
现在我们来看看


302
00:10:50,116 --> 00:10:51,046
代码中该怎么用


303
00:10:51,426 --> 00:10:52,706
我们从先前停下的地方继续


304
00:10:53,566 --> 00:10:56,246
也就是我们处理


305
00:10:56,246 --> 00:10:57,186
流中第一个错误的地方


306
00:10:57,666 --> 00:10:59,506
但现在 我们来使用


307
00:10:59,506 --> 00:11:00,356
flatMap 操作符


308
00:11:00,476 --> 00:11:02,276
更改真的很容易


309
00:11:03,326 --> 00:11:04,766
和用 catch 一样


310
00:11:04,766 --> 00:11:06,296
我们用 Just 从收到的数据


311
00:11:06,296 --> 00:11:08,376
创建新的发布者


312
00:11:08,376 --> 00:11:09,356
这就是我们刚从


313
00:11:09,356 --> 00:11:10,476
map 操作符中解码的数据


314
00:11:11,176 --> 00:11:12,666
借助 flatMap 操作符的


315
00:11:12,666 --> 00:11:15,096
嵌套域 我们就可以


316
00:11:15,096 --> 00:11:16,596
依次 return .decode


317
00:11:16,596 --> 00:11:18,276
.catch 并将结果返回给 flatMap


318
00:11:18,276 --> 00:11:19,606
此时 flatMap 会


319
00:11:19,606 --> 00:11:21,666
订阅这个发布者


320
00:11:21,666 --> 00:11:24,106
产生的发布者就会是


321
00:11:24,106 --> 00:11:25,846
MagicTrick 的发布者


322
00:11:25,846 --> 00:11:30,256
且不会失败 我们处理完


323
00:11:30,256 --> 00:11:31,736
上游失败后


324
00:11:31,736 --> 00:11:33,086
需要继续完成


325
00:11:33,086 --> 00:11:34,846
既定目标 也就是尝试


326
00:11:34,846 --> 00:11:36,926
发布法术的名字


327
00:11:37,416 --> 00:11:40,266
有了 Combine 这非常简单


328
00:11:40,266 --> 00:11:42,146
使用另一个操作符


329
00:11:42,146 --> 00:11:43,376
publisher(for:) 操作符即可


330
00:11:44,136 --> 00:11:45,366
我们用它来进入


331
00:11:45,366 --> 00:11:46,686
MagicTrick


332
00:11:46,736 --> 00:11:48,976
通过一个类型安全的关键路径


333
00:11:48,976 --> 00:11:50,516
并生成一个新的发布者 本例中是


334
00:11:50,556 --> 00:11:51,706
发布者返回的类型为字符串


335
00:11:55,046 --> 00:11:56,636
现在 我想谈谈  


336
00:11:56,636 --> 00:11:58,166
最后一种操作符


337
00:11:58,256 --> 00:11:59,166
它能提供一些


338
00:11:59,166 --> 00:12:00,206
强大的功能


339
00:12:00,766 --> 00:12:03,476
我们称其为定时操作符


340
00:12:03,896 --> 00:12:05,106
就像在现实生活中


341
00:12:05,106 --> 00:12:06,576
给东西定时一样


342
00:12:06,576 --> 00:12:08,726
定时操作符可以描述


343
00:12:08,726 --> 00:12:10,766
特定事件何时何地传递


344
00:12:13,196 --> 00:12:14,326
这类操作符受到


345
00:12:14,326 --> 00:12:15,866
RunLoop 和 DispatchQueues 的


346
00:12:15,866 --> 00:12:18,016
原生支持 定时操作符的


347
00:12:18,016 --> 00:12:19,406
例子包括


348
00:12:20,466 --> 00:12:22,616
delay 操作符 可以将


349
00:12:22,616 --> 00:12:24,976
事件传递延后至未来时间


350
00:12:27,066 --> 00:12:28,066
还有 throttle 可以


351
00:12:28,066 --> 00:12:29,376
确保事件传递


352
00:12:29,376 --> 00:12:30,536
不超过某个


353
00:12:30,536 --> 00:12:31,496
特定速率


354
00:12:33,026 --> 00:12:34,186
其他操作符 包括


355
00:12:34,186 --> 00:12:35,676
receive(on:) 可以确保


356
00:12:35,676 --> 00:12:37,456
下游接收的事件


357
00:12:37,456 --> 00:12:38,216
可按照特定的


358
00:12:38,216 --> 00:12:39,686
线程或队列传递


359
00:12:39,686 --> 00:12:42,936
我们就来使用这个操作符


360
00:12:42,936 --> 00:12:44,506
确保法术的名字


361
00:12:44,506 --> 00:12:46,586
始终在主队列中传递


362
00:12:47,746 --> 00:12:48,986
可以看到输出


363
00:12:48,986 --> 00:12:50,636
和失败的类型没有变化


364
00:12:51,146 --> 00:12:52,116
这其实对定时操作符


365
00:12:52,116 --> 00:12:53,476
来说很常见


366
00:12:54,436 --> 00:12:55,836
我们再来研究一下


367
00:12:55,836 --> 00:12:56,616
发布者链剩下的代码


368
00:12:58,056 --> 00:12:59,686
我们之前说到 flatMap


369
00:13:01,356 --> 00:13:03,206
这里我们用 publisher(for:)


370
00:13:03,206 --> 00:13:04,726
深入 MagicTrick 内部


371
00:13:04,726 --> 00:13:06,426
提取法术的名称


372
00:13:07,796 --> 00:13:10,646
最后 我们把工作


373
00:13:10,646 --> 00:13:11,446
转移到主线程上 用的是


374
00:13:11,446 --> 00:13:13,376
receive(on:) 操作符


375
00:13:13,816 --> 00:13:14,806
如果我们使用的是


376
00:13:14,806 --> 00:13:16,156
AppKit 或 UIKit


377
00:13:16,156 --> 00:13:17,646
其中 UI 依据主线程上下文更新


378
00:13:17,646 --> 00:13:18,966
那现在就实现了


379
00:13:18,966 --> 00:13:21,306
发布的值已经处在


380
00:13:21,306 --> 00:13:22,546
正确的线程上了


381
00:13:24,036 --> 00:13:25,576
如你所见 我们现在


382
00:13:25,576 --> 00:13:26,626
已经能用发布者和


383
00:13:26,626 --> 00:13:28,236
其操作符做很多事情了


384
00:13:29,206 --> 00:13:30,446
我们在最初的


385
00:13:30,446 --> 00:13:32,546
方案上 不断添加操作符


386
00:13:32,546 --> 00:13:34,516
依次进行修改


387
00:13:34,626 --> 00:13:36,856
最终循序渐进 产生了强类型值


388
00:13:37,396 --> 00:13:39,736
我们看到发布者


389
00:13:39,736 --> 00:13:40,606
能同步产生值


390
00:13:40,606 --> 00:13:42,806
正如在 Just 的例子中


391
00:13:43,156 --> 00:13:45,226
同时 它还能异步运作 例如使用


392
00:13:45,226 --> 00:13:46,126
NotificationCenter


393
00:13:46,676 --> 00:13:48,936
但现在 我想关注


394
00:13:48,936 --> 00:13:49,856
值发布的


395
00:13:49,856 --> 00:13:50,846
另一面


396
00:13:51,336 --> 00:13:52,996
也就是值的接收


397
00:13:54,306 --> 00:13:55,836
现在我想谈谈订阅者


398
00:13:58,246 --> 00:13:59,306
和发布者一样


399
00:13:59,586 --> 00:14:01,166
Combine 中的订阅者有两个


400
00:14:01,166 --> 00:14:03,326
associatedtype 即它们的输入


401
00:14:04,106 --> 00:14:05,836
和它们容许的失败


402
00:14:07,576 --> 00:14:09,416
它们也描述了三个


403
00:14:09,416 --> 00:14:10,596
事件函数 分别对应


404
00:14:10,596 --> 00:14:13,606
接收订阅 接收值 以及结束


405
00:14:14,176 --> 00:14:16,516
这三个函数调用的


406
00:14:16,516 --> 00:14:18,186
顺序经过严格定义


407
00:14:18,416 --> 00:14:19,486
总结起来 遵循


408
00:14:19,576 --> 00:14:20,416
三条规则


409
00:14:20,906 --> 00:14:24,426
规则一 回应


410
00:14:24,426 --> 00:14:26,246
订阅调用时 发布者


411
00:14:26,246 --> 00:14:28,476
只会调用一次 receive(subscription:)


412
00:14:28,566 --> 00:14:29,696
不多不少


413
00:14:33,066 --> 00:14:36,216
规则二 发布者之后


414
00:14:36,216 --> 00:14:38,246
可以提供零个或更多值


415
00:14:38,246 --> 00:14:39,786
传递给下游的订阅者


416
00:14:39,786 --> 00:14:41,766
以回应订阅者的请求


417
00:14:44,346 --> 00:14:46,196
规则三 发布者


418
00:14:46,196 --> 00:14:47,596
至多只能发送一个结束信号


419
00:14:47,596 --> 00:14:49,356
这个结束


420
00:14:49,356 --> 00:14:50,566
可以表明发布者


421
00:14:50,566 --> 00:14:52,946
已经完成 或者


422
00:14:52,946 --> 00:14:53,526
发生了失败


423
00:14:54,476 --> 00:14:55,646
这个结束信号一旦发出


424
00:14:55,646 --> 00:14:58,826
便不会有其他值被传出


425
00:14:59,406 --> 00:15:01,406
这三条规则可以


426
00:15:01,406 --> 00:15:02,656
归纳如下


427
00:15:03,176 --> 00:15:05,806
订阅者只会收到


428
00:15:05,806 --> 00:15:08,956
一个订阅 之后是


429
00:15:09,116 --> 00:15:11,606
零个或多个值


430
00:15:11,606 --> 00:15:12,616
可能由一个结束终止


431
00:15:12,616 --> 00:15:16,146
表明发布完成或失败


432
00:15:17,306 --> 00:15:19,086
我之所以说 可能


433
00:15:19,086 --> 00:15:20,276
是因为结束是可选的


434
00:15:20,866 --> 00:15:22,366
许多特定流理论上


435
00:15:22,366 --> 00:15:23,576
可以无限进行


436
00:15:23,576 --> 00:15:25,346
例如先前的 NotificationCenter 示例


437
00:15:28,356 --> 00:15:30,476
Combine 中 我们支持


438
00:15:30,476 --> 00:15:31,856
各种各样的订阅者


439
00:15:32,176 --> 00:15:33,856
我想向大家展示一下它们如何工作


440
00:15:36,516 --> 00:15:37,596
我们回到之前的发布者示例


441
00:15:37,596 --> 00:15:40,046
但我们现在


442
00:15:40,046 --> 00:15:42,006
想要了解的是


443
00:15:42,006 --> 00:15:43,486
我们正在使用的发布者


444
00:15:44,096 --> 00:15:45,316
我们就先腾出点儿地方来


445
00:15:47,316 --> 00:15:48,676
然后添加一个订阅者


446
00:15:50,206 --> 00:15:52,336
这里 我添加了 Combine 中最简单的订阅类型


447
00:15:52,336 --> 00:15:55,376
关键路径赋值


448
00:15:56,216 --> 00:15:58,406
使用的是 assign(to: on:)这个操作符


449
00:15:58,826 --> 00:16:00,766
它可以确保


450
00:16:00,766 --> 00:16:02,226
上游发布者释放的


451
00:16:02,226 --> 00:16:03,466
任何值都会赋值给


452
00:16:03,466 --> 00:16:04,846
特定关键路径


453
00:16:04,846 --> 00:16:05,876
下的特定对象


454
00:16:06,316 --> 00:16:08,266
而就是从现在起


455
00:16:08,266 --> 00:16:09,636
我们几乎可以随意


456
00:16:09,636 --> 00:16:10,716
使用任何发布者并为


457
00:16:10,716 --> 00:16:11,886
任何属性赋值


458
00:16:11,926 --> 00:16:12,656
功能非常强大


459
00:16:13,106 --> 00:16:15,886
这个操作符还会产生一个


460
00:16:15,886 --> 00:16:17,386
取消令牌


461
00:16:17,386 --> 00:16:18,656
你可以之后调用它


462
00:16:18,656 --> 00:16:19,256
从而终止订阅


463
00:16:19,256 --> 00:16:23,356
我想多谈谈取消


464
00:16:23,856 --> 00:16:26,386
我们在 Combine 中


465
00:16:26,386 --> 00:16:28,196
构建了取消


466
00:16:28,196 --> 00:16:29,836
因为它便于在发布者


467
00:16:29,836 --> 00:16:31,666
结束传递事件之前


468
00:16:31,666 --> 00:16:34,096
终止订阅


469
00:16:35,156 --> 00:16:36,336
如果你想释放


470
00:16:36,336 --> 00:16:37,366
与此订阅相关的资源


471
00:16:37,366 --> 00:16:38,816
这一点尤其有用


472
00:16:39,996 --> 00:16:41,796
当然 取消是一种


473
00:16:41,796 --> 00:16:43,646
尽力服务


474
00:16:43,646 --> 00:16:44,686
但它可以满足你的需求


475
00:16:44,686 --> 00:16:45,976
为订阅者取消订阅


476
00:16:48,236 --> 00:16:49,546
我们引入了新协议


477
00:16:49,546 --> 00:16:50,566
用以描述


478
00:16:50,566 --> 00:16:52,546
可以取消或被取消的事物


479
00:16:53,326 --> 00:16:55,306
我们引入了


480
00:16:55,306 --> 00:16:56,926
一个极为便利的类


481
00:16:57,086 --> 00:16:58,866
叫做 AnyCancellable


482
00:16:58,866 --> 00:17:00,146
它带来的好处是


483
00:17:00,356 --> 00:17:01,476
它可以自动


484
00:17:01,476 --> 00:17:02,706
在清理阶段时调用 cancel


485
00:17:04,036 --> 00:17:05,465
这可以显著减少


486
00:17:05,465 --> 00:17:06,376
你需要专门调用


487
00:17:06,376 --> 00:17:08,246
cancel 的次数


488
00:17:09,056 --> 00:17:10,586
你只需要依靠 Swift


489
00:17:10,586 --> 00:17:12,136
提供的强大


490
00:17:12,136 --> 00:17:13,646
内存管理能力即可


491
00:17:15,296 --> 00:17:16,846
我们接下来看看


492
00:17:16,846 --> 00:17:18,336
第二种订阅形式


493
00:17:18,846 --> 00:17:21,366
这里用到了 sink 操作符


494
00:17:21,796 --> 00:17:23,445
这种方法很棒


495
00:17:23,445 --> 00:17:24,906
你只要提供一个闭包


496
00:17:24,906 --> 00:17:26,236
对收到的任何值


497
00:17:26,236 --> 00:17:27,316
这个闭包都会被调用


498
00:17:27,316 --> 00:17:28,465
你就可以对它进行


499
00:17:28,465 --> 00:17:30,476
你想要的任何额外修改


500
00:17:31,236 --> 00:17:34,366
和 assign 一样 sink 会返回


501
00:17:34,436 --> 00:17:36,476
一个 canceller


502
00:17:36,476 --> 00:17:37,856
之后你可以用它来终止订阅


503
00:17:41,046 --> 00:17:42,076
第三种订阅方式是


504
00:17:42,116 --> 00:17:43,276
两者的结合


505
00:17:43,956 --> 00:17:45,996
我们称它们为主题


506
00:17:45,996 --> 00:17:46,826
它们的行为既有点像


507
00:17:46,826 --> 00:17:48,756
发布者也有点儿像订阅者


508
00:17:50,096 --> 00:17:50,966
它们一般支持


509
00:17:50,966 --> 00:17:52,466
将收到的值发送给多个目标


510
00:17:52,466 --> 00:17:54,326
格外重要的是


511
00:17:54,326 --> 00:17:56,316
你可以用它们


512
00:17:56,316 --> 00:17:57,406
命令式的发送值


513
00:17:57,776 --> 00:17:59,156
这一点极其重要


514
00:17:59,156 --> 00:18:00,596
特别是当你在已有的


515
00:18:00,596 --> 00:18:01,926
代码基础上工作的时候


516
00:18:03,396 --> 00:18:04,356
我们来看看它们是


517
00:18:04,356 --> 00:18:06,556
如何工作的 之后再展示


518
00:18:06,556 --> 00:18:07,416
如何在实践中运用


519
00:18:07,936 --> 00:18:10,536
我之前提到 使用主题


520
00:18:10,706 --> 00:18:12,276
便可以向多个


521
00:18:12,276 --> 00:18:13,326
下游订阅者广播


522
00:18:13,326 --> 00:18:15,686
也可以


523
00:18:15,906 --> 00:18:17,196
命令式发送值


524
00:18:18,276 --> 00:18:20,196
任何收到的值都会


525
00:18:20,196 --> 00:18:21,976
广播给所有下游订阅者


526
00:18:24,156 --> 00:18:25,916
如果值都是由上游


527
00:18:25,916 --> 00:18:26,976
发布者产生的 也会如此广播


528
00:18:30,046 --> 00:18:31,616
Combine 中 我们支持两种主题


529
00:18:31,916 --> 00:18:34,046
一种是 Passthrough


530
00:18:34,046 --> 00:18:36,156
其中不存储值


531
00:18:36,466 --> 00:18:37,716
只有你订阅这个主题的时候


532
00:18:37,716 --> 00:18:38,976
你才能看到值


533
00:18:41,616 --> 00:18:43,716
我们还支持 CurrentValue 主题


534
00:18:44,526 --> 00:18:46,016
它保留了收到的


535
00:18:46,016 --> 00:18:47,186
最后一个值的历史记录


536
00:18:47,766 --> 00:18:49,056
这样新的订阅者


537
00:18:49,056 --> 00:18:50,906
就能很好的交接


538
00:18:53,066 --> 00:18:54,306
现在 来看看它们在实际操作中的样子


539
00:18:54,306 --> 00:18:55,706
和之前一样 我们先来看发布者


540
00:18:57,256 --> 00:18:58,986
创建主题非常简单


541
00:18:58,986 --> 00:19:00,326
只需选取你需要的主题


542
00:19:00,606 --> 00:19:01,826
指明输出和


543
00:19:01,826 --> 00:19:03,956
失败类型并调用构造函数


544
00:19:08,336 --> 00:19:09,916
主题的行为和订阅者类似


545
00:19:10,126 --> 00:19:11,416
因为它们都要订阅


546
00:19:11,416 --> 00:19:12,346
上游发布者


547
00:19:12,926 --> 00:19:15,906
同时 它也类似发布者


548
00:19:15,906 --> 00:19:17,126
需要调用我今天


549
00:19:17,126 --> 00:19:18,356
提到过的操作符


550
00:19:18,576 --> 00:19:20,276
比如 sink 等


551
00:19:20,276 --> 00:19:22,076
来形成订阅自己的订阅者


552
00:19:22,596 --> 00:19:24,876
你甚至还可以命令式的发送值


553
00:19:24,876 --> 00:19:26,896
比如这个有魔力的词语


554
00:19:28,516 --> 00:19:30,586
事实上 主题非常常用


555
00:19:30,586 --> 00:19:32,016
我们甚至定义了


556
00:19:32,016 --> 00:19:33,456
操作符 来向流中


557
00:19:33,456 --> 00:19:35,176
注入主题 例如 Share


558
00:19:35,516 --> 00:19:36,636
它可以将 Passthrough 主题


559
00:19:36,636 --> 00:19:39,666
注入流中


560
00:19:39,856 --> 00:19:41,256
主题的功能非常非常强大


561
00:19:41,256 --> 00:19:43,796
你会发现很多


562
00:19:43,796 --> 00:19:44,776
有趣的使用方法


563
00:19:44,776 --> 00:19:46,846
接下来 我想


564
00:19:46,846 --> 00:19:47,876
换个话题 谈谈


565
00:19:47,876 --> 00:19:49,236
第四种 也是最后一种订阅者


566
00:19:49,236 --> 00:19:53,396
就是与 SwiftUI 集成


567
00:19:55,156 --> 00:19:56,876
SwiftUI 了不起的一点


568
00:19:56,876 --> 00:19:58,656
就是你只需要


569
00:19:58,656 --> 00:20:00,526
在 App 中


570
00:20:00,526 --> 00:20:01,656
描述依赖


571
00:20:01,656 --> 00:20:03,226
剩下的就可交给框架代劳


572
00:20:04,526 --> 00:20:05,866
就 Combine 而言


573
00:20:06,146 --> 00:20:07,266
这意味着你只需要


574
00:20:07,266 --> 00:20:08,786
提供发布者


575
00:20:08,786 --> 00:20:11,526
描述数据何时改变 如何改变


576
00:20:13,056 --> 00:20:15,306
为此 你只需要


577
00:20:15,306 --> 00:20:16,626
让自定义类型遵从


578
00:20:16,626 --> 00:20:18,016
BindableObject 协议


579
00:20:19,406 --> 00:20:21,176
SwiftUI 中的 BindableObjects


580
00:20:21,176 --> 00:20:22,286
只有一个 associatedtype


581
00:20:22,976 --> 00:20:26,596
这个发布者


582
00:20:26,596 --> 00:20:27,926
限制为永远不失败


583
00:20:27,926 --> 00:20:29,566
这可以与 UI 框架


584
00:20:29,566 --> 00:20:31,436
配合得天衣无缝


585
00:20:31,466 --> 00:20:32,786
因为这种语言的


586
00:20:32,786 --> 00:20:34,076
类型系统强制要求你


587
00:20:34,076 --> 00:20:35,826
先处理上游错误


588
00:20:35,986 --> 00:20:37,766
再接触发布者


589
00:20:40,096 --> 00:20:41,456
最后 你指定


590
00:20:41,456 --> 00:20:43,156
一个名为


591
00:20:43,446 --> 00:20:45,026
didChange 的属性


592
00:20:45,026 --> 00:20:46,536
产生实际发布者来通知你


593
00:20:46,536 --> 00:20:48,226
你的类型何时改变


594
00:20:48,226 --> 00:20:49,196
就这样


595
00:20:50,476 --> 00:20:52,096
要想进一步了解 SwiftUI 中


596
00:20:52,176 --> 00:20:53,736
数据流的工作原理 我强烈建议


597
00:20:53,736 --> 00:20:54,876
大家观看 Data Flow Through SwiftUI 会议


598
00:20:54,876 --> 00:20:56,606
我们在其中


599
00:20:56,606 --> 00:20:57,816
深入探讨了许多


600
00:20:57,816 --> 00:20:59,416
可以实现的细节


601
00:21:00,386 --> 00:21:02,176
但为了让大家体验一下


602
00:21:02,176 --> 00:21:03,676
我来向大家展示它的实际表现


603
00:21:05,166 --> 00:21:06,426
首先 我们从


604
00:21:06,426 --> 00:21:08,146
巫师学校 App 中的


605
00:21:08,146 --> 00:21:09,216
现有模型开始


606
00:21:09,866 --> 00:21:12,176
之后 我们添加


607
00:21:12,176 --> 00:21:12,986
遵循 BindableObject


608
00:21:13,326 --> 00:21:14,326
现在 我们用


609
00:21:14,326 --> 00:21:15,676
主题来描述我们的


610
00:21:15,676 --> 00:21:17,066
模型对象如何改变


611
00:21:18,146 --> 00:21:19,006
我们真的不需要


612
00:21:19,006 --> 00:21:20,656
主题传递任何


613
00:21:20,656 --> 00:21:23,806
特定种类的值


614
00:21:23,806 --> 00:21:25,146
因为这个框架可以根据我们


615
00:21:25,146 --> 00:21:26,266
对主体方法的调用


616
00:21:26,266 --> 00:21:26,586
自行处理


617
00:21:26,586 --> 00:21:27,936
我们就选 void 作为


618
00:21:27,936 --> 00:21:29,506
主题输出的类型


619
00:21:32,296 --> 00:21:33,666
像这样使用主题


620
00:21:33,666 --> 00:21:35,636
十分灵活 因为现在


621
00:21:35,636 --> 00:21:36,716
我们可以在对象变化时


622
00:21:36,716 --> 00:21:38,976
命令式发送信息


623
00:21:41,256 --> 00:21:43,546
但现在 我们就先使用一些


624
00:21:43,546 --> 00:21:45,346
属性观察器


625
00:21:45,346 --> 00:21:47,326
直接在主题中调用 send


626
00:21:47,326 --> 00:21:48,796
当任一属性变化时


627
00:21:48,796 --> 00:21:49,966
表明我们的


628
00:21:49,966 --> 00:21:51,226
模型对象也变化了


629
00:21:51,646 --> 00:21:54,616
接下来 我们要将这个模型


630
00:21:54,616 --> 00:21:57,326
与 SwiftUI 视图挂钩


631
00:21:57,326 --> 00:22:00,486
操作如下 我们声明一个


632
00:22:00,486 --> 00:22:02,036
ObjectBinding 类型的模型 这样


633
00:22:02,036 --> 00:22:03,346
SwiftUI 就能自动


634
00:22:03,346 --> 00:22:05,206
发现并订阅我们的发布者


635
00:22:05,936 --> 00:22:10,336
之后 我们在 body 属性引用


636
00:22:10,336 --> 00:22:12,796
模型的属性 就这样


637
00:22:13,886 --> 00:22:15,346
SwiftUI 会自动


638
00:22:15,346 --> 00:22:17,166
在你表明模型发生变化时


639
00:22:17,166 --> 00:22:18,686
生成新的主体


640
00:22:22,046 --> 00:22:22,876
我想大家展示了 Combine


641
00:22:22,876 --> 00:22:24,036
有非常多的内置


642
00:22:24,036 --> 00:22:25,186
功能 大家可以


643
00:22:25,186 --> 00:22:26,696
自己组织 合成许多


644
00:22:26,696 --> 00:22:27,436
强大的功能


645
00:22:28,536 --> 00:22:30,146
我们非常兴奋 


646
00:22:30,246 --> 00:22:31,576
因为有了新框架


647
00:22:31,576 --> 00:22:32,686
你就能够大幅


648
00:22:32,686 --> 00:22:34,376
简化异步数据流


649
00:22:34,916 --> 00:22:36,876
要展示这一点


650
00:22:36,876 --> 00:22:37,946
我的同事 Ben 会上台


651
00:22:37,946 --> 00:22:38,826
告诉大家 如何


652
00:22:38,826 --> 00:22:40,226
进一步将这些


653
00:22:40,226 --> 00:22:41,546
强大功能整合进


654
00:22:41,546 --> 00:22:43,686
你现有的 App 中 谢谢大家


655
00:22:44,516 --> 00:22:50,316
[掌声]


656
00:22:50,816 --> 00:22:51,346
>> 谢谢 Michael


657
00:22:51,456 --> 00:22:52,806
我很高兴今天在这里


658
00:22:52,806 --> 00:22:53,976
见到大家


659
00:22:56,066 --> 00:22:57,646
设计 Combine 时


660
00:22:57,646 --> 00:22:58,746
我们高度重视构成


661
00:22:59,166 --> 00:23:00,126
如大家在 Michael 的


662
00:23:00,126 --> 00:23:02,696
示例中所见 我们从一个


663
00:23:02,696 --> 00:23:04,646
简单的发布者开始 经过


664
00:23:04,646 --> 00:23:05,776
各种转换后


665
00:23:06,206 --> 00:23:08,736
创造了最终的发布者实现了目标


666
00:23:08,736 --> 00:23:12,346
我们来看个例子


667
00:23:12,956 --> 00:23:14,936
我们要在


668
00:23:14,936 --> 00:23:16,326
App 中提供注册功能


669
00:23:16,326 --> 00:23:17,856
这样 巫师就能在我们的


670
00:23:17,856 --> 00:23:18,446
巫师学校注册了


671
00:23:18,446 --> 00:23:20,676
我们有一些要求


672
00:23:22,116 --> 00:23:23,236
首先 我们要保证


673
00:23:23,236 --> 00:23:25,266
用户名通过服务器验证


674
00:23:25,766 --> 00:23:30,076
第二 我们有密码字段


675
00:23:30,146 --> 00:23:31,636
和密码验证


676
00:23:31,676 --> 00:23:33,136
我们要保证二者相同


677
00:23:33,936 --> 00:23:34,976
且长度都大于八个字符


678
00:23:37,046 --> 00:23:38,176
最后 我们要保证


679
00:23:38,176 --> 00:23:39,836
如果这些条件


680
00:23:39,836 --> 00:23:41,926
都满足 我们就能启用或禁用 UI


681
00:23:43,306 --> 00:23:44,966
所以 这个例子中 我们有


682
00:23:44,966 --> 00:23:46,636
异步行为


683
00:23:46,636 --> 00:23:48,076
有一些设备本地的


684
00:23:48,076 --> 00:23:49,646
同步行为 我们


685
00:23:49,646 --> 00:23:50,506
还要能够把它们


686
00:23:50,506 --> 00:23:51,016
组合起来


687
00:23:51,016 --> 00:23:52,616
我们来看看 Combine 能


688
00:23:52,616 --> 00:23:53,806
提供什么帮助


689
00:23:56,106 --> 00:23:58,156
首先 我要用 Interface


690
00:23:58,156 --> 00:23:59,606
Builder 为密码字段


691
00:23:59,606 --> 00:24:00,996
在值变化属性上


692
00:24:00,996 --> 00:24:02,466
创建目标动作


693
00:24:05,046 --> 00:24:06,246
在代码中使用后


694
00:24:07,126 --> 00:24:08,536
只要用户在这些字段中输入


695
00:24:08,536 --> 00:24:10,146
我们就能收到信号


696
00:24:10,676 --> 00:24:12,076
我们会获取当前值的


697
00:24:12,076 --> 00:24:14,116
文本属性


698
00:24:14,116 --> 00:24:15,836
并将其存入实例变量


699
00:24:16,876 --> 00:24:18,456
但我们想把它们


700
00:24:18,456 --> 00:24:19,816
和其他行为组合


701
00:24:19,816 --> 00:24:20,676
特别是我们先前


702
00:24:20,676 --> 00:24:23,376
提到的同步行为该怎么做


703
00:24:24,676 --> 00:24:27,776
很简单 只要将 Published


704
00:24:27,776 --> 00:24:29,266
添加至每个属性 我们就能


705
00:24:29,266 --> 00:24:30,946
对他们添加发布者


706
00:24:34,066 --> 00:24:35,536
Published 是一个属性包装器


707
00:24:35,536 --> 00:24:37,206
它使用 Swift 5.1


708
00:24:37,206 --> 00:24:39,706
中的新特性 将发布者添加到


709
00:24:39,706 --> 00:24:40,546
任何给定属性


710
00:24:42,106 --> 00:24:43,376
我们通过几个简单例子


711
00:24:43,376 --> 00:24:44,516
来看看如何使用它


712
00:24:47,216 --> 00:24:48,946
Published 属性包装器


713
00:24:48,946 --> 00:24:50,546
按你的需求


714
00:24:50,546 --> 00:24:51,936
添加在属性前


715
00:24:53,326 --> 00:24:54,926
在代码中使用时


716
00:24:54,926 --> 00:24:55,966
就和以前一样


717
00:24:56,556 --> 00:25:00,056
我们也可以储存它


718
00:25:00,056 --> 00:25:00,886
得到字符串值


719
00:25:00,886 --> 00:25:02,196
这个例子中 currentPassword


720
00:25:02,196 --> 00:25:03,976
现在是字符串 1234


721
00:25:06,166 --> 00:25:07,486
它的特殊之处在于


722
00:25:07,486 --> 00:25:08,776
我们要用 $


723
00:25:08,776 --> 00:25:09,426
作前缀引用它


724
00:25:09,786 --> 00:25:11,096
这样 我们就在访问


725
00:25:11,096 --> 00:25:11,916
被包装的值


726
00:25:12,616 --> 00:25:14,966
我们之后就能使用


727
00:25:14,966 --> 00:25:16,426
平常对发布者


728
00:25:16,426 --> 00:25:18,186
使用的操作符或订阅它


729
00:25:18,186 --> 00:25:20,216
此时要用 sink


730
00:25:20,216 --> 00:25:23,756
之后 如果我们要


731
00:25:23,756 --> 00:25:25,826
再将属性设定成另一个


732
00:25:25,826 --> 00:25:27,436
伟大的密码 password


733
00:25:28,136 --> 00:25:30,726
我们的订阅者就会在变化时收到值


734
00:25:31,626 --> 00:25:32,796
显然 这个人没有


735
00:25:32,796 --> 00:25:33,966
关注密码安全


736
00:25:37,196 --> 00:25:38,366
我们谈到 要对


737
00:25:38,366 --> 00:25:40,436
我们的两个发布者


738
00:25:40,436 --> 00:25:41,776
同时进行判断


739
00:25:44,086 --> 00:25:45,506
我们为它们添加了


740
00:25:45,586 --> 00:25:46,866
Published 属性 并添加了


741
00:25:46,866 --> 00:25:47,946
两个发布者也就是


742
00:25:47,946 --> 00:25:49,186
被发布的字符串 不会失败


743
00:25:49,906 --> 00:25:52,506
我们想要的结果是


744
00:25:52,506 --> 00:25:54,216
只发布一个


745
00:25:54,216 --> 00:25:56,306
验证过的密码


746
00:25:58,116 --> 00:25:59,726
我们为此有一个操作符


747
00:25:59,726 --> 00:26:01,496
叫做 CombineLatest


748
00:26:05,046 --> 00:26:06,106
这里是我们之前


749
00:26:06,386 --> 00:26:07,446
提到的两个属性


750
00:26:08,096 --> 00:26:09,766
借助 CombineLatest 我们就能


751
00:26:09,766 --> 00:26:11,366
引用带美元符号


752
00:26:11,456 --> 00:26:13,486
前缀的属性包装器


753
00:26:14,176 --> 00:26:16,096
之后 当任何一个改变时


754
00:26:16,166 --> 00:26:17,476
我们就能收到信号


755
00:26:17,856 --> 00:26:19,176
比方说 如果用户


756
00:26:19,176 --> 00:26:21,066
已经在密码字段输入了


757
00:26:21,136 --> 00:26:22,486
现在开始在


758
00:26:22,486 --> 00:26:24,166
密码确认字段中输入内容


759
00:26:24,686 --> 00:26:25,976
PasswordAgain 就会改变


760
00:26:25,976 --> 00:26:27,016
而 Password 仍是


761
00:26:27,016 --> 00:26:29,166
原先输入第一个字段的值


762
00:26:29,656 --> 00:26:32,156
之后 我们就能用闭包


763
00:26:32,156 --> 00:26:33,636
确保我们符合


764
00:26:33,636 --> 00:26:34,716
行业要求 也就是


765
00:26:34,716 --> 00:26:36,246
二者要相同 且长度


766
00:26:36,246 --> 00:26:38,856
都大于八个字符


767
00:26:38,896 --> 00:26:40,496
否则 我们就返回 nil


768
00:26:40,496 --> 00:26:41,496
因为我们要将


769
00:26:41,496 --> 00:26:42,676
这个信号与其他信号


770
00:26:42,676 --> 00:26:43,886
共同使用 判断我们的


771
00:26:43,886 --> 00:26:44,816
表单是否有效


772
00:26:45,616 --> 00:26:47,636
为此 我们将 nil 作为我们的信号


773
00:26:50,206 --> 00:26:52,596
所以 和类型一样


774
00:26:52,716 --> 00:26:54,946
类型反映了我们采取的措施


775
00:26:55,716 --> 00:26:56,726
我们可以直接在


776
00:26:56,726 --> 00:26:57,726
代码中读出


777
00:26:58,226 --> 00:27:00,106
我们有两个 Pulished 的字符串


778
00:27:00,616 --> 00:27:02,116
我们组合了它们最新的值


779
00:27:02,376 --> 00:27:04,276
最后获得了可选字符串


780
00:27:07,076 --> 00:27:08,216
但如果我们的要求是


781
00:27:08,216 --> 00:27:09,146
想要确保


782
00:27:09,146 --> 00:27:10,046
人们不去用那些糟糕的密码


783
00:27:10,046 --> 00:27:12,206
并添加一个 Map 呢


784
00:27:13,256 --> 00:27:14,586
可以看到 类型在这里发生了变化


785
00:27:15,206 --> 00:27:16,846
可以看出 我们组合了


786
00:27:16,846 --> 00:27:18,156
两个 Published 字符串的


787
00:27:18,156 --> 00:27:20,076
最新值


788
00:27:20,076 --> 00:27:21,536
用 map 处理 得到可选字符串


789
00:27:23,006 --> 00:27:24,596
这很棒 可以在


790
00:27:24,596 --> 00:27:25,896
几乎所有用例中


791
00:27:25,896 --> 00:27:26,676
帮助调试


792
00:27:27,076 --> 00:27:28,406
但这个例子中 我们就


793
00:27:28,516 --> 00:27:29,706
把它作为 API 边界


794
00:27:29,826 --> 00:27:31,256
希望将它


795
00:27:31,256 --> 00:27:32,106
与其他发布者组合


796
00:27:32,106 --> 00:27:33,996
所以 如果我们


797
00:27:33,996 --> 00:27:35,626
能只关注重点的话 岂不美哉


798
00:27:35,626 --> 00:27:37,236
这里的重点是 这是一个


799
00:27:37,236 --> 00:27:39,126
可选字符串发布者不会失败


800
00:27:40,576 --> 00:27:43,416
为此 我们有一个操作符


801
00:27:43,416 --> 00:27:45,466
叫做 eraseToAnyPublisher


802
00:27:45,466 --> 00:27:47,226
可以返回可选字符串或 never 的


803
00:27:47,226 --> 00:27:48,856
AnyPublisher


804
00:27:49,346 --> 00:27:51,556
可以看到 类型


805
00:27:51,556 --> 00:27:53,016
并没有变化 但


806
00:27:53,016 --> 00:27:54,366
我们确实可以把它


807
00:27:54,366 --> 00:27:55,706
当作我们想要的 API


808
00:27:55,836 --> 00:27:57,306
边界推广 还能顺便


809
00:27:57,306 --> 00:27:58,856
隐藏所有的实现细节


810
00:28:01,056 --> 00:28:02,246
来回顾一下我们


811
00:28:02,246 --> 00:28:04,376
都做了什么 我们的


812
00:28:04,376 --> 00:28:05,816
初始属性是字符串


813
00:28:05,816 --> 00:28:07,386
为它添加了字符串发布者


814
00:28:07,676 --> 00:28:09,506
其中使用了 Published 属性包装器


815
00:28:10,056 --> 00:28:12,486
我们之后使用了 CombineLatest


816
00:28:12,486 --> 00:28:13,606
组合了这两个发布者的


817
00:28:13,606 --> 00:28:15,986
的最新值 并添加了


818
00:28:15,986 --> 00:28:16,926
我们的业务逻辑


819
00:28:17,436 --> 00:28:21,376
之后我们使用 map 来过滤


820
00:28:21,376 --> 00:28:24,696
糟糕的密码 最后


821
00:28:24,696 --> 00:28:26,046
我们用了 eraseToAnyPublishser


822
00:28:26,166 --> 00:28:27,566
因为这是 API 边界


823
00:28:27,566 --> 00:28:28,976
我们要将它和别的东西组合起来


824
00:28:32,276 --> 00:28:33,756
真了不起 我们有了第一个发布者


825
00:28:38,046 --> 00:28:40,716
接下来 我们还想


826
00:28:40,716 --> 00:28:42,146
为一些异步活动


827
00:28:42,146 --> 00:28:43,056
构建模型


828
00:28:43,626 --> 00:28:45,606
我们要保证用户名通过


829
00:28:45,606 --> 00:28:46,926
服务器验证 这需要


830
00:28:46,926 --> 00:28:48,546
快速处理用户输入


831
00:28:49,176 --> 00:28:51,706
和之前一样 我们给


832
00:28:52,296 --> 00:28:54,096
字符串属性存储添加 Pulished 属性


833
00:28:54,356 --> 00:28:55,706
再给 valueChanged


834
00:28:55,706 --> 00:28:58,336
属性挂上一个目标动作


835
00:28:58,796 --> 00:28:59,726
但这里有点特殊


836
00:28:59,726 --> 00:29:01,846
因为我们不想


837
00:29:01,846 --> 00:29:02,906
用户每输入


838
00:29:02,906 --> 00:29:04,296
一个字符 就


839
00:29:04,296 --> 00:29:05,576
发起一次网络运行


840
00:29:05,976 --> 00:29:07,276
不然 服务器会被挤爆的


841
00:29:07,276 --> 00:29:08,986
我们要让信号


842
00:29:08,986 --> 00:29:10,706
发送更顺畅


843
00:29:11,516 --> 00:29:13,066
为此 我们有函数防抖


844
00:29:13,826 --> 00:29:16,326
你可以用函数防抖


845
00:29:16,326 --> 00:29:17,786
制定你想接收值的窗口


846
00:29:17,786 --> 00:29:19,056
且接收值


847
00:29:19,056 --> 00:29:20,926
不早于这个窗口


848
00:29:20,926 --> 00:29:23,126
我们来看个实例


849
00:29:24,486 --> 00:29:25,986
这是我们的上游发布者


850
00:29:26,536 --> 00:29:27,496
这个例子中 这是一个


851
00:29:27,496 --> 00:29:29,596
文本字段 中间


852
00:29:29,596 --> 00:29:30,526
是函数防抖


853
00:29:30,856 --> 00:29:32,396
如果用户打字很快


854
00:29:33,436 --> 00:29:34,646
你就会看到 信号发送很快


855
00:29:35,566 --> 00:29:36,616
但我们可以使信号发送平滑


856
00:29:36,616 --> 00:29:38,136
在窗口中只传递一个信号


857
00:29:41,096 --> 00:29:42,456
这很好 但我们还能


858
00:29:42,456 --> 00:29:43,416
做得更好


859
00:29:45,026 --> 00:29:46,286
如果用户在窗口中打字


860
00:29:46,286 --> 00:29:48,516
而值最终


861
00:29:48,516 --> 00:29:49,576
一直都是相同的


862
00:29:49,576 --> 00:29:50,606
就没有理由再


863
00:29:50,606 --> 00:29:51,546
呼叫服务器


864
00:29:51,546 --> 00:29:53,116
看用户名是否有效


865
00:29:53,116 --> 00:29:55,786
所以 如果用户输入 Merlin


866
00:29:55,786 --> 00:29:58,806
我们会获取值 如果删除最后的 n


867
00:29:58,806 --> 00:30:00,726
再输入 n 就又成了 Merlin


868
00:30:00,726 --> 00:30:01,626
但我们也不用再次


869
00:30:01,626 --> 00:30:02,206
呼叫服务器


870
00:30:02,836 --> 00:30:04,276
removeDuplicates 操作符就是


871
00:30:04,276 --> 00:30:04,536
实现这个的


872
00:30:05,206 --> 00:30:06,356
它可以确保我们不用


873
00:30:06,356 --> 00:30:07,746
在窗口内一遍


874
00:30:07,746 --> 00:30:11,296
又一遍地发布同一个值


875
00:30:11,426 --> 00:30:12,986
再来看代码 我们给


876
00:30:12,986 --> 00:30:14,656
用户名属性添加了


877
00:30:14,656 --> 00:30:15,236
Published


878
00:30:15,816 --> 00:30:18,126
之后我们使用函数防抖


879
00:30:18,126 --> 00:30:19,206
消除信号传输抖动


880
00:30:20,546 --> 00:30:22,176
最后 我们移除了重复项


881
00:30:22,706 --> 00:30:25,506
但我们还没有处理完


882
00:30:25,506 --> 00:30:26,586
异步操作


883
00:30:26,586 --> 00:30:27,756
我们刚刚平滑了信号


884
00:30:28,656 --> 00:30:29,646
我们真正想要的是


885
00:30:29,646 --> 00:30:30,586
查询服务器 看看


886
00:30:30,586 --> 00:30:31,566
用户名是否有效


887
00:30:32,136 --> 00:30:34,546
我们的 App 中


888
00:30:34,546 --> 00:30:35,786
已经有了一个函数


889
00:30:35,886 --> 00:30:37,026
叫做 usernameAvailable


890
00:30:38,106 --> 00:30:39,726
接下来 我要将它作为


891
00:30:39,726 --> 00:30:40,916
发布者引入


892
00:30:42,346 --> 00:30:44,226
从 Michael 的例子中 我们


893
00:30:44,226 --> 00:30:45,496
了解到 flatMap 能让你


894
00:30:45,496 --> 00:30:47,336
从流中获取值


895
00:30:47,536 --> 00:30:48,836
并返回新的发布者


896
00:30:49,416 --> 00:30:52,466
我们该如何调用它呢


897
00:30:53,696 --> 00:30:55,296
为此 我们有一个叫


898
00:30:55,296 --> 00:30:58,026
Future 的东西 当你


899
00:30:58,026 --> 00:30:58,966
构造的时候 你为它提供一个


900
00:30:58,966 --> 00:31:00,256
闭包 其中包括一个 promise


901
00:31:01,006 --> 00:31:02,266
promise 就是一个


902
00:31:02,266 --> 00:31:04,046
闭包 其中包含结果


903
00:31:04,046 --> 00:31:05,936
可能是成功或失败


904
00:31:09,046 --> 00:31:10,686
它的使用非常直观


905
00:31:11,666 --> 00:31:13,466
我们调用 usernameAvailable 函数


906
00:31:13,466 --> 00:31:14,916
当它异步完成 我们


907
00:31:14,916 --> 00:31:17,026
获得值之后 我们在


908
00:31:17,026 --> 00:31:18,996
promise 中填充结果 这个例子里是 success


909
00:31:19,506 --> 00:31:21,006
和之前一样 我们表明


910
00:31:21,006 --> 00:31:22,946
如果不可用 结果是 nil


911
00:31:26,056 --> 00:31:28,146
我们来回顾一下步骤 最初


912
00:31:28,146 --> 00:31:29,126
我们有一个很简单的发布者


913
00:31:29,126 --> 00:31:31,136
也就是用户名发布者


914
00:31:31,536 --> 00:31:32,466
我们采用函数防抖


915
00:31:32,466 --> 00:31:34,286
平滑信号 并移除了


916
00:31:34,286 --> 00:31:35,936
窗口中的全部重复项


917
00:31:37,346 --> 00:31:39,236
之后 我们使用 Future 包装


918
00:31:39,236 --> 00:31:41,006
现有 API 来构造


919
00:31:41,006 --> 00:31:42,176
异步网络调用


920
00:31:42,176 --> 00:31:45,426
我们使用了 flatMap 来


921
00:31:45,426 --> 00:31:46,376
构造流分支


922
00:31:47,846 --> 00:31:49,556
之后 我们将它添加至任一


923
00:31:49,556 --> 00:31:51,196
发布者因为它是 API 边界


924
00:31:52,076 --> 00:31:53,276
现在我们就创造了


925
00:31:53,276 --> 00:31:54,696
两个自定义发布者


926
00:31:54,696 --> 00:31:57,066
分别是 validatedPassword 和


927
00:31:57,066 --> 00:31:58,036
validatedUsername


928
00:31:58,576 --> 00:32:01,566
接下来我们要组合它们


929
00:32:06,046 --> 00:32:07,086
现在 我们要做的是


930
00:32:07,086 --> 00:32:08,436
利用两个信号 一个是


931
00:32:08,436 --> 00:32:10,326
设备本地信号


932
00:32:10,326 --> 00:32:11,406
另一个是异步


933
00:32:11,406 --> 00:32:13,496
网络调用 并使用它们


934
00:32:13,496 --> 00:32:14,536
启用或禁用 UI


935
00:32:14,536 --> 00:32:16,876
我们已经知道该怎么做了


936
00:32:18,276 --> 00:32:19,896
我们使用 CombineLatest 操作符


937
00:32:20,386 --> 00:32:21,726
我们要获取之前


938
00:32:21,726 --> 00:32:22,476
创造的两个发布者


939
00:32:23,836 --> 00:32:24,796
我们要检查它们是否可用


940
00:32:25,696 --> 00:32:26,886
这个例子中 我们只


941
00:32:26,886 --> 00:32:29,026
返回一个元组 其中以可选


942
00:32:29,026 --> 00:32:32,956
包含全部证书 如果没有 则返回 nil


943
00:32:36,166 --> 00:32:37,236
将这些与你的 UI


944
00:32:37,236 --> 00:32:38,436
连接起来其实非常简单


945
00:32:39,636 --> 00:32:41,266
我们为登录按钮编写一个


946
00:32:41,836 --> 00:32:43,496
输出口


947
00:32:43,656 --> 00:32:46,666
我们创建一个实例变量来储存


948
00:32:46,666 --> 00:32:48,416
这个订阅 这样我们


949
00:32:48,416 --> 00:32:49,796
就能在这个视图控制器的


950
00:32:49,846 --> 00:32:50,746
全生命周期保留它


951
00:32:51,056 --> 00:32:52,036
因为我们想要


952
00:32:52,036 --> 00:32:53,856
在展示表单的全过程中


953
00:32:53,856 --> 00:32:54,706
启用或禁用这个按钮


954
00:32:57,056 --> 00:32:57,746
所以我们就存储它


955
00:32:58,546 --> 00:32:59,966
我们将它映射到一个布尔值


956
00:33:00,716 --> 00:33:02,216
因为我们想要把它


957
00:33:02,216 --> 00:33:03,756
赋值给按钮的 isEnabled 属性


958
00:33:06,156 --> 00:33:08,076
最后 我们使用 receive(on:)


959
00:33:08,076 --> 00:33:09,006
来切换到主线程


960
00:33:09,006 --> 00:33:10,206
这是我们需要对


961
00:33:10,206 --> 00:33:11,296
任何 UI 代码做的


962
00:33:11,296 --> 00:33:13,716
之后 我们使用 assign


963
00:33:13,716 --> 00:33:15,146
操作符 将它赋值给


964
00:33:15,146 --> 00:33:16,766
给定关键路径的


965
00:33:16,766 --> 00:33:22,486
signupButton 很了不起


966
00:33:22,486 --> 00:33:23,976
我们有了一切需要的东西


967
00:33:26,046 --> 00:33:26,906
总体来看 我们最初只有


968
00:33:26,906 --> 00:33:28,246
三个非常简单的发布者


969
00:33:28,246 --> 00:33:30,746
它们只能发布字符串


970
00:33:33,086 --> 00:33:35,386
之后 我们使用组合


971
00:33:35,386 --> 00:33:37,036
不断采取小改动


972
00:33:37,036 --> 00:33:38,706
组建起了这些 创建了


973
00:33:38,706 --> 00:33:40,696
最终的链条 之后


974
00:33:40,696 --> 00:33:42,446
我们将它们组合起来 将它们赋值给按钮


975
00:33:43,456 --> 00:33:44,976
这就是 Combine 的意义所在


976
00:33:48,076 --> 00:33:49,956
所以 我建议大家马上上手


977
00:33:50,296 --> 00:33:52,576
将你 App 的小部分


978
00:33:52,576 --> 00:33:53,606
组合成自定义


979
00:33:53,606 --> 00:33:55,046
发布者 找出


980
00:33:55,046 --> 00:33:56,526
可以拆分成小型


981
00:33:56,576 --> 00:33:58,416
发布者的小块逻辑 然后


982
00:33:58,416 --> 00:34:00,026
不断使用组合 将它们


983
00:34:00,196 --> 00:34:01,836
全部连接起来


984
00:34:02,656 --> 00:34:04,046
你完全可以逐渐采用


985
00:34:04,046 --> 00:34:05,266
你不需要马上


986
00:34:05,266 --> 00:34:07,276
改变所有东西


987
00:34:07,276 --> 00:34:08,306
可以有所选择


988
00:34:08,306 --> 00:34:09,346
我们认为 你可以使用 Future


989
00:34:09,346 --> 00:34:14,085
实现现在已有的功能


990
00:34:14,266 --> 00:34:15,596
你可以使用 Future


991
00:34:15,596 --> 00:34:17,226
组合回调和其他内容 如我们刚才所见


992
00:34:20,146 --> 00:34:21,676
欲知更多信息 请观看


993
00:34:21,676 --> 00:34:24,176
我们的介绍 Combine 会议


994
00:34:24,176 --> 00:34:26,456
以及 SwiftUI 的数据流会议


995
00:34:26,456 --> 00:34:27,656
今天晚些时候 我们 


996
00:34:27,656 --> 00:34:29,966
也会在 AppKit 实验室 谢谢大家


997
00:34:30,516 --> 00:34:36,500
[掌声]

