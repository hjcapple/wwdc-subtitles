1
00:00:00,506 --> 00:00:05,516
[音乐]


2
00:00:06,231 --> 00:00:08,231
[掌声]


3
00:00:08,446 --> 00:00:10,006
>> 我的名字是 Janum Trivedi


4
00:00:10,006 --> 00:00:11,466
我是 UIKit 框架团队的


5
00:00:11,496 --> 00:00:12,466
一名工程师


6
00:00:13,696 --> 00:00:15,666
首先 我们来谈一谈


7
00:00:15,666 --> 00:00:18,236
构建适用于多个窗口的 App


8
00:00:18,916 --> 00:00:20,786
在 iOS 13 中 支持多个窗口


9
00:00:20,786 --> 00:00:22,776
是一个很好的方法


10
00:00:22,776 --> 00:00:24,016
来使现有的 App 变得更有用


11
00:00:24,016 --> 00:00:26,006
同时大大提高


12
00:00:26,006 --> 00:00:27,556
用户的工作效率


13
00:00:30,056 --> 00:00:31,576
那么今天我们将讨论


14
00:00:31,576 --> 00:00:32,746
三个主要的话题


15
00:00:33,496 --> 00:00:34,666
首先 我们将会


16
00:00:34,666 --> 00:00:36,436
快速浏览一下


17
00:00:36,436 --> 00:00:38,176
对 App 生命周期的更改


18
00:00:38,226 --> 00:00:39,856
它将允许在 iOS 13 上


19
00:00:39,856 --> 00:00:41,236
出现多个窗口


20
00:00:42,456 --> 00:00:44,856
接着 我们会深入研究


21
00:00:44,856 --> 00:00:47,206
新的 UI Scene Delegate


22
00:00:47,206 --> 00:00:48,436
在那里我们还会讨论


23
00:00:48,436 --> 00:00:49,896
你需要完成的工作


24
00:00:50,486 --> 00:00:52,816
最后 我们会回顾一些


25
00:00:52,816 --> 00:00:54,386
ArchitectureKit 中的最佳范例


26
00:00:54,386 --> 00:00:55,346
这样你和你的团队就可以


27
00:00:55,346 --> 00:00:56,926
利用它们来保证


28
00:00:56,926 --> 00:00:57,906
可以给你的用户提供一个


29
00:00:57,906 --> 00:00:59,506
持续的 无缝的


30
00:00:59,506 --> 00:01:01,236
且多任务的体验


31
00:01:01,796 --> 00:01:06,356
那么 首先让我们来看看


32
00:01:06,356 --> 00:01:07,866
在 iOS 12 及之前的版本中


33
00:01:07,866 --> 00:01:09,046
App 代理的一些


34
00:01:09,106 --> 00:01:10,976
作用和职责


35
00:01:10,976 --> 00:01:14,166
App 代理有两个主要的作用


36
00:01:14,166 --> 00:01:15,436
第一是将进程级事件


37
00:01:15,436 --> 00:01:17,716
通知给你的 App


38
00:01:18,046 --> 00:01:19,286
那么 系统会在进程


39
00:01:19,286 --> 00:01:20,476
启动或将要结束的时候


40
00:01:20,476 --> 00:01:22,656
通知你的 App 代理


41
00:01:23,256 --> 00:01:24,976
但它还有第二个作用


42
00:01:25,326 --> 00:01:26,846
就是让你的 App


43
00:01:26,846 --> 00:01:29,566
知道其 UI 的状态


44
00:01:31,266 --> 00:01:33,446
那么 通过一些方法


45
00:01:33,446 --> 00:01:34,776
如 didEnterForeground 和 willResignActive


46
00:01:34,776 --> 00:01:36,616
系统就会让你知道


47
00:01:36,616 --> 00:01:37,846
你的 UI 的状态


48
00:01:38,446 --> 00:01:41,586
这在 iOS 12 及之前的版本中


49
00:01:41,586 --> 00:01:42,666
都是没有问题的


50
00:01:42,906 --> 00:01:44,686
因为 App 有一个进程


51
00:01:44,686 --> 00:01:46,666
同时也只有一个用户界面实例


52
00:01:46,666 --> 00:01:48,366
来与它匹配


53
00:01:48,936 --> 00:01:51,096
那么 今天你的 App 代理


54
00:01:51,096 --> 00:01:53,976
可能看起来会像这样


55
00:01:53,976 --> 00:01:55,406
只是可能没这么短


56
00:01:55,406 --> 00:01:59,156
那么在 didFinishLaunchingWithOptions 中


57
00:01:59,156 --> 00:02:00,716
你完成了几件事


58
00:02:00,716 --> 00:02:02,706
首先你完成了一些


59
00:02:02,706 --> 00:02:04,536
一次性的非 UI 全局设置


60
00:02:04,596 --> 00:02:05,856
比如连接到一个数据库


61
00:02:05,856 --> 00:02:07,376
或者初始化数据结构


62
00:02:07,996 --> 00:02:09,886
之后你立刻设置了


63
00:02:09,886 --> 00:02:11,136
你的用户界面


64
00:02:11,676 --> 00:02:14,756
而同样的 这在 iOS 12


65
00:02:14,756 --> 00:02:17,006
及之前的版本中完全有效


66
00:02:17,006 --> 00:02:18,156
但在 iOS 13 的模式中是无效的


67
00:02:18,956 --> 00:02:21,186
为什么呢 因为现在的 App


68
00:02:21,466 --> 00:02:23,176
虽然只共享一个进程


69
00:02:23,176 --> 00:02:25,026
但可能会有多个


70
00:02:25,026 --> 00:02:27,576
用户界面实例或场景会话


71
00:02:28,116 --> 00:02:32,406
这意味着 App 代理的职责


72
00:02:32,406 --> 00:02:33,846
需要做出一些改变


73
00:02:34,386 --> 00:02:35,496
它仍然会负责


74
00:02:35,496 --> 00:02:37,106
进程事件和生命周期


75
00:02:37,486 --> 00:02:38,796
但它不再负责任何


76
00:02:38,796 --> 00:02:40,756
与 UI 生命周期相关的事情


77
00:02:41,386 --> 00:02:43,186
相反 这些事情都将交给


78
00:02:43,456 --> 00:02:45,156
UI Scene Delegate 来处理


79
00:02:46,146 --> 00:02:47,716
那么 这对你来说意味着什么呢


80
00:02:48,346 --> 00:02:50,436
任何你曾在你的 App 代理中


81
00:02:50,436 --> 00:02:51,536
做过的 UI 设置或拆卸工作


82
00:02:51,536 --> 00:02:53,716
现在都需要迁移到


83
00:02:53,716 --> 00:02:56,076
Scene Delegate 中的相应方法


84
00:02:56,596 --> 00:02:59,986
事实上 在 iOS 13 中


85
00:02:59,986 --> 00:03:02,006
如果你的 App 采用新的


86
00:03:02,006 --> 00:03:03,876
场景生命周期 那 UIKit


87
00:03:03,876 --> 00:03:05,276
将停止调用与 UI 状态相关的


88
00:03:05,276 --> 00:03:06,976
旧的 App 代理方法


89
00:03:07,686 --> 00:03:09,266
相反 我们将会调用新的


90
00:03:09,696 --> 00:03:11,806
Scene Delegate 方法


91
00:03:11,806 --> 00:03:12,936
这很简单 因为这些


92
00:03:13,406 --> 00:03:15,316
大多数都是一一对应的映射


93
00:03:16,246 --> 00:03:18,346
但是不要担心 如果你想要


94
00:03:18,346 --> 00:03:19,696
在 iOS 13 上采用多窗口支持


95
00:03:19,696 --> 00:03:21,146
这并不意味着你需要


96
00:03:21,146 --> 00:03:23,066
丢掉 iOS 12 及之前的支持


97
00:03:23,776 --> 00:03:25,366
如果你要向后部署


98
00:03:25,366 --> 00:03:26,676
你可以简单地将两组方法


99
00:03:26,676 --> 00:03:28,356
都保留下来 UIKit 就会


100
00:03:28,356 --> 00:03:30,586
在运行时调用正确的方法


101
00:03:31,106 --> 00:03:35,086
那么 在我们深入讨论


102
00:03:35,086 --> 00:03:36,886
具体的代理方法之前


103
00:03:36,886 --> 00:03:37,876
App 代理还有


104
00:03:37,876 --> 00:03:40,206
一个另外的职责


105
00:03:40,466 --> 00:03:41,756
即系统会通知


106
00:03:41,756 --> 00:03:43,436
你的 App 代理


107
00:03:43,436 --> 00:03:44,886
当创建一个新的场景会话


108
00:03:44,886 --> 00:03:48,176
或丢弃一个现有的场景会话时


109
00:03:48,176 --> 00:03:51,276
我们来将这个生命周期


110
00:03:51,326 --> 00:03:52,786
变得更具体一点


111
00:03:53,196 --> 00:03:54,316
假设我一直在做


112
00:03:54,316 --> 00:03:55,806
这个蓝色的 App 


113
00:03:55,806 --> 00:03:57,246
而现在我要首次将它启动


114
00:03:57,456 --> 00:03:58,556
我们来看看调用栈


115
00:03:59,606 --> 00:04:01,826
首先 你的 App 代理


116
00:04:01,826 --> 00:04:02,996
要进行相同的 


117
00:04:02,996 --> 00:04:04,016
didFinishLaunchingWithOptions 调用


118
00:04:04,246 --> 00:04:05,536
同样 在这里进行一次性的


119
00:04:05,536 --> 00:04:07,716
非 UI 设置 是没有问题的


120
00:04:08,276 --> 00:04:10,906
之后 系统会立即


121
00:04:10,906 --> 00:04:12,936
创建一个场景会话


122
00:04:13,906 --> 00:04:15,306
但在它创建具体的 UIScene 之前


123
00:04:15,306 --> 00:04:16,875
它会要求我们的 App


124
00:04:16,875 --> 00:04:19,685
进行 UIScene 配置


125
00:04:20,226 --> 00:04:21,946
这个配置会指定


126
00:04:22,156 --> 00:04:24,086
Scene Delegate 和 Storyboard


127
00:04:24,086 --> 00:04:25,606
以及假设你指定了


128
00:04:25,606 --> 00:04:27,106
你想要用什么场景子类


129
00:04:27,106 --> 00:04:28,116
来创建场景


130
00:04:29,366 --> 00:04:31,376
值得注意的是


131
00:04:31,376 --> 00:04:33,026
你可以定义


132
00:04:33,026 --> 00:04:34,046
这些场景配置


133
00:04:34,046 --> 00:04:36,136
可以动态地在代码中定义


134
00:04:36,136 --> 00:04:38,986
或静态地在 info.plist 中定义


135
00:04:40,326 --> 00:04:43,726
这也为你提供了选择正确的配置的机会


136
00:04:44,116 --> 00:04:45,266
你可以有一个主要的场景配置


137
00:04:45,266 --> 00:04:48,046
你也可以有一个附属场景


138
00:04:48,466 --> 00:04:49,306
那么 你应该看看


139
00:04:49,306 --> 00:04:50,466
这里提供的可选参数


140
00:04:50,466 --> 00:04:52,536
并将它作为上下文


141
00:04:52,536 --> 00:04:55,386
来选择正确的场景配置


142
00:04:55,886 --> 00:05:00,536
一旦你定义了这些


143
00:05:00,536 --> 00:05:02,476
比如说在 info.plist 文件中


144
00:05:02,476 --> 00:05:04,136
这个很简单 你只需要按名称引用它


145
00:05:04,486 --> 00:05:06,436
确保你将传入的作用是


146
00:05:06,436 --> 00:05:08,196
引入的会话的作用


147
00:05:10,536 --> 00:05:12,886
好了 现在我们的 App 就启动了


148
00:05:13,146 --> 00:05:14,626
我们有一个场景会话


149
00:05:14,856 --> 00:05:16,026
但我们没有看到任何 UI


150
00:05:16,026 --> 00:05:17,606
这就是我们的 Scene Delegate


151
00:05:18,406 --> 00:05:21,066
连接到场景会话的地方


152
00:05:22,036 --> 00:05:23,406
我们来看看在这里


153
00:05:23,406 --> 00:05:23,966
我们应该做什么呢


154
00:05:23,966 --> 00:05:25,046
在这里 你用新指定的


155
00:05:25,046 --> 00:05:27,676
UI 窗口初始化器


156
00:05:27,756 --> 00:05:29,516
设置 UI 窗口


157
00:05:29,806 --> 00:05:31,126
我们会注意到我们传入了


158
00:05:31,126 --> 00:05:32,286
提供的窗口场景


159
00:05:32,976 --> 00:05:35,426
但重要的是我们还需要


160
00:05:35,426 --> 00:05:37,636
检查任何相关的


161
00:05:37,636 --> 00:05:40,626
用户活动或状态恢复


162
00:05:40,626 --> 00:05:42,806
以配置我们的窗口


163
00:05:43,376 --> 00:05:45,500
我们待会再详细讨论这个


164
00:05:47,046 --> 00:05:48,746
好 现在来看我们的 App


165
00:05:49,376 --> 00:05:50,856
那么 当我们的一个用户


166
00:05:50,856 --> 00:05:52,996
向上划动返回主页时会发生什么呢


167
00:05:54,426 --> 00:05:57,226
我们熟悉的 willResignActive


168
00:05:57,226 --> 00:05:58,746
和 didEnterBackground 方法


169
00:05:58,746 --> 00:06:01,306
会在你的 Scene Delegate 上被调用


170
00:06:01,956 --> 00:06:03,266
但现在有一些有趣的事情


171
00:06:03,826 --> 00:06:05,586
在此之后的某个时刻


172
00:06:05,816 --> 00:06:07,456
你的场景可能会断开连接


173
00:06:07,736 --> 00:06:08,896
那么 这意味着什么呢


174
00:06:09,116 --> 00:06:10,276
好 为了回收资源


175
00:06:10,276 --> 00:06:13,036
系统可能会


176
00:06:13,036 --> 00:06:14,356
在你的场景


177
00:06:14,356 --> 00:06:15,826
进入后台的某个时候


178
00:06:15,826 --> 00:06:16,786
从内存中释放该场景


179
00:06:17,096 --> 00:06:18,616
这也意味着你的


180
00:06:18,616 --> 00:06:20,096
Scene Delegate 将会


181
00:06:20,386 --> 00:06:21,716
从内存中被释放


182
00:06:21,716 --> 00:06:23,206
而该代理中所持有的


183
00:06:23,436 --> 00:06:25,986
任何窗口层级或视图层级也将被释放


184
00:06:27,236 --> 00:06:29,126
这给你提供了机会


185
00:06:29,126 --> 00:06:31,016
来释放 App 中


186
00:06:31,016 --> 00:06:32,256
与此场景相关的 


187
00:06:32,256 --> 00:06:33,676
保留在其他地方的


188
00:06:33,676 --> 00:06:36,406
内存中的任何大型资源


189
00:06:37,276 --> 00:06:38,916
但是重要的是 不要用它


190
00:06:38,916 --> 00:06:40,336
来永久删除任何


191
00:06:40,336 --> 00:06:41,976
用户数据或状态


192
00:06:42,226 --> 00:06:43,926
因为该场景稍后可能会


193
00:06:43,926 --> 00:06:44,726
重新连接并返回


194
00:06:48,236 --> 00:06:49,966
接着我们讨论一下


195
00:06:49,966 --> 00:06:51,996
当我们的用户真的


196
00:06:51,996 --> 00:06:53,966
在切换器上上划一个场景会话


197
00:06:53,966 --> 00:06:55,436
并明确地想要销毁它时


198
00:06:55,436 --> 00:06:57,526
会发生什么呢


199
00:06:57,746 --> 00:06:59,326
那么 系统会调用我们的


200
00:06:59,326 --> 00:07:01,716
App 代理 didDiscardSceneSessions


201
00:07:04,016 --> 00:07:06,556
这让我们终于能够真正永久地


202
00:07:06,556 --> 00:07:08,106
代理任何与该场景有关的


203
00:07:08,106 --> 00:07:09,296
用户状态或数据


204
00:07:09,296 --> 00:07:11,326
比如一个文档编辑 App 中


205
00:07:11,326 --> 00:07:13,306
未保存的草稿


206
00:07:14,086 --> 00:07:16,176
现在 也有可能


207
00:07:16,176 --> 00:07:17,856
你的一个用户从切换器中


208
00:07:17,856 --> 00:07:19,356
移除了一个或多个 UI 场景


209
00:07:19,356 --> 00:07:21,176
通过在你的 App 进程


210
00:07:21,176 --> 00:07:22,446
还未真正运行时向上划动


211
00:07:23,316 --> 00:07:24,586
如果你的进程还没有运行


212
00:07:24,586 --> 00:07:25,746
系统就会记录下
 
00:07:25,746 --> 00:07:27,536
被丢弃的会话


213
00:07:27,536 --> 00:07:28,516
在你的 App 下次启动后


214
00:07:28,516 --> 00:07:29,796
快速调用该会话


215
00:07:34,726 --> 00:07:36,136
现在 我们来讨论一些


216
00:07:36,136 --> 00:07:37,616
构建模式 你可以考虑


217
00:07:37,616 --> 00:07:39,346
将它们融入你的 App 中


218
00:07:39,886 --> 00:07:44,476
我们首先来说说状态恢复


219
00:07:45,786 --> 00:07:48,086
在 iOS 13 中 状态恢复


220
00:07:48,086 --> 00:07:49,536
不再是一个好东西


221
00:07:50,136 --> 00:07:52,216
至关重要的是


222
00:07:52,216 --> 00:07:53,416
你的 App 要实现


223
00:07:53,416 --> 00:07:55,206
基于场景的状态恢复


224
00:07:55,926 --> 00:07:57,126
我们来看看这是为什么


225
00:07:58,426 --> 00:07:59,286
这是我们的 App 切换器


226
00:07:59,406 --> 00:08:01,286
我有一个文档 App


227
00:08:01,286 --> 00:08:02,356
我正在计划一次自驾游


228
00:08:02,436 --> 00:08:03,416
我现在打开了四个


229
00:08:03,416 --> 00:08:04,756
不同文档的不同会话


230
00:08:05,716 --> 00:08:07,006
但是我真正关注的


231
00:08:07,236 --> 00:08:08,506
是“行李清单”和“日程安排”


232
00:08:09,556 --> 00:08:12,176
在某一时刻 另外两个


233
00:08:12,176 --> 00:08:13,226
在后台上的“自驾游”


234
00:08:13,226 --> 00:08:14,486
和“出席者”的场景


235
00:08:14,486 --> 00:08:16,616
已经被系统断开连接并释放


236
00:08:17,466 --> 00:08:18,896
如果我在这里


237
00:08:18,896 --> 00:08:20,886
不实现状态恢复的话


238
00:08:20,886 --> 00:08:21,896
当我回到“自驾游”时


239
00:08:21,896 --> 00:08:23,546
我就不会回到之前


240
00:08:23,546 --> 00:08:24,256
所在的状态


241
00:08:24,256 --> 00:08:25,056
我不会回到我之前


242
00:08:25,056 --> 00:08:26,336
正在编辑的文档的场景


243
00:08:27,136 --> 00:08:28,176
而是会直接重新开始


244
00:08:28,176 --> 00:08:29,296
就像打开一个全新的窗口


245
00:08:29,296 --> 00:08:31,776
但这并不是一个很好的用户体验


246
00:08:33,196 --> 00:08:34,275
那么 如何解决这个问题呢


247
00:08:34,946 --> 00:08:36,645
iOS 13 有一个全新的


248
00:08:37,346 --> 00:08:39,806
基于场景的状态恢复的 API


249
00:08:40,155 --> 00:08:41,576
它非常简单


250
00:08:42,816 --> 00:08:47,486
就是不再对视图层级进行编码


251
00:08:47,606 --> 00:08:49,496
而是对允许重新


252
00:08:49,496 --> 00:08:51,996
创建窗口的状态进行编码


253
00:08:54,356 --> 00:08:56,946
这也全部都基于 NSUserActivity


254
00:08:56,946 --> 00:08:57,856
因此 如果你的 App


255
00:08:57,856 --> 00:08:59,376
利用了功能强大的技术


256
00:08:59,376 --> 00:09:00,696
比如聚焦搜索或接力


257
00:09:00,696 --> 00:09:02,336
那你就可以用这些相同的活动


258
00:09:02,336 --> 00:09:04,136
来对你 App 的状态进行编码


259
00:09:04,796 --> 00:09:06,076
我们也要注意


260
00:09:06,076 --> 00:09:08,196
在 iOS 13 中 你返回给


261
00:09:08,196 --> 00:09:09,646
系统的状态恢复存档


262
00:09:09,646 --> 00:09:13,236
将会匹配 App 中的其余部分的


263
00:09:13,236 --> 00:09:14,336
相同数据保护类


264
00:09:17,756 --> 00:09:20,906
这在代码中是怎样的呢


265
00:09:20,906 --> 00:09:22,156
那么 在我们的 Scene Delegate 中


266
00:09:22,156 --> 00:09:23,356
我们实现场景的


267
00:09:23,356 --> 00:09:25,796
状态恢复活动


268
00:09:25,796 --> 00:09:29,346
然后我调用一个方法


269
00:09:29,346 --> 00:09:31,506
来在现有的窗口中寻找


270
00:09:31,506 --> 00:09:33,496
最活跃的相关用户活动表


271
00:09:34,046 --> 00:09:35,526
然后我们回到该表


272
00:09:36,276 --> 00:09:38,366
过一些时候 当该场景


273
00:09:38,366 --> 00:09:41,746
重新进入前台且连接成功时


274
00:09:41,746 --> 00:09:43,176
我们检查该会话是否含有一个


275
00:09:43,176 --> 00:09:44,286
状态恢复活动


276
00:09:44,896 --> 00:09:47,076
如果有 我们就用该活动


277
00:09:47,586 --> 00:09:48,656
如果没有 我们可以创建一个


278
00:09:48,656 --> 00:09:50,776
全新的没有任何状态的窗口


279
00:09:51,886 --> 00:09:53,546
这意味着无论如何


280
00:09:54,026 --> 00:09:55,396
当场景在后台断开连接时


281
00:09:55,396 --> 00:09:57,026
我们的用户永远不会注意到


282
00:09:57,026 --> 00:09:58,626
因为这不应该被注意到


283
00:10:00,856 --> 00:10:03,156
最后 我们来说说


284
00:10:03,156 --> 00:10:05,346
在采用多个窗口的支持时


285
00:10:05,346 --> 00:10:06,816
你可能会遇到的


286
00:10:06,816 --> 00:10:08,026
一个更重要的问题


287
00:10:08,196 --> 00:10:09,756
也就是如何最大程度地


288
00:10:09,756 --> 00:10:11,496
保持 App 场景的同步


289
00:10:11,496 --> 00:10:13,656
让我来把它具体化


290
00:10:13,796 --> 00:10:15,256
我一直在做一个新的


291
00:10:15,256 --> 00:10:17,396
聊天 App 就在这里


292
00:10:17,396 --> 00:10:18,866
而我们可以看到


293
00:10:18,866 --> 00:10:20,456
我最近刚在 iOS 13 上添加了


294
00:10:20,456 --> 00:10:21,236
对多个窗口的支持


295
00:10:22,636 --> 00:10:23,666
我有一个与我的朋友


296
00:10:23,666 --> 00:10:25,786
Giovanni 的聊天


297
00:10:25,786 --> 00:10:27,086
几分钟后他将和我一起上台


298
00:10:27,736 --> 00:10:28,896
注意 我们正在同时


299
00:10:28,896 --> 00:10:30,046
查看相同的对话


300
00:10:30,046 --> 00:10:31,076
在两个不同的视图控制器


301
00:10:31,076 --> 00:10:32,886
及两个不同的场景中


302
00:10:34,036 --> 00:10:35,276
那么 我们假设我要


303
00:10:35,276 --> 00:10:36,826
给 Giovanni 发送一条信息


304
00:10:36,826 --> 00:10:37,846
告诉他我准备好吃午饭了


305
00:10:39,056 --> 00:10:41,376
那么 只有一个场景更新了


306
00:10:42,176 --> 00:10:43,706
所以这是为什么呢


307
00:10:44,876 --> 00:10:46,816
好 这是因为在 iOS 中


308
00:10:46,816 --> 00:10:47,976
许多 App 的结构都是这样


309
00:10:47,976 --> 00:10:49,486
视图控制器会


310
00:10:49,486 --> 00:10:51,026
接收一个事件


311
00:10:51,446 --> 00:10:52,766
可能是通过点击按钮


312
00:10:52,766 --> 00:10:53,846
即我按下发送按钮


313
00:10:54,426 --> 00:10:56,086
然后视图控制器本就


314
00:10:56,086 --> 00:10:57,786
就会更新它自己的 UI


315
00:10:58,716 --> 00:11:00,166
之后 我们的视图控制器


316
00:11:00,166 --> 00:11:02,436
会通知模型或模型控制器


317
00:11:02,436 --> 00:11:05,266
而当我们只讨论


318
00:11:05,266 --> 00:11:07,046
一个用户界面实例时


319
00:11:07,046 --> 00:11:07,856
这基本上是没问题的


320
00:11:08,466 --> 00:11:10,146
但现在如果我们在一个


321
00:11:10,796 --> 00:11:11,816
显示相同数据的不同场景中


322
00:11:11,816 --> 00:11:13,166
引入第二个视图控制器


323
00:11:13,166 --> 00:11:15,296
那么无论什么时候


324
00:11:15,296 --> 00:11:16,666
这个新的视图控制器都不会


325
00:11:16,906 --> 00:11:18,916
收到通知来更新这个新数据


326
00:11:19,816 --> 00:11:20,446
这是一个问题


327
00:11:20,966 --> 00:11:24,556
那么我们可以解决这个问题


328
00:11:24,606 --> 00:11:25,976
在架构上 如果我们的


329
00:11:25,976 --> 00:11:27,186
视图控制器能够


330
00:11:27,186 --> 00:11:29,536
在接收到一个事件后


331
00:11:29,536 --> 00:11:31,356
立即并且只通知


332
00:11:31,736 --> 00:11:32,986
我们的模型控制器 


333
00:11:32,986 --> 00:11:35,416
那我们就可以让模型控制器


334
00:11:35,416 --> 00:11:36,686
通知任何相关的订阅者


335
00:11:36,686 --> 00:11:37,946
或者视图控制器


336
00:11:37,946 --> 00:11:39,996
来更新这个新数据


337
00:11:41,416 --> 00:11:43,196
有许多方法都可以完成这个


338
00:11:43,196 --> 00:11:45,046
我们可以使用代理和通知


339
00:11:45,376 --> 00:11:46,696
我们甚至可以用全新的


340
00:11:46,696 --> 00:11:48,836
今年发布的 Swift Combine 框架


341
00:11:49,716 --> 00:11:51,116
但我们先来看一个


342
00:11:51,116 --> 00:11:52,526
简单的 Swift 示例


343
00:11:52,526 --> 00:11:54,096
你可以考虑将其整合进你的 App 中


344
00:11:54,666 --> 00:11:55,976
这是现在的方法


345
00:11:55,976 --> 00:11:57,356
当我在发送信息时按下


346
00:11:57,566 --> 00:11:59,336
返回键时 它就会被调用


347
00:11:59,936 --> 00:12:01,426
我创建了一个信息模型对象


348
00:12:02,056 --> 00:12:03,306
我的视图控制器更新


349
00:12:03,306 --> 00:12:03,866
其自己的视图


350
00:12:04,446 --> 00:12:07,096
接着我们通知模型控制器


351
00:12:07,096 --> 00:12:08,746
来保存这个


352
00:12:09,286 --> 00:12:11,056
我们首先要做的


353
00:12:11,056 --> 00:12:11,916
就是让该视图控制器


354
00:12:12,236 --> 00:12:14,406
不改变它自己的视图状态


355
00:12:14,886 --> 00:12:16,646
相反 我们要去掉这些代码


356
00:12:16,746 --> 00:12:18,836
稍后我们会把它加回去


357
00:12:20,846 --> 00:12:22,706
现在 我们来看看


358
00:12:22,706 --> 00:12:25,446
该模型控制器 add() 方法到底在做什么


359
00:12:25,446 --> 00:12:26,576
其实很简单


360
00:12:27,206 --> 00:12:28,406
我们要做的就是


361
00:12:28,406 --> 00:12:29,176
保存该新消息


362
00:12:30,096 --> 00:12:31,286
但实际上我们想让


363
00:12:31,286 --> 00:12:33,556
模型控制器立刻进行通知


364
00:12:33,556 --> 00:12:34,526
如果任何其他视图控制器


365
00:12:34,526 --> 00:12:36,476
或连接的场景需要的更新的话


366
00:12:39,496 --> 00:12:41,186
我们如何发送这个更新呢


367
00:12:41,636 --> 00:12:43,936
我们需要一种结构化的方法


368
00:12:43,936 --> 00:12:46,276
来打包这个事件


369
00:12:46,276 --> 00:12:49,366
这样它就成为强类型


370
00:12:49,616 --> 00:12:51,166
且易于调试和测试


371
00:12:51,446 --> 00:12:52,576
那么 我们来继续创建


372
00:12:52,576 --> 00:12:54,116
一个新的类型


373
00:12:54,116 --> 00:12:55,206
我们称之为 UpdateEvent


374
00:12:55,206 --> 00:12:57,536
它是一个带有相关值的 Swift 枚举


375
00:12:58,066 --> 00:13:00,026
我们将添加一个新的消息类型


376
00:13:00,676 --> 00:13:02,276
这是我们的模型控制器


377
00:13:02,276 --> 00:13:03,506
将要在接收新的消息时


378
00:13:03,506 --> 00:13:04,836
创建的对象


379
00:13:04,836 --> 00:13:06,626
然后会发送给任何的


380
00:13:06,626 --> 00:13:08,456
相关的视图控制器或场景


381
00:13:09,656 --> 00:13:10,896
因为我们想发送这个


382
00:13:10,896 --> 00:13:12,496
我们将用 NSNotificationCenter


383
00:13:12,716 --> 00:13:14,076
作为这个的备份存储


384
00:13:14,076 --> 00:13:15,826
因此 我们会添加这个便利的


385
00:13:15,826 --> 00:13:17,636
post() 方法 它允许我们在一行中


386
00:13:17,846 --> 00:13:19,286
创建一个新的更新事件


387
00:13:19,286 --> 00:13:20,896
然后将其发送给任何订阅者


388
00:13:21,456 --> 00:13:25,166
实现这个相当简单


389
00:13:25,236 --> 00:13:27,006
我们只要发送一个通知


390
00:13:27,006 --> 00:13:29,646
到新消息的通知名称通道


391
00:13:30,126 --> 00:13:31,376
但这里的技巧是


392
00:13:31,376 --> 00:13:32,696
我们要将更新事件对象本身


393
00:13:32,926 --> 00:13:35,766
包含在通知对象中


394
00:13:35,766 --> 00:13:37,096
这会派上用场


395
00:13:37,096 --> 00:13:41,446
我们很快就会看到


396
00:13:41,576 --> 00:13:42,956
现在 当我们的模型控制器


397
00:13:42,956 --> 00:13:44,166
被通知添加了一个新消息时


398
00:13:44,166 --> 00:13:45,926
在我们保存它之后


399
00:13:46,196 --> 00:13:47,166
我们就可以创建这个新事件


400
00:13:47,166 --> 00:13:49,066
并调用 post()


401
00:13:51,546 --> 00:13:53,466
接着 如果我们看看


402
00:13:53,496 --> 00:13:54,696
要如何改变我们的视图控制器


403
00:13:55,436 --> 00:13:57,396
我们会注意到这个新事件


404
00:13:57,676 --> 00:13:59,836
在本例里 就是新消息通知名称


405
00:14:00,286 --> 00:14:03,366
然后我们创建一个 handler() 方法


406
00:14:03,366 --> 00:14:06,066
从参数中获取通知


407
00:14:06,816 --> 00:14:08,126
记住 当我们将更新事件


408
00:14:08,126 --> 00:14:12,426
作为通知对象进行传递时


409
00:14:12,546 --> 00:14:14,076
我们现在就可以从通知中


410
00:14:14,076 --> 00:14:15,426
直接拉出该事件


411
00:14:15,946 --> 00:14:18,736
然后我们可以很容易地


412
00:14:18,736 --> 00:14:20,506
打开这种事件类型情况


413
00:14:21,796 --> 00:14:22,886
因为我们创建了一个相关枚举


414
00:14:22,886 --> 00:14:26,726
我们就可以把信息拉出来


415
00:14:26,986 --> 00:14:29,326
现在 我们可以更新这里的用户界面


416
00:14:32,536 --> 00:14:33,736
那么 让我们来看看


417
00:14:33,736 --> 00:14:34,896
在实现这个新的构架之后


418
00:14:34,896 --> 00:14:37,496
当我向 Giovanni 发送相同的消息时会发生什么呢


419
00:14:38,196 --> 00:14:39,696
好了 所有的场景都更新了


420
00:14:41,516 --> 00:14:45,876
[掌声]


421
00:14:46,376 --> 00:14:47,866
那么 我们今天讲了很多


422
00:14:48,076 --> 00:14:48,976
我们已经讲了一些


423
00:14:48,976 --> 00:14:51,736
App 代理和 Scene Delegate 的不同


424
00:14:51,736 --> 00:14:53,296
及其职责的不同


425
00:14:53,696 --> 00:14:54,806
我们之前还说了一些


426
00:14:54,806 --> 00:14:57,586
主要的 Scene Delegate 方法


427
00:14:57,586 --> 00:14:59,066
及你应该做的工作


428
00:15:00,156 --> 00:15:01,306
我们也讨论了为什么


429
00:15:01,306 --> 00:15:02,736
状态恢复在你使用


430
00:15:02,736 --> 00:15:04,616
iOS 13 时是如此的重要


431
00:15:04,616 --> 00:15:06,726
以及如何利用新的


432
00:15:06,896 --> 00:15:07,926
基于场景的 API 来完成它


433
00:15:08,606 --> 00:15:11,166
最后 我们说了一些


434
00:15:11,166 --> 00:15:12,596
创建一个单向数据流的


435
00:15:12,596 --> 00:15:14,066
高级的模式 这样我们


436
00:15:14,066 --> 00:15:15,296
就可以在共享相同的数据时


437
00:15:15,296 --> 00:15:17,716
保持所有的场景同步 谢谢


438
00:15:19,508 --> 00:15:21,508
[掌声]

