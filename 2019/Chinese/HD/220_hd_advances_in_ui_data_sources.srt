1
00:00:00,506 --> 00:00:05,500
[音乐]


2
00:00:08,516 --> 00:00:11,546
[欢呼和掌声]


3
00:00:12,046 --> 00:00:12,376
>> 欢迎


4
00:00:15,496 --> 00:00:16,696
我是 Steve Breen


5
00:00:16,696 --> 00:00:18,256
我是 UIKit 团队的一名工程师


6
00:00:18,426 --> 00:00:19,586
今天我和我的同事


7
00:00:19,586 --> 00:00:21,186
来自 AppKit 团队的 Troy Stephens 


8
00:00:21,186 --> 00:00:22,456
和来自 App Store 团队的


9
00:00:22,456 --> 00:00:24,336
Jacob Klapper 一起


10
00:00:25,366 --> 00:00:27,096
今天我们要聊一些


11
00:00:27,216 --> 00:00:29,416
关于 UI 数据源的内容


12
00:00:30,296 --> 00:00:30,986
[笑声] 那么


13
00:00:30,986 --> 00:00:33,006
今天的演讲将分为四个部分


14
00:00:33,626 --> 00:00:34,656
首先我想谈谈


15
00:00:34,656 --> 00:00:35,936
目前的最新状况


16
00:00:36,076 --> 00:00:37,346
我们现在如何


17
00:00:37,346 --> 00:00:39,636
在平台上与数据源交互


18
00:00:40,636 --> 00:00:41,656
然后我们将讨论


19
00:00:41,656 --> 00:00:43,196
一种全新的方法


20
00:00:43,196 --> 00:00:45,856
将其引入 iOS tvOS 和 macOS


21
00:00:46,556 --> 00:00:48,156
接下来我们会过渡到一些演示


22
00:00:48,156 --> 00:00:50,146
获得一些关于这个


23
00:00:50,146 --> 00:00:51,926
全新 API 的实践


24
00:00:52,646 --> 00:00:54,236
最后我们将


25
00:00:54,236 --> 00:00:55,466
更详细地考虑


26
00:00:55,466 --> 00:00:56,576
如何充分利用


27
00:00:56,706 --> 00:00:59,466
这个新 API


28
00:01:00,256 --> 00:01:01,246
我们来谈谈


29
00:01:01,246 --> 00:01:02,636
目前最新的状况


30
00:01:02,636 --> 00:01:05,495
我们是如何在 UITableView


31
00:01:05,495 --> 00:01:07,206
和 UICollectionView 中与


32
00:01:07,206 --> 00:01:08,436
UI 数据源交互的呢?


33
00:01:09,836 --> 00:01:12,256
这里我们看到


34
00:01:12,256 --> 00:01:13,546
UICollectionView 数据源


35
00:01:13,546 --> 00:01:15,046
的一个示例的实现


36
00:01:15,926 --> 00:01:16,896
如果你用过


37
00:01:16,896 --> 00:01:18,456
UITableView 或 UICollectionViews


38
00:01:18,456 --> 00:01:19,346
那你以前见过这个


39
00:01:19,966 --> 00:01:21,886
这提供了三个方法


40
00:01:21,886 --> 00:01:24,496
包括协议必须的两个方法


41
00:01:24,496 --> 00:01:26,836
很简单 对吧


42
00:01:26,836 --> 00:01:28,466
我们已经询问了


43
00:01:28,466 --> 00:01:29,576
Section 的数量


44
00:01:29,576 --> 00:01:30,886
和每个 Section 中 Item 的数量


45
00:01:31,096 --> 00:01:32,676
在内容渲染方面


46
00:01:32,676 --> 00:01:33,796
我们会要求返回 Item 对应的 Cell


47
00:01:34,406 --> 00:01:38,136
非常简单 到现在它已经


48
00:01:38,136 --> 00:01:39,566
为我们服务十年了


49
00:01:39,796 --> 00:01:42,946
对吧 它有几个优点 超级简单


50
00:01:43,356 --> 00:01:44,486
你可以立刻推理出来


51
00:01:44,486 --> 00:01:46,296
如果你只想提供两个方法


52
00:01:46,296 --> 00:01:48,446
Section 中的 Item 数量


53
00:01:48,446 --> 00:01:50,426
如果你的数据源是一维的


54
00:01:50,426 --> 00:01:51,606
那就很简单了


55
00:01:52,576 --> 00:01:53,966
你可以很快地对它进行迭代


56
00:01:54,566 --> 00:01:56,566
但它也很灵活


57
00:01:56,636 --> 00:01:58,516
对吧 因为你不需要


58
00:01:58,596 --> 00:02:00,586
使用任何特定的数据结构


59
00:02:00,586 --> 00:02:02,896
来支持你的数据源


60
00:02:04,116 --> 00:02:05,276
它可以像一维数组


61
00:02:05,346 --> 00:02:06,386
一样简单


62
00:02:07,426 --> 00:02:08,826
如果你的数据源


63
00:02:08,826 --> 00:02:10,906
有多个 Item 和 Section


64
00:02:10,906 --> 00:02:11,796
它可能是二维的对吧


65
00:02:11,796 --> 00:02:12,946
非常简单 非常直接


66
00:02:15,606 --> 00:02:17,926
App 通常


67
00:02:17,926 --> 00:02:19,146
比一维或二维数组


68
00:02:19,146 --> 00:02:20,706
要复杂一些


69
00:02:22,456 --> 00:02:24,216
而且 App 每年都变得越来越复杂


70
00:02:24,216 --> 00:02:25,166
它们做的事情更多


71
00:02:25,166 --> 00:02:26,886
我们的用户需要更多的功能


72
00:02:26,886 --> 00:02:29,576
通常这些数据源


73
00:02:29,576 --> 00:02:31,316
是由 App 内部的


74
00:02:31,316 --> 00:02:32,746
复杂控制器支持的


75
00:02:33,686 --> 00:02:35,946
这些控制器可以做很多事


76
00:02:35,946 --> 00:02:36,876
它们可以与 Core Data 交互


77
00:02:36,876 --> 00:02:39,186
还可以与 Web 服务对话


78
00:02:39,186 --> 00:02:40,546
它们做了


79
00:02:40,546 --> 00:02:41,426
很多不同的事情


80
00:02:41,626 --> 00:02:43,916
我将很快地进行展示


81
00:02:45,296 --> 00:02:46,906
让我们来看看


82
00:02:46,906 --> 00:02:49,166
UI 层和控制器层之前的对话


83
00:02:49,166 --> 00:02:50,166
这个控制器层做了很多


84
00:02:50,166 --> 00:02:51,576
繁重的工作


85
00:02:51,576 --> 00:02:52,786
来获取数据对吧


86
00:02:53,686 --> 00:02:55,576
对话一开始很礼貌


87
00:02:56,106 --> 00:02:57,946
就像是 “嘿 请告诉我 Section 中 Item 的数量


88
00:02:57,946 --> 00:02:59,456
或者在我们渲染内容时


89
00:02:59,456 --> 00:03:00,046
给我对应的 Cell“


90
00:03:00,486 --> 00:03:01,456
非常简单


91
00:03:01,526 --> 00:03:02,956
到目前为止一切顺利


92
00:03:06,056 --> 00:03:08,016
但随着时间的推移 事情会变得更加复杂对吧


93
00:03:08,016 --> 00:03:09,076
比如这个控制器


94
00:03:09,076 --> 00:03:10,516
有一个 Web 服务请求


95
00:03:10,516 --> 00:03:11,896
在这里得到响应


96
00:03:11,896 --> 00:03:14,196
对吧 就像是我有你的


97
00:03:14,196 --> 00:03:15,776
推特之类的数据 对吧


98
00:03:16,396 --> 00:03:18,096
现在这个控制器层


99
00:03:18,196 --> 00:03:19,716
它本身是复杂的


100
00:03:20,376 --> 00:03:21,926
要让世界知道


101
00:03:21,926 --> 00:03:23,226
嘿 我改变了 有一些地方变了


102
00:03:23,846 --> 00:03:25,546
这就是事情变得


103
00:03:25,546 --> 00:03:27,996
有点复杂的地方对吧


104
00:03:27,996 --> 00:03:31,066
现在由 UI 层决定


105
00:03:31,066 --> 00:03:33,486
嘿 事情变了


106
00:03:33,486 --> 00:03:34,856
我现在要根据这个改变


107
00:03:34,856 --> 00:03:37,816
对我们的 UI 层进行更新


108
00:03:38,486 --> 00:03:40,086
这包括所有针对


109
00:03:40,086 --> 00:03:41,426
TableView 和


110
00:03:41,426 --> 00:03:42,756
CollectionView 的变化


111
00:03:42,756 --> 00:03:44,246
可能会有点复杂


112
00:03:44,246 --> 00:03:46,076
我们在去年的


113
00:03:46,076 --> 00:03:48,236
UICollectionView 一览会议中


114
00:03:48,236 --> 00:03:51,436
讨论了这种复杂性以及如何正确


115
00:03:51,436 --> 00:03:53,726
构造批次更新


116
00:03:53,726 --> 00:03:54,976
以及如何修改备份储存 诸如此类的


117
00:03:57,586 --> 00:03:59,276
但是有时候 不管你怎么努力


118
00:04:00,516 --> 00:04:02,626
[笑声]


119
00:04:03,126 --> 00:04:04,226
你知道事情总不会顺利


120
00:04:04,606 --> 00:04:05,586
这是一个不完美的世界


121
00:04:07,186 --> 00:04:08,746
从笑声中可以看出


122
00:04:08,886 --> 00:04:10,006
你以前可能也遇到过这种情况


123
00:04:10,006 --> 00:04:12,336
对吧 这并不罕见


124
00:04:12,336 --> 00:04:13,756
这真的很令人沮丧


125
00:04:13,756 --> 00:04:14,726
对吧 你遇到这种情况 然后会想


126
00:04:14,726 --> 00:04:18,875
"好吧 我做错了什么?" 这是我本人


127
00:04:18,875 --> 00:04:20,616
当你深入研究你的代码后


128
00:04:20,616 --> 00:04:21,716
你在 Stack Overflow 上查询


129
00:04:21,716 --> 00:04:22,886
看看发生了什么


130
00:04:23,206 --> 00:04:25,146
最终你可能会灰心


131
00:04:25,146 --> 00:04:26,516
只能调用 reloadData


132
00:04:26,516 --> 00:04:27,806
我们去年讨论了这个


133
00:04:27,806 --> 00:04:30,266
很好 这是正确的做法


134
00:04:30,386 --> 00:04:31,616
你的 App 会正常运行


135
00:04:32,676 --> 00:04:33,736
当你调用 reloadData 时


136
00:04:33,736 --> 00:04:35,616
你会得到一个非动画效果


137
00:04:36,306 --> 00:04:38,446
它会降低用户体验


138
00:04:39,836 --> 00:04:41,356
所以这不好


139
00:04:44,046 --> 00:04:46,156
我想用这一张幻灯片来讲讲哲学


140
00:04:46,156 --> 00:04:48,716
就一张 我保证出了什么问题呢


141
00:04:49,636 --> 00:04:52,456
问题是 我们的真相在哪里


142
00:04:53,786 --> 00:04:55,386
你知道的 我的意思是谁造成了这一切


143
00:04:55,386 --> 00:04:56,696
谁能解决这些问题


144
00:04:57,806 --> 00:04:59,256
这里最大的问题是


145
00:04:59,256 --> 00:05:01,016
我们的数据控制器


146
00:05:01,016 --> 00:05:02,186
或者说是作为一个数据源


147
00:05:02,186 --> 00:05:03,356
有它自己版本的真相


148
00:05:03,356 --> 00:05:04,466
随着时间的推移而变化


149
00:05:04,946 --> 00:05:07,136
UI 有一个版本的真相


150
00:05:08,336 --> 00:05:09,866
UI 层代码负责


151
00:05:09,866 --> 00:05:11,256
调节两者


152
00:05:11,256 --> 00:05:12,796
确保它们总是同步的


153
00:05:13,526 --> 00:05:15,476
正如我们所看到的 有时候这很难


154
00:05:16,816 --> 00:05:19,036
所以我们目前的方法容易出错


155
00:05:19,726 --> 00:05:22,976
主要是因为没有集中真理的概念


156
00:05:26,626 --> 00:05:27,766
这就是最新的状况


157
00:05:27,766 --> 00:05:28,476
这就是我们今天的处境


158
00:05:28,476 --> 00:05:29,206
但是我们接下来会怎么样呢


159
00:05:30,546 --> 00:05:31,716
我很高兴地宣布


160
00:05:31,716 --> 00:05:33,726
对于 iOS tvOS 和 macOS 


161
00:05:33,726 --> 00:05:36,326
我们今年将推出一种全新的方式


162
00:05:37,106 --> 00:05:39,556
我们称这个为差量数据源


163
00:05:40,516 --> 00:05:44,546
[欢呼和掌声]


164
00:05:45,046 --> 00:05:45,976
好了让我们深入了解一下这是什么


165
00:05:49,076 --> 00:05:50,576
没有 performBatchUpdates 我们继续


166
00:05:51,056 --> 00:05:53,976
与此同时 所有的崩溃 困扰和繁杂


167
00:05:53,976 --> 00:05:54,776
所有你不想处理的东西


168
00:05:54,776 --> 00:05:56,726
都被抛弃了


169
00:05:57,806 --> 00:05:59,086
我们只有一个


170
00:05:59,086 --> 00:05:59,986
被称为 apply() 的方法


171
00:06:00,546 --> 00:06:01,196
什么是 apply()


172
00:06:01,806 --> 00:06:03,176
apply() 是简单的 自动的


173
00:06:03,176 --> 00:06:04,496
省事的差异化对比


174
00:06:07,386 --> 00:06:09,136
我们用一个全新的构造


175
00:06:09,136 --> 00:06:10,766
称之为快照


176
00:06:10,826 --> 00:06:12,156
这是一个非常简单的想法


177
00:06:12,296 --> 00:06:13,846
这实际上是


178
00:06:13,846 --> 00:06:14,826
当前 UI 状态的真相


179
00:06:15,536 --> 00:06:18,306
它不是 IndexPath


180
00:06:18,306 --> 00:06:20,076
而是一组


181
00:06:20,346 --> 00:06:24,066
唯一的 Section 标识符和 Item 标识符


182
00:06:25,336 --> 00:06:26,766
你不是使用 IndexPath 进行更新


183
00:06:26,766 --> 00:06:28,736
而是用标识符


184
00:06:29,486 --> 00:06:30,226
让我们来看看


185
00:06:30,226 --> 00:06:32,666
这里发生了什么


186
00:06:34,156 --> 00:06:35,276
我是个很有创意的人


187
00:06:35,276 --> 00:06:37,146
屏幕上有 FOO


188
00:06:37,226 --> 00:06:38,256
BAR 和 BIF 对吧


189
00:06:38,256 --> 00:06:39,486
这就是我们互动的对象


190
00:06:39,486 --> 00:06:41,736
这些是 App 中的标识符


191
00:06:43,146 --> 00:06:45,156
假设控制器改变了


192
00:06:45,156 --> 00:06:46,546
现在我们有了这个


193
00:06:46,606 --> 00:06:48,316
我们想应用的全新的快照


194
00:06:49,116 --> 00:06:50,316
但这是我们当前的快照


195
00:06:50,316 --> 00:06:52,676
我们如何从新的事实


196
00:06:53,686 --> 00:06:54,676
得到当前的快照


197
00:06:56,686 --> 00:06:57,916
我们可以看到


198
00:06:57,916 --> 00:06:59,486
用 BAR FOO 和 BAZ


199
00:06:59,486 --> 00:07:01,496
配置了一个全新的快照


200
00:07:01,496 --> 00:07:02,656
我们有些项目是


201
00:07:02,656 --> 00:07:03,656
一直存在的


202
00:07:03,656 --> 00:07:05,036
只是改变了顺序


203
00:07:05,036 --> 00:07:06,796
然后有个新的项目进来了


204
00:07:07,516 --> 00:07:10,136
从概念上来讲


205
00:07:10,136 --> 00:07:11,796
apply() 知道


206
00:07:11,796 --> 00:07:12,996
当前的状态和新状态


207
00:07:12,996 --> 00:07:14,566
然后应用到 


208
00:07:14,566 --> 00:07:14,976
UI 元素上的


209
00:07:17,356 --> 00:07:19,096
没有第二步 这就完成了


210
00:07:19,096 --> 00:07:21,336
那我们该如何实现呢


211
00:07:21,336 --> 00:07:23,206
我们在所有平台上


212
00:07:23,376 --> 00:07:24,576
有四个类


213
00:07:25,226 --> 00:07:26,836
对于 iOS 和 tvOS


214
00:07:26,836 --> 00:07:27,686
我们有 UICollectionViewDiffableDataSource


215
00:07:27,686 --> 00:07:31,666
以及 UITableViewDiffableDataSource


216
00:07:31,666 --> 00:07:33,256
在 Mac 上 


217
00:07:33,636 --> 00:07:35,276
我们有 NSCollectionViewDiffableDataSource


218
00:07:36,046 --> 00:07:37,696
所有平台都通用的是


219
00:07:37,756 --> 00:07:39,796
这个 Snapshot 类


220
00:07:39,796 --> 00:07:40,856
它负责当前的


221
00:07:40,856 --> 00:07:43,846
UI 状态的 NSDiffableDataSourceSnapshot


222
00:07:44,896 --> 00:07:46,456
背景就介绍到这里


223
00:07:46,456 --> 00:07:48,126
我们接下来看一些代码


224
00:07:48,186 --> 00:07:49,376
为此我会让我的同事


225
00:07:49,376 --> 00:07:51,536
Troy Stephens 出来


226
00:07:51,766 --> 00:07:54,266
Troy [掌声]


227
00:07:54,516 --> 00:07:55,456
>> 非常感谢 Steve


228
00:07:56,116 --> 00:07:57,706
今天我很高兴


229
00:07:57,706 --> 00:07:59,266
带大家一起看一些


230
00:07:59,266 --> 00:08:00,746
使用这个强大而又


231
00:08:00,746 --> 00:08:02,956
漂亮简单的新 API 的例子


232
00:08:03,286 --> 00:08:04,526
因此如果你还没有


233
00:08:04,526 --> 00:08:06,086
下载本讲座的示例项目


234
00:08:06,086 --> 00:08:08,746
请务必下载 这样你就可以


235
00:08:08,966 --> 00:08:10,116
在空闲的时候跟着学习


236
00:08:10,466 --> 00:08:12,616
最重要的是


237
00:08:12,616 --> 00:08:14,946
用这个例子来


238
00:08:14,946 --> 00:08:16,616
真正理解所有这些东西是如何工作的


239
00:08:16,776 --> 00:08:17,776
它没有很多代码


240
00:08:18,066 --> 00:08:19,186
其实很简单


241
00:08:19,556 --> 00:08:22,076
当你查看这个示例项目时


242
00:08:22,076 --> 00:08:23,416
你会注意到


243
00:08:23,416 --> 00:08:24,796
除了我们今天将要查看的


244
00:08:24,846 --> 00:08:26,336
三个使用 DiffableDataSource 


245
00:08:26,336 --> 00:08:27,406
的示例之外


246
00:08:27,926 --> 00:08:29,816
这个项目还包含了


247
00:08:29,816 --> 00:08:31,266
我们在 215 会议中引入的


248
00:08:31,266 --> 00:08:32,645
功能强大的


249
00:08:32,645 --> 00:08:35,645
新组合布局 API 的示例


250
00:08:36,046 --> 00:08:37,626
这些例子恰好使用了


251
00:08:37,626 --> 00:08:39,905
DiffableDataSource 


252
00:08:40,006 --> 00:08:41,905
作为一种非常简单的方法


253
00:08:41,905 --> 00:08:42,936
将示例内容填充至


254
00:08:42,936 --> 00:08:43,746
CollectionView 中


255
00:08:44,256 --> 00:08:45,636
让我们操作演示机器


256
00:08:45,636 --> 00:08:45,976
一起来看一看


257
00:08:49,416 --> 00:08:51,116
我们的演示 App 在这里


258
00:08:51,496 --> 00:08:52,926
当我们今天


259
00:08:52,926 --> 00:08:54,496
讲解不同的例子时


260
00:08:54,776 --> 00:08:56,566
我们会注意到一个重复的模式


261
00:08:56,566 --> 00:08:58,676
这是一个简单的三步过程


262
00:08:59,186 --> 00:09:00,986
任何时候你想


263
00:09:00,986 --> 00:09:02,186
把一组新变化 新数据


264
00:09:02,186 --> 00:09:04,296
放到有完整数据源的


265
00:09:04,296 --> 00:09:05,776
CollectionView 或 UITableView 中


266
00:09:05,776 --> 00:09:08,676
你只需创建一个快照


267
00:09:09,306 --> 00:09:10,846
用要在更新周期中


268
00:09:10,846 --> 00:09:12,296
显示的项目描述


269
00:09:12,296 --> 00:09:13,856
填充快照


270
00:09:13,906 --> 00:09:15,756
然后应用快照


271
00:09:16,116 --> 00:09:17,376
更改将自动被


272
00:09:17,376 --> 00:09:19,356
提交到 UI


273
00:09:19,356 --> 00:09:20,786
DiffableDataSource 负责


274
00:09:20,786 --> 00:09:22,386
所有对 UI 元素的差异化对比


275
00:09:22,386 --> 00:09:23,556
和发布 UI 元素的更改


276
00:09:24,426 --> 00:09:25,946
我们来看一个具体的例子


277
00:09:25,946 --> 00:09:27,946
我要打开 Mountain Search


278
00:09:29,046 --> 00:09:30,526
这是一个很典型的


279
00:09:30,526 --> 00:09:31,236
搜索 UI 对吧?


280
00:09:31,236 --> 00:09:33,966
我们都能看到它 并推断出它的作用


281
00:09:34,216 --> 00:09:35,826
例如你可能在


282
00:09:35,826 --> 00:09:37,006
联系人 App 中看到这一点


283
00:09:37,006 --> 00:09:38,736
而在本例中 我们正在查看


284
00:09:38,736 --> 00:09:39,776
世界各地的山峰


285
00:09:40,626 --> 00:09:42,666
你可以想象


286
00:09:42,666 --> 00:09:43,626
在顶部有个搜索框


287
00:09:43,626 --> 00:09:45,046
当我开始输入搜索字段时


288
00:09:45,046 --> 00:09:46,666
我们希望看到


289
00:09:46,666 --> 00:09:48,556
列表自动过滤


290
00:09:48,556 --> 00:09:49,606
只显示匹配项


291
00:09:49,676 --> 00:09:51,426
我们会看到如果我开始输入


292
00:09:51,426 --> 00:09:54,176
我们做到了这一点


293
00:09:54,506 --> 00:09:55,456
这一切都是


294
00:09:55,456 --> 00:09:57,456
自动发生的


295
00:09:57,546 --> 00:09:58,356
还伴有优秀的动画


296
00:09:59,656 --> 00:10:01,626
这都是非常容易做到的


297
00:10:01,626 --> 00:10:03,896
用非常少的代码


298
00:10:03,976 --> 00:10:05,336
使用 DiffableDataSource 实现


299
00:10:05,336 --> 00:10:06,696
我们来看看它是如何工作的


300
00:10:08,336 --> 00:10:09,976
对于本例


301
00:10:09,976 --> 00:10:11,746
查看 MountainsViewController 源文件


302
00:10:13,486 --> 00:10:15,386
所有的行动都是从


303
00:10:15,386 --> 00:10:16,586
用户在搜索栏中进行输入


304
00:10:16,586 --> 00:10:17,136
开始的对吗


305
00:10:17,936 --> 00:10:19,256
这里有一个回调


306
00:10:19,256 --> 00:10:20,876
searchBarTextDidChange


307
00:10:20,876 --> 00:10:22,826
它将被发送至控制器


308
00:10:24,316 --> 00:10:25,796
从那里我们调用


309
00:10:25,836 --> 00:10:27,556
我们自己的 performQuery 函数


310
00:10:27,736 --> 00:10:29,466
传入的参数是


311
00:10:29,466 --> 00:10:30,926
我们从那个搜索栏得到搜索文本


312
00:10:31,306 --> 00:10:33,096
performQuery 本身


313
00:10:33,096 --> 00:10:34,116
非常简单


314
00:10:34,676 --> 00:10:37,236
我们所做的就是调用


315
00:10:37,236 --> 00:10:38,106
我们的 mountainsController


316
00:10:38,106 --> 00:10:39,566
这是我们模型层的对象


317
00:10:40,186 --> 00:10:42,106
我们要它提供一个经过过滤的


318
00:10:42,106 --> 00:10:44,266
排序的山峰列表


319
00:10:44,266 --> 00:10:45,636
与我们的搜索词相匹配


320
00:10:46,356 --> 00:10:48,126
我们现在有了这个山峰列表


321
00:10:49,616 --> 00:10:51,046
我们经历了我提到的


322
00:10:51,046 --> 00:10:52,156
三个步骤


323
00:10:52,196 --> 00:10:55,536
我们创建了一个新的
NSDiffableDataSourceSnapshot


324
00:10:56,476 --> 00:10:58,566
这个快照最初是空的


325
00:10:58,556 --> 00:10:59,456
里面什么也没有


326
00:10:59,456 --> 00:11:01,136
所以由我们来填充


327
00:11:01,136 --> 00:11:03,466
我们想要的 Section 和 Item


328
00:11:04,296 --> 00:11:06,646
在本例中 我们只显示一个 Section


329
00:11:07,216 --> 00:11:08,436
我们只需添加一个 Section


330
00:11:08,716 --> 00:11:09,896
我们可以称它为


331
00:11:09,896 --> 00:11:11,976
主 Section


332
00:11:14,336 --> 00:11:17,356
接下来我们添加


333
00:11:17,356 --> 00:11:18,796
在此次更新中显示


334
00:11:18,796 --> 00:11:20,386
Item 标识符


335
00:11:21,156 --> 00:11:22,376
从形式上来讲


336
00:11:22,376 --> 00:11:23,446
我们通常在这里传递


337
00:11:23,446 --> 00:11:24,386
一个标识符数组


338
00:11:24,896 --> 00:11:27,126
但是在 Swift 中你也可以


339
00:11:27,126 --> 00:11:29,196
通过使用你自己原生的类型


340
00:11:29,366 --> 00:11:31,646
使传参变得更加优雅


341
00:11:31,646 --> 00:11:32,916
如果你有一个原生类型


342
00:11:32,916 --> 00:11:34,456
它甚至可以是一个值类型


343
00:11:34,456 --> 00:11:36,486
比如一个结构体或一个枚举


344
00:11:36,796 --> 00:11:38,396
如果该类型是可哈希的


345
00:11:38,506 --> 00:11:39,756
那你就可以根据


346
00:11:39,756 --> 00:11:41,076
你所做的 Swift 语义传递


347
00:11:41,076 --> 00:11:42,716
你的原生对象


348
00:11:42,716 --> 00:11:43,796
我们过一会儿会


349
00:11:43,796 --> 00:11:46,166
了解它是如何工作的


350
00:11:46,526 --> 00:11:48,286
我们现在已经构建了快照


351
00:11:48,286 --> 00:11:49,036
可以进行下一步了


352
00:11:49,796 --> 00:11:51,876
我们所要做的就是调用


353
00:11:51,876 --> 00:11:53,126
我们的 DiffableDataSource


354
00:11:53,126 --> 00:11:54,766
让它应用快照


355
00:11:55,196 --> 00:11:56,196
将差异展现出来


356
00:11:56,196 --> 00:11:57,776
DiffableDataSource 运行时


357
00:11:57,776 --> 00:11:59,606
会自动找出


358
00:11:59,606 --> 00:12:00,906
上一次更新和


359
00:12:00,906 --> 00:12:01,866
下一次更新之间的变化


360
00:12:02,276 --> 00:12:03,496
请注意这里根本没有代码


361
00:12:03,496 --> 00:12:05,296
我们不需要停下来并找出


362
00:12:05,296 --> 00:12:07,186
上一个更新周期中


363
00:12:07,186 --> 00:12:08,286
在用户输入当前字符之前


364
00:12:08,286 --> 00:12:12,206
显示的内容是什么


365
00:12:12,206 --> 00:12:13,176
一切都是自动处理的


366
00:12:13,176 --> 00:12:14,226
没什么好担心的


367
00:12:14,226 --> 00:12:16,976
我们不是在处理 IndexPaths


368
00:12:16,976 --> 00:12:18,046
它们脆弱又短暂对吧


369
00:12:18,086 --> 00:12:19,426
它们指的是


370
00:12:19,616 --> 00:12:20,856
某个特定的更新


371
00:12:20,856 --> 00:12:21,536
在不同的更新中


372
00:12:21,536 --> 00:12:22,306
有着不同的含义


373
00:12:22,716 --> 00:12:24,166
我们处理的标识符


374
00:12:24,166 --> 00:12:26,446
是鲁棒和持久的


375
00:12:26,566 --> 00:12:29,236
所以这里的操作 非常简单


376
00:12:30,636 --> 00:12:31,686
在我们离开这段代码之前


377
00:12:31,686 --> 00:12:32,726
我希望你注意到一些


378
00:12:32,726 --> 00:12:34,376
关于 Snapshot 的事情


379
00:12:34,376 --> 00:12:35,326
你可能已经注意到了


380
00:12:35,326 --> 00:12:37,816
它是 Swift 中的一个泛型类


381
00:12:37,816 --> 00:12:39,916
所以它的参数是


382
00:12:39,916 --> 00:12:42,126
我们决定使用的


383
00:12:42,126 --> 00:12:43,846
Section 标识符类型和


384
00:12:43,846 --> 00:12:44,696
Item 标识符类型


385
00:12:45,246 --> 00:12:48,816
首先看 Section 标识符类型这比较琐碎


386
00:12:48,816 --> 00:12:50,146
在一般情况下


387
00:12:50,576 --> 00:12:51,906
这是一种非常方便的技术


388
00:12:51,906 --> 00:12:52,906
你只需要一个 Section


389
00:12:52,906 --> 00:12:54,936
对吧 你可以为此声明


390
00:12:54,936 --> 00:12:55,606
一个枚举类型


391
00:12:56,166 --> 00:12:57,436
Swift 中枚举类型的一个好处是


392
00:12:57,436 --> 00:12:59,796
它们是 自动可哈希的


393
00:12:59,796 --> 00:13:01,536
为它们添加了可哈希性


394
00:13:01,976 --> 00:13:03,246
我们这里有一个枚举


395
00:13:03,246 --> 00:13:05,976
和一个 case 语句 没有其他的了


396
00:13:09,046 --> 00:13:10,076
对于我们的 Mountain 类型


397
00:13:10,076 --> 00:13:13,566
我们将查看 MountainsController


398
00:13:13,566 --> 00:13:14,276
也就是模型层


399
00:13:14,866 --> 00:13:16,586
我们在这把 Mountain 


400
00:13:16,586 --> 00:13:18,746
声明为一个 Swift 结构


401
00:13:19,296 --> 00:13:21,066
我们声明结构类型


402
00:13:21,066 --> 00:13:23,076
为 Hashable


403
00:13:23,076 --> 00:13:24,186
这样我们可以将它与 


404
00:13:24,186 --> 00:13:25,586
DiffableDataSource 一起使用


405
00:13:25,586 --> 00:13:26,966
而不是传递标识符


406
00:13:27,356 --> 00:13:28,816
重要的要求是


407
00:13:28,816 --> 00:13:31,186
每一座山都要用


408
00:13:31,246 --> 00:13:33,516
它的哈希值进行唯一识别


409
00:13:34,086 --> 00:13:36,866
所以我们通过给每座山


410
00:13:36,866 --> 00:13:38,726
自动生成唯一标识符


411
00:13:38,726 --> 00:13:40,786
来实现这一点


412
00:13:43,016 --> 00:13:48,606
在这里我们遵循了承诺的可哈希性


413
00:13:48,606 --> 00:13:50,916
我们只用那个标识符来


414
00:13:50,916 --> 00:13:51,666
提供哈希值


415
00:13:52,246 --> 00:13:53,156
这样我们就可以


416
00:13:53,156 --> 00:13:54,496
找到每一座山


417
00:13:54,636 --> 00:13:56,206
虽然每座山是值类型


418
00:13:56,206 --> 00:13:58,096
只是通过复制来传递


419
00:13:58,356 --> 00:13:59,746
没有可供引用的指针


420
00:14:00,026 --> 00:14:01,766
但是标识符和


421
00:14:01,766 --> 00:14:02,886
特定于该标识符的哈希值


422
00:14:02,886 --> 00:14:04,716
是它们足够独特


423
00:14:04,716 --> 00:14:06,056
以便 DiffableDataSource 


424
00:14:06,056 --> 00:14:07,376
可以追踪它们 从一个更新


425
00:14:07,376 --> 00:14:08,296
到下一个更新


426
00:14:08,506 --> 00:14:09,926
作为可哈希性的一部分


427
00:14:09,926 --> 00:14:11,486
我们也在这里进行了


428
00:14:11,486 --> 00:14:12,466
相等测试


429
00:14:12,946 --> 00:14:14,826
因此我们已经了解如何


430
00:14:14,826 --> 00:14:16,216
对 DiffableDataSource 发布更改


431
00:14:19,146 --> 00:14:20,166
让我们回到


432
00:14:20,166 --> 00:14:21,176
MountainsViewController


433
00:14:23,936 --> 00:14:25,636
非常方便的是


434
00:14:25,636 --> 00:14:26,766
我们创建了一个名为


435
00:14:26,906 --> 00:14:28,066
ConfigureDataSource 的函数


436
00:14:28,066 --> 00:14:29,376
我们在其中配置数据源


437
00:14:29,726 --> 00:14:30,806
代码量


438
00:14:30,806 --> 00:14:31,516
真的很少


439
00:14:33,106 --> 00:14:34,146
在本例中


440
00:14:34,146 --> 00:14:35,666
我们使用的是 UICollectionView


441
00:14:35,666 --> 00:14:36,666
所以我们实例化一个


442
00:14:36,666 --> 00:14:38,966
UICollectionViewDiffableDataSource


443
00:14:39,446 --> 00:14:41,886
我们传递的参数是


444
00:14:41,886 --> 00:14:43,696
Section 和 Item 类型


445
00:14:44,656 --> 00:14:45,866
把一个指向


446
00:14:45,866 --> 00:14:46,886
我们想要使用的 CollectionView 的指针


447
00:14:46,886 --> 00:14:47,286
也传递过去


448
00:14:47,956 --> 00:14:49,236
DiffableDataSource 会接受


449
00:14:49,236 --> 00:14:50,546
那个指针并自动


450
00:14:50,546 --> 00:14:52,586
接通自身作为


451
00:14:52,586 --> 00:14:53,746
CollectionView 的数据源


452
00:14:53,746 --> 00:14:54,906
我们不需要继续操作


453
00:14:57,406 --> 00:14:59,226
最后我们有这个


454
00:14:59,226 --> 00:15:00,586
尾随闭包参数


455
00:15:00,586 --> 00:15:02,226
用于 DiffableDataSource 的初始化


456
00:15:02,746 --> 00:15:04,366
所有这些


457
00:15:04,366 --> 00:15:06,256
都是你通常需要写的代码


458
00:15:06,256 --> 00:15:07,726
如果你从头开始


459
00:15:07,726 --> 00:15:09,396
实现你自己的数据源


460
00:15:09,396 --> 00:15:11,766
你将要实现 cellForItem(at: IndexPath) 方法


461
00:15:12,156 --> 00:15:13,896
这是数据源回调方法


462
00:15:13,896 --> 00:15:15,426
和我们在此处做的工作


463
00:15:15,426 --> 00:15:16,806
一模一样


464
00:15:17,236 --> 00:15:18,946
我们回调至


465
00:15:18,946 --> 00:15:22,226
CollectionView 并请求它


466
00:15:22,226 --> 00:15:24,246
提供适当类型的 Cell


467
00:15:24,246 --> 00:15:25,766
显示我们想要的数据


468
00:15:25,766 --> 00:15:28,296
我们用想要显示的内容


469
00:15:28,296 --> 00:15:29,276
填充该 Cell


470
00:15:29,276 --> 00:15:30,386
然后将其返回


471
00:15:30,526 --> 00:15:31,786
所以这只是使用了


472
00:15:31,786 --> 00:15:34,116
cellForItem(at: IndexPath) 代码


473
00:15:34,256 --> 00:15:35,526
并方便地将其移植到


474
00:15:35,526 --> 00:15:36,906
一个很好的闭包封装中


475
00:15:36,906 --> 00:15:38,646
是我们在实例化数据源时


476
00:15:38,646 --> 00:15:40,046
传递的


477
00:15:40,726 --> 00:15:41,766
有一个很好很方便的


478
00:15:41,766 --> 00:15:44,346
不同在于 除了提供我们


479
00:15:44,346 --> 00:15:46,186
要求的 Item


480
00:15:46,186 --> 00:15:47,866
IndexPath 之外


481
00:15:47,866 --> 00:15:49,846
也提供了其标识符


482
00:15:49,846 --> 00:15:52,486
在本例中 


483
00:15:52,546 --> 00:15:54,376
是原生的 Swift 值类型


484
00:15:54,536 --> 00:15:55,686
这对应于我们想要


485
00:15:55,686 --> 00:15:56,566
显示的特定 Item


486
00:15:57,506 --> 00:15:59,636
所以我们把 mountain 作为参数传递


487
00:15:59,636 --> 00:16:00,746
没有更多的工作要做


488
00:16:00,746 --> 00:16:02,086
我们不必使用


489
00:16:02,086 --> 00:16:04,326
IndexPath 去查找


490
00:16:04,326 --> 00:16:07,146
它属于哪个模型层对象


491
00:16:07,456 --> 00:16:09,436
我们只是把 mountain 作为参数传递


492
00:16:09,436 --> 00:16:10,756
我们获取到山的名称


493
00:16:10,756 --> 00:16:13,096
并将其设置为该 Cell 的


494
00:16:13,096 --> 00:16:14,676
标签文本


495
00:16:15,676 --> 00:16:17,096
这就是全部内容


496
00:16:17,416 --> 00:16:18,916
关于如何设置


497
00:16:18,916 --> 00:16:20,196
和配置 CollectionView


498
00:16:20,196 --> 00:16:22,636
的所有其他内容都与之前相同


499
00:16:22,906 --> 00:16:24,666
在这个示例代码中


500
00:16:24,666 --> 00:16:25,826
没有隐藏任何


501
00:16:25,826 --> 00:16:26,556
performBatchUpdates() 代码


502
00:16:26,966 --> 00:16:27,916
这就是所有内容


503
00:16:27,916 --> 00:16:29,976
非常简单 来看看另一个例子


504
00:16:34,066 --> 00:16:36,536
这里我们有一个来自 iOS


505
00:16:36,536 --> 00:16:39,526
熟悉的 Wi-Fi 设置 UI 模型


506
00:16:39,526 --> 00:16:41,266
这个只比上一个


507
00:16:41,266 --> 00:16:42,626
稍微复杂一点


508
00:16:42,626 --> 00:16:43,936
因为我们在这里


509
00:16:43,936 --> 00:16:46,006
有两个不同的部分


510
00:16:46,396 --> 00:16:47,906
我们在顶部有个


511
00:16:47,906 --> 00:16:49,466
叫 Config 的部分


512
00:16:49,466 --> 00:16:51,686
其中有 Wi-Fi 启用/禁用开关


513
00:16:52,056 --> 00:16:53,966
并显示我们


514
00:16:53,966 --> 00:16:55,646
连接的当前网络


515
00:16:55,816 --> 00:16:58,136
在这下面我们有另一个动态更新的部分


516
00:16:58,136 --> 00:17:00,386
向我们展示了


517
00:17:00,386 --> 00:17:02,446
检测网络的列表


518
00:17:02,476 --> 00:17:03,986
供我们连接


519
00:17:05,205 --> 00:17:06,386
另外需要注意的是


520
00:17:06,386 --> 00:17:07,626
如果我们点击 Wi-Fi


521
00:17:07,626 --> 00:17:10,286
禁用开关


522
00:17:10,286 --> 00:17:11,646
或重新打开


523
00:17:12,556 --> 00:17:15,546
我们会看到一个流畅的 动画的


524
00:17:15,546 --> 00:17:16,136
UI 折叠或展开


525
00:17:16,136 --> 00:17:17,846
所有这些都可以使用


526
00:17:17,846 --> 00:17:18,826
DiffableDataSource 轻松实现


527
00:17:18,965 --> 00:17:20,746
让我们来看看这个


528
00:17:20,746 --> 00:17:22,356
动态 UI 是如何实现的


529
00:17:23,626 --> 00:17:25,906
转到我们的 WiFiSettingsViewController


530
00:17:28,036 --> 00:17:31,186
我们将查看 updateUI 函数


531
00:17:31,186 --> 00:17:32,586
我们将该函数命名为 updateUI


532
00:17:32,586 --> 00:17:34,046
我们已经注意到确保


533
00:17:34,046 --> 00:17:35,286
在我们需要显示的内容


534
00:17:35,626 --> 00:17:38,486
发生变化时它都会被调用


535
00:17:38,936 --> 00:17:39,896
大多数时候


536
00:17:39,896 --> 00:17:41,436
可能是因为我们检测到的


537
00:17:41,436 --> 00:17:43,186
当前可用的网络集合发生了变化


538
00:17:43,186 --> 00:17:44,406
但也可能是因为


539
00:17:44,406 --> 00:17:46,056
用户切换了 Wi-Fi


540
00:17:46,056 --> 00:17:47,096
启用/禁用 按钮


541
00:17:47,366 --> 00:17:48,566
出现任何改变我们 UI 的东西


542
00:17:48,566 --> 00:17:50,386
我们都确保会调用它


543
00:17:51,786 --> 00:17:53,456
所以我们在这里仍然有


544
00:17:53,456 --> 00:17:54,806
相同的三步过程


545
00:17:55,316 --> 00:17:57,266
获得我们想要显示的数据后


546
00:17:57,266 --> 00:17:58,776
我们从获取


547
00:17:58,776 --> 00:18:00,106
配置项目开始


548
00:18:00,106 --> 00:18:01,606
因为我们通常需要这些


549
00:18:02,206 --> 00:18:04,146
我们继续创建一个快照


550
00:18:04,736 --> 00:18:06,726
这个快照最初也是空的


551
00:18:06,726 --> 00:18:07,566
那就让我们用我们想要


552
00:18:07,566 --> 00:18:07,976
展示的东西填充它


553
00:18:10,776 --> 00:18:12,366
我们添加的第一个 Section


554
00:18:12,366 --> 00:18:14,016
出现在顶端的配置部分


555
00:18:15,046 --> 00:18:16,386
我们添加它的 Item


556
00:18:16,386 --> 00:18:18,376
所以会有一个或两个 Item 是取决于


557
00:18:18,376 --> 00:18:19,326
Wi-Fi 是否启用


558
00:18:21,476 --> 00:18:23,076
如果现在启用了 Wi-Fi 


559
00:18:23,076 --> 00:18:25,026
我们也会想和后端


560
00:18:25,026 --> 00:18:25,716
和模型层交流


561
00:18:25,716 --> 00:18:28,836
索要可用网络的列表


562
00:18:29,396 --> 00:18:31,806
我们将把这个列表


563
00:18:31,806 --> 00:18:34,226
包装成一些我们


564
00:18:34,226 --> 00:18:35,946
在稍后会看到的项目类型中


565
00:18:38,256 --> 00:18:39,916
我们为该网络列表


566
00:18:39,916 --> 00:18:40,886
添加一个 Section


567
00:18:41,316 --> 00:18:43,326
然后我们要添加


568
00:18:43,326 --> 00:18:44,876
那个 Section 中的 Item


569
00:18:45,396 --> 00:18:46,246
请注意


570
00:18:46,246 --> 00:18:47,296
我们在这里有


571
00:18:47,396 --> 00:18:49,266
两个不同的 Section


572
00:18:49,266 --> 00:18:51,983
我们可以明确哪个 Section 添加了 Item


573
00:18:55,056 --> 00:18:56,316
就是这样 我们准备好了


574
00:18:56,316 --> 00:18:58,086
我们已经描述了所有我们想展示的内容


575
00:18:58,336 --> 00:18:59,266
所以我们只需让


576
00:18:59,266 --> 00:19:00,756
DiffableDataSource 


577
00:19:00,756 --> 00:19:02,636
应用这些更改


578
00:19:02,666 --> 00:19:03,796
可以以动画的形式展现差异


579
00:19:04,236 --> 00:19:05,596
可能有时候


580
00:19:05,596 --> 00:19:06,816
你想要选择


581
00:19:06,816 --> 00:19:07,386
不用动画展现差异


582
00:19:07,386 --> 00:19:08,626
例如


583
00:19:08,626 --> 00:19:09,776
当你第一次打开 UI


584
00:19:09,776 --> 00:19:11,306
并显示初始数据集时


585
00:19:11,626 --> 00:19:13,116
你可能想 也可能不想要动画


586
00:19:13,396 --> 00:19:15,306
通常你希望它是即时的


587
00:19:15,536 --> 00:19:16,506
因此你可以将


588
00:19:16,636 --> 00:19:17,516
animatingDifferences 设为 false


589
00:19:17,516 --> 00:19:17,976
就像我们在本例中做的一样


590
00:19:22,436 --> 00:19:23,826
看我们这里使用的类型


591
00:19:23,826 --> 00:19:24,596
我们将一个 Section 类型


592
00:19:24,596 --> 00:19:26,166
和一个 Item 类型


593
00:19:26,166 --> 00:19:27,466
作为参数提供给


594
00:19:27,466 --> 00:19:28,426
DiffableDataSource


595
00:19:29,226 --> 00:19:30,606
回到顶部我们可以看到


596
00:19:30,606 --> 00:19:31,646
正如我们想象的一样


597
00:19:31,646 --> 00:19:33,066
Section 仍然是枚举类型


598
00:19:33,066 --> 00:19:34,286
我们在这里需要


599
00:19:34,286 --> 00:19:35,666
两个不同的 Section


600
00:19:37,106 --> 00:19:39,586
再次 作为枚举类型的 Section


601
00:19:39,586 --> 00:19:40,836
在 Swift 中是自动可哈希的


602
00:19:40,836 --> 00:19:41,976
所以我们很高兴


603
00:19:44,206 --> 00:19:45,796
然后我们在这里声明了一个 Item 类型


604
00:19:45,866 --> 00:19:47,306
这是一种结构体类型


605
00:19:47,306 --> 00:19:47,966
与 Mountains 一样


606
00:19:48,296 --> 00:19:50,046
我们声明它是可哈希的


607
00:19:50,756 --> 00:19:52,226
声明这个类型的原因是


608
00:19:52,226 --> 00:19:53,536
当我们查看列表时


609
00:19:53,536 --> 00:19:55,416
它主要包含列表是


610
00:19:55,416 --> 00:19:57,736
其中的网络项目


611
00:19:57,736 --> 00:19:58,766
但除此之外


612
00:19:58,766 --> 00:20:00,406
上面还有个不同的项目


613
00:20:00,406 --> 00:20:02,136
就是 Wi-Fi 启用/禁用开关


614
00:20:02,136 --> 00:20:03,236
那不是网络项目


615
00:20:03,236 --> 00:20:04,826
所以我们这里有一个异构列表


616
00:20:05,126 --> 00:20:06,266
我们所做的就是


617
00:20:06,266 --> 00:20:08,336
用这种通用包装器类型


618
00:20:08,336 --> 00:20:09,586
封装每个 Item


619
00:20:10,446 --> 00:20:11,946
但是由于这个包装器类型


620
00:20:11,946 --> 00:20:13,556
是我们要传递给 DiffableDataSource


621
00:20:13,556 --> 00:20:14,666
的项目类型


622
00:20:14,666 --> 00:20:16,236
我们必须注意确保


623
00:20:16,236 --> 00:20:17,696
它是可哈希的并且


624
00:20:17,696 --> 00:20:18,686
项目是由哈希值


625
00:20:18,686 --> 00:20:20,186
唯一标识的


626
00:20:21,026 --> 00:20:23,796
所以对于网络项目


627
00:20:23,796 --> 00:20:25,866
我们可以从 netowrk Item


628
00:20:25,866 --> 00:20:26,816
得到唯一标识符


629
00:20:26,816 --> 00:20:29,306
移植到 Network Item 中


630
00:20:30,786 --> 00:20:32,146
对于配置项目


631
00:20:32,146 --> 00:20:33,606
我们只是动态


632
00:20:33,606 --> 00:20:34,426
生成 UUID


633
00:20:36,866 --> 00:20:38,026
再看看我们的


634
00:20:38,026 --> 00:20:40,296
哈希函数


635
00:20:40,366 --> 00:20:42,176
它只是基于唯一标识符


636
00:20:42,176 --> 00:20:43,406
计算哈希值


637
00:20:43,406 --> 00:20:44,616
而这就是


638
00:20:44,616 --> 00:20:45,916
DiffableDataSource 能够


639
00:20:45,916 --> 00:20:47,516
识别从一个更新周期


640
00:20:47,516 --> 00:20:50,176
到下一个更新周期时相同的项目所需的全部内容


641
00:20:51,616 --> 00:20:52,816
让我们看看


642
00:20:52,816 --> 00:20:53,696
配置数据源的位置


643
00:20:55,616 --> 00:20:57,486
这与之前非常相似


644
00:20:57,486 --> 00:20:59,256
除了这次


645
00:20:59,256 --> 00:21:00,886
我们用的是 UITableView


646
00:21:01,306 --> 00:21:02,696
从创建和提交 


647
00:21:02,766 --> 00:21:04,886
快照的角度来看


648
00:21:04,886 --> 00:21:06,336
这并不重要


649
00:21:06,336 --> 00:21:07,396 
API 非常相似


650
00:21:07,396 --> 00:21:08,986
但对于设置


651
00:21:08,986 --> 00:21:10,236
我们必须实例化正确类型的


652
00:21:10,266 --> 00:21:11,186
DiffableDataSource


653
00:21:11,286 --> 00:21:13,496
我们有一个 UITableViewDiffableDataSource


654
00:21:14,406 --> 00:21:16,066
我们用将要使用的


655
00:21:16,066 --> 00:21:18,506
Section 和 Item 类型作为参数


656
00:21:18,506 --> 00:21:19,486
然后传递一个


657
00:21:19,486 --> 00:21:20,996
指向 TableView 的指针


658
00:21:21,066 --> 00:21:24,056
它将进行连接


659
00:21:24,056 --> 00:21:26,196
把 DiffableDataSource 作为数据源


660
00:21:27,646 --> 00:21:29,326
最后我们得到了


661
00:21:29,356 --> 00:21:30,526
提供 Item 的尾随闭包


662
00:21:30,696 --> 00:21:32,926
乍一看起来


663
00:21:32,926 --> 00:21:35,126
这更复杂


664
00:21:35,126 --> 00:21:36,386
但实际上只是因为


665
00:21:36,386 --> 00:21:37,896
我们有各种不同类型的项目


666
00:21:37,896 --> 00:21:39,606
我们要显示的项目是异质的


667
00:21:39,606 --> 00:21:41,056
基本上有三种类型的项目


668
00:21:41,396 --> 00:21:42,646
我们以不同的方式处理它们


669
00:21:43,696 --> 00:21:44,626
但是这段代码中


670
00:21:44,626 --> 00:21:45,036
即使我们没有使用


671
00:21:45,036 --> 00:21:46,106
DiffableDataSource 


672
00:21:46,106 --> 00:21:46,366
它也会存在


673
00:21:46,366 --> 00:21:47,886
它会在 cellForItem(at: IndexPath)


674
00:21:47,966 --> 00:21:49,486
方法中出现


675
00:21:50,166 --> 00:21:52,846
设置这个 UI 很简单


676
00:21:52,846 --> 00:21:54,346
甚至配置


677
00:21:54,346 --> 00:21:55,976
DiffableDataSource 也不是那么难


678
00:21:57,416 --> 00:22:00,166
最后一个例子


679
00:22:00,166 --> 00:22:01,226
可能是最有趣的


680
00:22:01,556 --> 00:22:02,566
这里我们有一个


681
00:22:02,566 --> 00:22:05,036
UICollectionView 


682
00:22:05,036 --> 00:22:06,286
它显示的项目


683
00:22:06,286 --> 00:22:08,276
表示为色卡


684
00:22:08,746 --> 00:22:09,786
它们一开始是


685
00:22:09,786 --> 00:22:12,036
随机混色的


686
00:22:12,626 --> 00:22:14,916
如果我点击 Sort 按钮


687
00:22:14,916 --> 00:22:16,666
我们可以看着它们被迭代排序


688
00:22:16,806 --> 00:22:18,426
为频谱顺序


689
00:22:19,316 --> 00:22:20,976
所以除了观看时令人着迷


690
00:22:20,976 --> 00:22:21,976
和有趣之外


691
00:22:21,976 --> 00:22:22,043
[笑声]


692
00:22:22,543 --> 00:22:25,576
[掌声]


693
00:22:26,076 --> 00:22:27,516
这要归功于 Steve


694
00:22:28,666 --> 00:22:29,806
除了观看时非常迷人


695
00:22:29,806 --> 00:22:31,466
和有趣之外


696
00:22:31,726 --> 00:22:33,256
这个例子与我们在其他例子中


697
00:22:33,256 --> 00:22:34,776
构建和提交


698
00:22:34,776 --> 00:22:36,706
更新的方式


699
00:22:36,706 --> 00:22:38,346
略有不同


700
00:22:39,036 --> 00:22:41,786
所以如果我们想


701
00:22:41,786 --> 00:22:42,976
如果我们的目标只是


702
00:22:42,976 --> 00:22:44,396
把所有的东西排序然后


703
00:22:44,396 --> 00:22:46,116
跳到最终状态 我们可以这么做对吧


704
00:22:46,386 --> 00:22:48,296
这个演示程序的设置


705
00:22:48,296 --> 00:22:51,006
使我们能够在


706
00:22:51,046 --> 00:22:52,296
每个中间阶段观察


707
00:22:52,326 --> 00:22:53,536
迭代排序过程


708
00:22:54,136 --> 00:22:55,586
为了做到这一点


709
00:22:55,586 --> 00:22:57,146
我们的排序功能


710
00:22:57,146 --> 00:22:58,176
会经过每个阶段


711
00:22:58,176 --> 00:22:59,646
并一步步给我们提供结果


712
00:22:59,646 --> 00:23:01,366
它为我们提供了


713
00:23:01,366 --> 00:23:03,356
每个连续的新状态 


714
00:23:03,356 --> 00:23:05,286
每次发生更新时


715
00:23:05,286 --> 00:23:06,536
我们都会创建一个快照


716
00:23:06,536 --> 00:23:07,146
并应用快照


717
00:23:07,146 --> 00:23:08,286
才有了这个


718
00:23:08,336 --> 00:23:09,876
美好有趣的动画视图


719
00:23:10,936 --> 00:23:11,786
来看看我们是


720
00:23:11,786 --> 00:23:12,686
如何实现它的


721
00:23:12,686 --> 00:23:12,976
以及它的不同之处


722
00:23:16,996 --> 00:23:17,776
我们将在这里查看


723
00:23:17,776 --> 00:23:19,496
InsertionSortViewController


724
00:23:21,576 --> 00:23:23,126
所有有趣的动作


725
00:23:23,126 --> 00:23:25,666
都发生在 PerformSortStep 函数中


726
00:23:26,876 --> 00:23:29,006
正如我所说


727
00:23:29,006 --> 00:23:30,266
总是有三步循环


728
00:23:30,266 --> 00:23:31,356
我们将获得一个快照


729
00:23:31,356 --> 00:23:33,506
填充它然后应用它


730
00:23:33,626 --> 00:23:36,916
但在这种情况下


731
00:23:36,916 --> 00:23:38,166
我们没有创建


732
00:23:38,166 --> 00:23:39,736
新的空快照


733
00:23:39,736 --> 00:23:41,016
而是利用 DiffableDataSource 的功能


734
00:23:41,436 --> 00:23:43,986
请求当前的快照


735
00:23:44,386 --> 00:23:46,046
现在这个快照


736
00:23:46,076 --> 00:23:47,766
预先填充了


737
00:23:47,856 --> 00:23:49,376
当前 CollectionView


738
00:23:49,376 --> 00:23:50,596
看到的 UICollectionView 中


739
00:23:50,596 --> 00:23:51,526
显示的内容的真实情况


740
00:23:52,576 --> 00:23:54,626
所以我们不必从头开始


741
00:23:54,776 --> 00:23:56,306
我们可以从该状态


742
00:23:56,306 --> 00:23:58,096
开始并计算下一个


743
00:23:58,556 --> 00:24:01,496
中间状态在这里


744
00:24:01,496 --> 00:24:02,786
我们填充 Snapshot


745
00:24:02,786 --> 00:24:05,156
我们将看到熟悉的 appendItems 


746
00:24:05,156 --> 00:24:05,726
函数被调用


747
00:24:05,726 --> 00:24:07,936
但我们这里也有一个 deleteItems 函数


748
00:24:08,236 --> 00:24:09,576
当你查看到


749
00:24:09,576 --> 00:24:10,986
Snapshot API 时


750
00:24:10,986 --> 00:24:12,296
你将会看到有各种各样的


751
00:24:12,296 --> 00:24:13,596
功能可以在你


752
00:24:13,596 --> 00:24:14,756
进行此类用法时


753
00:24:14,756 --> 00:24:15,786
修改现有 Snapshot


754
00:24:15,786 --> 00:24:17,356
你可以将 Item 从一个地方


755
00:24:17,356 --> 00:24:18,816
移到另一个地方 以此类推


756
00:24:19,656 --> 00:24:20,656
但在其他方面


757
00:24:20,706 --> 00:24:21,666
和之前没有什么区别


758
00:24:21,666 --> 00:24:22,736
我们只是想


759
00:24:22,736 --> 00:24:24,996
设置我们想要显示的新的最终状态


760
00:24:24,996 --> 00:24:27,066
我们使用的是标识符


761
00:24:27,066 --> 00:24:28,866
而不是 IndexPath


762
00:24:28,866 --> 00:24:29,776
这点很好


763
00:24:30,566 --> 00:24:33,386
最后当我们完成时


764
00:24:33,386 --> 00:24:35,176
我们所要做的就是


765
00:24:35,176 --> 00:24:36,706
将 Snapshot 应用于


766
00:24:36,706 --> 00:24:37,726
我们的 DiffableDataSource


767
00:24:38,556 --> 00:24:39,756
我们得到了这个好看的


768
00:24:40,446 --> 00:24:42,976
渐进式排序 非常好


769
00:24:43,041 --> 00:24:45,041
[掌声]


770
00:24:45,066 --> 00:24:49,556
谢谢 [掌声]


771
00:24:50,056 --> 00:24:51,286
这就是我们设置


772
00:24:51,286 --> 00:24:52,226
DiffableDataSource 的地方


773
00:24:52,226 --> 00:24:54,246
这是用于 UICollectionView


774
00:24:54,606 --> 00:24:56,436
我们指定我们使用的类型


775
00:24:56,436 --> 00:24:58,546
CollectionView


776
00:24:58,546 --> 00:25:00,026
我们还有提供 Item 的闭包


777
00:25:00,026 --> 00:25:01,596
也很简单


778
00:25:01,596 --> 00:25:02,636
因为我们只是


779
00:25:02,636 --> 00:25:03,716
显示这些色卡


780
00:25:04,926 --> 00:25:06,196
所以通过这三个例子


781
00:25:06,196 --> 00:25:08,866
我们可以看出


782
00:25:08,866 --> 00:25:11,306
创建这些


783
00:25:11,306 --> 00:25:13,046
动态 UI 所需的代码很少很简单


784
00:25:13,536 --> 00:25:15,986
这些 UI 对更改也有非常强的鲁棒性


785
00:25:15,986 --> 00:25:17,586
我们可以进行更改


786
00:25:17,586 --> 00:25:18,826
而不必担心在代码中


787
00:25:18,826 --> 00:25:20,086
出现奇怪的异常


788
00:25:20,086 --> 00:25:21,096
它们的鲁棒性都很强


789
00:25:21,096 --> 00:25:23,086
已经融入到了 API


790
00:25:23,086 --> 00:25:23,496
的工作原理中


791
00:25:24,166 --> 00:25:25,256
我们现在确实触及了一些


792
00:25:25,286 --> 00:25:27,066
有趣的细微差别


793
00:25:27,066 --> 00:25:29,096
特别是对象


794
00:25:29,096 --> 00:25:30,826
唯一标识的重要性


795
00:25:30,826 --> 00:25:31,946
如果你使用的是 Swift 类型


796
00:25:31,946 --> 00:25:34,276
这些 Swift 类型需要


797
00:25:34,276 --> 00:25:35,456
符合的要求是


798
00:25:35,456 --> 00:25:36,646
必须可哈希


799
00:25:37,096 --> 00:25:38,886
让我们进入更深的研究


800
00:25:38,886 --> 00:25:40,286
使这些问题成为


801
00:25:40,286 --> 00:25:40,836
讨论的焦点


802
00:25:40,926 --> 00:25:41,966
我现在要邀请我的同事


803
00:25:41,966 --> 00:25:43,656
Steve 再次上台


804
00:25:43,656 --> 00:25:47,626
谢谢 [掌声]


805
00:25:48,126 --> 00:25:50,356
>> 通过所有的演示


806
00:25:50,436 --> 00:25:52,836
我对这个 UI 是如何工作的


807
00:25:52,836 --> 00:25:53,816
有了一些了解


808
00:25:54,156 --> 00:25:56,046
我想对如何充分利用


809
00:25:56,046 --> 00:25:57,276
这个 API 进行


810
00:25:57,276 --> 00:25:58,976
更详细的讨论


811
00:26:02,656 --> 00:26:04,346
好的 首先


812
00:26:04,346 --> 00:26:05,236
正如我们在整个演示中看到的


813
00:26:05,236 --> 00:26:06,396
基本上有三个步骤


814
00:26:06,666 --> 00:26:07,856
你希望创建一个 Snapshot


815
00:26:08,906 --> 00:26:10,246
根据你的需要来配置它


816
00:26:10,246 --> 00:26:13,096
然后应用它 所以你总是希望调用


817
00:26:13,096 --> 00:26:13,806
apply() 方法


818
00:26:14,256 --> 00:26:15,576
而你不需要再


819
00:26:15,576 --> 00:26:16,766
调用 performBatchUpdates 方法了


820
00:26:16,986 --> 00:26:17,646
那已经过时了


821
00:26:17,946 --> 00:26:19,766
也不需要 insertItems 都没有了


822
00:26:19,946 --> 00:26:21,266
如果你调用这些函数


823
00:26:21,266 --> 00:26:22,066
框架会抱怨


824
00:26:22,296 --> 00:26:23,846
你知道


825
00:26:23,846 --> 00:26:28,306
你会看到的创建快照


826
00:26:28,306 --> 00:26:29,706
有两种方法


827
00:26:29,766 --> 00:26:31,276
最常见的方法


828
00:26:31,276 --> 00:26:32,486
是创建一个空的快照


829
00:26:32,706 --> 00:26:33,816
在这里我们看到


830
00:26:33,816 --> 00:26:35,206
我们用 Section 和 Item 类型


831
00:26:35,206 --> 00:26:36,996
构建 Snapshot 


832
00:26:38,376 --> 00:26:39,736
你也可以创建一个


833
00:26:39,736 --> 00:26:40,696
就像我们在最后一个


834
00:26:40,696 --> 00:26:41,896
演示中看到的那样


835
00:26:41,896 --> 00:26:42,766
当某个动作发生


836
00:26:42,766 --> 00:26:44,196
你需要修改


837
00:26:44,196 --> 00:26:45,326
一个小地方时


838
00:26:45,326 --> 00:26:50,036
这非常有用 现在当你创建它时


839
00:26:50,036 --> 00:26:50,936
你将得到一份副本


840
00:26:51,056 --> 00:26:52,696
所以你可以随意改变它


841
00:26:52,696 --> 00:26:54,066
它不会影响


842
00:26:54,206 --> 00:26:55,976
它的数据源


843
00:26:58,186 --> 00:26:59,456
一旦你有了这个快照


844
00:26:59,456 --> 00:27:00,836
如果你提出了一些问题


845
00:27:00,836 --> 00:27:01,856
比如 Item 的数量是多少


846
00:27:01,856 --> 00:27:02,746
Section 的数量是多少


847
00:27:02,846 --> 00:27:03,946
识别标识符


848
00:27:04,286 --> 00:27:06,296
你都可以做到 你可以在 SDK 中


849
00:27:06,296 --> 00:27:07,976
查看到很多 API 这里只展示了一些


850
00:27:11,156 --> 00:27:12,296
我保证过


851
00:27:12,296 --> 00:27:13,146
不再有 IndexPath


852
00:27:13,146 --> 00:27:14,456
因此当我们配置


853
00:27:14,456 --> 00:27:16,496
这些快照时


854
00:27:16,496 --> 00:27:18,666
你将永远不会通过显示的 API 


855
00:27:18,666 --> 00:27:20,516
看到 IndexPath


856
00:27:21,066 --> 00:27:22,506
所以到目前为止


857
00:27:22,506 --> 00:27:23,846
我们已经看到了一种


858
00:27:23,846 --> 00:27:25,226
非常常见的添加 Section 和 Item 的模式


859
00:27:25,226 --> 00:27:26,026
诸如此类


860
00:27:26,026 --> 00:27:27,026
但你也可以执行


861
00:27:27,026 --> 00:27:28,456
插入 移动 和删除等操作


862
00:27:29,246 --> 00:27:31,226
所有这些 API 都采用


863
00:27:31,456 --> 00:27:34,276
其他相对标识符


864
00:27:34,276 --> 00:27:35,596
来进行标示


865
00:27:35,596 --> 00:27:37,426
如果我想插入 20 个


866
00:27:37,426 --> 00:27:38,746
唯一的新标识符


867
00:27:39,686 --> 00:27:40,776
在另一个标识符之前或之后插入


868
00:27:40,776 --> 00:27:42,736
我们完成任务的


869
00:27:42,736 --> 00:27:43,336
明确的 API


870
00:27:43,336 --> 00:27:44,256
所以你会说


871
00:27:44,256 --> 00:27:45,566
在这个标识符之前


872
00:27:45,566 --> 00:27:46,236
插入这些标识符


873
00:27:47,056 --> 00:27:49,246
现在如果你在特定 Section 中


874
00:27:49,246 --> 00:27:50,316
没有任何内容


875
00:27:50,316 --> 00:27:51,536
则没有标识符可以


876
00:27:51,536 --> 00:27:53,086
锚定插入或移动


877
00:27:53,696 --> 00:27:55,356
这就是我们提供 append API 的原因


878
00:27:55,356 --> 00:27:57,586
你可以添加 Section 和 Item


879
00:27:58,836 --> 00:28:00,316
现在在你熟悉的路径中


880
00:28:00,316 --> 00:28:01,106
你有许多 Section


881
00:28:01,106 --> 00:28:03,386
你在这里配置你的快照


882
00:28:03,386 --> 00:28:04,866
你可以循环遍历 Section 数据


883
00:28:04,866 --> 00:28:05,996
在这种情况下


884
00:28:05,996 --> 00:28:08,316
可以在不指定 Section 的情况下添加 Item


885
00:28:08,316 --> 00:28:09,456
Swift 中有一个


886
00:28:09,456 --> 00:28:11,426
默认参数指定为 null


887
00:28:11,666 --> 00:28:13,246
在这种情况下


888
00:28:13,246 --> 00:28:14,966
是默认添加到最后一个已知的 Section


889
00:28:14,966 --> 00:28:15,976
这使得代码非常美观


890
00:28:19,066 --> 00:28:21,246
我们再来谈谈标识符


891
00:28:21,986 --> 00:28:22,896
这些必须是唯一的


892
00:28:23,386 --> 00:28:25,726
这不是一个大问题


893
00:28:25,726 --> 00:28:26,896
因为大多数 App 


894
00:28:26,896 --> 00:28:28,616
在其模型对象中都有


895
00:28:28,616 --> 00:28:29,426
某种身份概念


896
00:28:29,916 --> 00:28:31,456
因此使用该唯一标识符


897
00:28:31,456 --> 00:28:32,976
是很自然的步骤


898
00:28:35,046 --> 00:28:35,936
现在在 Swift 中


899
00:28:35,936 --> 00:28:37,096
需要符合可哈希的要求


900
00:28:37,526 --> 00:28:38,976
这很方便


901
00:28:38,976 --> 00:28:39,926
Swift 中的很多东西


902
00:28:39,926 --> 00:28:40,536
都会自动完成


903
00:28:40,536 --> 00:28:42,356
我们在枚举类型中


904
00:28:42,356 --> 00:28:42,976
看到了这种自动合成


905
00:28:45,646 --> 00:28:47,466
我们有字符串


906
00:28:47,466 --> 00:28:48,956
整数和 UUID


907
00:28:48,956 --> 00:28:50,456
所有这些可用于


908
00:28:50,456 --> 00:28:51,286
DiffableDataSource 的东西


909
00:28:52,746 --> 00:28:54,636
现在我们看到了


910
00:28:54,636 --> 00:28:56,266
你可以将一些模型数据


911
00:28:56,266 --> 00:28:57,396
引入这些标识符


912
00:28:57,496 --> 00:28:58,626
这真的很方便


913
00:28:58,996 --> 00:29:00,266
现在你的身份需要来自


914
00:29:00,266 --> 00:29:01,506
某个唯一的标识符


915
00:29:01,856 --> 00:29:03,816
但你也可以引入其他属性


916
00:29:03,816 --> 00:29:05,536
当我们看到山峰的名字时


917
00:29:05,536 --> 00:29:07,666
也可以找到我们例子中的对象


918
00:29:08,536 --> 00:29:09,426
这非常方便


919
00:29:09,426 --> 00:29:10,656
因为当你配置你的 Cell 时


920
00:29:10,656 --> 00:29:11,866
你所需要的所有东西


921
00:29:11,866 --> 00:29:12,966
都在这里


922
00:29:12,966 --> 00:29:13,926
别去别的地方找了


923
00:29:18,056 --> 00:29:19,816
这是一个小的快速模版


924
00:29:19,816 --> 00:29:20,886
我们在整个示例中一直有看到


925
00:29:20,886 --> 00:29:22,086
关于如何


926
00:29:22,086 --> 00:29:26,966
在 Swift 创建可哈希的结构体非常直观


927
00:29:30,506 --> 00:29:31,246
那么基于 IndexPath 的


928
00:29:31,466 --> 00:29:32,636
API 要怎么处理呢


929
00:29:32,636 --> 00:29:34,926
我们有 CollectionView 和 TableView


930
00:29:34,926 --> 00:29:36,656
它们有大量基于 IndexPath 的 API


931
00:29:36,656 --> 00:29:38,276
其中很多都在 Delegate 方法中


932
00:29:38,276 --> 00:29:40,176
因此如果用户与内容交互


933
00:29:40,176 --> 00:29:41,776
并点击某个项目


934
00:29:42,476 --> 00:29:43,356
你将得到这个熟悉的


935
00:29:43,356 --> 00:29:46,006
Delegate 消息 didSelectItemAt indexPath


936
00:29:47,126 --> 00:29:48,536
但是我们已经进入了这个


937
00:29:48,536 --> 00:29:49,636
基于标识符的新世界


938
00:29:49,636 --> 00:29:50,236
我们将如何处理


939
00:29:50,236 --> 00:29:51,066
这个 IndexPath


940
00:29:51,066 --> 00:29:51,906
你知道那是老一套


941
00:29:51,906 --> 00:29:54,236
所以我们这里有新的 API


942
00:29:54,296 --> 00:29:55,356
让你在标识符


943
00:29:55,356 --> 00:29:57,716
和 IndexPaths 之间进行转换


944
00:29:57,716 --> 00:29:59,196
然后从 IndexPaths 


945
00:29:59,196 --> 00:29:59,926
转化为标识符


946
00:29:59,926 --> 00:30:01,046
所以这里我们看一个例子


947
00:30:01,556 --> 00:30:04,606
我们正在使用过去的 IndexPath 


948
00:30:04,606 --> 00:30:06,746
并将其转换回标识符


949
00:30:06,746 --> 00:30:07,736
这会在常数时间内完成


950
00:30:07,846 --> 00:30:08,976
这非常非常快


951
00:30:12,426 --> 00:30:13,886
说到性能


952
00:30:14,906 --> 00:30:17,406
我们做了大量的工作


953
00:30:17,406 --> 00:30:19,516
让它尽可能更快


954
00:30:19,656 --> 00:30:20,606
还有很多


955
00:30:20,606 --> 00:30:21,976
低层次的东西非常重要


956
00:30:25,266 --> 00:30:26,646
如果你学过


957
00:30:26,646 --> 00:30:27,746
计算机科学


958
00:30:27,746 --> 00:30:29,176
关于差异对比是如何发生的整个概念


959
00:30:29,176 --> 00:30:30,516
你会知道这是


960
00:30:30,516 --> 00:30:31,606
一个 O(N) 的线性运算


961
00:30:31,606 --> 00:30:34,236
而简单来说


962
00:30:34,236 --> 00:30:35,276
它只是意味着你的 Item 越多


963
00:30:35,276 --> 00:30:36,976
你进行差异对比的时间越长


964
00:30:39,106 --> 00:30:40,236
因此在开发过程中


965
00:30:40,236 --> 00:30:42,006
衡量 App 很重要


966
00:30:42,006 --> 00:30:43,836
我们都知道这一点 我们希望确保


967
00:30:43,836 --> 00:30:46,076
主队列尽可能空闲


968
00:30:46,106 --> 00:30:48,766
以便真正响应用户事件


969
00:30:48,766 --> 00:30:50,376
我们渲染的非常快


970
00:30:50,896 --> 00:30:52,746
所以当你在测试你的 App 时


971
00:30:52,796 --> 00:30:53,536
你们都会测试 App


972
00:30:53,906 --> 00:30:55,566
在开发过程中 尤其是在结束时


973
00:30:55,746 --> 00:30:58,776
我想确保主队列上的尽可能的没有内容


974
00:30:59,906 --> 00:31:01,036
如果你发现线性差异对比中


975
00:31:01,036 --> 00:31:02,426
有大量 Item 需要花费


976
00:31:02,426 --> 00:31:03,526
额外的时间


977
00:31:03,526 --> 00:31:05,656
那么从后台队列


978
00:31:05,656 --> 00:31:06,966
调用 apply() 方法会比较安全


979
00:31:07,516 --> 00:31:14,336
[掌声]


980
00:31:14,836 --> 00:31:15,926
真正酷的是


981
00:31:15,986 --> 00:31:17,286
我们为了支持而使用的


982
00:31:17,286 --> 00:31:18,486
API 的数量


983
00:31:18,486 --> 00:31:19,376
没有 API


984
00:31:20,016 --> 00:31:21,046
[笑声]


985
00:31:21,046 --> 00:31:21,976
这就是最好的 API


986
00:31:22,031 --> 00:31:24,031
[欢呼声和掌声]


987
00:31:24,046 --> 00:31:28,046
对吗 那么如果从后台队列


988
00:31:28,046 --> 00:31:29,586
调用 apply() 会发生什么


989
00:31:29,586 --> 00:31:30,886
实际上


990
00:31:30,886 --> 00:31:31,966
框架足够聪明可以知道


991
00:31:31,966 --> 00:31:32,856
现在不在主队列中


992
00:31:32,856 --> 00:31:34,056
它会说 让我们继续


993
00:31:34,056 --> 00:31:35,076
在这里进行差异对比


994
00:31:36,126 --> 00:31:37,716
一旦计算出差异


995
00:31:37,956 --> 00:31:39,086
我们就会跳到主队列


996
00:31:39,086 --> 00:31:40,926
应用我们差异对比的结果


997
00:31:40,926 --> 00:31:41,966
程序就像往常一样继续


998
00:31:45,256 --> 00:31:46,706
只有一个忠告


999
00:31:46,706 --> 00:31:47,696
我保证就一个


1000
00:31:48,406 --> 00:31:51,136
如果选择此模型从


1001
00:31:51,136 --> 00:31:52,466
后台调用 apply() 


1002
00:31:52,606 --> 00:31:53,226
则应保持一致


1003
00:31:53,626 --> 00:31:55,236
永远都从后台队列中调用它


1004
00:31:55,286 --> 00:31:56,486
你永远不希望发生混乱


1005
00:31:56,526 --> 00:31:58,226
一会从后台队列


1006
00:31:58,326 --> 00:32:00,786
一会儿从主队列调用它 请始终用同样的方法


1007
00:32:02,496 --> 00:32:03,566
我们是好公民


1008
00:32:03,566 --> 00:32:05,656
如果你弄错了 我们会抱怨的


1009
00:32:06,536 --> 00:32:08,016
所以在 Apple 公司


1010
00:32:08,216 --> 00:32:09,716
合作是很重要的一部分


1011
00:32:09,716 --> 00:32:11,166
这是我们组织的主要力量


1012
00:32:11,166 --> 00:32:12,666
是我们彼此交谈


1013
00:32:12,666 --> 00:32:14,616
和共同解决问题的方法


1014
00:32:15,286 --> 00:32:16,976
作为框架的作者


1015
00:32:16,976 --> 00:32:18,146
这其中的一部分是


1016
00:32:18,146 --> 00:32:19,456
确保你所有的客户


1017
00:32:19,456 --> 00:32:20,796
或者你经常与之交谈的人


1018
00:32:20,796 --> 00:32:22,366
找到困扰他们的问题所在


1019
00:32:22,756 --> 00:32:24,536
这显然是正在困扰他们的问题之一


1020
00:32:25,106 --> 00:32:27,636
在这期间我们和那些正在制作


1021
00:32:27,636 --> 00:32:29,146
Share Sheet 的人聊了聊


1022
00:32:29,146 --> 00:32:30,966
这是 iOS 13 中


1023
00:32:30,966 --> 00:32:33,786
重新设计的新 Share Sheet


1024
00:32:34,776 --> 00:32:36,076
具有出色的隔空投送扩展功能


1025
00:32:36,076 --> 00:32:38,026
当他们拥有这个全新的设计时 他们才发现


1026
00:32:38,026 --> 00:32:39,216
他们说 哦 这看起来很棒


1027
00:32:39,216 --> 00:32:40,976
我们需要这个 他们确实做到了


1028
00:32:41,016 --> 00:32:42,996
因此我想让一位


1029
00:32:42,996 --> 00:32:44,526
来自 Share Sheet 的同事


1030
00:32:44,526 --> 00:32:46,876
Jacob Klapper 来指导


1031
00:32:46,876 --> 00:32:48,546
我们完成这项工作 Jacob


1032
00:32:49,516 --> 00:32:54,426
[掌声]


1033
00:32:54,926 --> 00:32:57,596
>> 大家好 我很高兴向你们


1034
00:32:57,596 --> 00:32:58,586
展示 Share Sheet 


1035
00:32:58,586 --> 00:32:59,966
如何利用 iOS 13 中


1036
00:32:59,966 --> 00:33:02,976
新的 CollectionView API


1037
00:33:05,046 --> 00:33:06,066
我们在全新的


1038
00:33:06,066 --> 00:33:07,126
Share Sheet 中


1039
00:33:07,816 --> 00:33:08,786
Share Sheet 实际上


1040
00:33:08,786 --> 00:33:10,306
利用了新的


1041
00:33:10,306 --> 00:33:12,086
组合布局 API


1042
00:33:12,086 --> 00:33:13,406
和 DiffableDataSource


1043
00:33:13,406 --> 00:33:14,646
但 DiffableDataSource


1044
00:33:14,646 --> 00:33:16,126
真正闪耀的地方在于


1045
00:33:16,126 --> 00:33:17,446
全新的隔空投送扩展


1046
00:33:18,696 --> 00:33:21,176
因此隔空投送扩展程序


1047
00:33:21,176 --> 00:33:22,846
有一个浏览设备的浏览器


1048
00:33:23,156 --> 00:33:24,576
实际上我们已经


1049
00:33:24,576 --> 00:33:26,606
使用 UUID 来唯一标识


1050
00:33:26,606 --> 00:33:27,656
发现的每个设备


1051
00:33:28,166 --> 00:33:30,206
因此当发现新设备时


1052
00:33:30,206 --> 00:33:31,876
我们可以创建


1053
00:33:31,876 --> 00:33:34,036
一个空的快照啊


1054
00:33:34,036 --> 00:33:35,506
附加我们的 Section 和 Item


1055
00:33:35,506 --> 00:33:36,536
并应用差异对比


1056
00:33:36,876 --> 00:33:39,056
DiffableDataSource 负责其余部分


1057
00:33:39,056 --> 00:33:40,056
无论移除或


1058
00:33:40,056 --> 00:33:41,826
删除多少 Item


1059
00:33:41,826 --> 00:33:43,736
动画都很漂亮


1060
00:33:44,276 --> 00:33:46,196
DiffableDataSource 对我们来说


1061
00:33:46,196 --> 00:33:47,316
已经改变了游戏规则


1062
00:33:47,626 --> 00:33:48,986
我们迫不及待地想看看


1063
00:33:48,986 --> 00:33:50,566
你在 App 中用它做什么


1064
00:33:50,646 --> 00:33:51,866
现在舞台还给 Troy


1065
00:33:51,866 --> 00:33:53,486
听听他最后的想法


1066
00:33:55,516 --> 00:33:57,556
[掌声]


1067
00:33:58,056 --> 00:33:59,426
>> 天呐


1068
00:33:59,426 --> 00:34:00,456
听到 DiffableDataSource 


1069
00:34:00,456 --> 00:34:02,146
在我们自己的 App 中


1070
00:34:02,196 --> 00:34:03,566
发挥了如此大的作用


1071
00:34:03,566 --> 00:34:05,106
我非常兴奋


1072
00:34:05,106 --> 00:34:06,526
我们非常高兴


1073
00:34:06,526 --> 00:34:08,606
让我们内部采用的 API 


1074
00:34:08,606 --> 00:34:09,866
能够在我们的


1075
00:34:10,146 --> 00:34:12,976
平台上供开发者使用


1076
00:34:21,045 --> 00:34:22,505
我们今天已经看到


1077
00:34:22,505 --> 00:34:24,485
DiffableDataSource 极大地


1078
00:34:24,485 --> 00:34:26,416
简化了将模型数据


1079
00:34:26,416 --> 00:34:28,485
放到 CollectionViews 


1080
00:34:28,485 --> 00:34:31,676
和 UITableViews 中的工作


1081
00:34:31,976 --> 00:34:33,596
我们认为这真正改变了游戏规则


1082
00:34:33,596 --> 00:34:36,476
它使这个过程非常简单和鲁棒


1083
00:34:36,755 --> 00:34:38,516
不会再有令人困惑的异常


1084
00:34:38,696 --> 00:34:40,126
在调试和难以编写的


1085
00:34:40,186 --> 00:34:42,216
批处理代码中出现


1086
00:34:42,216 --> 00:34:44,025
你可以专注于


1087
00:34:44,025 --> 00:34:46,496
你想让你的 App 做什么上


1088
00:34:46,496 --> 00:34:49,315
把其他的留给框架 今天你可以在 iOS


1089
00:34:49,426 --> 00:34:53,186
tvOS 和 macOS 上


1090
00:34:53,186 --> 00:34:54,606
使用 DiffableDataSource 


1091
00:34:55,176 --> 00:34:57,016
除了为你计算差异对比


1092
00:34:57,016 --> 00:34:58,676
并自动将它


1093
00:34:58,906 --> 00:35:00,236
提交给 UI


1094
00:35:00,236 --> 00:35:01,936
你能得到这些


1095
00:35:01,936 --> 00:35:03,946
漂亮的动画对吧


1096
00:35:03,946 --> 00:35:05,516
你不需要做额外的工作


1097
00:35:05,516 --> 00:35:07,476
就能得到那种


1098
00:35:07,786 --> 00:35:09,316
令人愉快的用户交互效果


1099
00:35:10,126 --> 00:35:12,566
内置的差异对比很快


1100
00:35:12,566 --> 00:35:14,556
它经受了严峻的压力测试


1101
00:35:14,906 --> 00:35:17,296
DiffableDataSource 是一个鲁棒的 API 


1102
00:35:17,296 --> 00:35:19,086
你可以使用它


1103
00:35:19,086 --> 00:35:20,186
并运行它


1104
00:35:20,656 --> 00:35:22,686
快行动起来吧


1105
00:35:22,946 --> 00:35:24,526
在你的 App 中使用


1106
00:35:24,526 --> 00:35:25,656
DiffableDataSource


1107
00:35:25,986 --> 00:35:27,266
我们迫不及待地想要看到


1108
00:35:27,266 --> 00:35:28,356
这将减轻你的负担


1109
00:35:28,356 --> 00:35:31,176
你将能够用更少的时间


1110
00:35:31,176 --> 00:35:32,206
更少的烦恼


1111
00:35:32,206 --> 00:35:34,176
来创造令人愉快的用户体验


1112
00:35:36,636 --> 00:35:37,896
如果你觉得这个讲座有趣


1113
00:35:37,896 --> 00:35:39,256
而且你正在使用


1114
00:35:39,256 --> 00:35:40,426
CollectionViews


1115
00:35:40,426 --> 00:35:43,166
我们还有另一个 你会非常喜欢的会议名为


1116
00:35:43,166 --> 00:35:44,616
Advances in Collection View Layout


1117
00:35:44,976 --> 00:35:47,176
我们描述了一个全新的


1118
00:35:47,176 --> 00:35:48,706
布局系统


1119
00:35:48,706 --> 00:35:50,276
它可以简单地描述


1120
00:35:50,276 --> 00:35:51,736
你想要在 CollectionView 中


1121
00:35:51,736 --> 00:35:52,666
拥有的任何自定义布局


1122
00:35:52,986 --> 00:35:53,906
并且能够看到


1123
00:35:53,906 --> 00:35:55,356
它的实现


1124
00:35:55,356 --> 00:35:57,666
而不需要任何高性能的结果


1125
00:35:57,666 --> 00:35:58,916
所以我们觉得你会喜欢的


1126
00:35:58,916 --> 00:36:00,346
一定要参加那个会议


1127
00:36:01,316 --> 00:36:02,976
谢谢大家今天的收看


1128
00:36:03,516 --> 00:36:08,500
[掌声]

