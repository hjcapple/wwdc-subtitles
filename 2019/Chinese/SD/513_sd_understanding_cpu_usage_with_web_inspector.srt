1
00:00:01,176 --> 00:00:04,500
[音乐]


2
00:00:07,296 --> 00:00:08,966
>> 大家好 我是 Jonathan Davis


3
00:00:08,966 --> 00:00:10,626
Web 技术的传播者


4
00:00:10,626 --> 00:00:12,196
来自 Safari 和 WebKit 团队


5
00:00:12,686 --> 00:00:14,376
欢迎观看“使用网页检查器


6
00:00:14,376 --> 00:00:15,976
了解 CPU 使用率”


7
00:00:17,666 --> 00:00:20,676
众所周知 用户很在乎电池续航


8
00:00:20,676 --> 00:00:22,516
或许你们仅凭直觉就能猜到


9
00:00:22,516 --> 00:00:23,646
在我们的设备上


10
00:00:23,646 --> 00:00:25,726
网页浏览器是最常使用的 App 之一


11
00:00:26,236 --> 00:00:28,686
但除此之外 网页内容


12
00:00:28,686 --> 00:00:30,366
也出现在许多流行的


13
00:00:30,366 --> 00:00:32,616
iOS App 和 macOS App 里


14
00:00:33,226 --> 00:00:34,626
这意味着网页内容


15
00:00:34,626 --> 00:00:36,276
会显著影响用户的电池续航


16
00:00:36,276 --> 00:00:38,376
所以使它更节能


17
00:00:38,376 --> 00:00:40,246
会有很大影响


18
00:00:41,346 --> 00:00:42,736
Safari 浏览器和 Webkit 


19
00:00:42,736 --> 00:00:43,706
早就提供了这种功能


20
00:00:43,706 --> 00:00:45,226
也就是尽可能地


21
00:00:45,226 --> 00:00:47,096
自动为用户节能


22
00:00:47,096 --> 00:00:48,746
例如 当一个网页在后台运行时


23
00:00:48,746 --> 00:00:49,556
会调用节流定时器


24
00:00:50,456 --> 00:00:51,896
加上内容拦截插件的支持


25
00:00:51,896 --> 00:00:53,716
用户得以自行


26
00:00:53,716 --> 00:00:55,156
拦截不想加载的内容


27
00:00:55,156 --> 00:00:56,646
那些内容往往是垃圾信息


28
00:00:56,646 --> 00:00:58,006
拖慢浏览器速度


29
00:00:58,006 --> 00:00:59,976
甚至会追踪用户行为


30
00:01:01,896 --> 00:01:03,316
然而 即使 Safari 浏览器


31
00:01:03,316 --> 00:01:05,025
有内置的节能特性


32
00:01:05,275 --> 00:01:06,766
仍然有很多事


33
00:01:06,766 --> 00:01:08,616
是网页开发者能做的


34
00:01:08,616 --> 00:01:10,126
这对我们大家来说都是一个好机会


35
00:01:10,126 --> 00:01:11,646
来改善网页表现


36
00:01:11,646 --> 00:01:13,566
为用户构建节能的网页


37
00:01:14,786 --> 00:01:18,376
好消息是 你所知道的所有


38
00:01:18,376 --> 00:01:20,796
优化网页表现的做法


39
00:01:20,796 --> 00:01:22,896
同时也是最好的节能手段


40
00:01:23,486 --> 00:01:24,946
我们听说过的所有


41
00:01:24,946 --> 00:01:26,716
关于提升网页加载速度


42
00:01:27,166 --> 00:01:29,346
优化 JavaScript


43
00:01:29,346 --> 00:01:31,476
使用 CSS 动画属性与过渡属性


44
00:01:31,886 --> 00:01:33,496
都有助于延长电池续航


45
00:01:34,606 --> 00:01:35,756
无论你对所有这些


46
00:01:35,756 --> 00:01:36,976
提升网页表现的


47
00:01:36,976 --> 00:01:38,606
最优做法烂熟于心


48
00:01:38,606 --> 00:01:40,306
还是刚刚入门 我都会向你们展示


49
00:01:40,306 --> 00:01:42,056
网页检查器里的一款强大的新工具


50
00:01:42,056 --> 00:01:43,546
它会赋予你超能力


51
00:01:43,546 --> 00:01:45,996
便于你找出哪些表现尚有不足


52
00:01:45,996 --> 00:01:47,586
并以此延长电池续航


53
00:01:48,426 --> 00:01:50,406
我们叫它 CPU 使用率时间线


54
00:01:50,406 --> 00:01:52,676
它是网页检查器的一项新功能


55
00:01:52,676 --> 00:01:55,316
你会在 macOS 上的 Safari 13 里找到它


56
00:01:55,826 --> 00:01:57,336
它有一个电量使用窗口  


57
00:01:57,336 --> 00:01:58,906
使你能轻易发现


58
00:01:58,906 --> 00:02:00,036
那些导致 CPU 高使用率的


59
00:02:00,036 --> 00:02:01,926
行为带来的影响


60
00:02:03,996 --> 00:02:05,556
今天 我将向你们展示


61
00:02:05,556 --> 00:02:07,206
如何使用新的 CPU 使用率时间线


62
00:02:07,206 --> 00:02:11,846
发现 CPU 使用时的耗电问题


63
00:02:11,846 --> 00:02:13,386
接着我会简述一些策略


64
00:02:13,386 --> 00:02:16,276
使你的基于网页的项目变得更节能


65
00:02:17,276 --> 00:02:18,536
在你使用这个时间线之前


66
00:02:18,536 --> 00:02:20,066
你需要启用“开发”菜单


67
00:02:20,066 --> 00:02:22,156
来访问网页检查器


68
00:02:23,946 --> 00:02:25,616
只需打开 Safari 浏览器的偏好设置


69
00:02:25,936 --> 00:02:28,496
点击 高级


70
00:02:28,496 --> 00:02:31,506
点击 在菜单栏中显示“开发”菜单来启用它


71
00:02:33,256 --> 00:02:35,356
接着 打开一个网页


72
00:02:35,356 --> 00:02:36,546
从“开发”菜单中打开


73
00:02:36,546 --> 00:02:40,116
网页检查器 或者使用快捷键


74
00:02:40,116 --> 00:02:41,016
Command 加 Option 加 I


75
00:02:41,256 --> 00:02:44,056
接下来我会使用新的


76
00:02:44,056 --> 00:02:45,936
CPU 使用率时间线来寻找 webkit.org 上


77
00:02:45,936 --> 00:02:48,196
有哪些可以改善能耗的地方


78
00:02:48,326 --> 00:02:50,356
主页非常简单


79
00:02:50,676 --> 00:02:51,826
但也挺有趣


80
00:02:51,906 --> 00:02:54,186
还是有一些动态元素


81
00:02:54,186 --> 00:02:56,256
比如背景里不显眼的 logo 动画


82
00:02:58,776 --> 00:03:00,646
现在网页检查器已经打开


83
00:03:00,646 --> 00:03:02,036
点击时间线标签页


84
00:03:05,206 --> 00:03:07,716
左上角是不同时间线的列表


85
00:03:08,056 --> 00:03:10,246
也有其他时间线可用


86
00:03:10,246 --> 00:03:11,886
但是默认时间线下寻找


87
00:03:11,886 --> 00:03:13,826
如何改善 CPU 使用率就够了


88
00:03:16,236 --> 00:03:17,656
要想开始录制


89
00:03:17,656 --> 00:03:19,276
你可以点这个红色的“录制”按钮


90
00:03:19,276 --> 00:03:20,606
或者按下“空格”键


91
00:03:20,606 --> 00:03:21,876
但我会点击“刷新”按钮


92
00:03:21,876 --> 00:03:23,336
它会自动开始录制


93
00:03:23,336 --> 00:03:25,986
并且捕获页面加载情况


94
00:03:27,536 --> 00:03:29,736
当检查 CPU 使用率时


95
00:03:29,736 --> 00:03:32,766
一定要记住录制至少 15 秒


96
00:03:32,766 --> 00:03:35,186
以得到一次有效的测量


97
00:03:36,116 --> 00:03:37,616
我会让这次录制稍长一些


98
00:03:37,616 --> 00:03:39,396
来获取足够的数据


99
00:03:41,326 --> 00:03:42,306
在时间线上滚动滚轮


100
00:03:42,306 --> 00:03:43,796
来放大一些


101
00:03:43,796 --> 00:03:44,536
我就能看到所有细节


102
00:03:47,106 --> 00:03:48,786
点击 CPU 时间线


103
00:03:48,786 --> 00:03:50,356
你可以看到该网页


104
00:03:50,356 --> 00:03:51,466
CPU 使用率的细节


105
00:03:52,416 --> 00:03:54,136
只瞟一眼 我就能判断


106
00:03:54,136 --> 00:03:55,176
该网页表现不错


107
00:03:55,176 --> 00:03:56,576
能耗保持得很低


108
00:03:57,326 --> 00:03:58,896
加载时间短很有用


109
00:03:59,256 --> 00:04:01,346
如果页面闲置


110
00:04:01,676 --> 00:04:03,096
时间线显示该网页


111
00:04:03,096 --> 00:04:04,386
基本上什么都没有运行


112
00:04:05,016 --> 00:04:06,236
很棒 因为这意味着


113
00:04:06,236 --> 00:04:07,976
即使用户把网页开一天


114
00:04:07,976 --> 00:04:10,006
CPU 使用率也会掉到


115
00:04:10,006 --> 00:04:11,856
一个非常低的状态


116
00:04:11,856 --> 00:04:14,086
网页内容带来的功耗可忽略不计


117
00:04:16,416 --> 00:04:17,875
网页内容中许多有趣的事情


118
00:04:17,875 --> 00:04:20,005
都发生在主线程


119
00:04:20,596 --> 00:04:22,055
主线程图表显示了


120
00:04:22,055 --> 00:04:23,336
在主线程上完成的


121
00:04:23,496 --> 00:04:24,486
不同种类的工作


122
00:04:24,486 --> 00:04:26,056
包含 JavaScript 处理


123
00:04:26,466 --> 00:04:28,796
绘制 布局 以及


124
00:04:28,796 --> 00:04:30,846
布局服务内的 例如页面重绘


125
00:04:31,806 --> 00:04:32,896
基于这些 我们能看到


126
00:04:32,896 --> 00:04:34,336
大多数工作


127
00:04:34,336 --> 00:04:35,286
都花在了绘制上


128
00:04:35,756 --> 00:04:37,556
在指示器的中间


129
00:04:37,556 --> 00:04:38,826
显示了主线程


130
00:04:38,826 --> 00:04:40,046
完成工作所花的时间


131
00:04:40,326 --> 00:04:42,286
整个录制时间大概有 20 秒


132
00:04:42,286 --> 00:04:45,456
但是主线程只花了 100 毫秒


133
00:04:45,456 --> 00:04:46,306
就完成了工作


134
00:04:48,586 --> 00:04:50,146
在主线程图表的下方


135
00:04:50,146 --> 00:04:51,906
是 CPU 使用率的详解


136
00:04:51,906 --> 00:04:53,596
含括了所有


137
00:04:53,596 --> 00:04:55,616
为网页内容工作的线程


138
00:04:55,816 --> 00:04:58,036
要了解详细信息的话


139
00:04:58,036 --> 00:04:59,516
你可以在时间线上点击 拖拽


140
00:04:59,516 --> 00:05:02,986
来选择完成任务时的时间范围


141
00:05:04,396 --> 00:05:06,306
在 CPU 使用率图的下方


142
00:05:06,306 --> 00:05:09,176
这个窄条是主线程指示器


143
00:05:09,176 --> 00:05:11,826
显示了在不同时间点


144
00:05:11,826 --> 00:05:14,166
主线程上处理过的各种工作


145
00:05:14,636 --> 00:05:16,866
在这片逐渐活跃的区域


146
00:05:16,866 --> 00:05:18,406
这里有一些


147
00:05:18,406 --> 00:05:19,716
红色的布局事件 后面


148
00:05:19,716 --> 00:05:21,446
跟着大量的绘制工作


149
00:05:21,446 --> 00:05:22,636
就像上面的图表


150
00:05:22,636 --> 00:05:23,706
但是这里显示了发生的时间


151
00:05:26,216 --> 00:05:28,306
但功耗影响计量表把这些


152
00:05:28,306 --> 00:05:29,446
统统算了进来


153
00:05:29,736 --> 00:05:31,386
它的数值基于


154
00:05:31,386 --> 00:05:33,426
所有 CPU 核心在这段时间内的


155
00:05:33,426 --> 00:05:35,806
总体平均使用率


156
00:05:38,016 --> 00:05:39,536
能耗计量表


157
00:05:39,536 --> 00:05:41,256
是可交互的


158
00:05:41,256 --> 00:05:42,786
而且作为总平均数


159
00:05:42,786 --> 00:05:44,086
会根据选择的时间范围变化


160
00:05:44,446 --> 00:05:46,366
在页面加载期间


161
00:05:46,366 --> 00:05:47,886
计量表显示出中等能耗


162
00:05:47,886 --> 00:05:49,866
但是加载本就是一个相当耗能的过程


163
00:05:49,866 --> 00:05:51,706
所以结果可以预期


164
00:05:52,156 --> 00:05:54,236
至少没有达到高能耗


165
00:05:54,236 --> 00:05:55,176
那原本可能会有问题


166
00:05:55,176 --> 00:05:57,086
但双击时间线区域


167
00:05:57,086 --> 00:05:58,666
选择整条录制


168
00:05:58,666 --> 00:06:00,396
这里显示总体的


169
00:06:00,396 --> 00:06:02,276
CPU 均值还是很低


170
00:06:02,906 --> 00:06:04,536
我可以通过点击和拖拽


171
00:06:04,536 --> 00:06:06,386
时间线来选定


172
00:06:06,386 --> 00:06:08,126
录制中的某段时间


173
00:06:08,126 --> 00:06:09,566
观察均值的变化


174
00:06:11,286 --> 00:06:13,416
现在 当我点击并抓取所选区域


175
00:06:13,416 --> 00:06:14,876
将它滑动到


176
00:06:14,876 --> 00:06:16,246
网页闲置期间


177
00:06:16,666 --> 00:06:18,166
能耗降到极低


178
00:06:18,816 --> 00:06:19,836
这真的很棒


179
00:06:20,316 --> 00:06:21,856
当网页闲置时


180
00:06:21,856 --> 00:06:23,316
我们不希望用户


181
00:06:23,316 --> 00:06:25,496
为没有在使用的内容耗能


182
00:06:27,266 --> 00:06:29,116
闲置时 CPU 的使用率保持在较低范围


183
00:06:29,116 --> 00:06:30,456
即使页面背景上


184
00:06:30,456 --> 00:06:32,966
有个旋转的 logo 动画


185
00:06:33,316 --> 00:06:34,376
那是因为它使用了


186
00:06:34,376 --> 00:06:36,556
简单的 CSS 动画属性


187
00:06:36,556 --> 00:06:38,396
能在低功耗下运行


188
00:06:38,396 --> 00:06:40,976
同时让网页有良好的视觉表现


189
00:06:42,156 --> 00:06:43,606
Webkit.org 到现在为止都表现得不错


190
00:06:43,606 --> 00:06:45,056
当你检查功耗问题时


191
00:06:45,056 --> 00:06:47,076
推荐优先检查


192
00:06:47,076 --> 00:06:48,406
加载和闲置


193
00:06:49,016 --> 00:06:50,926
为了顾及所有方面


194
00:06:50,926 --> 00:06:51,716
我们也需要获得一些


195
00:06:51,716 --> 00:06:52,726
交互时的数据


196
00:06:54,406 --> 00:06:56,396
Webkit 特性状态网页


197
00:06:56,396 --> 00:06:57,756
能够让你了解到


198
00:06:57,756 --> 00:06:59,256
WebKit 对于你最喜欢的


199
00:06:59,256 --> 00:07:00,506
网页特性的最新支持情况


200
00:07:00,926 --> 00:07:02,266
你可以用它筛选和搜索


201
00:07:02,266 --> 00:07:03,676
这用来捕获交互数据


202
00:07:03,676 --> 00:07:04,646
再完美不过了


203
00:07:04,936 --> 00:07:07,296
我会录制一段时间线


204
00:07:07,296 --> 00:07:09,036
然后与网页进行一些交互


205
00:07:09,036 --> 00:07:10,456
下滑到底部


206
00:07:15,766 --> 00:07:17,976
接着快速搜索


207
00:07:17,976 --> 00:07:19,346
到处点几下


208
00:07:19,986 --> 00:07:22,796
重申 我们至少


209
00:07:22,796 --> 00:07:24,236
要录 15 秒


210
00:07:24,736 --> 00:07:26,256
既然我们在一个新的网页上


211
00:07:26,256 --> 00:07:28,086
所以也应该包括一段闲置期


212
00:07:29,066 --> 00:07:30,466
我让它继续录制


213
00:07:30,466 --> 00:07:32,976
直到获得足够的闲置时间的数据


214
00:07:37,346 --> 00:07:38,556
好了 这样看起来不错


215
00:07:39,436 --> 00:07:40,476
我选中整段录制


216
00:07:40,476 --> 00:07:42,636
滚动光标


217
00:07:42,636 --> 00:07:43,966
将时间线缩小一些


218
00:07:43,966 --> 00:07:49,186
这样就能看到完整的 CPU 使用率细节了


219
00:07:53,756 --> 00:07:55,186
我们开始分析这些区域


220
00:07:55,186 --> 00:07:56,956
从加载开始


221
00:07:58,836 --> 00:08:00,526
在快速加载期间


222
00:08:00,526 --> 00:08:01,876
网页成功避开了高功耗区域


223
00:08:01,876 --> 00:08:03,596
这里没问题


224
00:08:05,206 --> 00:08:07,326
接下来我们来看交互时的功耗


225
00:08:08,236 --> 00:08:11,406
功耗影响保持在中等区域


226
00:08:11,406 --> 00:08:12,976
即使有这么多进程正在处理


227
00:08:12,976 --> 00:08:14,346
你可以从 JavaScript 与事件


228
00:08:14,346 --> 00:08:15,986
时间线上看到 滚动和交互时


229
00:08:15,986 --> 00:08:18,186
有许多脚本被触发


230
00:08:18,866 --> 00:08:19,976
让 CPU 在滚动时做无用功


231
00:08:19,976 --> 00:08:21,646
是我们想极力避免的


232
00:08:21,646 --> 00:08:23,996
因为滚动非常耗能


233
00:08:24,956 --> 00:08:26,076
让我们看看是否有必要


234
00:08:26,076 --> 00:08:27,366
进行这项工作


235
00:08:28,156 --> 00:08:29,796
统计与源数据


236
00:08:29,796 --> 00:08:31,086
这两块区域可以告诉我们一些事


237
00:08:31,936 --> 00:08:33,376
在选中的录制时间里


238
00:08:33,376 --> 00:08:34,895
有超过 1200 个


239
00:08:34,895 --> 00:08:37,405
JavaScript 里的条目


240
00:08:37,405 --> 00:08:38,916
有 594 个请求动画的定时器被启动


241
00:08:38,916 --> 00:08:41,836
还有 647 个滚动事件


242
00:08:42,716 --> 00:08:44,226
我知道减少定时器的数量


243
00:08:44,226 --> 00:08:45,516
和不滚动


244
00:08:45,516 --> 00:08:46,786
能有更好的功耗表现


245
00:08:46,786 --> 00:08:47,946
但是我们需要看看代码


246
00:08:47,946 --> 00:08:49,946
来了解是否必要或者是否能够提升


247
00:08:50,876 --> 00:08:52,666
在统计区域


248
00:08:52,666 --> 00:08:54,236
你可以点击计时器或事件


249
00:08:54,236 --> 00:08:55,616
来筛选右边的数据源


250
00:08:55,666 --> 00:08:57,556
从而找到触发它的代码


251
00:08:57,556 --> 00:08:59,106
点击数据源


252
00:08:59,106 --> 00:09:00,276
会直接让你在 JavaScript 调试器里


253
00:09:00,276 --> 00:09:01,286
看到代码


254
00:09:04,316 --> 00:09:06,236
好 看起来


255
00:09:06,236 --> 00:09:07,936
请求动画帧的定时器


256
00:09:07,936 --> 00:09:09,776
在调用 updateImages


257
00:09:09,806 --> 00:09:11,406
会在所有图片上重复应用


258
00:09:11,466 --> 00:09:12,706
检查它们是否在视图中


259
00:09:12,806 --> 00:09:14,076
如果在的话 就加载


260
00:09:14,676 --> 00:09:16,286
这是个非常基本的


261
00:09:16,286 --> 00:09:18,426
减少加载图像的特性


262
00:09:18,426 --> 00:09:19,916
但是在调试器里的暗色代码


263
00:09:20,256 --> 00:09:22,076
告诉我们 inView 和 loadImage


264
00:09:22,076 --> 00:09:22,966
从来没有被调用


265
00:09:24,506 --> 00:09:25,496
即使我们滚动到


266
00:09:25,496 --> 00:09:27,616
页面底部


267
00:09:27,616 --> 00:09:29,446
又回到顶部


268
00:09:29,446 --> 00:09:30,666
但这很合理


269
00:09:30,666 --> 00:09:32,236
因为该页面基本没有图片


270
00:09:32,736 --> 00:09:34,386
所以延迟加载图片的代码


271
00:09:34,386 --> 00:09:36,186
在该页面根本不该被触发


272
00:09:36,996 --> 00:09:38,446
我们切回代码看看


273
00:09:38,656 --> 00:09:40,816
图像和事件


274
00:09:40,816 --> 00:09:42,046
处理器在这里


275
00:09:43,346 --> 00:09:44,996
所以看一眼代码


276
00:09:44,996 --> 00:09:46,306
它在这段时间里


277
00:09:46,306 --> 00:09:47,916
一直在设置


278
00:09:47,916 --> 00:09:48,586
处理滚动和调整大小的处理器


279
00:09:49,246 --> 00:09:50,746
为了避免这种事情


280
00:09:50,746 --> 00:09:52,366
我们只需添加一个条件防护器


281
00:09:53,666 --> 00:09:55,206
好了 来试试吧


282
00:09:58,656 --> 00:10:00,406
我们来录制一条


283
00:10:00,406 --> 00:10:01,526
经过修改的时间线


284
00:10:02,236 --> 00:10:03,586
接下来我点回到


285
00:10:03,586 --> 00:10:06,246
时间线标签 开始新的录制


286
00:10:06,246 --> 00:10:11,086
我会快速滚动一下


287
00:10:13,996 --> 00:10:15,216
你可以看到在时间线里


288
00:10:15,216 --> 00:10:17,306
没有任何 JavaScript 条目


289
00:10:17,496 --> 00:10:19,296
全部都只是绘制


290
00:10:19,296 --> 00:10:20,566
所以我们的防护器


291
00:10:20,566 --> 00:10:21,986
有效在没有任何延迟加载的页面上


292
00:10:21,986 --> 00:10:23,676
滚动的时候


293
00:10:23,676 --> 00:10:24,726
阻止了额外的 JavaScript 工作


294
00:10:26,316 --> 00:10:27,866
这样一来能耗就降低了


295
00:10:27,866 --> 00:10:30,566
主线程的所有工作只有


296
00:10:30,566 --> 00:10:32,276
对滚动的绘制 但是我们


297
00:10:32,276 --> 00:10:33,586
需要确保那些


298
00:10:33,586 --> 00:10:35,846
用了延迟加载图像的网页仍然正常


299
00:10:37,636 --> 00:10:39,036
再一次 有了这个修改


300
00:10:39,306 --> 00:10:41,156
我会在一个底部有


301
00:10:41,156 --> 00:10:42,756
MotionMark 图标的网页上录制


302
00:10:42,756 --> 00:10:44,176
一条新的时间线


303
00:10:44,176 --> 00:10:45,236
这次应该会用到延迟加载


304
00:10:47,016 --> 00:10:49,446
完美 MotionMark 图片加载成功


305
00:10:49,736 --> 00:10:51,126
我会继续滚动


306
00:10:51,126 --> 00:10:52,416
得到新行为的 CPU 测量


307
00:10:52,416 --> 00:10:54,076
然后点击 CPU 时间线


308
00:10:54,076 --> 00:10:57,866
看看怎么样


309
00:10:58,136 --> 00:11:00,936
我们减少了定时器和事件


310
00:11:00,936 --> 00:11:03,146
让页面刚好够用


311
00:11:03,476 --> 00:11:07,916
这很棒 但是对于有延迟加载的图像的网页


312
00:11:07,916 --> 00:11:10,436
仍然有很多条目在 Script 里


313
00:11:11,286 --> 00:11:12,756
Safari 中有一个可用的 API


314
00:11:12,756 --> 00:11:14,276
我们可以用它来


315
00:11:14,276 --> 00:11:15,636
完善这种解决方案


316
00:11:16,176 --> 00:11:17,406
我们可以替换掉


317
00:11:17,406 --> 00:11:18,956
请求动画帧的相关实现


318
00:11:19,076 --> 00:11:21,126
使用 Intersection Observer


319
00:11:22,526 --> 00:11:24,016
Intersection Observer 可以告诉我们


320
00:11:24,016 --> 00:11:25,446
一个元素什么时候进入视图


321
00:11:25,686 --> 00:11:27,046
这样你可以把工作


322
00:11:27,046 --> 00:11:28,196
限制在仅当元素可见的时候


323
00:11:28,436 --> 00:11:29,766
一旦不在屏幕上显示


324
00:11:29,766 --> 00:11:31,466
你可以立即让它停止工作


325
00:11:31,466 --> 00:11:33,026
使 CPU 回到低功耗状态


326
00:11:33,026 --> 00:11:34,306
从而实现节能


327
00:11:36,256 --> 00:11:37,176
当 Intersection Observer


328
00:11:37,176 --> 00:11:38,816
生效后 我们再来


329
00:11:38,816 --> 00:11:40,536
录制一段时间线


330
00:11:40,536 --> 00:11:41,776
做一些滚动来观察


331
00:11:41,776 --> 00:11:42,856
这种方案的表现


332
00:11:44,016 --> 00:11:45,196
当我开始滚动


333
00:11:45,456 --> 00:11:46,736
这里只有一个单独的条目进入了 JavaScript


334
00:11:46,736 --> 00:11:48,526
而其余的时间里 


335
00:11:48,526 --> 00:11:50,516
当我滚动的时候 只有绘制


336
00:11:57,516 --> 00:11:58,686
最终 Intersection Observer 的


337
00:11:58,686 --> 00:12:02,666
方案使 CPU 平均使用率


338
00:12:02,666 --> 00:12:04,796
从 16.3% 降到了 9.5%


339
00:12:05,276 --> 00:12:06,596
一点一滴都有所帮助


340
00:12:06,596 --> 00:12:08,086
得到的提升非常可观


341
00:12:08,516 --> 00:12:10,816
综上 有许多方法可以


342
00:12:10,816 --> 00:12:12,246
为网页内容节能


343
00:12:13,586 --> 00:12:15,436
使用 CPU 使用率时间线来


344
00:12:15,436 --> 00:12:17,076
观察网页内容


345
00:12:17,076 --> 00:12:18,676
在交互与闲置时的表现


346
00:12:18,676 --> 00:12:19,966
来改善网页的功耗


347
00:12:21,096 --> 00:12:23,176
请记得降低 CPU 使用率


348
00:12:23,176 --> 00:12:24,906
就等同于为用户节能和减少


349
00:12:24,906 --> 00:12:25,906
电量消耗


350
00:12:27,586 --> 00:12:29,586
CSS 动画属性与过渡属性


351
00:12:29,586 --> 00:12:31,146
能够在低功耗下


352
00:12:31,146 --> 00:12:34,176
提供动态效果


353
00:12:34,176 --> 00:12:36,026
在滚动时免除了一些工作


354
00:12:36,196 --> 00:12:38,426
使用 Intersection Observer API 作为替代


355
00:12:39,506 --> 00:12:41,306
用户想要的是一种有吸引力的 动态的


356
00:12:41,306 --> 00:12:43,056
网页内容体验


357
00:12:43,056 --> 00:12:44,086
但是最佳的体验


358
00:12:44,086 --> 00:12:45,916
是那种尽可能


359
00:12:45,916 --> 00:12:47,086
少占用 CPU 的做法


360
00:12:48,386 --> 00:12:49,106
在 Webkit Blog 上还有更多


361
00:12:49,106 --> 00:12:50,476
提供给网页开发者的


362
00:12:50,476 --> 00:12:52,006
节能小技巧


363
00:12:52,516 --> 00:12:53,416
你们可以在视频附带的


364
00:12:53,416 --> 00:12:56,016
资源区找到链接


365
00:12:57,866 --> 00:12:59,196
希望你们会在自己的网页内容上


366
00:12:59,196 --> 00:13:00,776
试试这些工具


367
00:13:00,776 --> 00:13:02,476
并将本视频给出的建议


368
00:13:02,476 --> 00:13:03,816
作为起步


369
00:13:03,816 --> 00:13:05,526
寻求如何优化


370
00:13:05,526 --> 00:13:06,646
你的网页内容


371
00:13:06,646 --> 00:13:08,496
和我们一起


372
00:13:08,496 --> 00:13:10,016
通过使网页更节能


373
00:13:10,016 --> 00:13:11,976
来使其更强大

