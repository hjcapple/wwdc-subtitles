1
00:00:00,506 --> 00:00:05,500
[音乐]


2
00:00:12,496 --> 00:00:14,496
[掌声]


3
00:00:14,976 --> 00:00:16,666
>> 各位早上好


4
00:00:16,666 --> 00:00:17,616
感谢各位来参加我们的会议


5
00:00:19,206 --> 00:00:21,996
在 Apple 我们开发技术


6
00:00:22,936 --> 00:00:24,436
我们开发的技术用于让各位


7
00:00:24,436 --> 00:00:27,356
创造具有惊人体验的优质 App


8
00:00:27,886 --> 00:00:30,916
我最喜爱的 App 是那些


9
00:00:30,916 --> 00:00:32,296
无缝地融入技术


10
00:00:32,296 --> 00:00:34,096
并且让我们能在使用时


11
00:00:34,096 --> 00:00:35,166
沉浸其中的 App


12
00:00:36,956 --> 00:00:39,496
今天我想与各位探讨的是


13
00:00:39,496 --> 00:00:40,946
其中两个技术


14
00:00:41,446 --> 00:00:43,036
Core ML 和 ARKit


15
00:00:43,586 --> 00:00:47,026
这两个技术共同帮助


16
00:00:47,116 --> 00:00:48,666
我们的设备更深入


17
00:00:48,666 --> 00:00:50,466
认识周围的世界


18
00:00:51,696 --> 00:00:54,216
它们帮助我们将虚拟世界


19
00:00:54,216 --> 00:00:54,976
和现实世界融合在一起


20
00:00:57,216 --> 00:00:58,646
今天我们将带各位


21
00:00:58,646 --> 00:00:59,926
领略如何开发出 App


22
00:00:59,926 --> 00:01:02,046
实现以上目的


23
00:01:02,516 --> 00:01:04,245
在此过程中我们将探讨一些


24
00:01:04,245 --> 00:01:05,296
将会遇到的挑战


25
00:01:05,296 --> 00:01:07,076
以及怎样克服它们


26
00:01:07,636 --> 00:01:09,136
并且我们还将探讨


27
00:01:09,136 --> 00:01:11,266
在面对困难时


28
00:01:11,266 --> 00:01:12,066
衍生的一些主题


29
00:01:13,836 --> 00:01:17,596
首先我们的第一个问题是


30
00:01:17,676 --> 00:01:19,486
机器学习是否有帮助


31
00:01:20,656 --> 00:01:23,016
当然如果我说没有帮助的话


32
00:01:23,016 --> 00:01:24,166
今天的会议将会非常短暂


33
00:01:24,806 --> 00:01:27,286
但我不能简单地肯定这一观点


34
00:01:27,286 --> 00:01:29,946
因为这一问题的答案


35
00:01:29,946 --> 00:01:31,996
取决于你正在解决的问题


36
00:01:31,996 --> 00:01:33,396
以及你必须去处理


37
00:01:33,396 --> 00:01:34,836
的有关数据


38
00:01:36,276 --> 00:01:37,366
因为机器学习的内容


39
00:01:37,366 --> 00:01:38,646
就是理解你所拥有的信息


40
00:01:38,646 --> 00:01:40,506
机器学习有关于


41
00:01:40,596 --> 00:01:42,486
理解数据内部的模式


42
00:01:42,486 --> 00:01:44,476
这些模式可能很难用


43
00:01:44,476 --> 00:01:45,816
程序化的语言去描述


44
00:01:46,246 --> 00:01:48,876
而且这些数据是存在于


45
00:01:49,556 --> 00:01:49,746
你的 App 中的


46
00:01:50,106 --> 00:01:51,576
你的用户每天都在输入数据


47
00:01:52,236 --> 00:01:53,836
他们使用键盘


48
00:01:53,836 --> 00:01:55,246
来输入文本信息


49
00:01:56,216 --> 00:01:57,706
他们使用麦克风


50
00:01:57,706 --> 00:01:58,536
来记录声音信息


51
00:02:00,456 --> 00:02:01,976
他们使用摄像头


52
00:02:01,976 --> 00:02:03,726
记录照片和视频


53
00:02:04,246 --> 00:02:07,006
所以当我们遇到问题的时候


54
00:02:07,006 --> 00:02:08,466
机器学习有帮助吗


55
00:02:08,466 --> 00:02:10,265
这是一个很好的问题


56
00:02:10,705 --> 00:02:12,536
所以你需要认真审视你所要


57
00:02:12,536 --> 00:02:13,256
解决问题的类型


58
00:02:13,256 --> 00:02:15,016
以及你目前可以用于


59
00:02:15,016 --> 00:02:16,726
解决这个问题的数据有哪些


60
00:02:19,656 --> 00:02:20,986
我们今天要了解的第二个主题


61
00:02:20,986 --> 00:02:22,806
是去理解你的


62
00:02:22,806 --> 00:02:25,076
模型具有的行为


63
00:02:25,996 --> 00:02:28,276
这些模型被训练为接收


64
00:02:28,276 --> 00:02:30,326
特定格式的输入


65
00:02:30,326 --> 00:02:33,376
然后提供


66
00:02:33,426 --> 00:02:35,036
特定格式的输出


67
00:02:35,616 --> 00:02:38,806
也就是说如果你的输入并不是


68
00:02:38,806 --> 00:02:40,176
模型预期的特定格式


69
00:02:40,176 --> 00:02:42,856
那么它的输出也将是


70
00:02:42,856 --> 00:02:44,046
你所无法预计的


71
00:02:44,046 --> 00:02:48,046
而要说到输出


72
00:02:48,046 --> 00:02:49,026
如果你不知道你的模型输出什么


73
00:02:49,026 --> 00:02:50,326
那么要在你的应用中


74
00:02:50,326 --> 00:02:51,736
实现神奇的用户体验


75
00:02:52,176 --> 00:02:54,886
可能是会非常难的


76
00:02:56,136 --> 00:02:57,396
我们将通过几种方式


77
00:02:57,396 --> 00:02:59,316
来让你将某些模型的


78
00:02:59,316 --> 00:03:01,726
输入和输出可视化


79
00:03:02,206 --> 00:03:05,116
但是现在 先继续我们的旅程


80
00:03:06,166 --> 00:03:07,666
我们说过我们将利用


81
00:03:07,666 --> 00:03:09,456
一系列技术的组合


82
00:03:09,456 --> 00:03:10,776
来融合虚拟世界和现实世界


83
00:03:10,836 --> 00:03:12,786
那除了 App 之外


84
00:03:12,786 --> 00:03:14,606
还有什么内容更适合完成这一目的呢


85
00:03:14,706 --> 00:03:16,986
我们认为为儿童构建一个


86
00:03:17,276 --> 00:03:18,716
教育类的游戏


87
00:03:18,806 --> 00:03:20,526
来练习他们的数学技巧


88
00:03:20,526 --> 00:03:23,376
像是计数和加减乘除


89
00:03:23,376 --> 00:03:24,986
这个想法非常有趣


90
00:03:25,796 --> 00:03:28,306
并且我们知道孩子们有时候


91
00:03:28,306 --> 00:03:30,266
会利用骰子来练习这些技能


92
00:03:30,906 --> 00:03:32,266
那现在我们就可以把


93
00:03:32,616 --> 00:03:35,036
虚拟的骰子放进 App 中


94
00:03:35,036 --> 00:03:36,406
让这些骰子在屏幕上滚动


95
00:03:36,656 --> 00:03:37,806
但我们想更有趣的方式会是


96
00:03:37,806 --> 00:03:39,946
如果能让孩子们在现实中


97
00:03:39,946 --> 00:03:41,236
在桌面上投实体的骰子


98
00:03:41,236 --> 00:03:42,856
并且让这些骰子能与


99
00:03:43,396 --> 00:03:45,086
我们的 App 交互


100
00:03:46,336 --> 00:03:47,996
所以这就是我们所做的


101
00:03:48,296 --> 00:03:50,586
我们遇到的第一个挑战是


102
00:03:50,586 --> 00:03:55,646
如何让我们的应用识别出骰子


103
00:03:56,146 --> 00:03:59,306
这里有几种方法


104
00:04:00,266 --> 00:04:01,906
让我们以编程方式开始


105
00:04:02,526 --> 00:04:05,306
但这会有一些困难


106
00:04:06,616 --> 00:04:08,106
如果我们将问题限制在


107
00:04:08,106 --> 00:04:10,256
识别六面骰


108
00:04:10,256 --> 00:04:11,726
我们就可以开始研究骰子的属性


109
00:04:12,536 --> 00:04:14,666
比如看我身后的骰子


110
00:04:14,666 --> 00:04:15,606
它的颜色是灰色的


111
00:04:16,935 --> 00:04:19,466
但并非所有骰子都是灰色的


112
00:04:19,466 --> 00:04:21,536
所以这并不一定有用


113
00:04:22,856 --> 00:04:24,926
如果你在 2D 平面上观察它


114
00:04:25,476 --> 00:04:26,876
它是一个六边形的形状


115
00:04:26,986 --> 00:04:28,596
由三个斜矩形构成


116
00:04:30,206 --> 00:04:31,926
但随着骰子在桌面上滚动


117
00:04:31,926 --> 00:04:33,176
这些形状将会发生变化


118
00:04:33,836 --> 00:04:36,416
如果我们仔细观察每一面


119
00:04:36,416 --> 00:04:38,396
它们上面会有很多点


120
00:04:38,396 --> 00:04:40,096
但是这也会因为


121
00:04:40,256 --> 00:04:41,426
你所看的面的变化以及


122
00:04:41,426 --> 00:04:42,966
观察角度变化


123
00:04:42,966 --> 00:04:44,236
而有所改变


124
00:04:45,426 --> 00:04:47,066
所以随着这些属性的改变


125
00:04:47,346 --> 00:04:49,476
要编写程序来识别骰子


126
00:04:49,476 --> 00:04:52,476
将会是一件困难的事情


127
00:04:52,866 --> 00:04:56,106
所以让我们来看看


128
00:04:56,106 --> 00:04:56,976
机器学习的方法


129
00:05:00,536 --> 00:05:02,376
我们可以训练图像分类模型


130
00:05:02,376 --> 00:05:06,146
来识别出图像中的骰子


131
00:05:06,706 --> 00:05:10,996
但我们想知道图像中有多少骰子


132
00:05:10,996 --> 00:05:12,766
而不仅仅是判断


133
00:05:12,766 --> 00:05:14,706
图像中是否有骰子存在


134
00:05:15,896 --> 00:05:17,356
因此我们考虑使用


135
00:05:17,356 --> 00:05:18,426
对象检测模型


136
00:05:18,986 --> 00:05:21,056
对象检测模型将告诉我们


137
00:05:21,056 --> 00:05:22,316
图像中是否有骰子存在


138
00:05:22,316 --> 00:05:24,366
并且还将告诉我们骰子的位置


139
00:05:24,366 --> 00:05:26,076
如果我们知道骰子在图像中的位置


140
00:05:26,076 --> 00:05:27,176
那我们就可以


141
00:05:27,176 --> 00:05:30,606
计算图像里骰子的个数


142
00:05:30,786 --> 00:05:32,596
要做到这一点


143
00:05:32,596 --> 00:05:34,846
我们需要获取数据


144
00:05:34,846 --> 00:05:37,336
所以我们将一堆骰子


145
00:05:37,606 --> 00:05:38,116
放在桌面上滚动


146
00:05:38,606 --> 00:05:41,436
接下来我们拍摄这些图片


147
00:05:41,436 --> 00:05:43,286
然后用边界框标记他们


148
00:05:43,286 --> 00:05:44,886
这些边界框标注出


149
00:05:44,886 --> 00:05:45,906
骰子在图像中的位置


150
00:05:46,226 --> 00:05:49,486
之后我们利用新的


151
00:05:49,486 --> 00:05:51,276
Create ML 来训练我们的


152
00:05:51,276 --> 00:05:52,246
对象检测模型


153
00:05:54,716 --> 00:05:56,026
如果你想了解更多有关


154
00:05:56,026 --> 00:05:57,966
训练的信息


155
00:05:57,966 --> 00:05:59,046
可以参阅 Create ML for Object Detection


156
00:05:59,046 --> 00:06:00,876
and Sound Classification 这一会议


157
00:06:00,876 --> 00:06:04,806
现在我想邀请 Scott


158
00:06:04,806 --> 00:06:06,356
来实际展示


159
00:06:07,596 --> 00:06:13,036
Scott [鼓掌]


160
00:06:13,536 --> 00:06:14,496
>> 大家早上好


161
00:06:14,936 --> 00:06:15,176
>> 早上好


162
00:06:17,136 --> 00:06:18,246
>> 正如 Brent 讨论的那样


163
00:06:18,246 --> 00:06:19,916
我们将探索使用被称为对象检测


164
00:06:19,916 --> 00:06:21,516
的机器学习技术


165
00:06:21,516 --> 00:06:23,006
来增加我们的 App 


166
00:06:23,006 --> 00:06:24,446
识别骰子能力的方法


167
00:06:25,066 --> 00:06:26,396
而且我相信你们都想


168
00:06:26,396 --> 00:06:27,726
看到这一方法可以奏效


169
00:06:27,726 --> 00:06:29,000
所以让我们开始吧


170
00:06:38,536 --> 00:06:40,736
在这里我们有一个简单的 App


171
00:06:40,946 --> 00:06:41,996
这一 App 连接了实时摄像机视图


172
00:06:41,996 --> 00:06:43,586
并且我们添加了


173
00:06:43,586 --> 00:06:44,866
已经训练好的


174
00:06:44,866 --> 00:06:46,706
对象检测器来对骰子计数


175
00:06:47,196 --> 00:06:48,236
所以让我们来看看


176
00:06:48,236 --> 00:06:49,366
当画面中增加骰子时会发生什么


177
00:06:50,766 --> 00:06:55,896
一二三四


178
00:06:56,056 --> 00:06:59,366
我们可以掷骰子来让这变得更有趣


179
00:07:00,066 --> 00:07:02,416
所以这是很棒的


180
00:07:02,416 --> 00:07:04,446
我们的 App 能够使用


181
00:07:04,786 --> 00:07:05,866
对象检测器来识别骰子


182
00:07:06,476 --> 00:07:07,836
但是我们今天要讨论的主题


183
00:07:07,836 --> 00:07:09,066
之一是理解


184
00:07:09,066 --> 00:07:10,966
你的模型的行为


185
00:07:11,416 --> 00:07:13,616
因此让我们实际看一下


186
00:07:13,616 --> 00:07:15,286
模型所看到内容的


187
00:07:15,286 --> 00:07:16,436
通过调试可视化能得到什么


188
00:07:17,006 --> 00:07:18,096
正如你所见的


189
00:07:18,096 --> 00:07:20,066
我们在每个检测到的对象


190
00:07:20,066 --> 00:07:21,926
周围都绘制了边界框


191
00:07:21,926 --> 00:07:23,576
在这一场景下对象是桌上的骰子


192
00:07:23,576 --> 00:07:25,216
如果我们移动它们


193
00:07:25,566 --> 00:07:28,396
那么这些边界框也会随之移动


194
00:07:28,606 --> 00:07:30,346
这对你来说非常重要


195
00:07:30,346 --> 00:07:32,756
因为如果你正在训练一个


196
00:07:32,756 --> 00:07:34,606
对象检测器模型


197
00:07:34,606 --> 00:07:35,946
并且你没有在


198
00:07:35,946 --> 00:07:37,416
你不想检测的其他物体


199
00:07:37,416 --> 00:07:38,556
看到有边界框存在


200
00:07:38,556 --> 00:07:40,826
或者你并没有看到


201
00:07:40,886 --> 00:07:42,156
在你想要检测的物体上


202
00:07:42,156 --> 00:07:43,436
出现你想要的边界框


203
00:07:43,846 --> 00:07:45,276
这可能是你在这种


204
00:07:45,276 --> 00:07:46,536
光照条件下收集更多数据的


205
00:07:46,536 --> 00:07:47,866
一次很好的机会


206
00:07:48,376 --> 00:07:49,746
你可能会想收集


207
00:07:49,746 --> 00:07:50,726
不同背景下


208
00:07:50,726 --> 00:07:52,786
不同光照以及


209
00:07:53,096 --> 00:07:54,276
不同数量对象的更多数据


210
00:07:54,276 --> 00:07:55,756
在这个场景下我们有四个


211
00:07:55,836 --> 00:07:56,716
但你有可能想使用


212
00:07:56,716 --> 00:07:58,486
五个或者六个甚至多达十个


213
00:07:58,486 --> 00:08:00,706
或者更少甚至没有骰子


214
00:08:00,706 --> 00:08:02,066
的图片来训练模型


215
00:08:02,066 --> 00:08:03,746
使之不会识别错误


216
00:08:07,076 --> 00:08:09,116
让我们来看看一些


217
00:08:09,116 --> 00:08:11,346
实现这一目的的代码


218
00:08:11,506 --> 00:08:12,566
当你处理使用 Create ML


219
00:08:12,566 --> 00:08:13,536
在 Vision 框架下


220
00:08:13,536 --> 00:08:15,186
训练过的对象检测器时


221
00:08:15,186 --> 00:08:16,796
你得到的结果是


222
00:08:16,796 --> 00:08:19,586
VNRecognizedObjectObeservation 列表


223
00:08:20,316 --> 00:08:21,536
因此这里我们有一个函数


224
00:08:21,536 --> 00:08:22,846
处理这些观测结果


225
00:08:22,846 --> 00:08:23,946
并且完成一些功能


226
00:08:24,526 --> 00:08:25,746
第一个也是最简单的


227
00:08:26,286 --> 00:08:27,146
我们只计数骰子的个数


228
00:08:27,606 --> 00:08:29,806
这就和观察结果的数量是一样的


229
00:08:29,806 --> 00:08:31,766
因为每个骰子只计数 1


230
00:08:32,326 --> 00:08:34,716
接下来我们有几个辅助函数


231
00:08:34,716 --> 00:08:36,035
可以根据这些已经识别的对象


232
00:08:36,035 --> 00:08:37,566
的观测结果来在图片上


233
00:08:37,676 --> 00:08:40,346
绘制边界框


234
00:08:40,936 --> 00:08:43,145
第一个函数的功能是


235
00:08:43,145 --> 00:08:44,636
为每一个识别出来的对象观测结果


236
00:08:44,636 --> 00:08:46,316
绘制需要的边界框


237
00:08:46,316 --> 00:08:47,826
这一边界根据你提供给 Vision


238
00:08:47,966 --> 00:08:50,186
的输入图像输出


239
00:08:50,186 --> 00:08:51,656
标准化之后的坐标


240
00:08:51,656 --> 00:08:53,936
以便该函数将这些


241
00:08:54,006 --> 00:08:55,316
结果映射回我们的


242
00:08:55,316 --> 00:08:56,496
视图控制器中的视图坐标系


243
00:08:56,496 --> 00:08:57,366
这样我们就可以在


244
00:08:57,366 --> 00:08:58,546
屏幕的正确位置绘制它们


245
00:08:58,606 --> 00:09:00,606
将它们覆盖在


246
00:09:00,606 --> 00:09:01,466
图像中的实际物体上方


247
00:09:03,026 --> 00:09:04,376
接下来我们还有一个辅助函数


248
00:09:04,376 --> 00:09:06,836
可以帮助我们在屏幕上


249
00:09:07,106 --> 00:09:08,416
绘制精美的圆角矩形


250
00:09:08,416 --> 00:09:10,326
这一圆角矩形被称为 CALayer


251
00:09:10,396 --> 00:09:13,276
接下来我们将 CALayer 添加到


252
00:09:13,276 --> 00:09:15,986
屏幕上需要渲染的叠加层上


253
00:09:16,656 --> 00:09:17,886
所有这些代码都可以在


254
00:09:17,886 --> 00:09:19,276
与这一会议相关的示例 App 中找到


255
00:09:19,276 --> 00:09:22,876
大家可以去查看


256
00:09:23,136 --> 00:09:25,246
到现在为止进展顺利


257
00:09:25,486 --> 00:09:27,566
我们的 App 已经可以


258
00:09:27,566 --> 00:09:28,296
利用对象检测来计数骰子


259
00:09:29,216 --> 00:09:30,716
但你可能已经意识到或者想过


260
00:09:30,716 --> 00:09:32,686
游戏通常并不依赖于


261
00:09:32,686 --> 00:09:35,886
骰子的数量这一事实


262
00:09:35,886 --> 00:09:37,196
它们通常依赖于


263
00:09:37,236 --> 00:09:37,866
骰子上面显示的数值


264
00:09:38,796 --> 00:09:40,436
所以我们还需要更进一步


265
00:09:40,486 --> 00:09:42,416
弄清楚如何识别


266
00:09:42,416 --> 00:09:45,586
这些在骰子上显示的数值


267
00:09:45,796 --> 00:09:47,166
这是我们希望我们的 App


268
00:09:47,166 --> 00:09:49,446
最终需要实现的功能


269
00:09:49,446 --> 00:09:50,376
我们希望它可以告诉


270
00:09:50,376 --> 00:09:52,476
右侧的骰子结果是 5 


271
00:09:52,476 --> 00:09:55,156
而左侧骰子的结果是 1


272
00:09:55,366 --> 00:09:57,166
幸运的是 正如 Brent 所提到的


273
00:09:57,166 --> 00:09:59,476
对象探测器不仅可以检测物体


274
00:09:59,576 --> 00:10:01,106
它还能对物体进行分类


275
00:10:01,106 --> 00:10:02,626
因为它被构建来识别


276
00:10:02,626 --> 00:10:05,916
各种不同的物体和图像


277
00:10:06,666 --> 00:10:11,186
接下来让我们更新我们的训练数据


278
00:10:11,186 --> 00:10:14,376
将不同值的骰子视为不同类


279
00:10:14,376 --> 00:10:16,766
就像你在屏幕上看到的那样


280
00:10:18,796 --> 00:10:21,136
这听起来能够实现


281
00:10:21,136 --> 00:10:22,856
所以我们在我们的 App 中


282
00:10:22,856 --> 00:10:24,246
进行了尝试


283
00:10:24,246 --> 00:10:26,286
让我们来看看


284
00:10:26,286 --> 00:10:27,516
遇到的一些实例


285
00:10:27,566 --> 00:10:31,126
在大多数情况下它运行得很好


286
00:10:31,416 --> 00:10:32,566
正如你在我身后图片中


287
00:10:32,866 --> 00:10:34,866
所看到的那样


288
00:10:34,866 --> 00:10:36,396
我们的对象检测器可以


289
00:10:36,436 --> 00:10:38,036
正确且准确地检测和分类


290
00:10:38,036 --> 00:10:39,026
屏幕左侧出现的骰子


291
00:10:39,026 --> 00:10:42,446
但如果我们关注另一边


292
00:10:42,446 --> 00:10:44,506
我们将发现我们的对象检测器


293
00:10:44,506 --> 00:10:45,846
将 6 和 4 这两个骰子


294
00:10:45,846 --> 00:10:48,266
检测为一个骰子


295
00:10:49,816 --> 00:10:50,766
如果我们仔细考虑一些


296
00:10:50,766 --> 00:10:52,986
事情发生的原因


297
00:10:52,986 --> 00:10:54,616
很明显模型不能将它们


298
00:10:54,616 --> 00:10:56,476
分开识别成两个独立的骰子


299
00:10:56,476 --> 00:10:58,986
并且这一情况


300
00:10:58,986 --> 00:11:00,246
要归结于 4 这个骰子


301
00:11:00,246 --> 00:11:02,346
被出现在前面的那个骰子遮住


302
00:11:03,646 --> 00:11:05,266
所以考虑一下这件事情之后


303
00:11:05,266 --> 00:11:06,936
我们意识到我们真正关心的


304
00:11:06,936 --> 00:11:09,356
是这些骰子的顶部


305
00:11:09,356 --> 00:11:11,296
并且骰子的顶部对于我们


306
00:11:11,296 --> 00:11:12,796
来说总是可见的


307
00:11:13,946 --> 00:11:15,916
所以我们将更进一步


308
00:11:15,916 --> 00:11:17,396
给予我们的模型一点小帮助


309
00:11:17,846 --> 00:11:19,616
我们更新了所有训练数据


310
00:11:19,776 --> 00:11:21,896
关注这些骰子的顶部


311
00:11:22,566 --> 00:11:24,616
所以我们现在训练的对象检测器


312
00:11:24,616 --> 00:11:26,256
并不是为了检测骰子


313
00:11:26,256 --> 00:11:28,316
而是去检测骰子的顶部


314
00:11:29,406 --> 00:11:31,326
那么让我们来看看当我们这样做时 将会发生什么


315
00:11:31,756 --> 00:11:34,326
正如你所看到的


316
00:11:34,326 --> 00:11:36,646
我们的模型仍然能正确


317
00:11:36,766 --> 00:11:39,206
识别和分类左边这些骰子


318
00:11:39,206 --> 00:11:41,726
但现在这个模型还能够


319
00:11:41,726 --> 00:11:43,786
正确地将右边的骰子


320
00:11:43,786 --> 00:11:44,516
进行检测和分类


321
00:11:47,476 --> 00:11:49,926
今天我们还想与你分享另外一个小插曲


322
00:11:51,396 --> 00:11:53,396
在我们的探究过程中


323
00:11:53,886 --> 00:11:55,946
我们注意到了这种情况


324
00:11:55,946 --> 00:11:57,466
我们的模型一直在


325
00:11:57,726 --> 00:11:59,666
检测骰子的左侧


326
00:12:01,076 --> 00:12:02,146
在一开始这非常令人困惑


327
00:12:02,146 --> 00:12:04,096
但如果我们旋转这一个图像


328
00:12:04,096 --> 00:12:05,936
我们就能理解模型


329
00:12:06,006 --> 00:12:07,616
是如何将这些识别成顶部的


330
00:12:08,496 --> 00:12:09,816
这很容易理解


331
00:12:10,056 --> 00:12:10,986
只要我们去关注


332
00:12:10,986 --> 00:12:12,356
模型的输入是怎样的


333
00:12:13,146 --> 00:12:14,486
我们没有根据设备的方向


334
00:12:14,486 --> 00:12:15,966
调整图像的方向


335
00:12:15,966 --> 00:12:17,426
这是视觉任务中


336
00:12:17,426 --> 00:12:20,266
经常出现的一个问题


337
00:12:20,266 --> 00:12:21,926
因此这里的关键教训是


338
00:12:21,926 --> 00:12:23,506
如果你在模型的输出中


339
00:12:23,506 --> 00:12:25,046
发现了奇怪的行为


340
00:12:25,046 --> 00:12:26,056
看一下输入总没有什么坏处


341
00:12:26,896 --> 00:12:29,336
它也许就和根据设备的方向


342
00:12:29,336 --> 00:12:33,276
旋转你的图像一样简单


343
00:12:33,446 --> 00:12:35,000
让我们看看这个新模型效果如何


344
00:12:43,696 --> 00:12:45,026
还是同样的 App


345
00:12:45,686 --> 00:12:47,356
但我们进行了更新


346
00:12:47,546 --> 00:12:49,326
使得我们的模型可以对骰子


347
00:12:49,356 --> 00:12:51,666
进行检测和分类


348
00:12:51,766 --> 00:12:52,816
为了简单起见我将专注于


349
00:12:52,816 --> 00:12:53,756
三个骰子的情况


350
00:12:54,216 --> 00:12:56,286
我们可以看到我们的模型


351
00:12:56,716 --> 00:12:58,406
检测到了 6 和 5 和 2


352
00:12:59,426 --> 00:12:59,976
让我们掷一次骰子


353
00:13:02,996 --> 00:13:04,476
4 和 6 和 5


354
00:13:05,316 --> 00:13:06,936
棒极了 我们做的很好


355
00:13:07,516 --> 00:13:10,716
[鼓掌]


356
00:13:11,216 --> 00:13:12,076
我想请你关注一个


357
00:13:12,076 --> 00:13:14,856
我认为非常重要的细节


358
00:13:15,606 --> 00:13:17,296
如果我移动骰子


359
00:13:17,296 --> 00:13:18,656
你可以看到列表更新了


360
00:13:19,146 --> 00:13:20,816
我们实际上根据骰子


361
00:13:20,816 --> 00:13:22,566
在桌面上的排列顺序


362
00:13:22,566 --> 00:13:24,786
来显示值列表


363
00:13:25,476 --> 00:13:26,916
这是一个次要的设计细节


364
00:13:27,396 --> 00:13:29,426
但它确实带来了体验的一致性


365
00:13:29,426 --> 00:13:30,576
因为我们的用户


366
00:13:30,576 --> 00:13:32,166
能在桌面上看到


367
00:13:32,166 --> 00:13:33,586
这些骰子的排布情况


368
00:13:34,126 --> 00:13:36,196
所以既然我们已经将


369
00:13:36,196 --> 00:13:37,506
物理和虚拟世界进行融合


370
00:13:38,186 --> 00:13:40,976
我们实际上正在为


371
00:13:42,246 --> 00:13:44,406
用户提供非常一致的显示结果


372
00:13:45,536 --> 00:13:46,436
还有一件事情我们需要弄清楚


373
00:13:46,436 --> 00:13:48,696
什么算掷一次骰子


374
00:13:49,626 --> 00:13:51,466
与之前相同


375
00:13:51,466 --> 00:13:53,936
游戏通常不依赖于掷骰子的过程


376
00:13:53,936 --> 00:13:55,636
而是依赖掷骰子的结果


377
00:13:55,636 --> 00:13:57,086
当你进行游戏时


378
00:13:57,086 --> 00:13:58,546
你将会掷出一些骰子


379
00:13:58,546 --> 00:14:00,836
并根据投掷结果来决定


380
00:14:00,836 --> 00:14:02,696
棋子的移动或进行决策


381
00:14:02,776 --> 00:14:04,276
在这种情况下


382
00:14:04,366 --> 00:14:05,806
我们可能要为用户制作


383
00:14:05,876 --> 00:14:06,996
动画效果或者提供反馈


384
00:14:07,276 --> 00:14:08,386
你可能已经在之前的演示中注意到


385
00:14:08,386 --> 00:14:10,036
直到掷骰子结束


386
00:14:10,036 --> 00:14:12,326
画面上才显示数字


387
00:14:13,086 --> 00:14:14,726
那么我们应该怎么做呢


388
00:14:15,656 --> 00:14:16,736
首先我们需要问自己


389
00:14:16,736 --> 00:14:18,336
我们观察到了什么


390
00:14:19,906 --> 00:14:21,756
在这一情况下我们注意到


391
00:14:21,756 --> 00:14:23,816
骰子停了下来并且


392
00:14:23,816 --> 00:14:26,026
在不同的相机帧之间值是稳定的


393
00:14:27,196 --> 00:14:28,926
机器学习能在这里帮助我们吗


394
00:14:29,966 --> 00:14:32,716
或许我们可以构建一个


395
00:14:32,716 --> 00:14:34,056
顺序模型接收帧数据


396
00:14:34,096 --> 00:14:36,026
来决定掷骰子是否已经结束


397
00:14:36,026 --> 00:14:37,636
但我们已经有了一个


398
00:14:37,636 --> 00:14:38,886
能够理解桌上骰子


399
00:14:38,886 --> 00:14:40,416
排布的模型


400
00:14:40,816 --> 00:14:42,466
所以我们真正需要做的是


401
00:14:42,466 --> 00:14:43,816
解读我们模型的输出


402
00:14:46,256 --> 00:14:47,746
那么让我们来看看


403
00:14:47,746 --> 00:14:50,386
如何在代码中执行这一操作


404
00:14:50,586 --> 00:14:51,956
这里我们有一个函数


405
00:14:51,956 --> 00:14:54,046
它接受两个对象观察列表


406
00:14:54,046 --> 00:14:55,416
一个来自当前相机帧


407
00:14:55,416 --> 00:14:56,906
另一个来自于


408
00:14:56,966 --> 00:14:58,286
前一个相机帧


409
00:14:59,336 --> 00:15:01,746
所以我们需要检查一些事情 来判断当前骰子


410
00:15:01,776 --> 00:15:02,526
是否已经停止滚动


411
00:15:03,476 --> 00:15:05,396
首先我们现在拥有


412
00:15:05,396 --> 00:15:06,946
和之前一样多的骰子吗


413
00:15:07,996 --> 00:15:10,046
如果没有那么也许有一个骰子进入


414
00:15:10,046 --> 00:15:11,206
当前的相机帧里面


415
00:15:11,206 --> 00:15:12,346
于是我们有了比之前多的骰子


416
00:15:12,836 --> 00:15:14,226
如果数量比以前少了


417
00:15:14,536 --> 00:15:15,796
也许其中一个还在滚动


418
00:15:15,796 --> 00:15:17,186
所以我们的检测器


419
00:15:17,186 --> 00:15:18,526
没有将它检测出来


420
00:15:19,216 --> 00:15:21,246
因此如若我们没有和原来


421
00:15:21,376 --> 00:15:23,336
一样多的骰子 那掷骰子过程没有结束


422
00:15:23,816 --> 00:15:26,036
接下来我们将比较


423
00:15:26,036 --> 00:15:27,366
先前的预测结果


424
00:15:27,366 --> 00:15:30,136
和当前的预测结果


425
00:15:31,516 --> 00:15:32,876
如果骰子顶部显示的值


426
00:15:32,876 --> 00:15:35,606
并不相同那说明


427
00:15:35,606 --> 00:15:37,306
掷骰子过程没有结束


428
00:15:38,036 --> 00:15:40,186
我们还将检测这些预测结果


429
00:15:40,186 --> 00:15:41,456
边界框之间的重叠度


430
00:15:41,456 --> 00:15:43,366
是否超过 85%


431
00:15:44,296 --> 00:15:45,576
如果我们当前的预测结果


432
00:15:45,576 --> 00:15:46,776
和我们正在比较的预测结果


433
00:15:46,776 --> 00:15:48,036
之间的边界框并不重叠


434
00:15:48,036 --> 00:15:49,736
说明要么我们正在


435
00:15:49,736 --> 00:15:50,666
看的是两个完全不同的骰子


436
00:15:50,666 --> 00:15:54,086
要么这个骰子


437
00:15:54,086 --> 00:15:55,846
发生了明显的移动


438
00:15:57,106 --> 00:15:59,726
最后如果我们得到的


439
00:15:59,726 --> 00:16:01,306
匹配结果与桌面上骰子数量一致的话


440
00:16:01,306 --> 00:16:02,956
代表掷骰子过程结束


441
00:16:03,466 --> 00:16:07,966
因此现在我们的 App 能够


442
00:16:08,126 --> 00:16:11,156
查找计数并识别出桌面上的骰子


443
00:16:11,196 --> 00:16:13,516
并且判定掷骰的动作已经结束


444
00:16:13,516 --> 00:16:15,486
我们有了很好的基础


445
00:16:15,756 --> 00:16:16,576
可以做更多的事情


446
00:16:17,206 --> 00:16:18,246
接下来是时候谈谈我们


447
00:16:18,246 --> 00:16:19,186
旅程的下一步了


448
00:16:19,976 --> 00:16:22,516
为此我想欢迎 Brent 重返舞台


449
00:16:23,516 --> 00:16:26,036
[鼓掌]


450
00:16:26,536 --> 00:16:30,456
>> 感谢 Scott 好的


451
00:16:30,456 --> 00:16:33,436
正如 Scott 所说


452
00:16:33,436 --> 00:16:34,816
我们的 App 能够识别桌上的骰子


453
00:16:35,906 --> 00:16:36,836
下面我们需要关注的


454
00:16:36,836 --> 00:16:39,426
是我们如何处理用户的输入


455
00:16:39,426 --> 00:16:42,706
我们知道我们的用户将在


456
00:16:42,706 --> 00:16:44,016
我们的 App 中输入数字


457
00:16:44,016 --> 00:16:45,776
因为我们正在练习数学技能


458
00:16:45,846 --> 00:16:48,716
我们可以在屏幕上显示


459
00:16:48,716 --> 00:16:50,146
一个数字板


460
00:16:50,146 --> 00:16:51,386
并让他们点按数字


461
00:16:51,716 --> 00:16:53,816
但我们想要促进用户与 App 之间


462
00:16:53,816 --> 00:16:55,896
更自然的交互


463
00:16:56,146 --> 00:16:58,226
请记住我们的用户是孩子


464
00:16:58,226 --> 00:17:00,116
而这些孩子也正在


465
00:17:00,116 --> 00:17:01,936
练习书写数字


466
00:17:02,596 --> 00:17:04,846
所以我们想为什么不让


467
00:17:04,846 --> 00:17:06,856
他们直接在屏幕上画呢


468
00:17:06,856 --> 00:17:10,516
要做到这一点


469
00:17:10,516 --> 00:17:11,256
我们需要让我们的 App


470
00:17:11,256 --> 00:17:12,806
能识别手写数字


471
00:17:13,976 --> 00:17:15,506
幸运的是机器学习已经在


472
00:17:15,506 --> 00:17:16,695
解决这一问题上


473
00:17:16,695 --> 00:17:18,786
做得足够好


474
00:17:19,106 --> 00:17:20,236
事实上这里有一个完整的


475
00:17:20,236 --> 00:17:22,156
数据集可供你训练


476
00:17:22,156 --> 00:17:23,205
自己的模型来


477
00:17:23,266 --> 00:17:24,026
识别手写数字


478
00:17:24,026 --> 00:17:25,086
这一模型被称为 MNIST


479
00:17:26,396 --> 00:17:28,185
我们做到了这一点


480
00:17:28,185 --> 00:17:29,726
我们将它放在 Core ML


481
00:17:29,726 --> 00:17:30,406
模型页面上


482
00:17:31,576 --> 00:17:33,346
那么让我们看看如何


483
00:17:33,346 --> 00:17:34,436
在代码中使用这个模型


484
00:17:35,336 --> 00:17:36,396
我们将使用 Vision


485
00:17:36,396 --> 00:17:37,076
和 PencilKit 框架


486
00:17:37,676 --> 00:17:40,696
设置 Vision 来使用 


487
00:17:40,696 --> 00:17:42,226
Core ML 模型


488
00:17:42,226 --> 00:17:43,066
在这里的模型是 MNISTClassifier


489
00:17:43,536 --> 00:17:47,756
接下来我们从 PencilKit canvasViiew


490
00:17:47,756 --> 00:17:48,796
中获取图像


491
00:17:48,966 --> 00:17:52,876
这样我们设置好 Vision 请求处理器


492
00:17:52,876 --> 00:17:54,906
使用该图像


493
00:17:56,356 --> 00:17:59,286
接下来我们执行请求


494
00:17:59,286 --> 00:18:00,076
并得到结果


495
00:18:00,076 --> 00:18:00,976
就是这么简单


496
00:18:03,576 --> 00:18:04,956
所以我们将它集成到我们的模型中


497
00:18:04,956 --> 00:18:08,616
它开始工作得非常好


498
00:18:08,616 --> 00:18:10,716
我们识别了不少


499
00:18:10,716 --> 00:18:11,596
手写的数字


500
00:18:14,276 --> 00:18:15,976
但当我们书写的


501
00:18:15,976 --> 00:18:17,506
数字变大时


502
00:18:17,506 --> 00:18:19,856
我们发现了一些很有趣的东西


503
00:18:19,856 --> 00:18:20,766
我们的模型有时候


504
00:18:20,766 --> 00:18:21,906
会得到错误的预测结果


505
00:18:22,696 --> 00:18:24,566
所以发生了什么


506
00:18:24,946 --> 00:18:27,646
要理解这一点


507
00:18:27,646 --> 00:18:30,706
我们需要查看输入到模型里面的图像


508
00:18:30,706 --> 00:18:33,186
我们可以在 Xcode 里做到这一点


509
00:18:34,286 --> 00:18:36,626
于是我们设置一个


510
00:18:36,626 --> 00:18:38,096
从 PencilKit 中获取图像的断点


511
00:18:38,096 --> 00:18:40,886
然后我们使用 Xcode 的快速预览


512
00:18:41,206 --> 00:18:42,826
来查看实际图像到底是什么


513
00:18:42,956 --> 00:18:44,996
当我们完成这些时


514
00:18:44,996 --> 00:18:47,456
我们看到了一些有趣的东西


515
00:18:47,456 --> 00:18:49,766
示例中的 7 对于模型来说


516
00:18:49,766 --> 00:18:51,126
并不像 7


517
00:18:51,786 --> 00:18:53,446
而是更像 1


518
00:18:54,006 --> 00:18:56,396
那么这里发生了什么


519
00:18:56,396 --> 00:19:00,066
我们需要考虑模型


520
00:19:00,066 --> 00:19:01,506
对于输入的期望


521
00:19:02,956 --> 00:19:05,506
这个模型期望一个 28 乘以 28


522
00:19:05,506 --> 00:19:08,796
像素的图像


523
00:19:08,796 --> 00:19:10,156
但我们在屏幕上


524
00:19:10,156 --> 00:19:11,846
绘制的数字比这个大得多


525
00:19:13,096 --> 00:19:14,406
所以要获得正确格式的图像


526
00:19:14,456 --> 00:19:15,836
我们需要缩小输入


527
00:19:16,656 --> 00:19:18,716
但当我们缩小它时


528
00:19:18,716 --> 00:19:20,026
就丢失了屏幕上


529
00:19:20,026 --> 00:19:20,836
绘制的笔画的信息


530
00:19:20,836 --> 00:19:23,006
因此我们的 7 开始看起来


531
00:19:23,006 --> 00:19:24,316
更像 1


532
00:19:24,716 --> 00:19:28,376
当我们知道了这一点


533
00:19:28,406 --> 00:19:29,786
修复这个问题就变得简单


534
00:19:29,786 --> 00:19:31,476
我们需要用更粗的笔画


535
00:19:31,556 --> 00:19:35,046
这样的话


536
00:19:35,046 --> 00:19:37,006
我们输入到模型的图像


537
00:19:37,006 --> 00:19:38,806
就更接近于我们在屏幕上


538
00:19:38,806 --> 00:19:39,776
书写的图像


539
00:19:39,776 --> 00:19:41,766
并且此时模型预测出来


540
00:19:41,766 --> 00:19:43,446
的结果也变得更加正确


541
00:19:44,836 --> 00:19:46,616
PencilKit 让这一点变得很容易


542
00:19:47,786 --> 00:19:49,746
在这里我们将


543
00:19:49,746 --> 00:19:51,436
allowsFingerDrawing 设置为真


544
00:19:51,436 --> 00:19:52,726
因为我们用手指在屏幕上书写


545
00:19:52,856 --> 00:19:56,826
然后我们将工具设置为


546
00:19:56,906 --> 00:19:57,976
具有更粗笔画的马克笔


547
00:20:01,356 --> 00:20:04,416
好了 我们的模型现在


548
00:20:05,426 --> 00:20:07,706
可以很好地识别单个数字


549
00:20:08,396 --> 00:20:10,536
但我们还有别的一些挑战


550
00:20:11,396 --> 00:20:13,766
一些数字是以


551
00:20:13,766 --> 00:20:14,976
多个笔画进行书写的


552
00:20:15,506 --> 00:20:19,096
我们的模型提取数字


553
00:20:19,176 --> 00:20:20,796
的静态图像信息


554
00:20:20,796 --> 00:20:21,926
而不是关于该数字的笔画信息


555
00:20:23,016 --> 00:20:24,466
那么我们如何知道何时


556
00:20:24,766 --> 00:20:26,126
提取屏幕上书写的信息


557
00:20:26,196 --> 00:20:28,416
并将信息输入到我们模型中


558
00:20:29,126 --> 00:20:30,276
进行预测呢


559
00:20:30,276 --> 00:20:33,816
此外由于我们要对骰子的示数


560
00:20:33,816 --> 00:20:35,246
进行加法或乘法


561
00:20:35,246 --> 00:20:37,566
我们可能要处理多位数字


562
00:20:37,566 --> 00:20:39,896
而我们的模型只被训练


563
00:20:39,896 --> 00:20:41,116
用于识别单个数字


564
00:20:41,116 --> 00:20:43,236
而非多位数字


565
00:20:44,096 --> 00:20:45,726
那么我们如何处理这样的情况


566
00:20:46,496 --> 00:20:47,586
我们可以用机器学习


567
00:20:47,586 --> 00:20:48,956
来解决这些问题


568
00:20:48,956 --> 00:20:50,456
我们可以训练一个模型


569
00:20:50,456 --> 00:20:51,796
来识别关于数字的笔画信息


570
00:20:51,796 --> 00:20:54,156
或者我们可以训练


571
00:20:54,156 --> 00:20:55,686
一个模型去识别


572
00:20:55,686 --> 00:20:56,936
多位数字


573
00:20:56,986 --> 00:20:58,826
但我们已经知道了


574
00:20:58,826 --> 00:21:00,876
很多关于屏幕上书写内容的信息


575
00:21:01,386 --> 00:21:03,236
所以我们不使用机器学习


576
00:21:03,236 --> 00:21:04,576
而是使用程序的方法解决这一问题


577
00:21:04,876 --> 00:21:05,896
让我来向你演示如何做到


578
00:21:06,426 --> 00:21:08,676
我们来看看这个例子吧


579
00:21:09,736 --> 00:21:11,116
有人在屏幕上绘制


580
00:21:11,116 --> 00:21:12,426
1 的第一个笔画


581
00:21:12,426 --> 00:21:15,406
我们把它作为一个图像


582
00:21:15,406 --> 00:21:16,626
传递给我们的模型并得到预测结果


583
00:21:16,626 --> 00:21:17,796
这个结果就是 1 


584
00:21:19,246 --> 00:21:20,766
接下来他们绘制


585
00:21:20,766 --> 00:21:23,766
1 的底部横线


586
00:21:23,966 --> 00:21:25,616
我们看看之后的笔画


587
00:21:25,616 --> 00:21:28,216
是否与前一个笔画重叠


588
00:21:29,086 --> 00:21:30,836
因为发生重叠 所以我们知道


589
00:21:30,836 --> 00:21:32,976
这是同一个数字


590
00:21:32,976 --> 00:21:34,716
于是我们扔掉第一次预测的结果


591
00:21:34,716 --> 00:21:35,916
将第一画与第二画


592
00:21:35,916 --> 00:21:37,756
结合成同一个图片


593
00:21:37,756 --> 00:21:39,296
并将结合后的整张图片


594
00:21:39,296 --> 00:21:40,026
输入给我们的模型


595
00:21:40,136 --> 00:21:42,156
预测的结果为 1 


596
00:21:42,696 --> 00:21:45,536
接下来用户在屏幕上


597
00:21:45,536 --> 00:21:46,326
书写了新的笔画


598
00:21:47,546 --> 00:21:49,176
我们将关注第三个笔画


599
00:21:49,176 --> 00:21:51,926
查看其是否与前两个笔画中的


600
00:21:51,926 --> 00:21:52,876
任何一个重叠


601
00:21:53,746 --> 00:21:55,306
因为没有重叠


602
00:21:55,306 --> 00:21:56,906
我们知道它是一个单独的数字


603
00:21:56,906 --> 00:21:58,226
所以我们将它单独传递给模型


604
00:21:58,226 --> 00:22:02,356
并且预测它是 2 


605
00:22:02,596 --> 00:22:03,516
现在我想邀请 Scott 回来


606
00:22:03,516 --> 00:22:06,126
在 App 中向你们展示


607
00:22:06,126 --> 00:22:11,416
Scott [鼓掌]


608
00:22:11,916 --> 00:22:15,166
>> 感谢 Brent 现在我们的 App 更新了


609
00:22:15,266 --> 00:22:16,876
它仍然保留对象探测器


610
00:22:16,876 --> 00:22:18,316
用来检测骰子


611
00:22:18,536 --> 00:22:20,716
和分类骰子上的值


612
00:22:21,136 --> 00:22:22,536
但我们还在上面添加了


613
00:22:22,606 --> 00:22:23,856
如 Brent 前面所说的


614
00:22:23,856 --> 00:22:24,486
识别手写输入的功能


615
00:22:25,716 --> 00:22:27,726
所以我觉得是时候做一些计算了


616
00:22:30,276 --> 00:22:31,796
在这里用户可以选择将


617
00:22:31,796 --> 00:22:33,426
骰子的示数


618
00:22:33,426 --> 00:22:34,986
相加或相乘


619
00:22:35,306 --> 00:22:36,726
所以为了简单起见


620
00:22:36,726 --> 00:22:37,816
我将从加法开始


621
00:22:38,426 --> 00:22:40,066
那么让我们看看输入处理


622
00:22:40,066 --> 00:22:45,036
是如何工作的 对了


623
00:22:46,516 --> 00:22:50,626
[鼓掌]


624
00:22:51,126 --> 00:22:53,516
那么如果我们将这些值相乘


625
00:22:53,516 --> 00:22:55,036
我很确定会得到 24


626
00:22:56,036 --> 00:22:57,316
这是一个有趣的数字


627
00:22:57,826 --> 00:22:58,666
我希望你密切关注


628
00:22:58,666 --> 00:23:00,146
当我在屏幕上画 4 时


629
00:23:00,146 --> 00:23:01,226
发生了什么


630
00:23:02,756 --> 00:23:04,236
如果你考虑使用


631
00:23:04,236 --> 00:23:06,076
两个笔画书写 4


632
00:23:06,076 --> 00:23:07,086
那我们的模型在只看到


633
00:23:07,086 --> 00:23:08,336
第一个笔画时


634
00:23:08,456 --> 00:23:10,046
将很难识别出 4


635
00:23:10,046 --> 00:23:11,746
所以它可能会预测为其他数字


636
00:23:11,746 --> 00:23:13,966
直到我书写第二个笔画


637
00:23:15,066 --> 00:23:15,626
我们来看一下


638
00:23:21,276 --> 00:23:22,646
你是否注意到了


639
00:23:22,646 --> 00:23:24,046
这里的 4 的第一画被识别成 1 


640
00:23:24,046 --> 00:23:25,676
但当我书写了第二画时


641
00:23:25,726 --> 00:23:27,176
预测的结果立即变成了 4 


642
00:23:27,946 --> 00:23:30,646
有一个答案被设置为


643
00:23:30,716 --> 00:23:33,026
始终正确


644
00:23:33,026 --> 00:23:34,376
我只是想向你们展示更多的 4 


645
00:23:34,546 --> 00:23:34,746
让我们一起来看看


646
00:23:40,426 --> 00:23:43,846
很好 所以我们的 App 可以


647
00:23:43,846 --> 00:23:45,316
识别桌面上的骰子


648
00:23:45,316 --> 00:23:47,576
理解掷骰子行为 检查计算结果


649
00:23:47,576 --> 00:23:50,806
我们可以在屏幕上


650
00:23:50,996 --> 00:23:52,716
绘制数字作为输入


651
00:23:52,716 --> 00:23:53,896
但我们谈论的是将现实世界


652
00:23:53,896 --> 00:23:55,246
和虚拟世界进行融合


653
00:23:55,246 --> 00:23:56,846
所以我们认为


654
00:23:56,846 --> 00:23:58,526
如果孩子们在玩游戏的时候


655
00:23:58,526 --> 00:24:01,036
可以以语音的形式


656
00:24:01,036 --> 00:24:02,606
输入他们的答案


657
00:24:02,606 --> 00:24:04,116
那将会很有趣并且交互性很强


658
00:24:04,786 --> 00:24:07,766
那么让我们来看看


659
00:24:07,766 --> 00:24:09,416
再一次我要将这两个数


660
00:24:09,416 --> 00:24:11,516
运算来得到 24


661
00:24:11,926 --> 00:24:13,646
然后让我们用语音来做


662
00:24:14,906 --> 00:24:18,466
24 酷


663
00:24:21,276 --> 00:24:22,686
使用 Speech 框架


664
00:24:22,686 --> 00:24:23,396
让这一点变得非常容易


665
00:24:23,966 --> 00:24:29,836
今年我们在语音方面


666
00:24:29,836 --> 00:24:32,166
添加了离线语音识别


667
00:24:33,096 --> 00:24:34,406
这意味着即使你的设备


668
00:24:34,406 --> 00:24:35,756
未连接到互联网


669
00:24:36,126 --> 00:24:37,566
语音识别也可以


670
00:24:37,566 --> 00:24:38,516
在你的 App 中使用


671
00:24:39,566 --> 00:24:41,586
如果你希望将用户的数据


672
00:24:41,586 --> 00:24:43,746
保留在他们的设备上


673
00:24:43,746 --> 00:24:45,696
你实际上可以通过


674
00:24:45,696 --> 00:24:47,236
将语音识别器中的


675
00:24:47,236 --> 00:24:48,226
requiresOnDeviceRecognition


676
00:24:48,506 --> 00:24:50,026
设置为 true 来要求


677
00:24:50,026 --> 00:24:50,946
在设备上进行语音识别


678
00:24:54,406 --> 00:24:56,326
所以现在我们的 App 可以理解


679
00:24:56,326 --> 00:24:58,206
掷骰子行为


680
00:24:58,206 --> 00:25:00,716
并处理不同的输入形式


681
00:25:00,716 --> 00:25:02,706
但我们需要继续我们的旅程


682
00:25:02,796 --> 00:25:04,856
并完成任务


683
00:25:05,116 --> 00:25:06,206
所以我想欢迎


684
00:25:06,206 --> 00:25:06,956
Brent 重返舞台


685
00:25:07,516 --> 00:25:10,536
[鼓掌]


686
00:25:11,036 --> 00:25:11,546
>> 感谢你 Scott


687
00:25:17,576 --> 00:25:21,566
正如 Scott 所说


688
00:25:21,566 --> 00:25:24,616
我们的 App 可以识别骰子


689
00:25:24,616 --> 00:25:26,696
并且我们知道如何处理用户的输入


690
00:25:27,366 --> 00:25:29,896
但我们说这是一个游戏 对吧


691
00:25:30,626 --> 00:25:34,026
为了做到这一点


692
00:25:34,026 --> 00:25:36,066
接下来我们将整合 ARKit


693
00:25:36,066 --> 00:25:39,116
真正完成整个体验


694
00:25:39,666 --> 00:25:45,266
当然任何游戏都需要规则


695
00:25:45,546 --> 00:25:48,566
所以让我们先来看看规则


696
00:25:50,416 --> 00:25:52,706
我们的比赛是在一个


697
00:25:52,706 --> 00:25:54,516
分成九份的圆形板上进行的


698
00:25:55,206 --> 00:25:58,026
每个玩家从第一部分开始


699
00:25:58,026 --> 00:26:00,606
目标是围绕棋盘


700
00:26:00,606 --> 00:26:02,486
顺时针移动


701
00:26:02,486 --> 00:26:04,666
并刚好停在第九部分


702
00:26:05,286 --> 00:26:09,536
掷的数太小


703
00:26:09,536 --> 00:26:11,226
会让你走的不够远


704
00:26:12,656 --> 00:26:14,556
掷的数太大


705
00:26:14,556 --> 00:26:18,706
你就会越过你的目标


706
00:26:18,906 --> 00:26:20,256
在每个玩家的回合中


707
00:26:20,256 --> 00:26:22,616
他们掷骰子并且有两个选择


708
00:26:22,616 --> 00:26:25,496
他们可以取


709
00:26:25,496 --> 00:26:27,516
骰子的和


710
00:26:27,516 --> 00:26:28,836
并沿顺时针方向移动该数字


711
00:26:29,666 --> 00:26:30,856
或者他们可以取


712
00:26:30,856 --> 00:26:33,006
骰子顶部数字的差


713
00:26:33,046 --> 00:26:33,926
并沿顺时针方向移动该数字


714
00:26:35,166 --> 00:26:38,426
那么 Scott 你想要来比一比吗


715
00:26:39,516 --> 00:26:43,500
[鼓掌]


716
00:26:50,356 --> 00:26:51,496
>> 那么现在我们将


717
00:26:51,496 --> 00:26:53,766
虚拟棋盘集成到 ARKit 游戏中


718
00:26:53,806 --> 00:26:57,366
并且利用 Core ML 来识别骰子


719
00:26:58,036 --> 00:26:59,366
由 Brent 你来开始怎么样


720
00:26:59,666 --> 00:27:02,456
>> 听上去不错 好的


721
00:27:02,976 --> 00:27:06,356
5 我掷到的数是 5 和 2


722
00:27:06,356 --> 00:27:09,976
很好 我认为我应该把这些数字加起来


723
00:27:15,376 --> 00:27:17,656
>> 很好 噢你已经接近终点了


724
00:27:17,726 --> 00:27:17,976
>> 很接近了


725
00:27:22,056 --> 00:27:24,996
>> 那么我掷了 6 和 1


726
00:27:24,996 --> 00:27:27,116
我可以将数字相减得到 5


727
00:27:27,186 --> 00:27:29,436
或者将其相加与 Brent 在 8 会合


728
00:27:29,436 --> 00:27:30,966
让我们把这些数加起来


729
00:27:37,796 --> 00:27:38,276
>> 很好


730
00:27:38,516 --> 00:27:42,626
我不认为 我会掷出 1


731
00:27:42,626 --> 00:27:49,826
让我们来看看 这次我要做减法 得到的是 2


732
00:27:59,676 --> 00:28:01,446
>> 好吧我再次掷出 6 和 1


733
00:28:01,686 --> 00:28:02,746
这一次我也做减法


734
00:28:02,746 --> 00:28:04,546
然后用它们得到 5 


735
00:28:05,506 --> 00:28:07,746
Brent 认为


736
00:28:08,866 --> 00:28:10,066
我画的 5 很好笑


737
00:28:10,926 --> 00:28:13,946
>> 你知道这个游戏可能


738
00:28:13,946 --> 00:28:16,496
会持续非常长的时间


739
00:28:16,986 --> 00:28:18,876
我认为 Scott 已经提到了


740
00:28:18,876 --> 00:28:20,786
一个始终正确的数字


741
00:28:20,786 --> 00:28:23,366
接下来让我们看看


742
00:28:23,366 --> 00:28:23,926
这个数字在游戏里是否奏效


743
00:28:28,326 --> 00:28:31,536
>> Brent 你发现了秘密 干得好


744
00:28:31,776 --> 00:28:37,500
>> 成功了 [鼓掌]


745
00:28:43,626 --> 00:28:47,466
很好 我们将多种技术结合在一起


746
00:28:47,516 --> 00:28:49,686
以将我们的物理


747
00:28:49,806 --> 00:28:52,186
和虚拟世界融合


748
00:28:53,436 --> 00:28:54,686
我们建立了超越


749
00:28:54,686 --> 00:28:56,566
任何单一技术的体验


750
00:28:57,016 --> 00:28:58,646
它让我们在这个增强的新世界中


751
00:28:58,646 --> 00:28:59,996
玩这个有趣的游戏


752
00:29:01,366 --> 00:29:03,606
我们使用对象检测


753
00:29:03,606 --> 00:29:07,326
来识别桌子上的骰子


754
00:29:07,466 --> 00:29:09,476
我们使用图像分类


755
00:29:09,476 --> 00:29:11,706
来识别屏幕上的手写数字


756
00:29:12,916 --> 00:29:14,556
我们使用语音识别作为


757
00:29:14,556 --> 00:29:15,886
与我们的 App 互动的另一种方式


758
00:29:16,266 --> 00:29:18,636
我们引入了 ARKit 


759
00:29:18,636 --> 00:29:20,666
来真正完成整个体验


760
00:29:22,376 --> 00:29:23,996
如果你想了解更多信息


761
00:29:24,766 --> 00:29:28,616
请参阅开发者网站上的 228 号会议


762
00:29:28,676 --> 00:29:30,096
或明天在实验室与我们联系


763
00:29:30,716 --> 00:29:32,756
感谢各位 并祝各位能够享受余下的会议


764
00:29:33,508 --> 00:29:35,508
[鼓掌]

