1
00:00:00,506 --> 00:00:05,500
[音乐]


2
00:00:10,516 --> 00:00:13,566
[掌声]


3
00:00:14,066 --> 00:00:15,196
>> 大家好


4
00:00:16,146 --> 00:00:17,296
欢迎参加今天的 Metal 会议


5
00:00:18,096 --> 00:00:18,996
我是 Lionel


6
00:00:19,076 --> 00:00:20,386
我是 Apple 的 GPU


7
00:00:20,386 --> 00:00:21,766
软件性能团队中的一员


8
00:00:22,736 --> 00:00:25,546
我将与我的朋友 Max 和 Sarah 一起


9
00:00:25,546 --> 00:00:27,066
指导你如何将


10
00:00:27,066 --> 00:00:29,636
OpenGL App 带到 Metal 中


11
00:00:30,326 --> 00:00:33,496
去年 我们宣布


12
00:00:33,606 --> 00:00:36,936
OpenGL OpenGL ES 和 OpenCL


13
00:00:37,056 --> 00:00:37,966
都是不推荐的


14
00:00:38,976 --> 00:00:39,926
iOS 13 和 macOS Catalina


15
00:00:39,926 --> 00:00:43,436
将继续支持它们


16
00:00:43,436 --> 00:00:46,746
但现在是时候向前一步了


17
00:00:47,926 --> 00:00:49,476
新项目应该从一开始


18
00:00:49,476 --> 00:00:50,436
就以 Metal 为目标


19
00:00:50,816 --> 00:00:52,496
但如果你有一个


20
00:00:52,826 --> 00:00:54,176
想要移植到 Metal 的 OpenGL App


21
00:00:54,716 --> 00:00:57,696
那你就来对地方了


22
00:00:58,266 --> 00:00:59,836
我们在 2014 年


23
00:00:59,936 --> 00:01:03,266
首次引入 Metal


24
00:01:03,546 --> 00:01:04,635
作为我们全新的


25
00:01:04,926 --> 00:01:07,266
低成本 高效率 高性能的 GPU 编程 API


26
00:01:07,726 --> 00:01:10,936
在过去的五年里


27
00:01:11,386 --> 00:01:13,726
Apple 的核心框架


28
00:01:13,726 --> 00:01:15,706
一直采用 Metal


29
00:01:15,706 --> 00:01:17,146
并且取得了非常好的效果


30
00:01:17,586 --> 00:01:19,306
如果你的 App


31
00:01:19,306 --> 00:01:21,216
构建在 SpriteKit


32
00:01:21,546 --> 00:01:23,846
SceneKit RealityKit Core Image


33
00:01:23,846 --> 00:01:25,616
Core Animation 等层之上


34
00:01:25,616 --> 00:01:26,666
那么你已经在使用 Metal 了


35
00:01:28,796 --> 00:01:30,326
我们还与 Unity


36
00:01:30,326 --> 00:01:31,986
Unreal Engine 4 和 Lumberyard 等


37
00:01:31,986 --> 00:01:34,036
引擎厂商紧密合作


38
00:01:34,036 --> 00:01:37,326
以充分利用 Metal 的优势


39
00:01:37,836 --> 00:01:38,846
如果你正在使用这些引擎之一


40
00:01:38,846 --> 00:01:41,836
那么你已经赶上了速度


41
00:01:45,316 --> 00:01:47,656
如果你已经建立了


42
00:01:47,656 --> 00:01:49,656
自己的渲染器


43
00:01:49,656 --> 00:01:50,946
那么 Metal 会给你带来很多优势


44
00:01:51,926 --> 00:01:54,036
Metal 将 OpenGL 的图形


45
00:01:54,036 --> 00:01:56,376
和 OpenCL 的计算结合成


46
00:01:56,516 --> 00:01:57,816
一个统一的 API


47
00:01:59,336 --> 00:02:01,436
它允许你在 App 中使用


48
00:02:01,436 --> 00:02:02,936
多线程渲染


49
00:02:04,136 --> 00:02:05,766
每当有繁复的 CPU 操作


50
00:02:05,766 --> 00:02:07,226
需要执行时


51
00:02:07,226 --> 00:02:09,096
我们都会确保这些操作


52
00:02:09,096 --> 00:02:10,366
尽可能不频繁地发生


53
00:02:10,366 --> 00:02:11,876
以减少 App


54
00:02:11,876 --> 00:02:14,616
在执行期间的消耗


55
00:02:16,666 --> 00:02:18,746
Metal 的着色语言


56
00:02:18,796 --> 00:02:20,756
是基于 C++ 的


57
00:02:20,756 --> 00:02:23,036
App 中使用的所有着色器


58
00:02:23,036 --> 00:02:25,176
都可以预编译


59
00:02:25,176 --> 00:02:27,586
例如 你可以更容易地拥有


60
00:02:27,586 --> 00:02:28,556
各种材料的着色器


61
00:02:29,066 --> 00:02:32,056
最后同样重要的是


62
00:02:32,056 --> 00:02:33,786
我们在 Xcode 中


63
00:02:33,786 --> 00:02:36,426
构建了一整套调试和优化工具


64
00:02:37,936 --> 00:02:39,316
因此 一旦你将其移植到 Metal


65
00:02:39,316 --> 00:02:40,936
你就拥有了使你的 App


66
00:02:40,936 --> 00:02:42,656
更好运行的全部支持


67
00:02:43,786 --> 00:02:46,826
让我们开始吧 在本会议中


68
00:02:46,826 --> 00:02:48,046
我们将看看从 GL


69
00:02:48,046 --> 00:02:51,376
迁移到 Metal 的步骤


70
00:02:51,376 --> 00:02:52,906
并将典型的 GL App 与 Metal App


71
00:02:52,906 --> 00:02:57,286
进行比较


72
00:02:57,706 --> 00:03:00,076
作为概述


73
00:03:00,736 --> 00:03:03,036
让我们快速浏览一下 GL App 的步骤


74
00:03:03,996 --> 00:03:06,686
首先 你需要设立一个窗口


75
00:03:06,686 --> 00:03:07,656
用于渲染


76
00:03:08,326 --> 00:03:09,716
然后创建缓冲区


77
00:03:09,716 --> 00:03:11,806
纹理和采样器等资源


78
00:03:12,536 --> 00:03:13,866
你可以实现所有


79
00:03:14,146 --> 00:03:15,276
用 GLSL 编写的着色器


80
00:03:16,466 --> 00:03:17,726
在你可以在 GL 中


81
00:03:17,726 --> 00:03:19,126
渲染任何东西之前


82
00:03:19,126 --> 00:03:20,746
你需要创建特定的对象状态


83
00:03:20,746 --> 00:03:22,216
比如 GL 程序


84
00:03:22,216 --> 00:03:24,736
GL 帧缓冲对象 顶点数组对象


85
00:03:25,976 --> 00:03:28,026
一旦你初始化了


86
00:03:28,106 --> 00:03:30,416
渲染循环就开始了


87
00:03:30,416 --> 00:03:32,646
你的资源就会开始绘制你的帧


88
00:03:33,356 --> 00:03:35,206
对于每个帧


89
00:03:35,206 --> 00:03:38,046
你要首先更新资源


90
00:03:38,046 --> 00:03:40,346
绑定特定的帧缓冲区


91
00:03:40,346 --> 00:03:42,526
设置图形状态并进行绘制调用


92
00:03:43,536 --> 00:03:44,756
对每个帧缓冲区


93
00:03:44,756 --> 00:03:46,156
都重复此过程


94
00:03:46,416 --> 00:03:47,816
你可能有阴影贴图


95
00:03:47,816 --> 00:03:49,906
光照通道 一些后期处理


96
00:03:50,486 --> 00:03:53,396
可能有相当多的渲染通道


97
00:03:53,936 --> 00:04:00,376
最后 呈现最终渲染出的图像十分简单


98
00:04:01,436 --> 00:04:02,646
正如你所看到的


99
00:04:02,646 --> 00:04:04,226
Metal 流程看起来非常相似


100
00:04:04,976 --> 00:04:06,656
我们更新了一些原始的概念


101
00:04:06,656 --> 00:04:09,216
并引入了一些新的东西


102
00:04:09,446 --> 00:04:12,416
但总的来说 流程基本相同


103
00:04:12,626 --> 00:04:13,936
它不是对引擎的完全重写


104
00:04:13,936 --> 00:04:17,305
它以同样的方式工作


105
00:04:18,995 --> 00:04:21,625
我们将重新引入新的概念


106
00:04:21,625 --> 00:04:23,366
同时在 GL 和 Metal 之间


107
00:04:23,366 --> 00:04:26,216
画出平行线


108
00:04:26,216 --> 00:04:28,206
比较和对比这两个 API


109
00:04:28,206 --> 00:04:30,276
以帮助你成功地进行转换


110
00:04:30,846 --> 00:04:34,436
当你浏览


111
00:04:34,436 --> 00:04:36,496
任何的图形教程时


112
00:04:36,566 --> 00:04:39,396
首先要学习的是


113
00:04:39,636 --> 00:04:41,586
如何创建和绘制窗口


114
00:04:42,476 --> 00:04:44,046
让我们从窗口子系统开始


115
00:04:44,426 --> 00:04:45,726
GL 和 Metal 都有这个概念


116
00:04:45,726 --> 00:04:48,716
但是实现的方式略有不同


117
00:04:49,316 --> 00:04:52,226
需要对 App 设置


118
00:04:52,226 --> 00:04:54,006
并渲染一个绘图面


119
00:04:54,076 --> 00:04:55,576
视图和视图委托


120
00:04:55,606 --> 00:04:57,396
管理 API 和底层窗口系统


121
00:04:57,396 --> 00:04:59,636
之间的接口


122
00:04:59,636 --> 00:05:02,726
你可能正在使用这些框架


123
00:05:02,726 --> 00:05:04,786
来管理 GL 视图


124
00:05:04,786 --> 00:05:06,196
我们在 Metal 中


125
00:05:06,246 --> 00:05:07,336
也有类似的框架


126
00:05:08,466 --> 00:05:12,366
NSOpenGLView 和 GLKView 映射到 MTKView


127
00:05:13,156 --> 00:05:14,306
如果你在你的 App 中


128
00:05:14,306 --> 00:05:15,866
通过 EAGLLayer


129
00:05:15,866 --> 00:05:17,636
使用 Core Animation


130
00:05:17,636 --> 00:05:19,416
那么有一个等价的 CAMetalLayer


131
00:05:19,416 --> 00:05:24,266
例如 假设你正在使用 GLKView


132
00:05:25,566 --> 00:05:27,976
它有一个单一的入口点与提取率


133
00:05:28,336 --> 00:05:29,646
你需要它来检查


134
00:05:29,646 --> 00:05:31,366
目标的分辨率


135
00:05:31,366 --> 00:05:32,876
自上一帧以来是否发生变化


136
00:05:32,996 --> 00:05:34,616
根据需要 从渲染循环中


137
00:05:34,876 --> 00:05:37,136
更新渲染目标的大小


138
00:05:38,496 --> 00:05:40,456
在 MetalKit 中有一点更新


139
00:05:40,456 --> 00:05:41,686
当 drawable 需要更改时


140
00:05:41,686 --> 00:05:44,706
例如当你旋转屏幕


141
00:05:44,706 --> 00:05:45,806
或调整窗口大小时


142
00:05:45,806 --> 00:05:48,136
有一个单独的函数进行处理


143
00:05:48,456 --> 00:05:49,876
所以你不需要检查


144
00:05:49,876 --> 00:05:51,036
你的资源是否需要


145
00:05:51,036 --> 00:05:54,076
在你的 draw 函数中重新分配


146
00:05:54,076 --> 00:05:55,956
它致力于渲染代码


147
00:05:59,276 --> 00:06:00,396
如果你需要额外的灵活性


148
00:06:00,396 --> 00:06:02,236
我们提供 CAMetalLayer


149
00:06:02,286 --> 00:06:05,556
你可以将其


150
00:06:05,596 --> 00:06:07,466
用作视图的支持层


151
00:06:08,876 --> 00:06:11,216
CAEAGLLayer 定义了


152
00:06:11,216 --> 00:06:12,576
可绘制的属性


153
00:06:12,656 --> 00:06:15,636
比如颜色格式


154
00:06:15,636 --> 00:06:18,186
CAMetalLayer 允许设置


155
00:06:18,186 --> 00:06:20,616
drawable 尺寸


156
00:06:20,616 --> 00:06:22,176
像素格式 颜色空间等等


157
00:06:23,146 --> 00:06:25,056
重要的是


158
00:06:25,056 --> 00:06:28,016
CAMetalLayer 保有一个纹理库


159
00:06:28,016 --> 00:06:29,646
你可以调用下一个 drawable


160
00:06:29,646 --> 00:06:31,206
从而获取 drawable 来渲染你的帧


161
00:06:31,586 --> 00:06:32,846
这是一个很重要的概念


162
00:06:32,846 --> 00:06:34,646
我们会在需要的时候


163
00:06:34,896 --> 00:06:37,876
再回顾一下


164
00:06:37,976 --> 00:06:38,986
现在我们有一个窗口


165
00:06:39,546 --> 00:06:42,066
接下来我们要介绍一些


166
00:06:42,066 --> 00:06:43,286
Metal 中的新概念


167
00:06:43,536 --> 00:06:45,006
命令队列


168
00:06:45,006 --> 00:06:46,396
命令缓冲区 命令编码器


169
00:06:46,976 --> 00:06:48,896
这些对象在 Metal 中协同工作


170
00:06:48,896 --> 00:06:50,626
并向 GPU 提交工作


171
00:06:51,436 --> 00:06:52,616
它们是新的


172
00:06:52,616 --> 00:06:55,056
因为底层的 GL Context


173
00:06:55,166 --> 00:06:56,366
为你管理着提交


174
00:06:56,366 --> 00:07:02,096
GL 是一个隐式 API


175
00:07:02,096 --> 00:07:03,596
这意味着没有代码告诉 GL


176
00:07:03,596 --> 00:07:06,406
何时调度工作


177
00:07:06,676 --> 00:07:08,126
作为开发者


178
00:07:08,126 --> 00:07:09,626
你几乎无法控制


179
00:07:09,626 --> 00:07:11,586
图形工作何时真正发生


180
00:07:11,746 --> 00:07:13,376
比如何时编译着色器


181
00:07:13,376 --> 00:07:15,436
何时分配资源存储


182
00:07:15,436 --> 00:07:18,236
何时进行验证


183
00:07:18,236 --> 00:07:20,366
或者何时将工作


184
00:07:20,366 --> 00:07:21,576
真正地提交给 GPU


185
00:07:22,106 --> 00:07:24,106
GL Context 是一个


186
00:07:24,106 --> 00:07:25,026
大型的状态机器


187
00:07:25,026 --> 00:07:26,656
典型的工作流应该是这样的


188
00:07:27,306 --> 00:07:28,886
你的 App 创建一个 GL Context


189
00:07:28,886 --> 00:07:31,056
在线程上设置它


190
00:07:31,126 --> 00:07:33,676
然后调用任意的 GL 注释


191
00:07:34,276 --> 00:07:35,556
注释由底层的


192
00:07:35,586 --> 00:07:37,106
上下文记录


193
00:07:37,106 --> 00:07:39,056
并将在某个时间点执行


194
00:07:39,846 --> 00:07:40,966
让我们仔细看看


195
00:07:40,966 --> 00:07:41,866
到底发生了什么


196
00:07:43,186 --> 00:07:46,056
假设你的 App 只是发送 GL


197
00:07:46,056 --> 00:07:47,856
这些调用


198
00:07:47,856 --> 00:07:49,356
一些状态变化 一些 draw 调用


199
00:07:50,096 --> 00:07:51,236
在一个完美的场景中


200
00:07:51,236 --> 00:07:52,686
上下文会将其


201
00:07:52,966 --> 00:07:54,676
转换为 GPU 注释


202
00:07:54,676 --> 00:07:55,726
来填充内部缓冲区


203
00:07:56,126 --> 00:07:57,436
然后当它满了的时候


204
00:07:57,436 --> 00:07:58,786
它会把它发送到 GPU


205
00:07:59,566 --> 00:08:02,276
如果你插入一个 glFlush


206
00:08:02,276 --> 00:08:03,856
来强制执行


207
00:08:03,856 --> 00:08:05,876
你肯定知道它们就会在那个时候启动


208
00:08:06,456 --> 00:08:07,606
但实际上


209
00:08:07,606 --> 00:08:09,626
GPU 可以在任何时候提前开始执行


210
00:08:10,706 --> 00:08:12,766
好的 例如


211
00:08:12,766 --> 00:08:14,376
如果我们改变一个


212
00:08:14,376 --> 00:08:16,356
引入每个依赖项的绘制调用


213
00:08:16,356 --> 00:08:18,306
突然执行就会在那个时候启动


214
00:08:18,306 --> 00:08:20,036
你可能会遭受大量的停滞


215
00:08:21,476 --> 00:08:22,686
我们不得不再一次发问


216
00:08:22,686 --> 00:08:23,896
应该什么时候提交工作呢


217
00:08:23,896 --> 00:08:25,386
视情况而定


218
00:08:25,686 --> 00:08:28,956
这就是 OpenGL 的缺点之一


219
00:08:28,956 --> 00:08:30,946
性能不稳定


220
00:08:31,456 --> 00:08:33,366
任何一个小小的改变都可能


221
00:08:33,366 --> 00:08:35,676
迫使你偏离正轨


222
00:08:36,265 --> 00:08:37,916
另一方面 Metal


223
00:08:37,916 --> 00:08:39,785
是一个显式的 API


224
00:08:39,785 --> 00:08:41,256
这意味着 App 可以决定


225
00:08:41,256 --> 00:08:43,905
什么时候


226
00:08:43,986 --> 00:08:46,856
向 GPU 发送什么工作


227
00:08:47,576 --> 00:08:49,066
Metal 将 GL Context 的概念


228
00:08:49,066 --> 00:08:53,136
分解为内部工作对象的集合


229
00:08:54,026 --> 00:08:55,996
App 创建的第一个对象


230
00:08:56,766 --> 00:08:59,646
是一个 metalDevice 对象


231
00:08:59,646 --> 00:09:00,806
它是 GPU 的


232
00:09:01,296 --> 00:09:02,676
抽象表示


233
00:09:03,276 --> 00:09:05,666
然后 它创建一个名为


234
00:09:05,666 --> 00:09:07,006
metalCommandQueue 的键对象


235
00:09:07,656 --> 00:09:08,696
metalCommandQueue


236
00:09:08,696 --> 00:09:11,426
通过分配要填充的命令缓冲区


237
00:09:11,546 --> 00:09:13,556
来维护发送给 GPU 的


238
00:09:13,906 --> 00:09:15,016
命令的顺序


239
00:09:15,566 --> 00:09:18,596
而命令缓冲区只是一个


240
00:09:18,596 --> 00:09:19,916
GPU 命令列表


241
00:09:19,976 --> 00:09:22,106
你的 App 将填补发送给 GPU 执行


242
00:09:22,996 --> 00:09:24,286
在我们刚刚学习的 GL 例子中


243
00:09:24,286 --> 00:09:26,086
我们同样在 GL 中看到了


244
00:09:26,086 --> 00:09:27,126
这个命令缓冲区的概念


245
00:09:28,156 --> 00:09:29,536
让我们从现在开始


246
00:09:29,536 --> 00:09:32,746
处理这个命令缓冲区


247
00:09:33,066 --> 00:09:34,406
App 不会直接将命令


248
00:09:34,406 --> 00:09:35,976
写入命令缓冲区


249
00:09:35,976 --> 00:09:38,856
相反 它会创建一个


250
00:09:38,856 --> 00:09:40,016
Metal 命令编码器


251
00:09:40,886 --> 00:09:42,096
让我们看看主要的


252
00:09:42,096 --> 00:09:43,356
三种编码器


253
00:09:44,406 --> 00:09:46,236
我们使用的第一个编码器


254
00:09:46,236 --> 00:09:48,206
将充满用于复制周围资源的


255
00:09:48,206 --> 00:09:50,216
blit 命令


256
00:09:50,816 --> 00:09:53,816
这个命令编码器将 API 代码


257
00:09:53,866 --> 00:09:56,236
转换成 GPU 指令


258
00:09:56,666 --> 00:09:58,476
然后将它们写入命令缓冲区


259
00:09:59,286 --> 00:10:00,596
在一系列的命令被编码之后


260
00:10:00,596 --> 00:10:01,946
例如


261
00:10:01,946 --> 00:10:03,216
一系列的 blit 命令用于复制资源


262
00:10:03,216 --> 00:10:05,136
你的 App 将结束编码


263
00:10:05,136 --> 00:10:08,676
这将释放 encoder 对象


264
00:10:10,676 --> 00:10:13,136
此外 Metal 还支持


265
00:10:13,136 --> 00:10:14,786
一个计算编码器


266
00:10:14,786 --> 00:10:16,056
用于进行通常在 OpenCL 中


267
00:10:16,056 --> 00:10:17,876
已经完成的并行工作


268
00:10:19,056 --> 00:10:21,196
你需要将一些内核放入队列


269
00:10:22,096 --> 00:10:23,496
这些内核会被写入命令缓冲区


270
00:10:23,496 --> 00:10:25,046
然后你运行编码器


271
00:10:25,046 --> 00:10:26,746
并释放它


272
00:10:28,196 --> 00:10:30,336
最后 让我们使用渲染编码器


273
00:10:30,336 --> 00:10:32,936
执行你熟悉的渲染命令


274
00:10:34,336 --> 00:10:35,776
你可以对状态更改和绘制调用进行排队


275
00:10:35,776 --> 00:10:38,536
并结束编码器


276
00:10:41,356 --> 00:10:43,816
这里我们有一个充满


277
00:10:44,116 --> 00:10:45,696
不同工作负载的命令缓冲区


278
00:10:45,696 --> 00:10:47,556
但是 GPU 还没有做任何工作


279
00:10:48,346 --> 00:10:50,246
Metal 在 CPU 中


280
00:10:50,586 --> 00:10:53,036
创建了对象并编码了命令


281
00:10:53,956 --> 00:10:55,516
只有在 App


282
00:10:55,566 --> 00:10:56,946
完成注释编码


283
00:10:57,136 --> 00:10:58,556
并显式提交命令缓冲区之后


284
00:10:58,556 --> 00:11:00,456
GPU 才开始工作


285
00:11:00,456 --> 00:11:03,186
并执行这些命令


286
00:11:04,376 --> 00:11:05,516
现在 我们已经编码了命令


287
00:11:05,516 --> 00:11:08,366
让我们比较


288
00:11:08,366 --> 00:11:10,996
GL 和 Metal 的命令提交


289
00:11:12,176 --> 00:11:14,006
在 GL 中 没有对工作


290
00:11:14,006 --> 00:11:16,006
何时提交给 GPU 的直接控制


291
00:11:16,006 --> 00:11:17,586
你依赖于像 glFlush


292
00:11:17,586 --> 00:11:19,456
和 glFinish 这样的字锤


293
00:11:19,456 --> 00:11:20,706
来确保代码执行


294
00:11:20,706 --> 00:11:23,196
glFlush 提交命令


295
00:11:23,196 --> 00:11:25,306
并提交 CPU 线程


296
00:11:25,306 --> 00:11:26,836
直到它们被调度


297
00:11:27,226 --> 00:11:28,806
glFinish 提交 CPU 线程


298
00:11:28,806 --> 00:11:31,586
直到 GPU 完全完成


299
00:11:32,716 --> 00:11:34,466
在这些命令发生之前


300
00:11:34,466 --> 00:11:35,936
仍然可以在任何时候提交工作


301
00:11:35,936 --> 00:11:38,096
从而导致


302
00:11:38,096 --> 00:11:39,626
潜在的停滞和减速


303
00:11:40,416 --> 00:11:42,536
Metal 也有类似的功能


304
00:11:42,536 --> 00:11:43,786
你仍然可以


305
00:11:43,786 --> 00:11:45,386
显式地提交


306
00:11:45,386 --> 00:11:46,896
并等待命令缓冲区的


307
00:11:46,896 --> 00:11:48,126
调度或完成


308
00:11:48,636 --> 00:11:51,156
但除非绝对需要


309
00:11:51,156 --> 00:11:52,976
否则不建议


310
00:11:52,976 --> 00:11:55,396
使用这些等待命令


311
00:11:55,576 --> 00:11:56,956
相反 我们建议你


312
00:11:56,956 --> 00:11:58,526
只需提交你的命令缓冲区


313
00:11:58,526 --> 00:12:01,356
然后添加一个回调函数


314
00:12:01,356 --> 00:12:02,786
以便稍后当命令缓冲区


315
00:12:02,786 --> 00:12:04,466
在 GPU 上完成时


316
00:12:04,466 --> 00:12:06,376
你的 App 可以得到通知


317
00:12:07,106 --> 00:12:08,976
这将释放你的 CPU


318
00:12:08,976 --> 00:12:09,886
来继续其他工作


319
00:12:10,486 --> 00:12:14,606
现在 我们已经回顾了


320
00:12:15,006 --> 00:12:16,686
命令队列 命令缓冲区


321
00:12:16,936 --> 00:12:19,036
命令编码器


322
00:12:19,336 --> 00:12:20,836
接下来我们讨论资源创建


323
00:12:23,196 --> 00:12:25,206
任何图形 App


324
00:12:25,206 --> 00:12:28,206
都可能使用三种


325
00:12:28,206 --> 00:12:30,166
主要类型的资源


326
00:12:30,476 --> 00:12:31,906
缓冲区 纹理 采样器


327
00:12:32,666 --> 00:12:34,426
我们先来看看缓冲区


328
00:12:35,476 --> 00:12:37,426
在 GL 中 你有一个缓冲区对象


329
00:12:37,576 --> 00:12:39,146
和与其关联的内存


330
00:12:39,716 --> 00:12:42,536
你使用的 API 代码


331
00:12:42,536 --> 00:12:45,756
可以同时或分别修改对象状态内存


332
00:12:46,366 --> 00:12:50,186
例如


333
00:12:50,186 --> 00:12:51,826
这里可以使用 glBufferData


334
00:12:51,826 --> 00:12:54,886
修改内存和对象的状态


335
00:12:55,666 --> 00:12:56,986
稍后可以通过


336
00:12:56,986 --> 00:12:58,936
调用 glBufferData


337
00:12:58,936 --> 00:13:01,696
再次修改缓冲区维度


338
00:13:01,696 --> 00:13:03,726
在这种情况下


339
00:13:03,726 --> 00:13:06,216
旧对象及其内容将被 OpenGL 在内部丢弃


340
00:13:06,816 --> 00:13:11,036
在 Metal 中


341
00:13:11,036 --> 00:13:12,416
创建和填充缓冲区的 API


342
00:13:12,416 --> 00:13:14,406
看起来非常相似


343
00:13:14,406 --> 00:13:16,336
但主要的区别在于


344
00:13:16,336 --> 00:13:18,186
生成的主题是不可变的


345
00:13:18,556 --> 00:13:20,456
如果你在任何时候


346
00:13:20,456 --> 00:13:22,156
需要调整缓冲区的大小


347
00:13:22,156 --> 00:13:23,756
只需创建一个新的缓冲区


348
00:13:23,756 --> 00:13:25,186
并丢弃旧的缓冲区


349
00:13:26,896 --> 00:13:29,946
OpenGL 和 Metal 都有方法


350
00:13:29,946 --> 00:13:31,526
来指示你


351
00:13:31,526 --> 00:13:35,096
如何使用对象


352
00:13:35,096 --> 00:13:36,966
然而在 GL 中 enum 只是一个


353
00:13:37,346 --> 00:13:40,626
关于如何访问缓冲区对象中的


354
00:13:40,626 --> 00:13:42,166
数据的使用提示


355
00:13:42,926 --> 00:13:44,896
驱动程序使用该提示


356
00:13:44,896 --> 00:13:46,416
来决定缓冲区的


357
00:13:46,646 --> 00:13:48,106
定位内存的基础位置


358
00:13:48,106 --> 00:13:50,356
但是没有对存储的直接控制


359
00:13:51,156 --> 00:13:53,776
OpenGL 最终决定


360
00:13:53,776 --> 00:13:56,000
在哪里存储对象


361
00:13:57,386 --> 00:13:59,356
在 Metal 中


362
00:13:59,356 --> 00:14:01,716
API 允许你指定映射到


363
00:14:01,716 --> 00:14:03,296
特定内存分配行为的


364
00:14:03,296 --> 00:14:04,336
存储模式


365
00:14:05,436 --> 00:14:06,936
Metal 给予你控制


366
00:14:06,936 --> 00:14:08,746
因为你最知道


367
00:14:08,776 --> 00:14:09,696
你的对象将如何被使用


368
00:14:10,036 --> 00:14:13,026
这在对象创建中


369
00:14:13,026 --> 00:14:14,756
是一个很重要的概念


370
00:14:14,756 --> 00:14:16,816
所以我们会在看完


371
00:14:16,816 --> 00:14:20,000
纹理 API 之后马上回到这个内容


372
00:14:22,246 --> 00:14:23,916
在 GL 中


373
00:14:23,916 --> 00:14:26,196
每个纹理都有一个内部采样器对象


374
00:14:26,196 --> 00:14:28,716
App 采样模式时


375
00:14:28,716 --> 00:14:29,926
一个通常应用的采样器设置


376
00:14:30,516 --> 00:14:31,816
但是你也可以选择


377
00:14:31,816 --> 00:14:33,416
在纹理之外


378
00:14:33,646 --> 00:14:34,656
创建一个单独的采样器对象


379
00:14:35,916 --> 00:14:38,086
这里有一个


380
00:14:38,086 --> 00:14:39,236
创建和绑定纹理


381
00:14:39,836 --> 00:14:41,906
设置采样器


382
00:14:41,906 --> 00:14:44,156
最后填充数据的例子


383
00:14:44,786 --> 00:14:47,826
值得一提的是


384
00:14:47,826 --> 00:14:50,016
GL 有很多 API 调用


385
00:14:50,066 --> 00:14:53,006
来创建初始化的数据化纹理


386
00:14:54,166 --> 00:14:55,756
它还具有


387
00:14:55,866 --> 00:14:58,196
相同 API 的被命名资源版本


388
00:14:59,716 --> 00:15:01,366
在管理采样器方面


389
00:15:01,366 --> 00:15:02,636
还有更多的 API


390
00:15:02,636 --> 00:15:07,046
这样的例子不胜枚举


391
00:15:07,316 --> 00:15:09,116
Metal 的设计目标之一是


392
00:15:09,116 --> 00:15:11,606
提供一个更简单的 API


393
00:15:11,606 --> 00:15:14,326
能够保有所有的灵活性


394
00:15:14,976 --> 00:15:17,176
在 Metal 中


395
00:15:17,176 --> 00:15:19,386
纹理和采样器对象在创建后


396
00:15:19,386 --> 00:15:20,916
总是分离和不可变的


397
00:15:21,546 --> 00:15:25,756
为了创建纹理


398
00:15:25,756 --> 00:15:27,916
我们创建一个描述符


399
00:15:27,916 --> 00:15:29,646
设置各种属性来定义纹理尺寸


400
00:15:29,646 --> 00:15:31,476
比如 pixelFormat


401
00:15:31,476 --> 00:15:33,606
和尺寸等


402
00:15:35,096 --> 00:15:37,026
同样 我们说过的一个重要属性是


403
00:15:37,026 --> 00:15:39,016
storageMode


404
00:15:39,016 --> 00:15:41,406
用于指定在内存中存储纹理的位置


405
00:15:42,466 --> 00:15:43,736
最后 我们使用


406
00:15:43,866 --> 00:15:45,706
这个描述符


407
00:15:45,706 --> 00:15:46,526
来创建一个不可变的对象


408
00:15:47,056 --> 00:15:50,686
以类似的方式


409
00:15:51,016 --> 00:15:52,816
从 samplerDescriptor 开始


410
00:15:52,816 --> 00:15:55,206
设置其属性


411
00:15:55,726 --> 00:15:57,056
并创建不可变的 sampler 对象


412
00:15:58,086 --> 00:15:59,296
非常简单


413
00:16:00,556 --> 00:16:02,826
为了填充纹理的图像数据


414
00:16:02,946 --> 00:16:05,186
我们计算每一行的字节数


415
00:16:05,326 --> 00:16:06,896
就像我们在 OpenGL 中做的一样


416
00:16:06,956 --> 00:16:08,626
我们指定要加载的区域


417
00:16:09,486 --> 00:16:10,986
然后我们调用


418
00:16:11,086 --> 00:16:13,626
texture replaceRegion 方法


419
00:16:13,626 --> 00:16:15,676
该方法将数据从我们指定的指针


420
00:16:15,806 --> 00:16:18,066
复制到纹理中


421
00:16:21,116 --> 00:16:22,776
如果你加载了第一个纹理


422
00:16:22,776 --> 00:16:24,046
你可能会发现


423
00:16:24,046 --> 00:16:25,896
它是颠倒的


424
00:16:27,286 --> 00:16:28,656
这是因为在 Metal 中


425
00:16:28,656 --> 00:16:30,366
纹理坐标相对于 GL


426
00:16:30,366 --> 00:16:31,896
在 Y 轴上是翻转的


427
00:16:33,056 --> 00:16:34,726
值得一提的是


428
00:16:34,946 --> 00:16:38,066
Metal API 不在底层


429
00:16:38,066 --> 00:16:41,056
执行任何像素格式转换


430
00:16:41,286 --> 00:16:42,336
所以你需要


431
00:16:42,336 --> 00:16:43,896
使用你想要使用的格式


432
00:16:44,016 --> 00:16:44,976
上传你的纹理


433
00:16:49,466 --> 00:16:52,266
现在让我们回到存储模式


434
00:16:52,726 --> 00:16:55,626
如前所述 在 GL 中


435
00:16:55,626 --> 00:16:57,396
驱动程序必须


436
00:16:57,396 --> 00:16:59,456
对你希望如何使用资源做出最佳猜测


437
00:16:59,986 --> 00:17:01,396
作为开发者


438
00:17:01,396 --> 00:17:03,096
你可以在某些情况下提供提示


439
00:17:03,096 --> 00:17:04,496
比如何时创建缓冲区


440
00:17:04,496 --> 00:17:07,906
或者通过为帧缓冲区附件


441
00:17:07,906 --> 00:17:09,276
创建渲染缓冲区对象


442
00:17:09,836 --> 00:17:11,856
但在所有这些例子中


443
00:17:11,856 --> 00:17:13,556
这些仍然是提示


444
00:17:13,556 --> 00:17:16,195
实现细节对你仍然是隐藏的


445
00:17:16,806 --> 00:17:18,925
几分钟前


446
00:17:18,925 --> 00:17:20,665
我们简要介绍了


447
00:17:20,695 --> 00:17:22,246
Metal 附加的存储模式属性 


448
00:17:22,246 --> 00:17:25,626
你可以在纹理描述符


449
00:17:25,626 --> 00:17:27,435
和创建缓冲区时设置它


450
00:17:28,376 --> 00:17:30,236
让我们来看看这些的主要用例


451
00:17:31,596 --> 00:17:34,536
最简单的选择是


452
00:17:34,536 --> 00:17:36,716
使用共享存储模式


453
00:17:36,716 --> 00:17:39,146
CPU 和 GPU 都将可以访问资源


454
00:17:39,806 --> 00:17:41,396
对于缓冲区而言


455
00:17:41,396 --> 00:17:43,196
这意味着你必须在这里


456
00:17:43,196 --> 00:17:44,256
指向对象的内存支持


457
00:17:45,146 --> 00:17:48,136
对于 iOS 上的纹理


458
00:17:48,636 --> 00:17:49,956
这意味着你可以调用一些


459
00:17:49,956 --> 00:17:52,706
简单易用的函数来设置和检索图像数据


460
00:17:53,356 --> 00:17:57,466
你也可以使用一个


461
00:17:57,466 --> 00:17:59,736
私有存储模式


462
00:17:59,736 --> 00:18:02,606
它让 GPU 独占访问数据


463
00:18:03,156 --> 00:18:05,696
它允许 Metal 应用一些优化


464
00:18:05,696 --> 00:18:07,236
通常情况下


465
00:18:07,236 --> 00:18:09,256
如果 CPU 能够访问数据


466
00:18:09,746 --> 00:18:11,766
它是无法使用这些优化的


467
00:18:12,676 --> 00:18:14,896
只有 GPU 可以


468
00:18:14,896 --> 00:18:16,736
直接填充数据的内容


469
00:18:17,716 --> 00:18:19,046
因此 你可以使用


470
00:18:19,046 --> 00:18:21,056
来自使用共享存储的


471
00:18:21,056 --> 00:18:22,836
第二个中间资源的 blitEncoder


472
00:18:22,836 --> 00:18:26,016
来间接地填充来自 CPU 的数据


473
00:18:26,556 --> 00:18:30,256
在具有专用视频内存的语音上


474
00:18:30,256 --> 00:18:31,676
将资源设置为


475
00:18:31,676 --> 00:18:33,616
使用私有存储


476
00:18:34,256 --> 00:18:36,316
仅将其分配到视频内存中


477
00:18:36,316 --> 00:18:37,656
单个副本


478
00:18:38,236 --> 00:18:42,386
在 macOS 上


479
00:18:42,386 --> 00:18:44,176
有一个托管存储模式


480
00:18:44,176 --> 00:18:47,146
允许 CPU 和 GPU 访问对象的数据


481
00:18:48,436 --> 00:18:50,326
在具有专用视频内存的系统上


482
00:18:50,326 --> 00:18:52,526
Metal 可能需要


483
00:18:52,526 --> 00:18:55,206
创建第二个镜像内存支持


484
00:18:55,206 --> 00:18:58,516
以便两个进程都能有效地访问


485
00:18:59,276 --> 00:19:02,406
因此 显式代码是必要的


486
00:19:02,406 --> 00:19:03,666
以确保你的数据


487
00:19:03,946 --> 00:19:06,426
被 CPU 和 GPU 同步访问


488
00:19:06,426 --> 00:19:07,976
例如使用 didModifyRange


489
00:19:11,156 --> 00:19:14,046
为了总结


490
00:19:14,046 --> 00:19:16,216
我们回顾一下每种模式的一些典型用法


491
00:19:17,306 --> 00:19:20,146
在 macOS 上


492
00:19:20,146 --> 00:19:22,176
你将为静态素材和渲染目标


493
00:19:22,176 --> 00:19:24,606
使用私有存储模式


494
00:19:25,826 --> 00:19:28,316
你的小型动态缓冲区


495
00:19:28,316 --> 00:19:30,366
可以使用共享存储模式


496
00:19:31,216 --> 00:19:32,896
带有较小更新的较大缓冲区


497
00:19:32,896 --> 00:19:35,886
将使用托管存储模式


498
00:19:36,396 --> 00:19:40,086
在 iOS 上


499
00:19:40,086 --> 00:19:42,416
静态数据和渲染目标


500
00:19:42,416 --> 00:19:43,326
可以使用私有存储模式


501
00:19:43,816 --> 00:19:47,026
由于我们的设备使用统一的内存


502
00:19:47,456 --> 00:19:50,596
任何大小的动态数据


503
00:19:50,596 --> 00:19:52,566
都可以使用共享存储模式


504
00:19:52,566 --> 00:19:55,456
并且仍然可以获得很好的性能


505
00:19:59,716 --> 00:20:02,136
接下来


506
00:20:02,136 --> 00:20:03,896
让我们讨论一下


507
00:20:03,896 --> 00:20:05,086
为图形 App 开发着色器


508
00:20:05,086 --> 00:20:08,336
以及使用什么 API 来处理着色器


509
00:20:08,866 --> 00:20:12,326
在 GL 中


510
00:20:12,326 --> 00:20:13,996
进行着色器编译时


511
00:20:13,996 --> 00:20:17,696
你必须创建一个 shader 对象


512
00:20:17,996 --> 00:20:20,206
替换对象中的 ShaderSource


513
00:20:20,586 --> 00:20:22,756
及时进行编译


514
00:20:23,156 --> 00:20:25,806
并验证编译成功


515
00:20:25,866 --> 00:20:28,726
虽然这种工作流有它的优点


516
00:20:28,726 --> 00:20:30,586
但是你的 App


517
00:20:30,586 --> 00:20:32,176
必须为每次编译所有着色器


518
00:20:32,176 --> 00:20:36,936
付出性能的代价


519
00:20:37,056 --> 00:20:39,206
Metal 实现其效率的


520
00:20:39,206 --> 00:20:42,036
一个关键方法是


521
00:20:42,036 --> 00:20:44,596
更早 更少地工作


522
00:20:45,296 --> 00:20:46,816
在构建时


523
00:20:46,816 --> 00:20:48,346
Xcode 将编译所有


524
00:20:48,636 --> 00:20:50,096
Metal ShaderSource 文件


525
00:20:50,096 --> 00:20:52,196
到一个默认的 Metal 库文件中


526
00:20:52,196 --> 00:20:53,946
并将其放在 App 捆绑包中


527
00:20:53,946 --> 00:20:54,966
以便在运行时检索


528
00:20:55,836 --> 00:20:57,216
这消除了在运行时


529
00:20:57,216 --> 00:20:59,946
编译大量代码的需要


530
00:21:00,026 --> 00:21:01,556
并将 App 运行时的


531
00:21:02,086 --> 00:21:04,936
编译时间缩短了一半


532
00:21:05,206 --> 00:21:07,436
你所需要做的就是


533
00:21:07,436 --> 00:21:09,276
从与 App 绑定的文件中


534
00:21:09,276 --> 00:21:10,986
创建一个 Metal 库


535
00:21:11,486 --> 00:21:14,826
并从中获取着色器函数


536
00:21:17,656 --> 00:21:19,976
在 GL 中你使用 GLSL


537
00:21:19,976 --> 00:21:22,236
它基于 C 编程语言


538
00:21:23,696 --> 00:21:25,326
Metal 的着色语言


539
00:21:25,326 --> 00:21:27,536
或 MSL 是基于 C++ 的


540
00:21:27,776 --> 00:21:29,466
因此 对于大多数 GL 开发人员来说


541
00:21:29,466 --> 00:21:31,176
它应该是相当熟悉的


542
00:21:32,206 --> 00:21:34,216
它的 C++ 基础意味着


543
00:21:34,216 --> 00:21:35,446
你可以创建类


544
00:21:35,636 --> 00:21:36,726
模板和扩展


545
00:21:36,726 --> 00:21:40,000
你可以定义枚举和名称空间


546
00:21:41,216 --> 00:21:43,546
和 GLSL 一样


547
00:21:43,546 --> 00:21:45,466
也有内置的向量


548
00:21:45,516 --> 00:21:47,136
和矩阵类型


549
00:21:47,186 --> 00:21:48,726
许多内置的函数


550
00:21:48,726 --> 00:21:49,826
和操作用于图形


551
00:21:50,396 --> 00:21:52,596
还有一些类


552
00:21:52,836 --> 00:21:54,976
用于操作指定采样器状态的纹理


553
00:22:01,146 --> 00:22:03,796
与 Metal 一样


554
00:22:03,936 --> 00:22:05,936
MSL 也统一用于图形和计算


555
00:22:07,276 --> 00:22:09,156
最后


556
00:22:09,156 --> 00:22:11,776
由于着色器是预编译的


557
00:22:11,776 --> 00:22:13,586
Xcode 能够提供错误 警告和指导


558
00:22:13,586 --> 00:22:16,456
帮助你在构建时进行调试


559
00:22:17,576 --> 00:22:19,596
让我们看一下 MSL 的实际代码


560
00:22:19,596 --> 00:22:22,986
并将其与 GLSL 进行比较


561
00:22:24,176 --> 00:22:25,886
我们将通过一个


562
00:22:25,886 --> 00:22:28,436
简单的顶点着色器


563
00:22:28,436 --> 00:22:29,746
顶部是 GLSL 底部是 MSL


564
00:22:30,266 --> 00:22:34,526
让我们开始定义着色器


565
00:22:34,566 --> 00:22:35,736
这些是原型


566
00:22:36,006 --> 00:22:37,586
在 GLSL 中 void main()


567
00:22:38,266 --> 00:22:39,656
着色器中没有指定


568
00:22:39,656 --> 00:22:41,556
着色器阶段的内容


569
00:22:42,146 --> 00:22:43,656
它完全由


570
00:22:43,656 --> 00:22:46,136
传递到 glCreateShader 调用的


571
00:22:46,136 --> 00:22:47,416
着色器类型决定


572
00:22:48,776 --> 00:22:50,836
在 MSL 中 着色器阶段


573
00:22:50,836 --> 00:22:53,036
在着色器代码中显式指定


574
00:22:53,426 --> 00:22:54,916
这里的 vertex 限定符表示


575
00:22:54,916 --> 00:22:56,006
它将对生成


576
00:22:56,006 --> 00:22:57,336
完美示例的


577
00:22:57,476 --> 00:22:59,116
每个顶点执行


578
00:23:00,916 --> 00:23:03,726
在 GLSL 中


579
00:23:03,726 --> 00:23:05,486
每个着色器入口点都必须被调用 main


580
00:23:05,616 --> 00:23:06,806
并接受和返回 void


581
00:23:07,526 --> 00:23:09,866
在 MSL 中 每个入口点


582
00:23:09,866 --> 00:23:10,796
都有一个不同的名称


583
00:23:11,176 --> 00:23:13,256
当你使用 Xcode 构建着色器时


584
00:23:13,256 --> 00:23:15,076
编译器可以


585
00:23:15,076 --> 00:23:16,876
在预处理阶段


586
00:23:16,876 --> 00:23:18,926
解析 include 语句


587
00:23:18,926 --> 00:23:20,546
就像解析普通 C++ 代码一样


588
00:23:21,266 --> 00:23:22,926
在运行时


589
00:23:23,296 --> 00:23:24,916
你可以根据预先编译的


590
00:23:25,586 --> 00:23:27,596
Metal 库的不同名称查询函数


591
00:23:27,656 --> 00:23:31,376
然后我们来谈谈输入


592
00:23:32,416 --> 00:23:34,216
因为 GLSL 中的每个入口点


593
00:23:34,216 --> 00:23:35,716
都是一个没有参数的主函数


594
00:23:35,716 --> 00:23:38,016
所以所有输入


595
00:23:38,016 --> 00:23:39,476
都作为全局参数传递


596
00:23:40,226 --> 00:23:41,876
这适用于 vertex 属性


597
00:23:41,876 --> 00:23:43,836
和统一变量


598
00:23:45,056 --> 00:23:48,186
在 Metal 中


599
00:23:48,186 --> 00:23:50,266
所有到阴影阶段的输入


600
00:23:50,266 --> 00:23:51,126
都是入口函数的参数


601
00:23:51,546 --> 00:23:54,816
双括号声明 C++ 属性


602
00:23:54,916 --> 00:23:56,000
我们待会再看


603
00:23:57,676 --> 00:23:59,366
这里的一个输入


604
00:23:59,366 --> 00:24:01,496
是一个模型视图投影矩阵


605
00:24:02,006 --> 00:24:05,966
在 OpenGL 中


606
00:24:05,966 --> 00:24:07,986
为了将数据绑定到这些变量上


607
00:24:08,816 --> 00:24:11,546
App 必须知道


608
00:24:11,546 --> 00:24:13,306
C++ 代码中的 GLSL 名称


609
00:24:14,146 --> 00:24:16,796
这使得着色器开发容易出错


610
00:24:17,376 --> 00:24:21,076
在 MSL 中


611
00:24:21,076 --> 00:24:22,446
统一绑定索引


612
00:24:22,446 --> 00:24:24,096
由开发者


613
00:24:24,096 --> 00:24:25,906
在着色器中显式控制


614
00:24:25,906 --> 00:24:29,156
因此 App 可以直接绑定到特定的槽


615
00:24:29,646 --> 00:24:31,376
在这个例子中 位置 1


616
00:24:32,816 --> 00:24:34,106
这里的关键字常量


617
00:24:34,106 --> 00:24:36,836
表示模型视图投影的意图


618
00:24:36,836 --> 00:24:38,446
对所有顶点


619
00:24:38,446 --> 00:24:40,256
都是一致的


620
00:24:42,276 --> 00:24:44,086
着色器的另一个输入


621
00:24:44,086 --> 00:24:45,576
是一组顶点属性


622
00:24:46,266 --> 00:24:48,136
在 GLSL 中


623
00:24:48,396 --> 00:24:50,136
通常使用单独的属性输入


624
00:24:50,476 --> 00:24:52,416
这里的主要区别是


625
00:24:52,416 --> 00:24:55,256
MSL 使用你自己设计的结构


626
00:24:56,136 --> 00:24:57,746
阶段关键字表明


627
00:24:57,826 --> 00:24:59,066
着色器的每次调用


628
00:24:59,066 --> 00:25:01,660
都将收到自己的参数


629
00:25:03,806 --> 00:25:05,146
在设置好着色器的


630
00:25:05,146 --> 00:25:06,756
所有输入之后


631
00:25:06,756 --> 00:25:08,736
你就可以执行所有的计算


632
00:25:10,416 --> 00:25:12,556
至于输出 在 GLSL 中


633
00:25:12,556 --> 00:25:14,316
输出被分割为


634
00:25:14,316 --> 00:25:16,436
不同的属性


635
00:25:16,436 --> 00:25:18,866
比如 glTexCoord 和预定义的变量


636
00:25:18,866 --> 00:25:21,596
在本例中是 gl_Position


637
00:25:22,176 --> 00:25:25,886
在 MSL 中顶点着色器输出


638
00:25:26,106 --> 00:25:27,966
被合并到你自己的结构中


639
00:25:29,576 --> 00:25:31,866
我们使用了


640
00:25:31,866 --> 00:25:32,976
vertex VertexOutput 结构


641
00:25:33,406 --> 00:25:34,976
让我们向上滚动 MSL 代码


642
00:25:35,046 --> 00:25:37,386
看看它们到底是什么样子的


643
00:25:39,436 --> 00:25:41,926
如前所述


644
00:25:41,926 --> 00:25:44,536
GLSL 分别定义


645
00:25:44,536 --> 00:25:46,756
输入顶点属性


646
00:25:46,756 --> 00:25:49,166
Metal 允许你在结构中定义它们


647
00:25:49,776 --> 00:25:52,836
在 MSL 中有一些


648
00:25:52,836 --> 00:25:54,696
特殊的关键字顶点着色器输入


649
00:25:55,196 --> 00:25:57,966
我们用一个 attribute 关键字


650
00:25:57,966 --> 00:25:59,686
标记每个结构成分


651
00:25:59,686 --> 00:26:02,306
并为其分配一个属性索引


652
00:26:02,816 --> 00:26:05,286
与 GLSL 类似


653
00:26:05,636 --> 00:26:07,296
这些索引在 Metal API 中


654
00:26:07,396 --> 00:26:09,106
用于为顶点属性


655
00:26:09,256 --> 00:26:11,836
分配顶点缓冲流


656
00:26:15,556 --> 00:26:18,066
GLSL 预先定义了


657
00:26:18,066 --> 00:26:20,456
一些特殊的关键字


658
00:26:20,456 --> 00:26:23,166
比如 gl_Position


659
00:26:23,606 --> 00:26:25,086
表示哪个变量包含了


660
00:26:25,086 --> 00:26:26,396
用模型视图投影矩阵


661
00:26:26,396 --> 00:26:27,576
转换过的顶点坐标


662
00:26:29,046 --> 00:26:30,256
类似地 对于顶点输出


663
00:26:30,256 --> 00:26:32,576
MSL 中的结构


664
00:26:32,576 --> 00:26:35,206
特殊的关键字 position


665
00:26:35,206 --> 00:26:36,506
表示顶点着色器输出位置


666
00:26:36,726 --> 00:26:39,356
存储在该结构成分中


667
00:26:42,656 --> 00:26:46,296
与 GLSL 向量类型类似


668
00:26:46,296 --> 00:26:48,326
MSL 通过 simd.h 标头


669
00:26:48,486 --> 00:26:50,996
定义了许多 simd 类型


670
00:26:50,996 --> 00:26:53,896
可以在 CPU 和 GPU 代码之间共享


671
00:26:55,186 --> 00:26:56,376
但是有几件事


672
00:26:56,376 --> 00:26:57,536
你需要记住


673
00:26:58,926 --> 00:27:01,036
缓冲区中的向量和矩阵类型


674
00:27:01,036 --> 00:27:03,706
被对齐到 16 字节


675
00:27:03,906 --> 00:27:05,396
或者为了获得一半的精度 对齐到 8 字节


676
00:27:06,146 --> 00:27:07,276
因此它们不一定是压缩的


677
00:27:07,276 --> 00:27:09,256
例如 float3 的大小


678
00:27:09,256 --> 00:27:11,576
为 12 字节


679
00:27:11,576 --> 00:27:12,726
但对齐为 16 字节


680
00:27:13,346 --> 00:27:15,246
这是为了确保数据


681
00:27:15,246 --> 00:27:18,276
被对齐到最佳的 CPU 和 GPU 访问


682
00:27:19,686 --> 00:27:21,486
如果需要


683
00:27:21,486 --> 00:27:23,406
你可以使用特定的支持格式


684
00:27:23,786 --> 00:27:25,406
但是在使用它们之前


685
00:27:25,466 --> 00:27:29,966
你需要在着色器中解压它们


686
00:27:30,166 --> 00:27:32,306
我们刚刚回顾了


687
00:27:32,306 --> 00:27:35,176
GLSL 和 MSL 之间的主要区别


688
00:27:35,876 --> 00:27:38,536
为了使这个过渡


689
00:27:38,536 --> 00:27:41,006
平稳且容易


690
00:27:41,006 --> 00:27:42,986
我的同事 Max 将向你展示一个


691
00:27:42,986 --> 00:27:45,426
非常酷的工具来帮助你轻松地完成它 谢谢大家


692
00:27:46,516 --> 00:27:51,796
[掌声]


693
00:27:52,296 --> 00:27:53,286
>> 晚上好


694
00:27:54,616 --> 00:27:57,106
Metal 不仅仅是一个 API


695
00:27:57,346 --> 00:27:59,516
和一种着色语言


696
00:27:59,516 --> 00:28:01,666
它还是一个功能强大的工具集合


697
00:28:02,686 --> 00:28:04,556
我是 Max 我会尽量减少


698
00:28:04,556 --> 00:28:07,016
你在移植到 Metal 的过程中所遇到的麻烦


699
00:28:07,586 --> 00:28:11,546
让我们来看看这个场景


700
00:28:11,846 --> 00:28:13,976
这是第一次


701
00:28:13,976 --> 00:28:16,296
从一个老的 OpenGL 演示中调用绘制


702
00:28:16,296 --> 00:28:18,376
我们在 Apple 这里将把它移植到 Metal


703
00:28:19,126 --> 00:28:21,656
它绘制了一座寺庙


704
00:28:21,656 --> 00:28:23,926
和一棵树的模型


705
00:28:23,976 --> 00:28:25,016
两者都被四处的光源照亮


706
00:28:25,316 --> 00:28:26,976
让我们一起移植片段着色器


707
00:28:31,046 --> 00:28:32,916
我做的第一件事是


708
00:28:32,916 --> 00:28:34,926
直接复制粘贴我所有的


709
00:28:34,926 --> 00:28:37,616
旧 OpenGL 代码


710
00:28:37,616 --> 00:28:38,676
到我的 Metal 着色器文件中


711
00:28:39,886 --> 00:28:41,556
基于这点


712
00:28:41,556 --> 00:28:44,476
我已经创建了输入结构


713
00:28:44,476 --> 00:28:46,026
和函数原型


714
00:28:47,536 --> 00:28:48,076
让我们开始吧


715
00:28:49,266 --> 00:28:50,896
我们要做的就是


716
00:28:50,896 --> 00:28:52,656
直接复制粘贴


717
00:28:52,656 --> 00:28:55,186
主函数的内容


718
00:28:55,396 --> 00:28:56,846
到 Metal 函数中


719
00:28:58,166 --> 00:29:00,436
这里我们看到了


720
00:29:00,436 --> 00:29:02,016
Metal 的第一个强大之处


721
00:29:03,336 --> 00:29:06,176
因为着色器是预编译的


722
00:29:06,176 --> 00:29:07,406
我们会立即得到错误


723
00:29:07,816 --> 00:29:09,646
让我们仔细看看


724
00:29:10,456 --> 00:29:12,336
当然 构建向量类型


725
00:29:12,336 --> 00:29:13,806
现在有不同的名称


726
00:29:14,416 --> 00:29:17,276
vec2 变成了 float2


727
00:29:17,326 --> 00:29:20,616
vec3 变成了 float3


728
00:29:20,616 --> 00:29:22,786
vec4 变成了 float4


729
00:29:23,416 --> 00:29:24,776
我们很快就解决了这个问题


730
00:29:28,296 --> 00:29:29,826
下一个错误是


731
00:29:29,826 --> 00:29:31,956
我们所有的


732
00:29:31,956 --> 00:29:33,316
输入结构


733
00:29:33,316 --> 00:29:35,346
所有的全局变量


734
00:29:35,396 --> 00:29:36,496
都来自于输入结构


735
00:29:36,936 --> 00:29:38,336
因为我用了


736
00:29:38,446 --> 00:29:39,996
类似的命名方案


737
00:29:39,996 --> 00:29:40,976
这也很简单


738
00:29:48,596 --> 00:29:50,146
当然 我们也要用同样的方法


739
00:29:50,146 --> 00:29:52,716
修改 统一变量


740
00:29:58,186 --> 00:30:00,426
下一个错误有点复杂


741
00:30:01,106 --> 00:30:02,916
Metal 的取样是不同的


742
00:30:02,916 --> 00:30:04,186
让我们来看一下


743
00:30:05,336 --> 00:30:07,216
我们要从头开始


744
00:30:07,956 --> 00:30:10,406
我们可以直接调用


745
00:30:10,406 --> 00:30:12,976
colorMap 上的一个 sample 函数


746
00:30:13,136 --> 00:30:15,286
这里我们可以看到


747
00:30:15,286 --> 00:30:17,016
全自动完成是多么强大


748
00:30:18,166 --> 00:30:19,736
这个函数要求我们


749
00:30:19,736 --> 00:30:21,966
放入一个采样器和一个纹理坐标


750
00:30:21,966 --> 00:30:24,246
我们已经有了纹理坐标


751
00:30:25,416 --> 00:30:27,316
我们可以将采样器


752
00:30:27,316 --> 00:30:30,036
作为参数传递给函数


753
00:30:30,036 --> 00:30:31,636
或者在 Metal 中 我们可以像这样


754
00:30:31,636 --> 00:30:33,696
在代码中声明一个采样器


755
00:30:34,286 --> 00:30:37,556
我们需要对我们的


756
00:30:37,626 --> 00:30:39,636
normalMap 做同样的事情


757
00:30:48,236 --> 00:30:49,296
我们看到的


758
00:30:49,416 --> 00:30:52,026
最后一个错误是


759
00:30:52,026 --> 00:30:55,386
我们写进了很多 OpenGL 变量中的一个


760
00:30:55,716 --> 00:30:57,256
我们将返回


761
00:30:57,256 --> 00:30:59,846
最终计算得到的颜色


762
00:31:04,356 --> 00:31:06,036
我们还可以看到


763
00:31:06,036 --> 00:31:07,966
所有其他的函数 比如 normalize


764
00:31:08,356 --> 00:31:09,936
dot 点积 


765
00:31:09,936 --> 00:31:12,556
以及我最喜欢的函数 max 都是一样的


766
00:31:13,976 --> 00:31:15,946
现在着色器编译成功


767
00:31:16,516 --> 00:31:16,976
让我们试着运行一下


768
00:31:23,326 --> 00:31:24,486
发生了一些错误


769
00:31:25,056 --> 00:31:28,436
在 OpenGL 中


770
00:31:28,836 --> 00:31:30,256
当你的着色器出现错误时


771
00:31:30,256 --> 00:31:31,936
你通常会做的是


772
00:31:31,936 --> 00:31:33,906
查看源代码


773
00:31:33,976 --> 00:31:36,396
查看输出


774
00:31:36,836 --> 00:31:38,356
然后认真思考


775
00:31:39,146 --> 00:31:40,076
我们只需要使用


776
00:31:40,076 --> 00:31:41,266
着色器调试器


777
00:31:42,736 --> 00:31:44,106
轻点调试区域中的


778
00:31:44,106 --> 00:31:46,426
小相机图标


779
00:31:46,426 --> 00:31:47,756
将会捕获 GPU 跟踪


780
00:31:48,526 --> 00:31:51,536
这是我们对每个


781
00:31:51,536 --> 00:31:52,986
Metal API 调用的记录


782
00:31:53,876 --> 00:31:56,826
现在我们可以导航到 draw 调用


783
00:31:57,156 --> 00:31:58,376
我们在这绘制这棵树


784
00:31:59,566 --> 00:32:01,416
我们在这绘制寺庙


785
00:32:01,926 --> 00:32:04,616
让我长按下


786
00:32:04,616 --> 00:32:06,436
寺庙的楼梯


787
00:32:06,436 --> 00:32:08,526
打开像素检查器


788
00:32:08,526 --> 00:32:10,046
它允许我们启动着色器调试器


789
00:32:14,116 --> 00:32:16,596
我们现在看到的是


790
00:32:16,596 --> 00:32:18,906
我们移植到一起的代码


791
00:32:18,906 --> 00:32:20,646
和我们刚刚选择的


792
00:32:20,646 --> 00:32:22,266
像素的每行值


793
00:32:22,266 --> 00:32:25,566
让我们先看看我们的 colorMap


794
00:32:25,976 --> 00:32:30,026
我们可以看到这看起来像一个合理的纹理


795
00:32:30,206 --> 00:32:32,066
我们还可以看到楼梯


796
00:32:32,146 --> 00:32:33,466
在这个纹理的上半部分


797
00:32:33,466 --> 00:32:36,096
然而


798
00:32:36,486 --> 00:32:37,896
如果我们看一下纹理坐标


799
00:32:37,896 --> 00:32:40,046
我们就会发现


800
00:32:40,226 --> 00:32:43,066
我们是从下半部分采样的


801
00:32:43,126 --> 00:32:45,066
让我快速验证一下是不是这样


802
00:32:46,376 --> 00:32:48,096
我们要做的是


803
00:32:48,096 --> 00:32:51,256
反转纹理的 Y 坐标


804
00:32:52,056 --> 00:32:56,966
现在我们可以更新着色器


805
00:32:57,566 --> 00:33:00,606
看起来很合理


806
00:33:00,606 --> 00:33:02,046
我们可以继续执行


807
00:33:02,506 --> 00:33:03,496
你看 现在好多了


808
00:33:03,596 --> 00:33:08,696
在从 OpenGL 移植到 Metal 时


809
00:33:08,746 --> 00:33:11,686
这是一个非常常见的错误


810
00:33:13,086 --> 00:33:16,536
当然 真正的修复是


811
00:33:16,536 --> 00:33:18,396
你进入你的纹理加载代码


812
00:33:18,446 --> 00:33:20,356
并确保你的纹理在正确的原点加载


813
00:33:20,356 --> 00:33:22,336
这样你就不必在每个着色器中都做这个修复


814
00:33:23,416 --> 00:33:25,466
然而 功能丰富的编辑器


815
00:33:25,466 --> 00:33:27,536
和强大的调试工具的组合


816
00:33:27,536 --> 00:33:29,686
最终都将帮助你


817
00:33:29,686 --> 00:33:32,256
将游戏移植到 Metal


818
00:33:33,676 --> 00:33:34,866
非常感谢


819
00:33:35,386 --> 00:33:36,796
我的同事 Sarah


820
00:33:36,846 --> 00:33:38,246
现在将引导你完成之后的幻灯片内容


821
00:33:39,516 --> 00:33:43,616
[掌声]


822
00:33:44,116 --> 00:33:45,066
>> 谢谢你 Max


823
00:33:45,066 --> 00:33:46,286
大家好 我是 Sarah Clawson


824
00:33:46,286 --> 00:33:48,216
我将与你讨论


825
00:33:48,216 --> 00:33:50,076
关于从 GL 移植到 Metal 的其他内容


826
00:33:50,616 --> 00:33:53,686
目前为止 在一个图形 App 的生命中


827
00:33:53,686 --> 00:33:55,366
我们已经进行了很多的设置


828
00:33:56,176 --> 00:33:57,796
我们有一个用于渲染的窗口


829
00:33:58,006 --> 00:33:59,386
一个将命令传达给 GPU 的方式


830
00:33:59,386 --> 00:34:02,156
以及一组完备的


831
00:34:02,326 --> 00:34:03,466
资源和着色器


832
00:34:04,436 --> 00:34:05,946
接下来


833
00:34:05,946 --> 00:34:07,596
我们将讨论


834
00:34:07,596 --> 00:34:08,726
为渲染循环设置状态


835
00:34:10,826 --> 00:34:13,085
OpenGL 在状态管理方面


836
00:34:13,085 --> 00:34:14,226
有几个关键概念


837
00:34:14,976 --> 00:34:16,786
顶点数组对象定义了


838
00:34:16,815 --> 00:34:17,996
顶点属性布局


839
00:34:17,996 --> 00:34:19,556
和顶点缓冲区


840
00:34:20,396 --> 00:34:21,536
这个程序是顶点着色器


841
00:34:21,536 --> 00:34:23,735
和片段着色器的链接组合


842
00:34:24,676 --> 00:34:27,235
Framebuffer


843
00:34:27,286 --> 00:34:28,446
是 App 打算渲染的


844
00:34:28,446 --> 00:34:29,476
一组颜色


845
00:34:29,556 --> 00:34:30,876
和深度模板附件


846
00:34:31,946 --> 00:34:33,726
这些状态对象


847
00:34:33,946 --> 00:34:35,545
是在初始化过程中创建的


848
00:34:35,545 --> 00:34:36,786
并在整个帧中使用


849
00:34:37,436 --> 00:34:40,295
让我们通过一个示例


850
00:34:40,295 --> 00:34:42,946
来展示 OpenGL 如何管理状态


851
00:34:44,616 --> 00:34:46,106
这里我们有一个示例渲染循环


852
00:34:46,106 --> 00:34:48,616
其中 OpenGL App


853
00:34:48,616 --> 00:34:50,656
绑定一个 Framebuffer


854
00:34:50,656 --> 00:34:52,606
设置一个程序


855
00:34:52,606 --> 00:34:53,786
然后进行其他状态修改


856
00:34:53,786 --> 00:34:56,005
比如启用深度 人脸剔除


857
00:34:56,476 --> 00:34:57,746
或在调用 draw 之前


858
00:34:57,746 --> 00:35:00,326
更改颜色映射


859
00:35:00,506 --> 00:35:02,216
如果你从 OpenGL 的角度


860
00:35:02,256 --> 00:35:04,176
查看相同的 API 跟踪


861
00:35:04,176 --> 00:35:06,126
它必须在每次 API 调用时


862
00:35:06,126 --> 00:35:08,116
跟踪所有这些更改


863
00:35:08,276 --> 00:35:10,596
当一个 draw 调用发生时


864
00:35:10,596 --> 00:35:12,276
它必须停止并验证


865
00:35:12,276 --> 00:35:13,496
以确保以前


866
00:35:13,496 --> 00:35:14,916
对原始程序集


867
00:35:14,916 --> 00:35:16,476
深度状态


868
00:35:16,556 --> 00:35:18,566
光栅化器和可编程阶段的更改


869
00:35:18,566 --> 00:35:20,846
都彼此兼容


870
00:35:21,436 --> 00:35:24,526
这种验证可能非常繁重


871
00:35:24,526 --> 00:35:26,296
虽然 OpenGL 确实试图


872
00:35:26,296 --> 00:35:27,676
将其负面影响最小化


873
00:35:28,066 --> 00:35:30,356
但这样做的成效是有限的


874
00:35:31,366 --> 00:35:33,496
值得注意的是


875
00:35:33,496 --> 00:35:35,036
OpenGL 状态对象


876
00:35:35,036 --> 00:35:36,556
在首次引入时就走在了前面


877
00:35:37,946 --> 00:35:39,616
Framebuffer 对象将


878
00:35:39,616 --> 00:35:40,626
附加的渲染目标


879
00:35:41,606 --> 00:35:42,936
程序链接片段


880
00:35:42,936 --> 00:35:45,906
和顶点着色器组合在一起


881
00:35:45,906 --> 00:35:47,886
顶点数组对象


882
00:35:47,886 --> 00:35:49,146
则是更大的对象


883
00:35:49,146 --> 00:35:50,876
结合了一些顶点属性 API


884
00:35:50,876 --> 00:35:52,126
和顶点缓冲区设置


885
00:35:52,896 --> 00:35:54,546
但是即使有了所有这些变化


886
00:35:54,736 --> 00:35:55,936
尽管它们产生了积极的结果


887
00:35:55,936 --> 00:35:58,106
OpenGL 仍然需要在 draw 调用中


888
00:35:58,106 --> 00:35:59,746
验证许多东西


889
00:35:59,746 --> 00:36:04,236
比如


890
00:36:04,236 --> 00:36:06,276
glColorMask 能否帮助优化片段着色器


891
00:36:06,776 --> 00:36:09,016
片段着色器输出是否


892
00:36:09,016 --> 00:36:10,716
与附加的帧缓冲区兼容


893
00:36:11,276 --> 00:36:14,156
顶点布局是否


894
00:36:14,156 --> 00:36:15,136
与绑定程序兼容


895
00:36:16,406 --> 00:36:17,526
或者附加的渲染目标


896
00:36:17,526 --> 00:36:18,346
是可混合的吗


897
00:36:18,896 --> 00:36:22,036
当我们重新设计 Metal 的


898
00:36:22,086 --> 00:36:24,206
图形状态管理时


899
00:36:24,316 --> 00:36:25,846
我们将程序着色器


900
00:36:26,206 --> 00:36:27,966
与 VertexArray 对象的


901
00:36:27,966 --> 00:36:29,556
顶点输入布局相结合


902
00:36:29,556 --> 00:36:31,906
并添加关于


903
00:36:31,906 --> 00:36:33,256
pixelFormat 附件


904
00:36:33,256 --> 00:36:35,486
和混合状态的信息


905
00:36:35,486 --> 00:36:38,486
然后将它们组合到一个


906
00:36:38,536 --> 00:36:40,686
名为 PipelineDescriptor 的对象中


907
00:36:41,556 --> 00:36:43,176
这个结构描述了


908
00:36:43,176 --> 00:36:45,596
图形管道中的所有相关状态


909
00:36:46,836 --> 00:36:48,716
为了设置描述符


910
00:36:49,106 --> 00:36:49,796
你首先要初始化它


911
00:36:50,466 --> 00:36:52,146
然后设置所有


912
00:36:52,146 --> 00:36:53,486
我们刚才讲过的状态


913
00:36:53,556 --> 00:36:54,796
比如顶点和片段着色器


914
00:36:55,686 --> 00:36:57,336
顶点信息


915
00:36:57,336 --> 00:36:58,526
像素格式 以及混合状态


916
00:36:58,626 --> 00:37:01,836
然后使用描述符


917
00:37:01,836 --> 00:37:03,286
创建管道状态对象


918
00:37:03,286 --> 00:37:05,766
也就是 PSO


919
00:37:06,636 --> 00:37:08,406
这个不可变对象


920
00:37:08,406 --> 00:37:09,796
完全描述了渲染状态


921
00:37:09,796 --> 00:37:11,226
它的伟大之处在于


922
00:37:11,226 --> 00:37:12,846
你只需创建一次


923
00:37:12,846 --> 00:37:14,386
验证它的正确性


924
00:37:14,386 --> 00:37:15,696
然后在整个程序中使用它


925
00:37:16,276 --> 00:37:19,866
用类似的方式


926
00:37:19,866 --> 00:37:22,206
我们将所有深度和与模板相关的设置


927
00:37:22,206 --> 00:37:23,526
合并到深度/模板状态描述符中


928
00:37:24,326 --> 00:37:26,896
同样地


929
00:37:26,896 --> 00:37:28,266
它是所有深度/模板状态的集合


930
00:37:28,326 --> 00:37:30,186
使用这个描述符


931
00:37:30,186 --> 00:37:32,086
你就可以创建一个


932
00:37:32,086 --> 00:37:33,306
深度/模板状态对象


933
00:37:34,496 --> 00:37:35,996
这个对象也是不可变的


934
00:37:36,096 --> 00:37:37,876
并可在整个程序中使用


935
00:37:38,876 --> 00:37:40,756
我们在 OpenGL 中


936
00:37:40,756 --> 00:37:43,136
看到的渲染循环


937
00:37:43,136 --> 00:37:44,026
现在在 Metal 中看起来是这样的


938
00:37:44,836 --> 00:37:46,176
对于所有


939
00:37:46,246 --> 00:37:47,906
预验证的状态对象


940
00:37:47,906 --> 00:37:50,396
不再需要任何状态验证或跟踪


941
00:37:51,606 --> 00:37:55,566
让我们来比较一下


942
00:37:55,566 --> 00:37:57,436
在 Metal 中


943
00:37:57,436 --> 00:37:58,716
渲染编码器是渲染通道的开始


944
00:37:59,166 --> 00:38:00,446
类似于绑定帧缓冲区


945
00:38:01,006 --> 00:38:03,196
你的深度状态已经


946
00:38:03,346 --> 00:38:05,016
预置到对象中


947
00:38:05,016 --> 00:38:06,616
只需在 renderEncoder 上设置它


948
00:38:07,176 --> 00:38:10,056
pipelineState 对象


949
00:38:10,056 --> 00:38:11,766
表示程序着色器


950
00:38:11,846 --> 00:38:13,986
VertexArray 属性


951
00:38:13,986 --> 00:38:15,716
和 pixelFormat 的组合


952
00:38:15,716 --> 00:38:18,406
它也可在 renderEncoder 上设置


953
00:38:18,406 --> 00:38:21,346
现在 renderEncoder


954
00:38:21,346 --> 00:38:23,316
直接管理你的光栅化状态


955
00:38:24,296 --> 00:38:25,746
这里需要注意的是


956
00:38:25,746 --> 00:38:27,296
管道中


957
00:38:27,296 --> 00:38:28,596
仍然具有灵活性


958
00:38:28,596 --> 00:38:30,046
因为并不是所有内容


959
00:38:30,046 --> 00:38:30,936
都被预先放入了 pipelineState 对象中


960
00:38:31,356 --> 00:38:34,156
这是我们刚刚


961
00:38:34,156 --> 00:38:35,336
讨论过的状态列表


962
00:38:35,336 --> 00:38:37,596
你可以把它预置到你的 PSO 中


963
00:38:37,596 --> 00:38:38,586
比如顶点 片段函数


964
00:38:38,586 --> 00:38:40,156
像素格式 等等


965
00:38:41,356 --> 00:38:42,956
另一方面


966
00:38:42,956 --> 00:38:44,106
这是你在绘图时


967
00:38:44,106 --> 00:38:45,686
仍然设置的所有状态


968
00:38:46,746 --> 00:38:47,736
比如原始剔除模式和方向


969
00:38:47,736 --> 00:38:49,136
填充模式


970
00:38:49,736 --> 00:38:51,216
剪刀和视图区域


971
00:38:51,216 --> 00:38:53,156
仍然像 OpenGL 一样设置


972
00:38:53,156 --> 00:38:57,446
重要的是绘制调用保持不变


973
00:38:58,216 --> 00:38:59,706
这里的主要区别是


974
00:38:59,706 --> 00:39:01,236
你无需启用新状态


975
00:39:01,396 --> 00:39:02,366
这可能导致


976
00:39:02,366 --> 00:39:04,366
隐藏的验证成本


977
00:39:04,446 --> 00:39:06,186
你只需要替换掉一个新的 pipelineState 对象


978
00:39:06,186 --> 00:39:08,516
该对象在描述符中启用了混合


979
00:39:11,186 --> 00:39:12,556
我还想讨论


980
00:39:12,556 --> 00:39:13,876
另一种可能的优化


981
00:39:13,876 --> 00:39:15,916
你可能在 OpenGL 中使用过它


982
00:39:15,916 --> 00:39:18,666
来隐藏某些繁复的操作


983
00:39:19,996 --> 00:39:21,836
作为 OpenGL 开发者


984
00:39:21,836 --> 00:39:23,226
你可能已经看到


985
00:39:23,296 --> 00:39:25,256
在进行了一系列状态更改之后的


986
00:39:25,306 --> 00:39:27,316
第一次绘制调用时


987
00:39:27,316 --> 00:39:28,206
渲染循环出现了意外的小问题


988
00:39:29,096 --> 00:39:30,596
如果你遇到了这种情况


989
00:39:30,596 --> 00:39:32,216
你可以使用一个


990
00:39:32,216 --> 00:39:34,126
名为着色器预热的优化来隐藏它


991
00:39:35,546 --> 00:39:36,726
在着色器预热中


992
00:39:36,806 --> 00:39:38,346
App 为最常见的 GL 程序


993
00:39:38,346 --> 00:39:39,666
使用虚拟绘制调用


994
00:39:39,666 --> 00:39:42,276
以便 OpenGL


995
00:39:42,606 --> 00:39:43,676
提前创建


996
00:39:43,676 --> 00:39:44,846
所有必要的状态


997
00:39:45,856 --> 00:39:47,246
如果你已经在


998
00:39:47,406 --> 00:39:48,706
你的引擎中这样做了


999
00:39:48,706 --> 00:39:50,326
那么你将会很容易


1000
00:39:50,326 --> 00:39:54,286
用 PSO 创建来替换它


1001
00:39:54,386 --> 00:39:55,966
现在 Metal 中的着色器预热


1002
00:39:56,296 --> 00:39:58,196
是通过在不同的启用状态


1003
00:39:58,196 --> 00:40:00,396
创建单独的 PSO 对象而完成的


1004
00:40:00,876 --> 00:40:03,326
首先 你需要创建描述符


1005
00:40:03,326 --> 00:40:05,436
然后设置直到第一个


1006
00:40:05,436 --> 00:40:06,776
绘制调用之前的所有状态


1007
00:40:06,776 --> 00:40:09,276
并创建第一个 pipelineState 对象


1008
00:40:10,036 --> 00:40:11,596
然后 你可以使用


1009
00:40:11,596 --> 00:40:13,146
相同的描述符


1010
00:40:13,206 --> 00:40:14,306
更改它的一些状态


1011
00:40:14,306 --> 00:40:15,886
就像这里我们启用了混合


1012
00:40:15,886 --> 00:40:17,706
然后创建第二个 PipelineState 对象


1013
00:40:18,966 --> 00:40:20,506
这两个都是预验证的


1014
00:40:20,726 --> 00:40:22,736
因此在绘制期间


1015
00:40:22,736 --> 00:40:24,466
你可以在绘制调用之间交换它们


1016
00:40:25,806 --> 00:40:27,036
如果你正在从 OpenGL 移植到 Metal


1017
00:40:27,036 --> 00:40:29,796
希望这是一个简单了当的更改


1018
00:40:29,796 --> 00:40:33,666
现在我们将结束


1019
00:40:33,666 --> 00:40:35,896
App 的设置阶段


1020
00:40:35,896 --> 00:40:37,146
我想提出一点将 App


1021
00:40:37,146 --> 00:40:38,486
从 OpenGL 移植到


1022
00:40:38,516 --> 00:40:40,446
Metal 的主要好处


1023
00:40:40,446 --> 00:40:41,856
那就是 这将开始减少


1024
00:40:41,946 --> 00:40:43,896
高执行成本操作的频率


1025
00:40:44,456 --> 00:40:47,656
在 OpenGL 中


1026
00:40:47,656 --> 00:40:48,846
你的 App 必须等到绘制时间


1027
00:40:48,916 --> 00:40:50,686
才能执行编译


1028
00:40:50,826 --> 00:40:52,146
链接着色器


1029
00:40:52,146 --> 00:40:54,346
或验证状态等操作


1030
00:40:54,346 --> 00:40:55,846
这意味着这些繁复的操作


1031
00:40:55,846 --> 00:40:57,396
在每一帧中都会发生很多次


1032
00:40:57,976 --> 00:41:00,626
一旦你将 App 移植到 Metal


1033
00:41:01,276 --> 00:41:02,506
App 就会将这些操作


1034
00:41:02,506 --> 00:41:04,876
移动到其生命周期的不同阶段


1035
00:41:05,876 --> 00:41:07,516
使用预编译的着色器


1036
00:41:07,516 --> 00:41:09,166
着色器编译已经从初始化阶段


1037
00:41:09,166 --> 00:41:10,556
移到了构建阶段


1038
00:41:10,616 --> 00:41:11,656
因此它只需只执行一次


1039
00:41:13,046 --> 00:41:14,426
然后使用 PSO


1040
00:41:14,426 --> 00:41:16,806
将状态定义移动到内容加载


1041
00:41:17,046 --> 00:41:18,256
这样你就有足够的绘制时间


1042
00:41:18,316 --> 00:41:19,806
来调用 draw 函数


1043
00:41:19,806 --> 00:41:23,936
现在我们已经完成了


1044
00:41:23,936 --> 00:41:25,516
App 的设置阶段


1045
00:41:25,976 --> 00:41:27,416
让我们讨论一下如何使用所有这些


1046
00:41:27,956 --> 00:41:31,006
资源 着色器和对象来渲染帧


1047
00:41:33,396 --> 00:41:35,006
为了绘制一个单独的帧


1048
00:41:35,306 --> 00:41:36,916
你的 App 需要首先


1049
00:41:37,136 --> 00:41:38,586
更新纹理和缓冲区


1050
00:41:39,486 --> 00:41:40,786
然后建立一个


1051
00:41:40,786 --> 00:41:42,506
要渲染的渲染目标


1052
00:41:42,506 --> 00:41:43,836
然后在最终呈现你的工作之前


1053
00:41:43,836 --> 00:41:45,006
进行多次渲染


1054
00:41:46,236 --> 00:41:48,096
让我们讨论一下更新资源


1055
00:41:49,316 --> 00:41:50,796
通常来说


1056
00:41:50,796 --> 00:41:52,506
在整个渲染循环中


1057
00:41:52,506 --> 00:41:54,606
至少一部分资源需要不断更新


1058
00:41:55,916 --> 00:41:57,536
这样的例子有


1059
00:41:57,536 --> 00:41:59,116
着色器常量顶 顶点和索引缓冲区


1060
00:41:59,146 --> 00:42:00,436
以及纹理


1061
00:42:00,436 --> 00:42:05,476
这些修改可以通过


1062
00:42:05,806 --> 00:42:07,506
GPU 和 CPU 之间的同步


1063
00:42:07,506 --> 00:42:08,586
在帧之间完成


1064
00:42:08,586 --> 00:42:11,836
一个典型的 GL 资源更新


1065
00:42:12,096 --> 00:42:13,866
可以是


1066
00:42:13,866 --> 00:42:17,126
以下调用的任意组合


1067
00:42:17,126 --> 00:42:20,236
一个缓冲区可以由 CPU 更新


1068
00:42:20,236 --> 00:42:21,886
或者你也可以通过 GPU 凭借缓冲到缓冲的拷贝


1069
00:42:21,886 --> 00:42:23,126
来更新一个缓冲区


1070
00:42:24,436 --> 00:42:26,416
类似地


1071
00:42:26,416 --> 00:42:29,576
纹理可以由 CPU 更新


1072
00:42:29,576 --> 00:42:31,006
也可以通过 GPU 上的


1073
00:42:31,006 --> 00:42:32,076
纹理到纹理拷贝来更新


1074
00:42:32,536 --> 00:42:35,916
乍一看


1075
00:42:35,916 --> 00:42:36,966
Metal 提供了类似的功能


1076
00:42:37,386 --> 00:42:38,886
但是正如 Lionel 之前提到的


1077
00:42:39,226 --> 00:42:40,466
用于存储缓冲区和纹理的容器


1078
00:42:40,466 --> 00:42:42,426
是不可变的


1079
00:42:42,426 --> 00:42:43,826
并且是在初始化过程中创建的


1080
00:42:44,326 --> 00:42:45,736
但是 它们的内容


1081
00:42:45,736 --> 00:42:48,096
可以通过以下任意组合进行修改


1082
00:42:48,686 --> 00:42:52,306
具有共享或托管存储模式的缓冲区


1083
00:42:52,306 --> 00:42:54,086
可以通过其在 CPU 上的


1084
00:42:54,456 --> 00:42:57,246
contents 属性进行更新


1085
00:42:58,006 --> 00:43:00,786
在 GPU 上


1086
00:43:00,786 --> 00:43:02,946
blitEncoder 负责所有的数据复制


1087
00:43:03,506 --> 00:43:05,226
所以你可以通过 blitEncoder 上的


1088
00:43:05,226 --> 00:43:06,996
copyFromBuffer 方法


1089
00:43:07,036 --> 00:43:09,436
从 GPU 更新一个缓冲区


1090
00:43:10,896 --> 00:43:12,766
类似地


1091
00:43:12,766 --> 00:43:14,296
你可以通过 replaceRegion 方法


1092
00:43:14,296 --> 00:43:16,056
在 CPU 上更新具有共享


1093
00:43:16,056 --> 00:43:17,056
或托管存储模式的纹理


1094
00:43:18,246 --> 00:43:20,436
或者在 GPU 上


1095
00:43:20,436 --> 00:43:21,416
你可以通过 blitEncoder 上的


1096
00:43:21,706 --> 00:43:23,716
copyFromTexture 方法来更新纹理


1097
00:43:24,246 --> 00:43:27,646
值得注意的是


1098
00:43:27,726 --> 00:43:28,746
当涉及到这些更新时


1099
00:43:28,746 --> 00:43:31,236
存储模式很重要


1100
00:43:31,236 --> 00:43:32,506
因为只有具有共享或托管存储模式的


1101
00:43:32,506 --> 00:43:35,000
缓冲区和纹理可以由 CPU 更新


1102
00:43:37,326 --> 00:43:38,406
OpenGL 为你管理


1103
00:43:38,406 --> 00:43:39,906
GPU 和 CPU 之间的同步


1104
00:43:39,906 --> 00:43:41,156
尽管有时


1105
00:43:41,226 --> 00:43:42,886
在你的 App 等待一个


1106
00:43:42,886 --> 00:43:44,156
或另一个完成时


1107
00:43:44,156 --> 00:43:45,446
你的 App 会付出过高的代价


1108
00:43:46,736 --> 00:43:48,336
在 Metal 中


1109
00:43:48,396 --> 00:43:49,936
因为你可以控制内存的存储方式


1110
00:43:49,936 --> 00:43:52,606
所以还可以控制数据同步的方式和时间


1111
00:43:53,156 --> 00:43:54,926
这对于缓冲区和纹理都是适用的


1112
00:43:55,656 --> 00:43:59,676
如果你将 GL App 移植到 Metal


1113
00:43:59,676 --> 00:44:01,956
并且仅为资源更新


1114
00:44:01,956 --> 00:44:03,806
使用一个缓冲区


1115
00:44:03,806 --> 00:44:06,306
那么流程将会是这个样子


1116
00:44:06,506 --> 00:44:08,176
首先 CPU 将在


1117
00:44:08,176 --> 00:44:10,106
设置渲染通道期间更新资源


1118
00:44:10,846 --> 00:44:12,046
然后在完成之后


1119
00:44:12,046 --> 00:44:13,346
缓冲区


1120
00:44:13,346 --> 00:44:15,006
将被 GPU


1121
00:44:15,006 --> 00:44:16,326
在执行渲染通道期间消耗


1122
00:44:17,086 --> 00:44:18,886
然而


1123
00:44:18,886 --> 00:44:20,056
当 GPU 从这个缓冲区读取数据时


1124
00:44:20,056 --> 00:44:21,736
CPU 可能会开始设置


1125
00:44:21,736 --> 00:44:22,826
接下来的渲染通道


1126
00:44:22,826 --> 00:44:24,126
并需要更新相同的缓冲区


1127
00:44:25,056 --> 00:44:26,666
这是一个明显的竞争情况


1128
00:44:27,646 --> 00:44:29,606
我们来看一个解决这个问题的方法


1129
00:44:30,186 --> 00:44:32,436
一个简单的解决方案是


1130
00:44:32,436 --> 00:44:34,466
将这个资源提交给 GPU


1131
00:44:34,766 --> 00:44:36,906
并在它所使用的 commandBuffer 上


1132
00:44:37,026 --> 00:44:38,426
调用 waitUntilCompleted


1133
00:44:39,466 --> 00:44:40,766
正如我们前面讨论的


1134
00:44:40,816 --> 00:44:43,456
这类似于 glFinish


1135
00:44:43,456 --> 00:44:45,456
它在所有 CPU 工作上放置一个信号量


1136
00:44:45,456 --> 00:44:47,176
直到 GPU 完成执行


1137
00:44:47,346 --> 00:44:49,926
使用该缓冲区的渲染通道


1138
00:44:49,986 --> 00:44:52,506
执行完成后


1139
00:44:52,506 --> 00:44:54,336
从 GPU 接收回一个调用


1140
00:44:54,336 --> 00:44:56,476
通过这种方式


1141
00:44:56,476 --> 00:44:58,046
你可以确保


1142
00:44:58,046 --> 00:44:59,466
你的单个缓冲区


1143
00:44:59,466 --> 00:45:02,006
不会被 CPU 或 GPU 争夺


1144
00:45:03,536 --> 00:45:07,416
然而正如你所看到的


1145
00:45:07,416 --> 00:45:09,016
CPU 在 GPU 执行时是空闲的


1146
00:45:09,016 --> 00:45:10,996
GPU 在等待 CPU


1147
00:45:10,996 --> 00:45:12,946
提交工作时处于饥饿状态


1148
00:45:13,786 --> 00:45:15,266
因此 虽然在你开始


1149
00:45:15,266 --> 00:45:16,506
解决这些竞争情况时


1150
00:45:16,506 --> 00:45:18,036
这对你很有帮助


1151
00:45:18,036 --> 00:45:19,426
但不建议


1152
00:45:19,426 --> 00:45:20,446
使用 waitUntilCompleted


1153
00:45:20,446 --> 00:45:21,766
因为它会给程序


1154
00:45:21,766 --> 00:45:24,146
带来延迟


1155
00:45:25,136 --> 00:45:27,646
同步更新的一种有效方法是


1156
00:45:27,716 --> 00:45:29,526
根据 App 的需要


1157
00:45:29,526 --> 00:45:30,826
使用两个或多个缓冲区


1158
00:45:31,796 --> 00:45:32,986
这样 CPU 就可以


1159
00:45:32,986 --> 00:45:34,776
写一个缓冲区


1160
00:45:34,876 --> 00:45:36,946
而 GPU 可以从另一个缓冲区读取数据


1161
00:45:38,126 --> 00:45:40,286
让我们看一个简单的三重缓冲示例


1162
00:45:40,756 --> 00:45:43,736
这里我们从


1163
00:45:43,736 --> 00:45:45,596
第一个资源开始


1164
00:45:45,956 --> 00:45:48,006
准备让 GPU 使用


1165
00:45:48,856 --> 00:45:49,566
但是我们没有使用


1166
00:45:49,636 --> 00:45:51,346
waitUntilCompleted


1167
00:45:51,346 --> 00:45:53,826
而是添加了一个补全处理程序


1168
00:45:53,826 --> 00:45:55,196
这样一旦相应的帧


1169
00:45:55,196 --> 00:45:57,006
在 GPU 上完成


1170
00:45:57,006 --> 00:46:00,156
它就可以让 CPU 知道它已经完成了


1171
00:46:00,236 --> 00:46:02,456
但现在我们不需要等待它完成


1172
00:46:03,546 --> 00:46:04,976
当 GPU 执行时


1173
00:46:04,976 --> 00:46:06,286
三重缓冲的 CPU


1174
00:46:06,286 --> 00:46:08,686
可以跳过两次更新


1175
00:46:08,686 --> 00:46:09,656
因为它在不同的缓冲区


1176
00:46:11,046 --> 00:46:12,906
这是在 GPU 上


1177
00:46:12,906 --> 00:46:15,036
完成的帧


1178
00:46:15,036 --> 00:46:17,106
这是补全处理程序


1179
00:46:17,106 --> 00:46:18,176
运行的地方


1180
00:46:19,106 --> 00:46:20,606
它通知 GPU 的工作已经完成


1181
00:46:20,606 --> 00:46:22,016
然后将缓冲区


1182
00:46:22,016 --> 00:46:24,676
返回到缓冲池


1183
00:46:24,676 --> 00:46:26,796
以便在 GPU 继续执行时


1184
00:46:26,796 --> 00:46:28,096
下一帧的 CPU


1185
00:46:28,096 --> 00:46:29,166
可以使用它


1186
00:46:29,636 --> 00:46:31,586
我认为大多数开发者会发现


1187
00:46:31,586 --> 00:46:32,456
他们需要实现


1188
00:46:32,456 --> 00:46:33,876
三重缓冲


1189
00:46:33,876 --> 00:46:35,056
才能获得最佳性能


1190
00:46:35,536 --> 00:46:38,996
至于实现


1191
00:46:38,996 --> 00:46:40,106
当然 对于三重缓冲


1192
00:46:40,106 --> 00:46:41,856
你需要从一个包含三个缓冲区的队列开始


1193
00:46:43,706 --> 00:46:45,266
你还需要初始化


1194
00:46:45,306 --> 00:46:46,726
frameBorderySemaphore


1195
00:46:46,726 --> 00:46:47,676
初始值为 3


1196
00:46:47,676 --> 00:46:49,616
当 GPU 执行完毕时


1197
00:46:49,616 --> 00:46:51,616
这个信号量会在


1198
00:46:51,616 --> 00:46:53,166
每个帧边界处发出信号


1199
00:46:54,016 --> 00:46:55,336
让 CPU 知道


1200
00:46:55,336 --> 00:46:56,596
重写缓冲区是安全的


1201
00:46:57,026 --> 00:46:59,466
最后 我们需要


1202
00:46:59,466 --> 00:47:01,016
初始化缓冲区索引


1203
00:47:01,016 --> 00:47:04,136
以指向当前帧的缓冲区


1204
00:47:04,316 --> 00:47:06,696
在渲染循环内部


1205
00:47:06,696 --> 00:47:08,026
在写入缓冲区之前


1206
00:47:08,026 --> 00:47:09,456
我们需要确保


1207
00:47:09,546 --> 00:47:12,446
GPU 执行完成了相应的帧


1208
00:47:13,666 --> 00:47:15,086
所以在每次渲染通道的开始


1209
00:47:15,536 --> 00:47:17,746
我们需要等待


1210
00:47:17,746 --> 00:47:18,976
frameBoundarySemaphore


1211
00:47:18,976 --> 00:47:20,966
一旦接收到信号


1212
00:47:20,996 --> 00:47:23,316
我们就知道获取它的缓冲区


1213
00:47:23,376 --> 00:47:24,536
并将其用于新的帧数据


1214
00:47:24,536 --> 00:47:25,626
是安全的


1215
00:47:26,216 --> 00:47:29,946
现在我们对命令进行编码


1216
00:47:29,946 --> 00:47:31,806
并将这个资源绑定到 GPU


1217
00:47:31,806 --> 00:47:33,466
以便在下一帧中使用


1218
00:47:34,556 --> 00:47:36,026
但在提交之前


1219
00:47:36,026 --> 00:47:37,386
我们必须将完成处理程序


1220
00:47:37,386 --> 00:47:39,876
添加到 commandBuffer 中


1221
00:47:39,876 --> 00:47:40,906
然后提交它


1222
00:47:41,636 --> 00:47:43,116
一旦 GPU 完成执行


1223
00:47:43,116 --> 00:47:44,446
我们的完成处理程序


1224
00:47:44,486 --> 00:47:46,006
就会向帧信号量发出信号


1225
00:47:46,066 --> 00:47:48,436
让 CPU 知道


1226
00:47:48,436 --> 00:47:49,766
它已经完成了


1227
00:47:49,766 --> 00:47:51,596
可以重用缓冲区来进行下一帧的编码


1228
00:47:52,146 --> 00:47:54,816
这是一个简单的


1229
00:47:54,816 --> 00:47:56,886
三重缓冲区实现


1230
00:47:56,886 --> 00:47:59,256
你可以用于任何的动态资源更新


1231
00:47:59,796 --> 00:48:04,186
好的 现在我们已经更新了资源


1232
00:48:04,186 --> 00:48:07,026
让我们来谈谈渲染目标


1233
00:48:08,196 --> 00:48:10,456
在 OpenGL 中


1234
00:48:10,456 --> 00:48:12,386
Framebuffer 对象（FBO）


1235
00:48:11,716 --> 00:48:12,386
是渲染命令的目标


1236
00:48:13,416 --> 00:48:14,896
FBO 在一个伞下


1237
00:48:14,946 --> 00:48:16,136
收集许多纹理


1238
00:48:16,136 --> 00:48:17,596
和渲染缓冲对象


1239
00:48:17,596 --> 00:48:19,516
并在其中进行渲染


1240
00:48:20,076 --> 00:48:21,576
Framebuffer 的状态是可变的


1241
00:48:21,576 --> 00:48:23,736
通过绑定 Framebuffer


1242
00:48:23,736 --> 00:48:25,116
并最终将它们交换显示


1243
00:48:25,176 --> 00:48:27,306
渲染通道得以被松散地描述


1244
00:48:27,406 --> 00:48:30,756
这是一个典型的


1245
00:48:30,756 --> 00:48:32,066
带有 Framebuffer 的 OpenGL 工作流


1246
00:48:33,566 --> 00:48:36,036
在 App 的初始化阶段


1247
00:48:36,036 --> 00:48:37,126
一个 Framebuffer 被创建


1248
00:48:37,386 --> 00:48:39,206
然后通过绑定使它运转


1249
00:48:39,206 --> 00:48:41,546
然后你附加像纹理这样的资源


1250
00:48:41,546 --> 00:48:43,106
然后检查


1251
00:48:43,106 --> 00:48:44,336
Framebuffer 状态


1252
00:48:44,336 --> 00:48:45,706
以确保它是有效的


1253
00:48:46,976 --> 00:48:49,056
在绘制期间


1254
00:48:49,056 --> 00:48:50,246
你可以通过绑定 Framebuffer 来生成一个流


1255
00:48:50,246 --> 00:48:52,466
这是渲染通道的是隐式的开始


1256
00:48:53,236 --> 00:48:54,566
然后在对它调用绘制之前


1257
00:48:55,286 --> 00:48:57,086
你必须清除它


1258
00:48:57,086 --> 00:49:01,296
最后 你可以发出信号


1259
00:49:01,296 --> 00:49:03,276
表示可以丢弃某些附件


1260
00:49:03,276 --> 00:49:04,606
让 OpenGL 知道没有必要


1261
00:49:04,606 --> 00:49:05,976
将这些内容存储到内存中


1262
00:49:06,796 --> 00:49:08,396
这些丢弃事件可以作为


1263
00:49:09,146 --> 00:49:11,036
结束渲染通道的提示


1264
00:49:11,416 --> 00:49:12,506
但这不是一个保证


1265
00:49:15,536 --> 00:49:17,286
在 Metal 中


1266
00:49:17,286 --> 00:49:19,546
渲染命令编码器是渲染命令的目标


1267
00:49:20,506 --> 00:49:21,686
渲染命令编码器


1268
00:49:21,686 --> 00:49:22,776
是由渲染通道描述符创建的


1269
00:49:22,776 --> 00:49:24,826
与 FBO 类似


1270
00:49:24,996 --> 00:49:26,496
它为一个渲染通道


1271
00:49:26,546 --> 00:49:27,746
收集许多渲染目的地


1272
00:49:27,746 --> 00:49:29,616
并促进对它们的渲染


1273
00:49:30,966 --> 00:49:32,116
渲染命令编码器


1274
00:49:32,116 --> 00:49:33,346
直接负责


1275
00:49:33,376 --> 00:49:34,666
为 GPU 生成硬件命令


1276
00:49:34,666 --> 00:49:36,736
渲染通道


1277
00:49:36,736 --> 00:49:38,496
由编码器的开始和结束


1278
00:49:38,556 --> 00:49:39,926
显式地描述


1279
00:49:40,496 --> 00:49:43,296
这是一个 Metal 中的渲染通道


1280
00:49:44,356 --> 00:49:46,306
首先 你创建 RenderPassDescriptor


1281
00:49:46,306 --> 00:49:48,686
RenderPassDescriptor


1282
00:49:48,686 --> 00:49:49,986
描述了所有附加的资源


1283
00:49:50,176 --> 00:49:52,936
还指定了


1284
00:49:52,936 --> 00:49:54,076
在渲染通道开始和结束时


1285
00:49:54,076 --> 00:49:55,316
发生的操作


1286
00:49:55,316 --> 00:49:58,176
这些操作称为 loadAction 和 storeAction


1287
00:49:59,086 --> 00:50:01,736
与 GL 相反 在 Metal 中


1288
00:50:01,736 --> 00:50:03,146
你不需要直接清除资源


1289
00:50:03,216 --> 00:50:06,106
相反地


1290
00:50:06,106 --> 00:50:08,406
你可以指定一个 loadAction 来清除它和颜色


1291
00:50:08,936 --> 00:50:11,756
这里 它是黑色的


1292
00:50:11,756 --> 00:50:13,586
这里的 storeAction 是 DontCare


1293
00:50:13,626 --> 00:50:16,296
类似于 GL 示例中的


1294
00:50:16,296 --> 00:50:18,306
GL 丢弃 Framebuffer


1295
00:50:19,646 --> 00:50:21,946
如果你希望将结果存储到内存中


1296
00:50:21,946 --> 00:50:23,146
你可以使用这里的 storeAction


1297
00:50:23,686 --> 00:50:27,266
在渲染时


1298
00:50:27,266 --> 00:50:28,306
你使用描述符来创建编码器


1299
00:50:28,306 --> 00:50:31,016
这样状态就设置好了


1300
00:50:31,226 --> 00:50:33,136
你进行所有的绘制调用


1301
00:50:33,136 --> 00:50:34,956
然后显式地结束编码


1302
00:50:35,436 --> 00:50:37,436
但是在丢弃 Framebuffer


1303
00:50:37,436 --> 00:50:39,336
或结束编码之前


1304
00:50:39,676 --> 00:50:40,976
让我们先绘制一些内容


1305
00:50:41,986 --> 00:50:44,366
一系列渲染命令


1306
00:50:44,366 --> 00:50:45,706
通常称为渲染通道


1307
00:50:46,866 --> 00:50:48,336
在渲染通道中


1308
00:50:48,336 --> 00:50:49,596
你可以设置状态并绘制调用输入


1309
00:50:49,596 --> 00:50:51,186
比如纹理和缓冲区


1310
00:50:51,186 --> 00:50:52,916
然后发出绘制命令


1311
00:50:54,016 --> 00:50:56,536
这是一个典型的 OpenGL 绘制序列


1312
00:50:57,706 --> 00:50:59,606
一个表现良好的 OpenGL App


1313
00:50:59,606 --> 00:51:00,856
试图提前设置它的所有状态


1314
00:51:00,896 --> 00:51:03,236
然后绑定它的目标


1315
00:51:03,566 --> 00:51:07,826
和一个 GL 程序来链接着色器


1316
00:51:08,446 --> 00:51:11,166
然后它将把


1317
00:51:11,166 --> 00:51:13,086
顶点缓冲区 统一变量


1318
00:51:13,086 --> 00:51:15,216
和纹理等资源绑定到程序的不同阶段


1319
00:51:16,576 --> 00:51:17,846
最后 它会开始绘制


1320
00:51:21,356 --> 00:51:22,806
正如我们之前讨论过的


1321
00:51:22,806 --> 00:51:25,216
OpenGL 状态更改


1322
00:51:25,216 --> 00:51:26,336
可能会导致隐藏的验证检查


1323
00:51:26,336 --> 00:51:28,266
如果你已经在 OpenGL 中


1324
00:51:28,266 --> 00:51:29,896
将状态更改


1325
00:51:29,896 --> 00:51:31,146
组合在一起


1326
00:51:31,196 --> 00:51:32,596
以避免这些性能问题


1327
00:51:32,596 --> 00:51:33,916
那么你将充分利用


1328
00:51:34,186 --> 00:51:35,456
Metal 的预验证状态对象


1329
00:51:36,846 --> 00:51:38,636
在 Metal 中


1330
00:51:38,636 --> 00:51:39,776
因为验证只在


1331
00:51:39,776 --> 00:51:41,376
创建 PipelineState 对象时发生


1332
00:51:41,376 --> 00:51:42,926
而且着色器是预编译的


1333
00:51:43,296 --> 00:51:45,276
所以渲染循环会变得更小


1334
00:51:45,866 --> 00:51:48,446
但是对于开发者来说


1335
00:51:48,476 --> 00:51:49,706
不需要做太多的更改


1336
00:51:50,866 --> 00:51:52,326
这和我们在 OpenGL 中看到的代码是一样的


1337
00:51:52,326 --> 00:51:53,846
但是现在是在 Metal 中


1338
00:51:55,586 --> 00:51:57,006
你从渲染命令编码器开始


1339
00:51:57,006 --> 00:51:58,776
这相当于设置


1340
00:51:58,776 --> 00:52:00,486
GL Framebuffer


1341
00:52:00,486 --> 00:52:03,696
然后设置预构建的


1342
00:52:03,696 --> 00:52:05,026
PipelineState 对象


1343
00:52:05,026 --> 00:52:06,466
它相当于 GL use 程序


1344
00:52:06,656 --> 00:52:09,356
在那之后


1345
00:52:09,356 --> 00:52:10,776
我们为我们的 Metal 程序分配资源


1346
00:52:10,966 --> 00:52:13,346
从 VertexBuffer 和统一变量开始


1347
00:52:13,946 --> 00:52:15,366
你可以在这里注意到


1348
00:52:15,366 --> 00:52:16,986
你必须为每个着色器阶段设置统一变量


1349
00:52:17,506 --> 00:52:20,326
而不是像 GL 中那样


1350
00:52:20,326 --> 00:52:22,586
为 GL 程序设置统一变量


1351
00:52:23,726 --> 00:52:24,936
在这里 因为我们是


1352
00:52:24,936 --> 00:52:26,256
直接从 OpenGL 移植过来的


1353
00:52:26,256 --> 00:52:27,216
所以我们发送的是同样的统一变量


1354
00:52:27,216 --> 00:52:29,726
但在 Metal 中


1355
00:52:29,726 --> 00:52:30,876
你可以按你的意愿发送不同的统一变量


1356
00:52:31,236 --> 00:52:33,506
然后设置你的纹理


1357
00:52:33,506 --> 00:52:35,306
并发出绘制调用


1358
00:52:35,366 --> 00:52:36,816
最后 一旦你完成了


1359
00:52:36,876 --> 00:52:38,376
所有的绘制调用


1360
00:52:38,376 --> 00:52:39,626
你就可以结束渲染通道了


1361
00:52:41,776 --> 00:52:43,146
虽然工作被提交了


1362
00:52:43,196 --> 00:52:45,526
却仍然有呈现的问题


1363
00:52:46,156 --> 00:52:49,716
当 GPU 渲染这个场景时


1364
00:52:49,716 --> 00:52:51,136
它会写出来给 Framebuffer 来显示


1365
00:52:52,236 --> 00:52:54,516
在 OpenGL 中为了呈现


1366
00:52:54,516 --> 00:52:56,746
渲染过的帧


1367
00:52:56,746 --> 00:52:58,386
当你从 drawInRect 返回时


1368
00:52:58,746 --> 00:53:00,706
上下文会为你调用 presetRenderBuffer


1369
00:53:01,906 --> 00:53:03,136
而 Metal


1370
00:53:03,136 --> 00:53:04,596
则直接通过 drawables 的


1371
00:53:04,656 --> 00:53:06,486
Core Animations 池来实现这一点


1372
00:53:07,296 --> 00:53:09,646
drawables 是用于屏幕显示的纹理


1373
00:53:10,206 --> 00:53:13,036
你还可以将渲染通道


1374
00:53:13,086 --> 00:53:14,076
编码为 drawables


1375
00:53:15,126 --> 00:53:16,376
获取当前 drawable


1376
00:53:16,376 --> 00:53:17,726
然后在渲染循环之后


1377
00:53:18,036 --> 00:53:22,146
告诉命令缓冲区显示它


1378
00:53:22,346 --> 00:53:24,126
还记得我们的代码吗


1379
00:53:24,126 --> 00:53:26,296
从刚开始


1380
00:53:26,296 --> 00:53:28,156
我们讲窗口子系统的时候


1381
00:53:29,006 --> 00:53:30,396
这里 我们将深入研究


1382
00:53:30,396 --> 00:53:33,856
glkView 和 drawInMTKView


1383
00:53:33,916 --> 00:53:35,196
看看如何呈现所渲染的内容


1384
00:53:35,806 --> 00:53:37,956
就是这样


1385
00:53:38,706 --> 00:53:40,396
你需要在 glkView 中


1386
00:53:40,396 --> 00:53:42,336
绑定 Framebuffer


1387
00:53:42,336 --> 00:53:43,986
执行渲染命令


1388
00:53:43,986 --> 00:53:45,466
然后当你从 drawInRect 返回时


1389
00:53:45,466 --> 00:53:46,546
显示就已经处理好了


1390
00:53:47,996 --> 00:53:49,926
在 Metal 中也是一样的


1391
00:53:49,926 --> 00:53:51,186
你创建 commandBuffer


1392
00:53:51,586 --> 00:53:52,916
通过创建结束编码器


1393
00:53:52,916 --> 00:53:55,456
来执行渲染命令


1394
00:53:55,456 --> 00:53:56,796
然后你必须执行的


1395
00:53:56,836 --> 00:53:58,966
一个额外步骤是


1396
00:53:58,966 --> 00:54:00,926
在最终提交 commandBuffer 之前


1397
00:54:00,926 --> 00:54:02,726
调用 presentDrawable


1398
00:54:02,776 --> 00:54:05,416
如果你的渲染循环非常简单


1399
00:54:05,416 --> 00:54:06,806
只有一个编码器


1400
00:54:07,126 --> 00:54:08,296
那么这就是全部你要做的


1401
00:54:09,066 --> 00:54:10,446
然而 如果你有一个


1402
00:54:10,446 --> 00:54:12,106
更复杂的 App


1403
00:54:12,106 --> 00:54:13,416
你可能需要查看


1404
00:54:13,416 --> 00:54:14,956
我们关于“如何处理你的 drawables 


1405
00:54:14,956 --> 00:54:17,166
优化 Metal App 和游戏” 的演讲


1406
00:54:17,166 --> 00:54:20,346
这就是我们的框架


1407
00:54:20,706 --> 00:54:21,776
我们已经展示了如何轻松地


1408
00:54:21,776 --> 00:54:23,626
迁移窗口子系统


1409
00:54:24,446 --> 00:54:26,406
我们已经讨论了资源创建步骤


1410
00:54:26,956 --> 00:54:28,456
我们已经移植了着色器


1411
00:54:28,456 --> 00:54:30,586
并使用超棒的工具来快速找到问题


1412
00:54:31,136 --> 00:54:33,596
我们创建了渲染命令队列


1413
00:54:33,656 --> 00:54:34,946
命令缓冲区和命令编码器


1414
00:54:34,946 --> 00:54:37,266
来设置渲染通道


1415
00:54:37,516 --> 00:54:39,726
我们创建了预验证状态对象


1416
00:54:40,166 --> 00:54:42,496
然后为了渲染每个帧


1417
00:54:42,496 --> 00:54:44,626
我们使用三重缓冲来更新资源


1418
00:54:45,576 --> 00:54:46,536
我们在命令中


1419
00:54:46,536 --> 00:54:47,936
使用了渲染命令编码器


1420
00:54:47,936 --> 00:54:49,706
在最终呈现渲染帧之前


1421
00:54:49,706 --> 00:54:51,776
我们在渲染通道中


1422
00:54:51,816 --> 00:54:53,156
绘制了几何图形


1423
00:54:53,696 --> 00:54:56,106
我们已经通览了


1424
00:54:56,106 --> 00:54:57,516
图形 App 的生命历程


1425
00:54:57,516 --> 00:54:59,066
并展示了 Metal 是如何自然演变的


1426
00:54:59,906 --> 00:55:01,936
OpenGL 中的


1427
00:55:02,286 --> 00:55:03,866
许多已建立的概念


1428
00:55:03,866 --> 00:55:05,476
已经迁移到 Metal 中


1429
00:55:05,476 --> 00:55:07,136
并与我们


1430
00:55:07,136 --> 00:55:09,156
为解决图形社区中所提出的特定问题


1431
00:55:09,156 --> 00:55:10,066
而添加的新概念协同工作


1432
00:55:11,086 --> 00:55:12,756
如果你能从这个会议中学到一件事


1433
00:55:12,756 --> 00:55:14,296
我们希望你能知道


1434
00:55:14,296 --> 00:55:15,706
将你的 App


1435
00:55:15,706 --> 00:55:17,516
从 OpenGL 移植到 Metal


1436
00:55:17,516 --> 00:55:19,246
其实并不可怕


1437
00:55:19,246 --> 00:55:21,626
并且你的 App 将从中受益


1438
00:55:23,006 --> 00:55:24,666
但如果你还能够学一件事


1439
00:55:24,666 --> 00:55:26,596
那就是 Metal 还提供了


1440
00:55:26,596 --> 00:55:28,516
一套很棒的工具


1441
00:55:29,626 --> 00:55:31,326
来增强你的开发体验


1442
00:55:32,226 --> 00:55:34,736
Max 已经演示了


1443
00:55:34,736 --> 00:55:35,836
Xcode 的内置框架


1444
00:55:35,836 --> 00:55:38,756
捕获和着色器调试器


1445
00:55:38,756 --> 00:55:40,166
以便你更深入地了解


1446
00:55:40,166 --> 00:55:40,866
代码中的细微问题


1447
00:55:41,366 --> 00:55:43,456
Xcode 也提供了


1448
00:55:43,456 --> 00:55:46,076
新的 GPU 内存查看器


1449
00:55:46,076 --> 00:55:48,566
以理解和优化如何在你的 App 中使用内存


1450
00:55:50,026 --> 00:55:51,406
在 Instruments 中


1451
00:55:51,406 --> 00:55:52,456
我们有一个游戏性能模板


1452
00:55:52,456 --> 00:55:53,826
其中包括 Metal 系统跟踪


1453
00:55:54,256 --> 00:55:56,016
从而可视化地提交问题


1454
00:55:56,466 --> 00:55:57,826
这可能会导致帧率下降


1455
00:55:59,216 --> 00:56:02,246
今年我们还在模拟器中


1456
00:56:02,606 --> 00:56:04,606
添加了对 Metal 的支持


1457
00:56:06,466 --> 00:56:07,476
是的 你一定很兴奋


1458
00:56:08,016 --> 00:56:10,436
[笑声]


1459
00:56:10,936 --> 00:56:13,026
macOS Catalina 上的全新 Xcode 11 中


1460
00:56:13,026 --> 00:56:15,226
我们有完整的硬件加速


1461
00:56:15,226 --> 00:56:17,356
使你能够利用 Metal 运行


1462
00:56:17,356 --> 00:56:20,226
你的 iOS 游戏和 App


1463
00:56:20,646 --> 00:56:21,806
以及 tvOS 模拟器


1464
00:56:23,186 --> 00:56:24,356
模拟器支持


1465
00:56:24,356 --> 00:56:26,766
MTLGPUFamilyApple2 功能集


1466
00:56:26,766 --> 00:56:28,356
应该可以满足


1467
00:56:28,406 --> 00:56:30,096
在所有可用屏幕分辨率下


1468
00:56:30,166 --> 00:56:32,586
运行所有 App 和游戏的大部分需求


1469
00:56:33,086 --> 00:56:36,246
要更深入地了解模拟器


1470
00:56:36,316 --> 00:56:37,746
以及它是如何


1471
00:56:37,746 --> 00:56:39,846
实现硬件加速的


1472
00:56:39,846 --> 00:56:41,966
请在明天早上查看关于模拟器的会议


1473
00:56:42,946 --> 00:56:44,016
如果你想解决一个


1474
00:56:44,016 --> 00:56:45,946
关于 Metal 的特定问题


1475
00:56:45,946 --> 00:56:48,306
你可以在网上看到我们很多很多的会议内容


1476
00:56:50,096 --> 00:56:52,496
获取更多信息


1477
00:56:52,496 --> 00:56:54,326
你可以在我们的网站上查看我们的文档


1478
00:56:54,326 --> 00:56:56,126
或者明天上午到 Metal 实验室


1479
00:56:56,126 --> 00:56:57,386
访问我们


1480
00:56:58,416 --> 00:57:00,136
这就是今天的全部内容


1481
00:57:00,136 --> 00:57:01,956
谢谢大家的到来 我希望能在派对上见到你们


1482
00:57:02,516 --> 00:57:05,500
[掌声]

