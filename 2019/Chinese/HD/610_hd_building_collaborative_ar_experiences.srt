1
00:00:06,139 --> 00:00:10,677 line:0
（用Metal进行现代化渲染）


2
00:00:16,583 --> 00:00:17,584 line:-1
大家好


3
00:00:17,784 --> 00:00:21,088 line:-2
我是Jaap van Muijden
欢迎参加这场关于


4
00:00:21,188 --> 00:00:22,756 line:-1
用Metal进行现代化渲染的演讲


5
00:00:24,591 --> 00:00:25,859 line:-1
在演讲的第一部分


6
00:00:26,460 --> 00:00:28,996 line:-1
我会讲一些更高级的渲染技巧


7
00:00:29,129 --> 00:00:31,231 line:-1
你如今可以在你的app中使用了


8
00:00:32,432 --> 00:00:34,468 line:-2
然后我的同事
Srinivas Dasari


9
00:00:34,968 --> 00:00:38,338 line:-1
会讲如何把你的CPU渲染循环移到


10
00:00:38,972 --> 00:00:40,974 line:-1
更多GPU驱动的管道上


11
00:00:42,176 --> 00:00:47,714 line:-1
最后我们讲如何使用新的GPU家族


12
00:00:48,248 --> 00:00:50,350 line:-1
来写跨平台的代码


13
00:00:52,886 --> 00:00:54,421 line:-1
无论你是从零开始


14
00:00:54,988 --> 00:00:56,990 line:-2
或是想改善现有的
Metal app


15
00:00:58,025 --> 00:01:00,594 line:-2
或你有一个很棒的渲染引擎
你想把它移到


16
00:01:00,661 --> 00:01:01,929 line:-1
Metal平台上


17
00:01:02,729 --> 00:01:06,400 line:-1
我们会告诉你如何通过渲染技巧


18
00:01:07,668 --> 00:01:10,604 line:-2
最大限度地利用可用硬件
来满足你的需要


19
00:01:12,005 --> 00:01:17,211 line:-1
我们从如今的游戏和app使用的


20
00:01:17,277 --> 00:01:19,413 line:-1
一些渲染技巧开始讲


21
00:01:21,181 --> 00:01:23,383 line:-1
从基本延迟渲染开始


22
00:01:24,051 --> 00:01:26,220 line:-1
这是最常用的渲染技巧


23
00:01:26,320 --> 00:01:29,890 line:-2
游戏和图形app在所有平台上
都能使用它


24
00:01:30,490 --> 00:01:32,793 line:-1
我们会讨论经典的双通道设置


25
00:01:33,994 --> 00:01:37,731 line:-2
我们会告诉你如何在Metal上
实施双通道设置


26
00:01:38,165 --> 00:01:39,233 line:-2
以及如何针对iOS平台
对此进行优化


27
00:01:40,234 --> 00:01:44,338 line:-1
然后我们继续讲平铺延迟


28
00:01:44,404 --> 00:01:45,572 line:-1
它扩展了延迟渲染的照明通道


29
00:01:46,139 --> 00:01:48,942 line:-1
如果需要复杂的照明设置的话


30
00:01:49,009 --> 00:01:50,010 line:-1
它是个非常完美的功能


31
00:01:51,512 --> 00:01:53,280 line:-1
然后我们会了解前向渲染


32
00:01:53,780 --> 00:01:56,617 line:-2
这对于Metal app来说
是个很好的替换方案


33
00:01:56,783 --> 00:02:01,455 line:-1
要求复杂的材料、抗锯齿、透明度


34
00:02:01,522 --> 00:02:03,323 line:-1
或特殊的性能考虑


35
00:02:06,426 --> 00:02:09,496 line:-2
我们要讲的最后一个技巧是
可见度缓冲区渲染


36
00:02:10,097 --> 00:02:14,368 line:-2
它推迟集合逻辑
一直推迟到照明通道


37
00:02:14,535 --> 00:02:17,604 line:-2
现在在Metal 3中
它的实施比以前简单多了


38
00:02:18,705 --> 00:02:21,675 line:-2
但在此之前
先让我们从延迟渲染开始讲


39
00:02:23,443 --> 00:02:27,047 line:-1
延迟渲染把场景渲染分为两个通道


40
00:02:28,215 --> 00:02:29,550 line:-1
一个是几何通道


41
00:02:30,050 --> 00:02:31,985 line:-1
你可以把你的整个场景渲染到


42
00:02:32,186 --> 00:02:34,555 line:-2
过渡几何图形中
或叫做GBuffer


43
00:02:35,289 --> 00:02:38,859 line:-2
这个缓冲区中的纹理
你在写入模型或后处理管道中


44
00:02:38,926 --> 00:02:42,896 line:-1
所需要的所有法线、反照率、


45
00:02:42,963 --> 00:02:45,599 line:-1
粗糙度和任意一种表面或材料属性


46
00:02:46,834 --> 00:02:53,073 line:-2
然后在第二通道中
照明通道渲染场景的光照体积


47
00:02:53,473 --> 00:02:56,977 line:-2
并在一个累积纹理中创建
最终光照场景


48
00:02:58,011 --> 00:03:01,815 line:-2
延迟的光照着色器将把GBuffer中的
所有纹理绑定到一起


49
00:03:02,115 --> 00:03:05,352 line:-1
从而计算对最终光照表面颜色的影响


50
00:03:06,553 --> 00:03:09,223 line:-1
让我们先定义这个技巧的数据流


51
00:03:09,489 --> 00:03:11,825 line:-1
然后再讲Metal实施


52
00:03:13,260 --> 00:03:16,396 line:-1
在这里我们有两个渲染通道


53
00:03:16,463 --> 00:03:18,165 line:-2
我们要在GPU上相继地运行
这两个渲染通道


54
00:03:19,366 --> 00:03:22,936 line:-2
在我们的几何通道中
我们需要写出深度


55
00:03:23,470 --> 00:03:26,206 line:-2
深度用于执行在几何通道过程中的
深度调用


56
00:03:26,540 --> 00:03:30,477 line:-1
但它可以用于给照明通道


57
00:03:30,577 --> 00:03:31,578 line:-1
计算像素位置和世界空间


58
00:03:33,180 --> 00:03:35,415 line:-2
并且我们还输出
我们的GBuffer纹理


59
00:03:35,649 --> 00:03:40,220 line:-2
在我们的例子中 我们使用了法线、
反照率和粗糙度纹理


60
00:03:41,421 --> 00:03:43,624 line:-1
然后在我们的第二通道 照明通道中


61
00:03:43,957 --> 00:03:46,026 line:-1
我们读回GBuffer纹理


62
00:03:46,960 --> 00:03:50,631 line:-2
然后我们绘制光照体积并把它们
累积到我们的输出纹理中


63
00:03:52,299 --> 00:03:54,568 line:-2
让我们看一下如何在Metal中
构造这个数据流


64
00:03:56,136 --> 00:03:57,404 line:-1
要在Metal中设置渲染通道


65
00:03:57,471 --> 00:03:59,873 line:-1
你首先要有一个渲染通道描述符


66
00:04:01,175 --> 00:04:03,777 line:-1
渲染通道描述符最重要的部分


67
00:04:03,844 --> 00:04:04,878 line:-1
就是它的输出


68
00:04:05,445 --> 00:04:07,548 line:-2
在Metal中
这些是用附件定义的


69
00:04:08,916 --> 00:04:11,285 line:-2
每个渲染通道都可以拥有
单一深度附件


70
00:04:11,618 --> 00:04:13,020 line:-1
和多颜色附件


71
00:04:14,288 --> 00:04:18,125 line:-2
对于每个附件来说
我们必须要定义它的纹理


72
00:04:18,192 --> 00:04:19,426 line:-1
纹理要指向存储我们附件数据的数据


73
00:04:20,627 --> 00:04:22,563 line:-1
我们需要定义我们的加载动作


74
00:04:22,763 --> 00:04:25,766 line:-2
那会告诉我们如何从纹理中加载
现有数据


75
00:04:26,633 --> 00:04:31,138 line:-1
并且存储动作就是如何把渲染结果


76
00:04:31,205 --> 00:04:32,506 line:-1
存回纹理中


77
00:04:33,407 --> 00:04:36,410 line:-1
当你定义好所有附件的这些属性之后


78
00:04:37,044 --> 00:04:40,581 line:-1
你就可以创建渲染命令编码器


79
00:04:40,781 --> 00:04:44,885 line:-2
然后你就可以最终在你的渲染通道中
绘制Objection了


80
00:04:46,153 --> 00:04:48,755 line:-2
让我们看一下如何在Metal中
创建这个 从设置代码开始看


81
00:04:50,090 --> 00:04:52,526 line:-1
这是我们的设置功能


82
00:04:53,093 --> 00:04:55,128 line:-1
我们要从创建渲染通道描述符开始


83
00:04:55,762 --> 00:04:57,998 line:-1
现在我们刚开始填充所有附件


84
00:04:58,131 --> 00:04:59,499 line:-1
我们先从深度附件开始


85
00:05:00,234 --> 00:05:03,270 line:-2
因为我们使用深度附件来执行
深度调用


86
00:05:03,337 --> 00:05:05,906 line:-2
我们要确保在开始渲染场景之前
清除它


87
00:05:06,306 --> 00:05:08,308 line:-1
因此我们把加载动作设置为清除


88
00:05:08,876 --> 00:05:11,445 line:-1
当然 我们想存储深度用于第二通道


89
00:05:12,012 --> 00:05:14,114 line:-1
因此我们把存储类型设置为存储


90
00:05:15,215 --> 00:05:17,384 line:-1
现在我们转到我们的颜色附件


91
00:05:18,352 --> 00:05:21,989 line:-2
颜色附件 我们需要一个颜色附件
应用于GBuffer中每一个纹理


92
00:05:22,723 --> 00:05:25,058 line:-2
因为所有这些纹理都将以同样的方式
进行处理


93
00:05:25,125 --> 00:05:26,426 line:-1
我们只讲一下反照率


94
00:05:27,928 --> 00:05:32,533 line:-2
因为我们在渲染过程中很可能会使用
比如天空盒或背景


95
00:05:32,599 --> 00:05:36,470 line:-1
因此我们非常确定我们会覆盖


96
00:05:36,537 --> 00:05:38,639 line:-1
我们的每一个帧中的每一个像素


97
00:05:38,972 --> 00:05:41,441 line:-1
那意味着我们并不真正关心


98
00:05:41,842 --> 00:05:43,043 line:-2
我们的GBuffer纹理中
之前的任何值


99
00:05:43,177 --> 00:05:45,913 line:-1
因此我们可以把加载动作设为不关心


100
00:05:47,781 --> 00:05:50,117 line:-2
当然 我们想将存储
GBuffer的结果


101
00:05:50,184 --> 00:05:52,252 line:-1
因此我们把存储动作设为存储


102
00:05:53,453 --> 00:05:56,023 line:-1
现在我们可以创建照明通道描述符了


103
00:05:56,490 --> 00:06:00,694 line:-2
我们创建另一个描述符对象
然后定义附件


104
00:06:00,761 --> 00:06:01,929 line:-1
用于累积缓冲区


105
00:06:02,629 --> 00:06:05,465 line:-2
因为我们累积数据
我们需要在开始之前清除它


106
00:06:05,532 --> 00:06:07,501 line:-1
因此我们把加载动作设置为清除


107
00:06:08,535 --> 00:06:10,838 line:-1
当然 我们想保存我们的最终图片


108
00:06:10,971 --> 00:06:12,606 line:-1
因此我们的存储动作将是存储


109
00:06:14,875 --> 00:06:18,145 line:-2
现在让我们看一下
当我们使用这些渲染通道


110
00:06:18,212 --> 00:06:19,780 line:-1
来实际绘制我们的场景时的渲染循环


111
00:06:20,747 --> 00:06:22,716 line:-1
我们再次从几何通道开始看


112
00:06:23,217 --> 00:06:25,953 line:-2
我们使用我们的描述符
创建渲染命令编码器


113
00:06:26,854 --> 00:06:29,823 line:-1
然后我们开始迭代场景中的所有度量


114
00:06:30,224 --> 00:06:33,093 line:-1
这是渲染场景的一种非常简单的方式


115
00:06:34,461 --> 00:06:38,498 line:-2
我的同事Srinivas
将在本场演讲的第二部分


116
00:06:38,799 --> 00:06:41,502 line:-1
讲如何把基础的CPU渲染循环


117
00:06:42,102 --> 00:06:45,239 line:-1
移到更多GPU驱动的管道中


118
00:06:45,506 --> 00:06:46,773 line:-1
通过各种剔除和LOD选择来实现


119
00:06:47,875 --> 00:06:50,477 line:-2
好的 现在我们已经编写好
整个几何缓冲区


120
00:06:50,878 --> 00:06:55,382 line:-2
抱歉 整个几何通道
我们要接着创建照明通道


121
00:06:55,449 --> 00:06:58,051 line:-1
我们创建另一个渲染命令编码器


122
00:06:58,519 --> 00:07:01,688 line:-2
现在我们开始迭代
照明通道中的所有光照


123
00:07:02,489 --> 00:07:04,525 line:-1
每个光照 每个延迟光照着色器


124
00:07:04,691 --> 00:07:09,062 line:-2
都将绑定这些来自GBuffer
的纹理 从而计算它的最终光照颜色


125
00:07:10,430 --> 00:07:15,769 line:-2
嗯 这两个通道系统在macOS
和iOS的


126
00:07:16,003 --> 00:07:17,171 line:-1
所有平台上用起来都非常顺畅


127
00:07:17,571 --> 00:07:19,740 line:-2
各种类型的硬件都支持
这两个通道系统


128
00:07:20,574 --> 00:07:23,644 line:-1
但我们还可以采取一些措施


129
00:07:23,710 --> 00:07:24,978 line:-1
在iOS上进一步优化我们的实施


130
00:07:25,812 --> 00:07:29,349 line:-1
让我们从代码中退回到我们的概览中


131
00:07:30,684 --> 00:07:34,955 line:-2
你可以看到在两个渲染通道之间的
这个大缓冲区


132
00:07:35,856 --> 00:07:39,459 line:-2
几何通道把它的所有数据
都存储在这些GBuffer纹理中


133
00:07:40,194 --> 00:07:41,929 line:-1
然后照明通道又把它们都带回来了


134
00:07:42,462 --> 00:07:45,465 line:-1
如果我们在单个像素上有多个光照点


135
00:07:45,632 --> 00:07:48,101 line:-1
我们会多次执行这种读回


136
00:07:49,136 --> 00:07:52,072 line:-2
通过在Metal中使用一种叫做
可编程混合的技巧


137
00:07:52,773 --> 00:07:55,108 line:-1
我们可以避免把这个过渡负荷存储到


138
00:07:55,409 --> 00:08:00,614 line:-2
设备内存中
通过利用iOS设备的平铺架构实现


139
00:08:01,181 --> 00:08:03,050 line:-1
我们要如何利用这种技巧呢？


140
00:08:04,318 --> 00:08:05,819 line:-1
嗯 要启动可编程混合


141
00:08:05,886 --> 00:08:08,889 line:-1
我们要合并几何通道和照明通道


142
00:08:09,289 --> 00:08:12,759 line:-2
并按几何和光照规则创建一个
渲染编码器


143
00:08:14,361 --> 00:08:19,533 line:-2
因此 由于iOS架构的本质
在编码器的整个持续时间内


144
00:08:19,600 --> 00:08:22,970 line:-1
附件总是处于平铺内存中


145
00:08:24,104 --> 00:08:26,707 line:-1
这意味着我们不仅可以写入附件中


146
00:08:26,773 --> 00:08:28,075 line:-1
但我们实际上还会把它们读回


147
00:08:29,109 --> 00:08:32,513 line:-2
我们可以读回我们写入的
同一个像素的值


148
00:08:32,813 --> 00:08:34,381 line:-1
并且这就是我们想要实现的操作


149
00:08:34,448 --> 00:08:39,052 line:-2
当我们计算照明通道中的光照时
我们想检索


150
00:08:39,219 --> 00:08:41,655 line:-1
同一个像素的GBuffer附件


151
00:08:42,756 --> 00:08:46,293 line:-2
让我们看看这会如何影响我们的
光照着色器


152
00:08:47,427 --> 00:08:50,264 line:-2
在这里我们有来自照明通道的
光照片段着色器


153
00:08:51,064 --> 00:08:56,870 line:-2
你可能知道 你只需要把所有
你需要的纹理绑定到一起


154
00:08:56,937 --> 00:08:59,239 line:-1
就能得到GBuffer数据


155
00:08:59,940 --> 00:09:03,010 line:-2
然后你在所有GBuffer纹理中
读取所有这些纹理


156
00:09:03,076 --> 00:09:06,513 line:-1
从而获取所有材料和表面信息


157
00:09:07,247 --> 00:09:10,117 line:-2
只有这样你才可以把材料
和表面信息推到照明模型中


158
00:09:10,184 --> 00:09:11,852 line:-1
从而获得最终光照颜色


159
00:09:12,986 --> 00:09:15,589 line:-2
现在让我们看一下如果我们使用
可编程混合会怎么样


160
00:09:16,990 --> 00:09:21,695 line:-2
我们不绑定所有纹理
而是绑定所有颜色附件


161
00:09:22,829 --> 00:09:26,733 line:-2
我们可以直接在照明模型中
使用这些值


162
00:09:28,836 --> 00:09:32,239 line:-2
你可以看到我们已给GBuffer
创建了一个新的线性深度颜色附件


163
00:09:32,306 --> 00:09:35,475 line:-1
这是因为当你使用可编程混合时


164
00:09:35,542 --> 00:09:37,411 line:-1
你不能访问深度附件


165
00:09:39,379 --> 00:09:43,250 line:-1
现在我们不再绑定或取样任何纹理


166
00:09:43,717 --> 00:09:47,054 line:-2
让我们看一下如何使用这个来进一步
优化我们的内存布局


167
00:09:49,122 --> 00:09:53,160 line:-1
当使用可编程混合时


168
00:09:53,427 --> 00:09:54,695 line:-2
我们不再从GBuffer纹理中
写入或读取


169
00:09:55,329 --> 00:09:59,466 line:-2
我们可以把颜色附件的存储动作
设置为不关心


170
00:10:00,801 --> 00:10:02,536 line:-1
好的 这解决了带宽问题


171
00:10:02,970 --> 00:10:04,771 line:-2
但我们仍然有这些
Metal纹理对象


172
00:10:04,838 --> 00:10:06,139 line:-1
占用我们设备上的空间


173
00:10:06,807 --> 00:10:09,510 line:-2
我们需要告诉Metal
我们不再需要


174
00:10:09,576 --> 00:10:12,112 line:-2
为GBuffer纹理
提供任何物理内存了


175
00:10:13,180 --> 00:10:17,184 line:-2
我们通过把纹理的存储模式设为
不耗内存实现


176
00:10:17,718 --> 00:10:21,121 line:-1
我们告诉Metal我们不再对纹理


177
00:10:21,188 --> 00:10:22,422 line:-1
实施任何存储动作了


178
00:10:22,689 --> 00:10:24,358 line:-1
因此我们实际上不需要分配内存


179
00:10:25,726 --> 00:10:30,931 line:-2
通过这些步骤
我们现在得到了一个iOS实施


180
00:10:31,265 --> 00:10:35,335 line:-1
具有GBuffer所有的优点


181
00:10:35,802 --> 00:10:36,937 line:-1
但却没有内存或带宽负担


182
00:10:39,706 --> 00:10:42,576 line:-1
在讲平铺延迟之前 让我们总结一下


183
00:10:43,243 --> 00:10:46,813 line:-1
几何通道和照明通道的分离


184
00:10:47,080 --> 00:10:48,715 line:-2
使得可编程混合成为一个
非常多用途的技巧


185
00:10:49,349 --> 00:10:52,186 line:-2
它可以很好地处理
复杂的几何和照明通道


186
00:10:52,920 --> 00:10:57,824 line:-2
并且GBuffer可用于促进
非常深入的后处理管道


187
00:10:58,158 --> 00:11:03,063 line:-2
整个管道可使用这个可编程混合方法
排成一行


188
00:11:04,932 --> 00:11:08,635 line:-2
在macOS上
你仍然要处理GBuffer、内存


189
00:11:08,702 --> 00:11:09,703 line:-1
和带宽消耗


190
00:11:10,904 --> 00:11:13,607 line:-1
现在让我们讲一下平铺照明方案


191
00:11:14,474 --> 00:11:17,978 line:-1
这适用于想要渲染最大光照体积


192
00:11:18,278 --> 00:11:22,149 line:-1
但仍想减少光照通道消耗的情况


193
00:11:24,985 --> 00:11:28,889 line:-1
平铺延迟渲染技巧尝试解决


194
00:11:29,289 --> 00:11:30,858 line:-1
渲染大体积光照而导致的性能问题


195
00:11:31,692 --> 00:11:34,094 line:-2
在经典延迟中
我们独立渲染每个光照


196
00:11:34,661 --> 00:11:36,663 line:-1
这由于重叠光照


197
00:11:36,830 --> 00:11:38,065 line:-1
而导致了大量GBuffer消耗


198
00:11:39,533 --> 00:11:42,836 line:-2
平铺延迟渲染通过一个额外的计算
预通道延伸了照明


199
00:11:42,903 --> 00:11:45,772 line:-1
那就允许我们进行着色


200
00:11:45,839 --> 00:11:48,775 line:-2
但不是按光照层级着色
而是按平铺层级着色


201
00:11:50,310 --> 00:11:55,449 line:-2
预通道首先把我们的屏幕分成
照明平铺的2D网格


202
00:11:56,016 --> 00:11:58,085 line:-1
并给每个平铺生成一个光照列表


203
00:11:59,253 --> 00:12:01,855 line:-1
然后第二步就是照明


204
00:12:02,389 --> 00:12:05,993 line:-1
然后通过使用单一光照碎片着色器


205
00:12:06,326 --> 00:12:09,563 line:-1
这些光照用于有效地照亮平铺


206
00:12:09,630 --> 00:12:10,631 line:-1
但光照是光照列表中的光照


207
00:12:11,331 --> 00:12:15,502 line:-2
在我们深入实施细节之前
先让我们快速了解一下


208
00:12:15,569 --> 00:12:17,304 line:-1
如何生成这些光照列表


209
00:12:18,639 --> 00:12:22,976 line:-2
嗯 我们首先把视椎分成
这些小的子椎


210
00:12:23,243 --> 00:12:24,478 line:-1
每个平铺一个子椎


211
00:12:25,879 --> 00:12:29,783 line:-2
然后使用计算着色器
进一步调整子椎


212
00:12:29,950 --> 00:12:33,487 line:-2
通过使用平铺的位置
以及平铺的深度边界实现


213
00:12:34,188 --> 00:12:36,623 line:-2
我们可以这样做
因为我们已经运行了


214
00:12:36,823 --> 00:12:38,225 line:-1
几何通道


215
00:12:38,825 --> 00:12:40,661 line:-1
因此深度缓冲区已经填充好了


216
00:12:41,962 --> 00:12:45,232 line:-1
当我们调整这些子椎时 我们可以


217
00:12:45,299 --> 00:12:48,035 line:-1
测试所有视椎的光照体积


218
00:12:48,368 --> 00:12:50,404 line:-1
并向光照列表中添加任意交集


219
00:12:51,772 --> 00:12:56,043 line:-2
这整个过程可以在所有平铺中
并行执行


220
00:12:56,109 --> 00:12:59,146 line:-1
非常适合计算内核


221
00:13:00,447 --> 00:13:04,184 line:-2
我们要如何把这个整合到
我们刚才见到过的延迟管道中呢？


222
00:13:05,452 --> 00:13:07,721 line:-2
嗯 要在我们设置
这个双通道延迟之前


223
00:13:09,456 --> 00:13:12,559 line:-2
现在我们已经把计算通道
添加到它中间了


224
00:13:14,561 --> 00:13:16,864 line:-2
那会为我们创建光照列表
我们需要在一个光照列表缓冲区中


225
00:13:16,930 --> 00:13:21,034 line:-2
存储这些光照列表
并存储在设备内存中


226
00:13:22,336 --> 00:13:27,140 line:-1
再一次 这个方案适用于所有平台


227
00:13:27,207 --> 00:13:33,547 line:-2
我们只需要创建额外的计算
并把光照逻辑


228
00:13:33,614 --> 00:13:35,782 line:-1
从每个着色器一个光照


229
00:13:35,916 --> 00:13:38,819 line:-1
移到照明着色器中的迭代循环中


230
00:13:39,620 --> 00:13:43,423 line:-2
就像之前的渲染器一样
我们现在可以利用


231
00:13:43,490 --> 00:13:46,226 line:-2
iOS上的硬件平铺
来进一步进行优化


232
00:13:46,693 --> 00:13:51,798 line:-2
让我们看一下这在我们的单一编码器
iOS实施中怎么样


233
00:13:53,400 --> 00:13:55,702 line:-1
这是我们刚才讲过的单通道方案


234
00:13:56,103 --> 00:13:57,871 line:-1
我们需要在那儿使用这个计算


235
00:13:58,305 --> 00:14:00,674 line:-1
但我们需要留在单渲染命令编码器中


236
00:14:00,841 --> 00:14:02,075 line:-1
从而使用可编程混合


237
00:14:03,177 --> 00:14:09,016 line:-2
Metal提供一种有效的方式
即使用基于平铺的硬件架构


238
00:14:09,082 --> 00:14:12,753 line:-2
来渲染我们所光栅化的
每个平铺的计算


239
00:14:14,021 --> 00:14:18,625 line:-2
为了iOS上的这个目的
渲染命令编码器可以编码


240
00:14:18,825 --> 00:14:21,595 line:-1
平铺着色器管道 使其运行计算函数


241
00:14:22,663 --> 00:14:25,232 line:-1
这非常适合我们的平铺照明


242
00:14:25,632 --> 00:14:28,135 line:-1
因为我们现在获取了照明平铺概念


243
00:14:28,368 --> 00:14:30,270 line:-1
并把它直接映像到我们的硬件平铺上


244
00:14:32,005 --> 00:14:36,143 line:-2
因此现在我们的光照调用预通道可以
直接在我们的硬件平铺上运行


245
00:14:36,643 --> 00:14:41,248 line:-2
我们可以使用第二个Metal功能
叫做持久线程组内存


246
00:14:41,715 --> 00:14:46,620 line:-2
用于在平铺内存中存储所生成的
光照列表以及附件


247
00:14:48,255 --> 00:14:51,024 line:-2
然后与附件类似
我们可以把它们读回


248
00:14:51,258 --> 00:14:53,427 line:-1
但渲染命令编码器中的所有绘制


249
00:14:53,994 --> 00:14:57,164 line:-1
在我们的例子中是按光照绘制


250
00:15:00,067 --> 00:15:04,805 line:-2
我们现在移动了照明后端
使其与我们的图形一致


251
00:15:05,205 --> 00:15:07,241 line:-1
完全在平铺内存内执行


252
00:15:08,609 --> 00:15:10,077 line:-2
那么这在Metal中
看起来是什么样的？


253
00:15:10,644 --> 00:15:12,346 line:-1
让我们返回到设置代码中


254
00:15:14,181 --> 00:15:17,484 line:-1
创建平铺着色器与设置


255
00:15:17,551 --> 00:15:18,819 line:-1
普通的渲染管道状态非常相似


256
00:15:19,786 --> 00:15:21,088 line:-1
我们创建描述符


257
00:15:21,922 --> 00:15:23,590 line:-1
我们设置所有的颜色附件


258
00:15:24,625 --> 00:15:28,195 line:-1
然后设置我们想要执行的计算函数


259
00:15:28,562 --> 00:15:30,063 line:-1
然后创建管道状态


260
00:15:30,931 --> 00:15:33,400 line:-1
因为我们使用了持久线程组内存


261
00:15:33,600 --> 00:15:35,869 line:-1
我们需要在平铺中保留一点儿内存


262
00:15:36,537 --> 00:15:39,139 line:-1
因此我们返回到渲染通道描述符


263
00:15:39,940 --> 00:15:43,644 line:-2
然后保留足够的数据
来存储我们的光照列表


264
00:15:46,013 --> 00:15:49,816 line:-2
现在让我们转到渲染循环
看一下分派尺寸


265
00:15:50,918 --> 00:15:54,221 line:-2
我们的渲染循环这一次是从
单一渲染命令编码器开始


266
00:15:55,055 --> 00:15:59,526 line:-2
然后我们再一次循环场景中的
所有网格


267
00:16:01,195 --> 00:16:03,597 line:-1
然后我们不直接进入照明通道


268
00:16:03,664 --> 00:16:04,831 line:-1
而是首先执行平铺着色器


269
00:16:05,799 --> 00:16:11,205 line:-2
我们设置了管道状态
我们设置了一个缓冲区


270
00:16:11,271 --> 00:16:16,376 line:-2
存储我们场景中的所有光照
然后我们把线程组内存缓冲区


271
00:16:16,443 --> 00:16:17,444 line:-1
绑定到我们的平铺内存中


272
00:16:18,245 --> 00:16:20,647 line:-1
然后我们分派我们的平铺着色器


273
00:16:21,882 --> 00:16:27,387 line:-2
现在我们已经执行了平铺着色器
线程组内存会保存光照列表


274
00:16:27,688 --> 00:16:31,258 line:-1
然后我们就可以在照明绘制中使用了


275
00:16:31,792 --> 00:16:36,563 line:-1
我们可以让每个像素都能访问它


276
00:16:36,763 --> 00:16:38,332 line:-2
它使用了持久线程组内存的
平铺光照列表


277
00:16:38,966 --> 00:16:41,502 line:-2
现在可以非常有效率地给它的像素
进行着色了


278
00:16:42,836 --> 00:16:45,973 line:-2
最后 设置好这一切之后
让我们看看


279
00:16:46,173 --> 00:16:47,174 line:-1
这在着色器中看起来怎么样


280
00:16:48,442 --> 00:16:51,411 line:-2
在这里我们有两个着色器
顶部那个是平铺着色器


281
00:16:52,212 --> 00:16:54,381 line:-1
它把输出光照列表绑定到


282
00:16:54,715 --> 00:16:56,416 line:-1
一个持久线程组内存缓冲区中


283
00:16:58,952 --> 00:17:02,022 line:-1
然后它会以某种方式循环所有光照


284
00:17:02,089 --> 00:17:05,959 line:-1
并把光罩输出到持久线程组内存中


285
00:17:07,227 --> 00:17:09,530 line:-1
然后由第二着色器读回


286
00:17:09,596 --> 00:17:11,431 line:-1
第二着色器是我们真实的照明着色器


287
00:17:12,665 --> 00:17:16,637 line:-1
它会写入它平铺内的所有可见光照


288
00:17:17,137 --> 00:17:18,571 line:-1
并给像素着色


289
00:17:20,040 --> 00:17:23,143 line:-1
现在我们已经了解对平铺延迟技巧


290
00:17:23,242 --> 00:17:28,015 line:-1
实施平铺照明技巧的所有要点


291
00:17:28,482 --> 00:17:31,952 line:-2
让我们看一下如何使用这个原理
来扩展我们的渲染器


292
00:17:32,452 --> 00:17:35,822 line:-1
使其有效地创建一个额外的前向通道


293
00:17:37,291 --> 00:17:41,128 line:-2
因为我们已经在持久线程组内存中
设置了光照列表


294
00:17:41,428 --> 00:17:45,832 line:-2
我们可以使用同样的数据来促进一个
有效的平铺前向通道


295
00:17:47,901 --> 00:17:50,571 line:-2
无论何时当我们在前向通道中
对前向几何图形进行着色时


296
00:17:50,804 --> 00:17:54,775 line:-2
我们都可以使用同一个
持久线程组内存读取平铺光照列表


297
00:17:54,842 --> 00:17:59,513 line:-2
并使用在延迟照明中所使用的同一个
光照循环


298
00:17:59,580 --> 00:18:04,284 line:-1
来非常有效率地对前向像素进行着色


299
00:18:05,485 --> 00:18:08,789 line:-1
这个前向通道真的增强了渲染功能


300
00:18:09,056 --> 00:18:13,026 line:-2
并接受透明度、
特效和其它复杂的着色


301
00:18:13,093 --> 00:18:15,028 line:-2
如果只有延迟通道
那通常是不可能实现的


302
00:18:16,897 --> 00:18:19,666 line:-1
然而延迟管道总有一些限制


303
00:18:20,033 --> 00:18:21,068 line:-1
抗锯齿


304
00:18:22,302 --> 00:18:24,805 line:-1
复杂的材料表达仍然是个问题


305
00:18:25,038 --> 00:18:27,708 line:-1
因为有过渡的GBuffer表示


306
00:18:28,509 --> 00:18:31,245 line:-1
使用这个平铺技巧我们看到


307
00:18:31,311 --> 00:18:35,249 line:-1
我们可以非常有效地加强前向渲染


308
00:18:35,415 --> 00:18:36,683 line:-1
使用平铺照明技巧


309
00:18:37,851 --> 00:18:41,622 line:-1
让我们往回退一步 只看前向通道


310
00:18:41,922 --> 00:18:45,626 line:-2
因为除平铺照明之外
它凭借自身力量


311
00:18:45,692 --> 00:18:46,693 line:-1
成为了一个可行性方案


312
00:18:48,695 --> 00:18:53,467 line:-2
要创建只进行前向渲染的渲染器
我们只需要移除延迟几何图形


313
00:18:53,567 --> 00:18:54,568 line:-1
和照明通道即可


314
00:18:55,669 --> 00:19:00,807 line:-2
然而我们的照明剔除技巧
需要那个深度来调整它的子椎


315
00:19:02,409 --> 00:19:06,513 line:-2
因此我们需要用深度预通道
替换几何图形通道


316
00:19:06,713 --> 00:19:07,781 line:-1
来填充这个深度缓冲区


317
00:19:08,882 --> 00:19:11,852 line:-2
如果你的引擎已经拥有这样一个
深度预通道


318
00:19:11,919 --> 00:19:13,554 line:-2
那这对于你来说
是一个非常完美的方案


319
00:19:14,888 --> 00:19:18,458 line:-1
如果你有过度绘制、优化、遮挡剔除


320
00:19:18,525 --> 00:19:21,094 line:-2
或自我混合
那这个方案可以满足你的需要


321
00:19:22,296 --> 00:19:26,466 line:-2
然而在iOS硬件上
这种通道通常是不必要的


322
00:19:27,134 --> 00:19:29,970 line:-2
对于那些情况而言
还有另一种照明方案


323
00:19:30,037 --> 00:19:32,539 line:-1
叫做集群照明 可能更适合你


324
00:19:33,807 --> 00:19:36,577 line:-1
这个集群方案以不同的方式


325
00:19:37,010 --> 00:19:40,414 line:-1
创建光照列表 而不需要任何深度


326
00:19:41,448 --> 00:19:45,252 line:-2
因为对于集群光照来说
我们不会给平铺创建任何深度边界


327
00:19:45,319 --> 00:19:50,057 line:-1
但我们只是再细分深度轴上的椎


328
00:19:51,091 --> 00:19:54,661 line:-2
然后我们发出一个3D光照列表贴图
而不是2D光照贴图


329
00:19:56,430 --> 00:19:59,766 line:-1
这可能不如平铺照明中的子椎


330
00:19:59,833 --> 00:20:00,968 line:-1
那么有效率


331
00:20:01,602 --> 00:20:04,638 line:-1
但它将大大提高照明性能


332
00:20:05,205 --> 00:20:08,242 line:-2
因为仅通过本地光照列表
对每一个像素进行着色


333
00:20:10,110 --> 00:20:13,380 line:-1
使用集群剔除 与平铺着色


334
00:20:13,514 --> 00:20:14,915 line:-1
和持久线程组内存一起


335
00:20:15,282 --> 00:20:17,584 line:-2
这将为我们提供一个非常优化的
前向渲染器


336
00:20:19,887 --> 00:20:22,656 line:-2
我们现在已经了解了一些
最流行的管道


337
00:20:22,789 --> 00:20:24,291 line:-2
以及如何在Metal上
对它们进行渲染


338
00:20:25,359 --> 00:20:28,061 line:-2
现在我们要了解一下
可见度缓冲区渲染技巧


339
00:20:28,195 --> 00:20:31,098 line:-2
它以一种不同方式
处理GBuffer消耗


340
00:20:31,164 --> 00:20:35,002 line:-1
从而更适合不支持硬件平铺的老硬件


341
00:20:37,004 --> 00:20:39,373 line:-1
让我们一直退回到延迟渲染器中


342
00:20:40,140 --> 00:20:45,045 line:-2
我们目前所了解的大部分优化
只能在iOS架构上使用


343
00:20:46,547 --> 00:20:49,283 line:-1
可见度缓冲区技巧尝试以另一种方式


344
00:20:49,449 --> 00:20:53,921 line:-1
把过渡缓冲区瓶颈最小化


345
00:20:53,987 --> 00:20:57,224 line:-2
也就是在那个缓冲区中存储
绝对最小量的数据


346
00:20:58,358 --> 00:21:02,262 line:-2
我们不按像素存储所有表面
和材料属性


347
00:21:02,596 --> 00:21:06,900 line:-1
我们只存储原始标识符和重心坐标


348
00:21:09,469 --> 00:21:13,974 line:-2
这个数据不直接用于给整个场景着色
但它可用于


349
00:21:14,208 --> 00:21:17,411 line:-1
重构和插入原始几何图形


350
00:21:17,678 --> 00:21:20,814 line:-1
然后在本地在照明着色器内


351
00:21:21,114 --> 00:21:22,349 line:-1
运行整个材料逻辑


352
00:21:23,383 --> 00:21:26,987 line:-1
因为这个重构步骤消耗太大


353
00:21:27,354 --> 00:21:28,789 line:-2
但它在平铺照明技巧中用起来
效果很好


354
00:21:28,989 --> 00:21:32,426 line:-2
因为它保证只对每个像素
进行一次重构


355
00:21:34,394 --> 00:21:37,531 line:-2
当我们实施这个技巧时
通常最大的问题就是


356
00:21:37,598 --> 00:21:42,002 line:-2
如何创建原始索引以及如何创建
重心坐标


357
00:21:43,470 --> 00:21:45,772 line:-1
而不需要大量额外的处理


358
00:21:46,874 --> 00:21:48,675 line:-2
我们现在很高兴地告诉你们
在Metal 3中


359
00:21:48,876 --> 00:21:51,845 line:-2
你现在可以在片段着色器内
使用这两个新属性


360
00:21:52,145 --> 00:21:54,681 line:-1
检索当前原始索引


361
00:21:54,915 --> 00:21:57,384 line:-1
和当前像素的重心坐标的索引了


362
00:21:59,086 --> 00:22:01,622 line:-1
生成几何图形着色器现在非常简单


363
00:22:01,955 --> 00:22:04,057 line:-2
Metal 3使几何通道
比以前更快了


364
00:22:04,791 --> 00:22:07,995 line:-1
实施也比以前更简单了


365
00:22:10,264 --> 00:22:13,133 line:-2
我们现在学习了
你可以在Metal中


366
00:22:13,200 --> 00:22:14,868 line:-1
用于场景渲染的所有这些不同方案


367
00:22:15,536 --> 00:22:17,838 line:-1
现在让我们看一个小演示


368
00:22:17,905 --> 00:22:18,906 line:-1
演示一下其中一些渲染技巧


369
00:22:20,874 --> 00:22:24,211 line:-2
在这里我们有测试场景
有一些非常复杂的几何图形


370
00:22:24,444 --> 00:22:27,814 line:-2
和设置PBR材料
以及一组不同的材料着色器


371
00:22:28,649 --> 00:22:32,619 line:-2
我们可以在任意设备上使用延迟
或平铺延迟或甚至是前向渲染器


372
00:22:32,686 --> 00:22:33,854 line:-1
来渲染这个场景


373
00:22:34,555 --> 00:22:37,758 line:-1
让我们从普通的延迟渲染器开始


374
00:22:39,059 --> 00:22:42,296 line:-2
延迟渲染器有两个通道
我们之前看到过


375
00:22:42,563 --> 00:22:44,765 line:-1
第一个通道现在


376
00:22:44,831 --> 00:22:45,966 line:-2
通过这些过渡
GBuffers渲染一切


377
00:22:46,400 --> 00:22:48,602 line:-2
现在让我们看其中一些
GBuffer纹理


378
00:22:50,871 --> 00:22:52,339 line:-1
在这里我们有反照率


379
00:22:54,541 --> 00:22:55,542 line:-1
我们有法线


380
00:22:58,545 --> 00:23:00,247 line:-1
我们有GBuffer的粗糙度纹理


381
00:23:00,814 --> 00:23:04,284 line:-2
如果你有暂时的抗锯齿
或更复杂的照明模型


382
00:23:04,585 --> 00:23:06,987 line:-2
你很可能需要在GBuffer中
存储更多东西


383
00:23:07,988 --> 00:23:11,625 line:-2
我们现在看到的场景
是由第二照明通道进行照明的


384
00:23:12,226 --> 00:23:15,395 line:-2
因此让我们进入夜间场景
来更好地呈现我们的光照


385
00:23:17,331 --> 00:23:19,800 line:-2
现在在这个场景中
要获得这样的照明效果


386
00:23:19,867 --> 00:23:23,237 line:-2
我们需要渲染许多光照
我们可以在这里看到


387
00:23:24,137 --> 00:23:27,307 line:-2
在普通延迟中
我们应该每次渲染一个光照


388
00:23:27,608 --> 00:23:30,043 line:-1
那样效率很低 并且你可以看到


389
00:23:30,310 --> 00:23:31,378 line:-1
在不同的光照之间有许多重叠


390
00:23:32,212 --> 00:23:34,681 line:-1
因此让我们改用平铺延迟照明


391
00:23:36,884 --> 00:23:42,122 line:-2
在这里我们有同一个场景 渲染
使用平铺延迟渲染器


392
00:23:45,893 --> 00:23:50,163 line:-2
我们想在这里展示的是我们所拥有的
所有可能的可视化效果


393
00:23:50,531 --> 00:23:54,668 line:-1
关于不同的平铺如何给你呈现


394
00:23:54,735 --> 00:23:56,770 line:-2
在每一个不同的平铺中所渲染的
不同的光照体积


395
00:23:56,837 --> 00:24:00,908 line:-1
你可以看到使用这些平铺细分


396
00:24:00,974 --> 00:24:02,442 line:-1
相对于同时照亮所有像素来说


397
00:24:03,143 --> 00:24:06,547 line:-1
效果真的不一样


398
00:24:07,981 --> 00:24:10,083 line:-1
现在我们已经演示了一些


399
00:24:10,150 --> 00:24:12,719 line:-2
你可以用于渲染场景的可能的
渲染技巧


400
00:24:13,187 --> 00:24:16,156 line:-2
接下来我的同事
Srinivas会讲


401
00:24:16,490 --> 00:24:18,725 line:-1
如何把CPU繁重的渲染循环


402
00:24:18,825 --> 00:24:19,927 line:-1
放到GPU驱动的管道中去


403
00:24:24,565 --> 00:24:25,566 line:-1
谢谢Jaap


404
00:24:26,099 --> 00:24:27,501 line:-1
GPU驱动的管道


405
00:24:28,268 --> 00:24:31,405 line:-2
在Metal 2中我们引入了
GPU驱动的管道


406
00:24:31,471 --> 00:24:34,708 line:-2
由增强缓冲区
和非直接命令缓冲区组成


407
00:24:35,309 --> 00:24:38,378 line:-2
通过这些你现在可以
把基于CPU的渲染操作


408
00:24:38,445 --> 00:24:39,279 line:-1
移到GPU上来


409
00:24:39,746 --> 00:24:41,648 line:-2
我同事Jaap刚讲了
如何用Metal实施


410
00:24:41,715 --> 00:24:43,984 line:-1
各种高级渲染技巧


411
00:24:44,718 --> 00:24:48,755 line:-2
我要讲的是如何
把整个基于CPU的渲染循环


412
00:24:48,956 --> 00:24:49,957 line:-1
移到GPU上来


413
00:24:50,424 --> 00:24:52,893 line:-1
这不仅会让渲染循环变得更有效率


414
00:24:53,160 --> 00:24:56,263 line:-2
它还允许你释放CPU用于执行
你可能想要执行的其它处理


415
00:24:56,330 --> 00:25:00,234 line:-1
比如复杂的物理模拟REI


416
00:25:00,834 --> 00:25:04,271 line:-2
在深入讲细节之前
先让我们看一下渲染循环中


417
00:25:04,338 --> 00:25:06,240 line:-1
通常会执行哪些操作


418
00:25:07,975 --> 00:25:10,511 line:-1
大场景要求复杂的渲染操作


419
00:25:10,644 --> 00:25:15,315 line:-2
通常你会执行一系列操作
来有效地渲染场景


420
00:25:15,782 --> 00:25:18,619 line:-1
你要做的第一件事就是椎剔除


421
00:25:19,520 --> 00:25:22,856 line:-1
移除落在视椎外的对象


422
00:25:23,223 --> 00:25:25,192 line:-1
我们只讲绘制调用


423
00:25:25,692 --> 00:25:27,294 line:-1
接下来是遮挡剔除


424
00:25:27,761 --> 00:25:31,732 line:-2
在这里你排除由其它较大对象
所遮挡的对象


425
00:25:32,499 --> 00:25:36,537 line:-1
通常要做的另一件事是细节层次选择


426
00:25:36,737 --> 00:25:40,741 line:-1
根据模型到摄像机的距离


427
00:25:41,008 --> 00:25:42,543 line:-1
从一系列的模型细节层次中进行选择


428
00:25:43,310 --> 00:25:46,580 line:-2
那么带有所有这些操作的
基于CPU的渲染循环


429
00:25:46,647 --> 00:25:48,315 line:-1
一般看起来就像这样


430
00:25:49,516 --> 00:25:53,954 line:-2
从根本上说 你首先会
把被遮挡的绘制和遮挡测试


431
00:25:54,388 --> 00:25:59,359 line:-2
编码到命令缓冲区中
然后在GPU上的渲染通道中执行它


432
00:25:59,426 --> 00:26:00,861 line:-1
从而为下一帧生成遮挡数据


433
00:26:01,728 --> 00:26:05,332 line:-1
接下来你执行椎剔除


434
00:26:05,399 --> 00:26:06,400 line:-1
从而排除视椎外的对象


435
00:26:06,900 --> 00:26:10,838 line:-2
并做LOD选择
从而为模型选择一个细节层次


436
00:26:11,305 --> 00:26:15,442 line:-1
然后是遮挡剔除 从而排除


437
00:26:15,509 --> 00:26:17,110 line:-1
被较大对象遮挡的对象


438
00:26:17,878 --> 00:26:22,316 line:-1
那么最后你要编码可见对象的绘制


439
00:26:22,382 --> 00:26:25,252 line:-2
并在渲染通道中执行它
从而生成场景


440
00:26:25,786 --> 00:26:29,556 line:-2
现在这个流程用起来不错
但这里有一些功能效率很低


441
00:26:29,923 --> 00:26:31,758 line:-1
首先让我们看一下遮挡剔除


442
00:26:32,526 --> 00:26:36,196 line:-2
要执行遮挡剔除
你需要当前帧的遮挡数据


443
00:26:36,830 --> 00:26:40,467 line:-2
但因为你不想减少
当前帧中的任何同步性


444
00:26:40,667 --> 00:26:43,437 line:-2
你通常依赖于
上一帧的遮挡数据来实现


445
00:26:43,637 --> 00:26:46,373 line:-1
你通常得到的数据分辨率较低


446
00:26:47,140 --> 00:26:49,943 line:-2
因此它是近似数据
它可能会导致虚假遮挡


447
00:26:50,344 --> 00:26:53,413 line:-2
因此你很可能需要在游戏中
采取一些纠正措施


448
00:26:54,114 --> 00:26:57,951 line:-1
第二 这里有些操作很有麻痹性


449
00:26:58,051 --> 00:27:00,153 line:-1
比如椎剔除


450
00:27:01,154 --> 00:27:06,159 line:-1
在单CPU线程上 它是这样的


451
00:27:06,226 --> 00:27:08,095 line:-2
你要对每个对象执行椎剔除
一个接一个


452
00:27:08,695 --> 00:27:12,699 line:-2
现在你可以明确地把这个进程
分配到多个CPU线程上


453
00:27:13,367 --> 00:27:15,936 line:-1
但只有几个CPU线程可用


454
00:27:16,436 --> 00:27:20,240 line:-2
并且如果你包含你想要对每个对象
执行的全部操作


455
00:27:20,674 --> 00:27:22,376 line:-1
你很可能正在做这样的事


456
00:27:23,310 --> 00:27:25,379 line:-1
但这些操作是否很有麻痹性？


457
00:27:25,612 --> 00:27:28,515 line:-2
如果你有更多的线程
你当然可以并行处理


458
00:27:28,582 --> 00:27:32,352 line:-1
所有场景 处理场景中的所有对象


459
00:27:32,886 --> 00:27:36,323 line:-2
但一般来说场景中有成千上万个对象
因此要麻痹全部对象


460
00:27:36,390 --> 00:27:38,825 line:-1
你就需要成千上万个线程


461
00:27:39,359 --> 00:27:42,429 line:-2
因此执行这些操作的
最完美的选择是GPU


462
00:27:43,597 --> 00:27:47,634 line:-2
GPU是一个大规模的并行处理器
有成千上万个线程可用


463
00:27:47,701 --> 00:27:49,203 line:-1
用于安排操作的执行


464
00:27:49,770 --> 00:27:53,707 line:-2
可以把一个对象分配给一个
专用线程并执行


465
00:27:53,774 --> 00:27:56,176 line:-2
我们想要在那个对象上执行的
所有操作


466
00:27:56,710 --> 00:27:59,980 line:-2
通过成千上万个线程
你可以并行处理成千上万个对象


467
00:28:00,614 --> 00:28:04,184 line:-2
因此如果你把它从CPU移到GPU
渲染循环效率会很高


468
00:28:04,351 --> 00:28:09,923 line:-2
并且正如我之前提到过的那样
它还会释放你的CPU


469
00:28:10,023 --> 00:28:11,792 line:-1
用于执行其它想要执行的处理


470
00:28:12,559 --> 00:28:15,329 line:-2
如何把全部这些操作
移到GPU上呢？


471
00:28:16,196 --> 00:28:19,099 line:-2
你可以通过在GPU上
合并计算和渲染通道实现


472
00:28:19,166 --> 00:28:23,570 line:-2
从而我们可以在GPU上驱动
整个渲染循环


473
00:28:23,637 --> 00:28:25,305 line:-1
而不需要CPU参与


474
00:28:25,939 --> 00:28:27,541 line:-2
这个想法 我的意思是
这就是我们所需要的


475
00:28:27,841 --> 00:28:31,545 line:-2
这里的整个渲染循环都在GPU上
它完全由GPU驱动


476
00:28:32,412 --> 00:28:36,517 line:-2
现在让我们看一下这些通道
看这个GPU驱动的渲染循环


477
00:28:36,583 --> 00:28:37,584 line:-1
实际是如何运作的


478
00:28:38,685 --> 00:28:41,288 line:-2
现在我们需要的是
用于遮挡剔除的遮挡数据


479
00:28:41,555 --> 00:28:44,992 line:-2
那么首先我们有一个计算通道
获取场景数据


480
00:28:45,058 --> 00:28:48,962 line:-1
执行包围盒的椎剔除


481
00:28:49,029 --> 00:28:50,030 line:-1
并编码渲染包围盒的命令


482
00:28:50,464 --> 00:28:54,301 line:-2
现在这些编码的遮挡绘制命令
在一个渲染通道中执行


483
00:28:54,434 --> 00:28:56,703 line:-1
因此我们生成所有必要的遮挡数据


484
00:28:57,237 --> 00:28:59,373 line:-1
这个遮挡数据可以是多种不同的形式


485
00:28:59,439 --> 00:29:01,208 line:-1
取决于它的生成方式


486
00:29:01,675 --> 00:29:03,710 line:-1
那么你可能想进一步处理那个数据


487
00:29:04,411 --> 00:29:06,513 line:-1
为此我们有另一个计算通道


488
00:29:07,114 --> 00:29:10,551 line:-2
在这个通道中
包围盒数据可以转化为一种


489
00:29:10,617 --> 00:29:12,953 line:-1
更适用于遮挡剔除的形式


490
00:29:13,921 --> 00:29:17,090 line:-2
我们还需要一个计算通道
来执行我们所讲过的操作


491
00:29:17,591 --> 00:29:20,027 line:-1
也就是剔除、细节层次选择、


492
00:29:20,294 --> 00:29:22,262 line:-1
和编码场景绘制命令


493
00:29:22,996 --> 00:29:25,766 line:-2
这里有一件事要了解
即这里的遮挡剔除


494
00:29:25,832 --> 00:29:28,902 line:-1
已经不再依赖以前帧的数据了


495
00:29:29,570 --> 00:29:32,573 line:-1
在我们刚讲过的前两个通道中


496
00:29:32,639 --> 00:29:34,641 line:-1
为当前帧生成所要求的包围盒数据


497
00:29:35,142 --> 00:29:37,711 line:-1
同时因为我们生成当前帧的数据


498
00:29:38,078 --> 00:29:39,479 line:-1
数据也更精确了


499
00:29:40,948 --> 00:29:45,719 line:-2
最后我们有另一个渲染通道执行
场景绘制命令


500
00:29:45,786 --> 00:29:46,787 line:-1
用于渲染场景


501
00:29:47,688 --> 00:29:52,759 line:-2
在这个GPU驱动的渲染循环中
一切都发生在GPU上


502
00:29:53,193 --> 00:29:57,598 line:-2
无论何处都没CPU-GPU
同步操作 也不会依赖上一帧的数据


503
00:29:58,365 --> 00:30:00,667 line:-2
我们该如何创建这个GPU驱动的
管道呢？


504
00:30:01,535 --> 00:30:04,605 line:-2
现在很明确
要在GPU上创建这个渲染循环


505
00:30:04,671 --> 00:30:06,440 line:-1
我们至少需要两个东西


506
00:30:07,307 --> 00:30:08,742 line:-1
第一个是绘制命令


507
00:30:09,877 --> 00:30:14,214 line:-2
我们需要一种在GPU上编码
绘制命令的方式 从而计算通道


508
00:30:14,281 --> 00:30:16,016 line:-1
可以为渲染通道编码命令


509
00:30:16,650 --> 00:30:19,119 line:-2
Metal所提供的支持这个功能的
building block


510
00:30:19,186 --> 00:30:20,621 line:-1
是非直接命令缓冲区


511
00:30:21,321 --> 00:30:23,090 line:-1
我们还需要场景数据


512
00:30:23,857 --> 00:30:27,227 line:-2
我们应该能通过帧在GPU上访问
所编码的场景数据


513
00:30:27,294 --> 00:30:29,096 line:-1
在任何需要的情况下


514
00:30:29,730 --> 00:30:32,432 line:-2
通过这个场景数据
我们应该可以几乎描述


515
00:30:32,499 --> 00:30:37,137 line:-2
整个场景了 比如几何图形、
共享参数、材料等等


516
00:30:37,638 --> 00:30:41,141 line:-2
在Metal提供的支持这个功能的
building block中


517
00:30:41,208 --> 00:30:42,543 line:-1
是参数缓冲区


518
00:30:43,410 --> 00:30:46,613 line:-2
现在让我们深入看一下这两个
building block


519
00:30:47,648 --> 00:30:52,052 line:-2
现在参数缓冲区可以让你描述
整个场景数据


520
00:30:52,119 --> 00:30:53,620 line:-1
有复杂的数据结构


521
00:30:53,987 --> 00:30:57,591 line:-2
它们允许你在渲染循环的任何位置
访问场景数据


522
00:30:58,325 --> 00:31:01,995 line:-2
而非直接命令缓冲区
允许你在GPU上创建绘制调用


523
00:31:02,162 --> 00:31:05,098 line:-1
从根本上来说 它在GPU上支持


524
00:31:05,399 --> 00:31:06,400 line:-1
大量命令并行生成


525
00:31:06,834 --> 00:31:09,670 line:-1
现在让我们进一步看一下参数缓冲区


526
00:31:09,736 --> 00:31:12,105 line:-1
通过一个示例场景对象模型来看


527
00:31:14,041 --> 00:31:17,077 line:-2
我们所需要的第一个东西是
对场景数据的访问


528
00:31:17,778 --> 00:31:19,680 line:-1
那么场景数据通常都包含什么？


529
00:31:20,080 --> 00:31:21,081 line:-1
首先是网格


530
00:31:21,615 --> 00:31:22,816 line:-1
这就是网格


531
00:31:23,183 --> 00:31:26,920 line:-2
它是网格对象的一个区域
每个网格对象都描述了它的几何图形


532
00:31:27,421 --> 00:31:30,858 line:-1
还有材料 它是材料对象的一个区域


533
00:31:31,091 --> 00:31:35,195 line:-2
每个材料对象都有一组材料属性、
它所需要的任何纹理


534
00:31:35,262 --> 00:31:38,265 line:-1
以及描述阴影管道的管道操纵对象


535
00:31:38,699 --> 00:31:41,201 line:-1
场景还包含模型区域


536
00:31:41,935 --> 00:31:47,474 line:-2
在此每个模型都可以拥有一个LOD
因此在这个例子中


537
00:31:47,541 --> 00:31:52,713 line:-2
每个LOD一个模型
每个模型都包含网格区和材料区


538
00:31:53,480 --> 00:31:58,151 line:-2
最后我们有场景对象
关联网格、材料和模型


539
00:31:58,418 --> 00:31:59,586 line:-1
那些都是我们场景的一部分


540
00:32:00,420 --> 00:32:04,992 line:-2
让我们看一下这个对象模型
如何通过参数缓冲区进行表达


541
00:32:07,060 --> 00:32:11,665 line:-2
它是一个非常简单的一对一映像
从我们的对象模型映像到参数缓冲区


542
00:32:11,798 --> 00:32:15,769 line:-1
比如这里的场景参数缓冲区包含


543
00:32:15,836 --> 00:32:18,405 line:-1
我们在对象模型中描述的对象


544
00:32:19,072 --> 00:32:22,309 line:-1
就是网格区、材料区和模型区


545
00:32:22,843 --> 00:32:26,813 line:-2
从根本上来说 整个场景
现在可以通过参数缓冲区来描述


546
00:32:27,714 --> 00:32:29,716 line:-1
现在让我们看一下


547
00:32:29,783 --> 00:32:31,285 line:-1
如何在着色器中构造并访问它


548
00:32:34,121 --> 00:32:38,125 line:-1
现在我们所讨论的每个参数缓冲区


549
00:32:38,325 --> 00:32:39,326 line:-1
都用结构表示


550
00:32:39,660 --> 00:32:41,962 line:-1
那包含我们在对象模型中


551
00:32:42,029 --> 00:32:43,030 line:-1
所描述的元素


552
00:32:43,564 --> 00:32:47,935 line:-2
因为每个参数缓冲区都是一个
绝对灵活的结构


553
00:32:48,302 --> 00:32:52,606 line:-2
你可以添加比如数组、指针、
甚至是指向其它参数缓冲区的指针


554
00:32:53,006 --> 00:32:56,443 line:-1
比如这是一个Metal参数缓冲区


555
00:32:56,977 --> 00:33:00,814 line:-2
它包含Metal常量、
它所需要的任何纹理 当然了


556
00:33:00,881 --> 00:33:03,951 line:-1
还有描述阴影管道的管道专用对象


557
00:33:04,484 --> 00:33:08,021 line:-2
材料所需要的一切都在一个
参数缓冲区中


558
00:33:08,989 --> 00:33:11,859 line:-2
场景参数缓冲区
正是我们在对象模型中


559
00:33:11,925 --> 00:33:13,427 line:-1
所描述的样子


560
00:33:13,961 --> 00:33:18,098 line:-2
因此用参数缓冲区构造对象模型
非常简单


561
00:33:18,866 --> 00:33:22,769 line:-2
现在让我们看一下如何访问
共享中的这些参数缓冲区


562
00:33:24,805 --> 00:33:28,208 line:-2
我们刚讲过有一个计算内核
可以进行椎剔除


563
00:33:28,642 --> 00:33:31,245 line:-1
它编码绘制命令


564
00:33:31,311 --> 00:33:32,412 line:-2
把可见对象
绘制到非直接命令缓冲区中


565
00:33:33,280 --> 00:33:37,551 line:-2
每个线程都执行这个内核的一个实例
处理一个对象


566
00:33:37,818 --> 00:33:41,955 line:-2
并编码一个单一绘制调用
如果它决定那个对象可见的话


567
00:33:42,523 --> 00:33:44,224 line:-1
让我们看看它是如何实现的


568
00:33:45,425 --> 00:33:49,830 line:-2
首先我们给着色器传入
我们的高层级场景参数缓冲区


569
00:33:50,531 --> 00:33:55,669 line:-2
现在一旦我们可以访问着色器
可以访问场景


570
00:33:55,736 --> 00:33:56,837 line:-2
访问我们所需要的其它东西
就非常简单了


571
00:33:57,371 --> 00:34:01,275 line:-1
这里的命令R包含对我们想要编码的


572
00:34:01,341 --> 00:34:02,843 line:-1
非直接命令缓冲区的引用


573
00:34:04,178 --> 00:34:08,181 line:-2
我们首先根据线程ID
从场景中创建了这个模型


574
00:34:08,681 --> 00:34:12,652 line:-2
请注意这个计算内核的所有线程
是并行执行的


575
00:34:12,819 --> 00:34:14,655 line:-1
每个线程操作一个特定的对象


576
00:34:15,621 --> 00:34:19,726 line:-2
然后我们执行椎剔除
查看对象是否落在视椎外


577
00:34:20,460 --> 00:34:24,965 line:-2
一旦我们决定对象可见
我们就根据它到摄像机的距离


578
00:34:25,032 --> 00:34:26,533 line:-1
计算它的LOD


579
00:34:27,467 --> 00:34:30,036 line:-1
一旦我们有了LOD


580
00:34:30,103 --> 00:34:34,241 line:-1
读取它相应的网格和材料参数、


581
00:34:34,440 --> 00:34:35,943 line:-2
应用到那个LOD上的参数缓冲区
就非常直截了当了


582
00:34:36,610 --> 00:34:39,713 line:-2
之所以直截了当主要是因为
参数缓冲区


583
00:34:39,780 --> 00:34:42,516 line:-2
关联我们在场景中所需要的
资源的方式


584
00:34:43,650 --> 00:34:46,987 line:-2
我们已经得到我们所需的全部信息
现在是时候进行编码了


585
00:34:47,688 --> 00:34:50,724 line:-1
让我们看一下编码到非参数缓冲区


586
00:34:50,791 --> 00:34:54,194 line:-1
和非直接命令缓冲区到底是什么意思


587
00:34:57,164 --> 00:35:00,767 line:-2
非直接命令缓冲区
是渲染命令的一个区域


588
00:35:01,068 --> 00:35:03,136 line:-1
每个命令可以有不同的属性


589
00:35:03,670 --> 00:35:06,473 line:-1
一个命令可以包含一个管道专用对象


590
00:35:06,840 --> 00:35:10,444 line:-1
管道专用对象描述一个共享的管道


591
00:35:10,511 --> 00:35:11,578 line:-2
和绘制调用所需要的任意漩涡
和碎片缓冲区


592
00:35:12,045 --> 00:35:13,146 line:-1
还有绘制调用自己


593
00:35:13,580 --> 00:35:17,951 line:-2
从根本上说 编码的意思是
一旦我们决定一个对象可见


594
00:35:18,385 --> 00:35:21,588 line:-1
我们就读取它和它所有的属性


595
00:35:21,655 --> 00:35:23,457 line:-1
并把这些编码到非直接命令缓冲区中


596
00:35:23,891 --> 00:35:28,762 line:-2
现在凡是正在处理对象的线程
都可以编码到


597
00:35:28,829 --> 00:35:30,097 line:-2
这个非直接命令缓冲区的一个
特定的编码槽中


598
00:35:30,564 --> 00:35:32,933 line:-1
因为所有线程都是并行运行的


599
00:35:33,400 --> 00:35:35,402 line:-1
可以同时进行命令编码


600
00:35:36,370 --> 00:35:39,239 line:-1
现在让我们继续看剔除内核例子


601
00:35:39,306 --> 00:35:42,576 line:-1
看一个真实的编码示例


602
00:35:44,545 --> 00:35:48,015 line:-2
我们首先需要在命令缓冲区中
有一个位置


603
00:35:48,081 --> 00:35:49,082 line:-1
来编码绘制命令


604
00:35:49,550 --> 00:35:53,954 line:-2
因此我们使用绘制ID为我们自己
在非直接命令缓冲区中获取编码槽


605
00:35:54,755 --> 00:35:58,859 line:-2
就像我们所讨论的那样
我们需要设置绘制调用所需要的参数


606
00:35:59,359 --> 00:36:01,328 line:-2
现在我们刚获得的
材料和网格参数缓冲区


607
00:36:01,395 --> 00:36:04,064 line:-1
已经有我们要设置参数


608
00:36:04,131 --> 00:36:05,132 line:-1
所需要的全部信息


609
00:36:05,699 --> 00:36:08,735 line:-1
那么比如 从材料中我们可以设置


610
00:36:09,336 --> 00:36:10,337 line:-1
我们需要设置的管道专用对象


611
00:36:10,804 --> 00:36:15,275 line:-1
从网格对象中我们可以设置


612
00:36:15,342 --> 00:36:16,343 line:-2
我们需要设置的任何漩涡缓冲区
或漩涡一致性


613
00:36:16,944 --> 00:36:19,980 line:-2
当然了 碎片需要材料
因此我们也要设置它


614
00:36:20,514 --> 00:36:22,916 line:-1
最后 这就是如何编码绘制


615
00:36:23,584 --> 00:36:27,754 line:-2
就是这样
编码绘制调用非常简单和简便


616
00:36:29,790 --> 00:36:32,960 line:-2
现在让我们看看
你该如何在你的游戏中设置通道


617
00:36:34,528 --> 00:36:36,797 line:-2
现在我们首先需要一个
非直接命令缓冲区


618
00:36:36,864 --> 00:36:39,566 line:-2
来编码包围盒绘制命令
因为这是当我们讨论


619
00:36:39,633 --> 00:36:43,971 line:-2
GPU驱动的渲染器循环时
所讲到的第一个东西


620
00:36:44,571 --> 00:36:48,675 line:-2
要渲染包围盒
我们要启动一个计算分派


621
00:36:49,109 --> 00:36:50,944 line:-1
执行包围盒的椎剔除


622
00:36:51,311 --> 00:36:53,146 line:-1
并编码包围盒绘制命令


623
00:36:53,947 --> 00:36:59,119 line:-1
因为每个线程都是独立编码绘制的


624
00:36:59,353 --> 00:37:02,990 line:-2
因此在非直接命令缓冲区中
可以有多个状态设置、


625
00:37:03,056 --> 00:37:04,658 line:-1
写入和状态设置


626
00:37:05,425 --> 00:37:09,696 line:-2
我们可以根据需要
优化非直接命令缓冲区


627
00:37:09,963 --> 00:37:11,832 line:-1
从而移除任何驱动端阶段设置


628
00:37:12,766 --> 00:37:15,702 line:-2
现在这是一个随机通道
在非直接命令缓冲区中


629
00:37:15,769 --> 00:37:16,937 line:-1
执行包围盒绘制


630
00:37:17,905 --> 00:37:20,774 line:-1
类似地 其余通道的设置也很简单


631
00:37:21,041 --> 00:37:26,947 line:-1
比如这是我们的主计算分派


632
00:37:27,014 --> 00:37:31,718 line:-1
启动我们刚才讲过的剔除内核


633
00:37:32,019 --> 00:37:35,355 line:-2
它执行剔除测试、LOD选择
并编码绘制命令


634
00:37:35,923 --> 00:37:39,059 line:-2
我们已经准备好启动最后一个
渲染通道了


635
00:37:39,126 --> 00:37:40,494 line:-1
它会在非直接命令缓冲区中执行命令


636
00:37:41,094 --> 00:37:43,564 line:-2
那么就是这些
这就是绘制场景所要做的一切操作


637
00:37:44,264 --> 00:37:48,635 line:-1
现在让我们看一下在编码绘制命令后


638
00:37:49,169 --> 00:37:50,971 line:-2
非直接命令缓冲区看起来
是什么样子的


639
00:37:53,140 --> 00:37:55,008 line:-1
现在它可能很稀疏 有很多洞


640
00:37:55,676 --> 00:37:59,580 line:-2
这主要是因为正如我们在剔除内核
例子中所看到的那样


641
00:38:00,180 --> 00:38:03,617 line:-2
正在处理对象的线程
不会编码绘制命令


642
00:38:03,684 --> 00:38:05,986 line:-1
如果它发现那个对象不可见的话


643
00:38:06,720 --> 00:38:09,256 line:-1
比如这个例子中的对象一和对象三


644
00:38:09,957 --> 00:38:13,594 line:-2
那意味着非直接命令缓冲区中的
这些编码槽是空的


645
00:38:14,027 --> 00:38:17,698 line:-2
因此如果你把这个命令缓冲区
提交到GPU 它将会执行


646
00:38:17,764 --> 00:38:21,034 line:-1
一大堆空命令 那样效率很低


647
00:38:21,735 --> 00:38:25,939 line:-2
因此理想情况是像这样
把命令紧密地打包到一起


648
00:38:26,473 --> 00:38:30,777 line:-2
也就是当我们编码绘制时
我们需要一种打包命令的方式


649
00:38:31,778 --> 00:38:34,214 line:-1
为此我们有非直接原则


650
00:38:35,349 --> 00:38:41,088 line:-2
通过非直接范围
你可以告诉有执行调用的GPU


651
00:38:41,154 --> 00:38:42,222 line:-1
去哪里获取要执行的命令范围


652
00:38:42,823 --> 00:38:45,325 line:-2
从根本上说
你可以有非直接范围缓冲区


653
00:38:45,392 --> 00:38:49,763 line:-2
它有一个起始位置
和一堆要执行的命令


654
00:38:49,830 --> 00:38:53,267 line:-2
并且这个缓冲区
可以在你执行绘制命令的编码时


655
00:38:53,333 --> 00:38:54,334 line:-1
在GPU上进行填充


656
00:38:54,735 --> 00:38:57,938 line:-2
执行调用将从这个缓冲区中
选择起始位置


657
00:38:58,005 --> 00:38:59,840 line:-1
和要执行的命令的数量


658
00:39:00,874 --> 00:39:02,843 line:-1
它可用于打包 也可用于给出范围


659
00:39:03,610 --> 00:39:06,246 line:-2
现在让我们看一个例子
看这个实际是如何运作的


660
00:39:08,182 --> 00:39:11,985 line:-1
这是我们刚才讨论过的剔除内核


661
00:39:12,386 --> 00:39:15,122 line:-2
我们对它进行了修改
以使用非直接范围缓冲区


662
00:39:15,589 --> 00:39:17,758 line:-2
让我们看一下这个内核
如何打包绘制命令


663
00:39:19,393 --> 00:39:22,629 line:-1
我们首先传入指向


664
00:39:22,696 --> 00:39:23,830 line:-1
非直接范围缓冲区的长度元素的指针


665
00:39:24,331 --> 00:39:27,301 line:-1
当我们检索要编码的命令时


666
00:39:27,601 --> 00:39:29,469 line:-1
我们可以自动增加长度


667
00:39:30,103 --> 00:39:32,739 line:-1
现在每个线程都自动增加长度


668
00:39:32,906 --> 00:39:34,942 line:-1
当计算工作完成后


669
00:39:35,309 --> 00:39:38,045 line:-2
长度会被自动设置到
非直接范围缓冲区中


670
00:39:38,879 --> 00:39:41,181 line:-1
同时绘制命令也被打包好了


671
00:39:41,748 --> 00:39:45,919 line:-2
因为在这段代码中
由这个自动指令所返回的索引


672
00:39:46,286 --> 00:39:47,754 line:-1
是之前的长度值


673
00:39:48,255 --> 00:39:53,126 line:-2
因此比如 如果你从零开始
使用零号编码槽的线程


674
00:39:53,193 --> 00:39:54,661 line:-1
把长度增加到一


675
00:39:55,195 --> 00:39:56,964 line:-1
使用第一个编码槽的线程


676
00:39:57,030 --> 00:39:59,199 line:-1
把长度增加到二 以此类推


677
00:39:59,766 --> 00:40:02,536 line:-2
这很棒
因为现在我们不仅打包了命令


678
00:40:02,603 --> 00:40:04,605 line:-1
我们同时还更新了范围


679
00:40:05,606 --> 00:40:09,176 line:-1
现在让我们看一下如何在app中


680
00:40:09,476 --> 00:40:10,477 line:-1
设置非直接范围缓冲区


681
00:40:12,312 --> 00:40:17,184 line:-2
首先你要给计算通道创建一个
范围缓冲区 用于更新范围


682
00:40:17,985 --> 00:40:21,355 line:-1
接下来你要把范围缓冲区设置为


683
00:40:21,421 --> 00:40:23,156 line:-1
剔除计算内核的内核参数


684
00:40:24,057 --> 00:40:28,362 line:-2
然后我们执行启动了首先执行对象的
剔除内核的计算通道


685
00:40:28,629 --> 00:40:33,634 line:-1
同时自动更新范围


686
00:40:34,201 --> 00:40:37,971 line:-1
最后你通过非直接范围API


687
00:40:38,172 --> 00:40:39,540 line:-1
安排缓冲区中有执行命令的通道


688
00:40:39,907 --> 00:40:43,377 line:-1
现在这个调用将选择起始位置


689
00:40:43,443 --> 00:40:46,146 line:-2
和要从这个非直接范围缓冲区中
执行的命令的数量


690
00:40:46,847 --> 00:40:50,350 line:-1
通过非直接范围 你可以获得更多


691
00:40:50,417 --> 00:40:51,852 line:-1
非直接命令缓冲区的有效执行


692
00:40:53,487 --> 00:40:56,590 line:-1
目前在我们的GPU驱动的管道中


693
00:40:56,890 --> 00:41:00,160 line:-2
所有这些绘制命令
都创建在GPU上的计算通道中


694
00:41:00,794 --> 00:41:03,664 line:-1
并且这些计算通道是你的游戏中


695
00:41:03,730 --> 00:41:04,731 line:-1
发生常规分派的地方


696
00:41:05,199 --> 00:41:08,836 line:-2
那么有一个问题
就是在GPU上创建计算分派


697
00:41:09,002 --> 00:41:12,406 line:-2
我们是否可以把计算分派
编码到非直接命令缓冲区中？


698
00:41:12,940 --> 00:41:16,910 line:-2
我很高兴地告诉你们 我们在
Metal 3中新添加了一个功能


699
00:41:16,977 --> 00:41:20,714 line:-1
支持编码计算分派


700
00:41:21,715 --> 00:41:24,318 line:-2
现在你也可以
在GPU上创建计算分派了


701
00:41:24,651 --> 00:41:27,354 line:-1
关于功能性 计算非直接命令缓冲区


702
00:41:27,721 --> 00:41:28,689 line:-1
就跟渲染一样


703
00:41:28,822 --> 00:41:32,326 line:-2
它们也可以创建一次之后
就能一次又一次地重复使用


704
00:41:32,860 --> 00:41:35,295 line:-1
它们还可以帮助节约CPU周期


705
00:41:35,829 --> 00:41:41,101 line:-2
最棒的是渲染和计算现在都可以
在GPU上进行


706
00:41:41,835 --> 00:41:44,872 line:-2
非常棒
因为现在你可以创建更灵活的


707
00:41:44,938 --> 00:41:46,039 line:-1
GPU驱动的管道了


708
00:41:46,740 --> 00:41:50,110 line:-1
现在让我们通过一个用例看一个例子


709
00:41:51,912 --> 00:41:53,680 line:-1
每个补丁曲面细分因素


710
00:41:54,181 --> 00:41:57,985 line:-2
假如我们有一个网格
由一堆补丁组成


711
00:41:58,418 --> 00:42:01,021 line:-2
我们想给每个补丁
都生成曲面细分因素


712
00:42:01,755 --> 00:42:04,291 line:-2
我们当然可以在剔除计算内核中
实现


713
00:42:04,491 --> 00:42:08,095 line:-2
就是我们讲过的那个执行剔除任务
和编码绘制命令的剔除计算内核


714
00:42:08,595 --> 00:42:12,733 line:-2
它是GPU线程 处理对象的方式是
进入对象的每一个补丁


715
00:42:12,799 --> 00:42:15,502 line:-1
并生成曲面细分因素


716
00:42:16,203 --> 00:42:17,905 line:-1
但这样真的效率太低了


717
00:42:17,971 --> 00:42:23,076 line:-2
因为生成曲面细分因素自身
也是一个很有麻痹性的操作


718
00:42:23,810 --> 00:42:27,247 line:-2
因此如果按操作在多线程中进行分配
会很有效率


719
00:42:27,314 --> 00:42:31,051 line:-1
那样可以并行处理所有补丁


720
00:42:31,852 --> 00:42:34,621 line:-2
也就是说 正在处理对象的
剔除计算分派的每个线程


721
00:42:34,888 --> 00:42:38,192 line:-1
都可以编码计算分派


722
00:42:38,258 --> 00:42:39,593 line:-1
用于测试因素生成


723
00:42:40,027 --> 00:42:43,463 line:-2
并且这些分配
可以在另一个计算通道上执行


724
00:42:43,764 --> 00:42:44,865 line:-1
从而麻痹操作


725
00:42:45,632 --> 00:42:48,402 line:-2
那么通过GPU驱动的分派
我们现在可以实现了


726
00:42:48,869 --> 00:42:52,873 line:-2
让我们看一下
如何把GPU驱动的管道


727
00:42:52,940 --> 00:42:53,941 line:-1
交换为适应这种处理


728
00:42:56,710 --> 00:42:59,746 line:-1
这是我们之前讨论过的主计算通道


729
00:42:59,813 --> 00:43:02,549 line:-1
它执行剔除任务、LOD选择


730
00:43:02,616 --> 00:43:03,851 line:-1
并编码绘制命令


731
00:43:04,418 --> 00:43:09,323 line:-2
我们现在可以让这个通道
同时也编码分派 用于生成测试因素


732
00:43:09,790 --> 00:43:14,161 line:-1
比如在某线程决定某对象可见后


733
00:43:14,361 --> 00:43:16,864 line:-1
它可以编码分派


734
00:43:16,930 --> 00:43:18,465 line:-2
用于在非直接命令缓冲区中
生成测试因素


735
00:43:19,032 --> 00:43:23,237 line:-1
然后那些命令可以在主渲染通道之前


736
00:43:23,303 --> 00:43:24,972 line:-1
在另一个计算通道上执行


737
00:43:25,772 --> 00:43:30,978 line:-2
GPU驱动的分派
与GPU驱动的绘制合并


738
00:43:31,044 --> 00:43:33,046 line:-2
可以让我们创建更灵活的
GPU驱动的管道


739
00:43:34,481 --> 00:43:37,985 line:-2
我们要创建一个示例
为你实际演示一下我们所讲的内容


740
00:43:38,285 --> 00:43:39,286 line:-1
让我们看一下


741
00:43:41,655 --> 00:43:45,092 line:-1
这里是你之前见过的小酒馆场景


742
00:43:45,592 --> 00:43:48,829 line:-2
这个 我们实际上正在
低空飞过这里的街道


743
00:43:49,296 --> 00:43:53,033 line:-1
这个场景大约由280万个多边形


744
00:43:53,166 --> 00:43:55,235 line:-1
和接近8000个绘制调用构成


745
00:43:55,869 --> 00:43:57,871 line:-1
这只是一个视图的


746
00:43:58,005 --> 00:44:00,908 line:-2
如果你考虑这里使用的
用于阴影处理的阴影瀑布


747
00:44:00,974 --> 00:44:05,179 line:-2
那么这个渲染器正在处理
四个这样的视图


748
00:44:05,679 --> 00:44:10,384 line:-2
因此如果这场景在CPU上进行渲染
会有相当多的API调用


749
00:44:10,851 --> 00:44:13,787 line:-2
但在这个例子中
我们使用了非直接命令缓冲区


750
00:44:14,354 --> 00:44:17,824 line:-2
因此一切都在GPU上执行
它完全是由GPU驱动的


751
00:44:18,225 --> 00:44:20,027 line:-1
整个渲染循环都在GPU上


752
00:44:20,527 --> 00:44:23,363 line:-1
因此它节约了许多CPU


753
00:44:25,132 --> 00:44:27,935 line:-1
让我们再看一个视图


754
00:44:28,468 --> 00:44:31,972 line:-2
现在我们看的是同一个视图
同一个低空飞行 但我们正在看


755
00:44:32,039 --> 00:44:34,174 line:-1
摄像机穿过这里的街道


756
00:44:34,675 --> 00:44:38,178 line:-2
为了能让大家看清楚
我们把摄像机显示为一个白色物体


757
00:44:38,245 --> 00:44:39,246 line:-1
那就是摄像机


758
00:44:40,781 --> 00:44:41,915 line:-1
我们显示了几何图形


759
00:44:41,982 --> 00:44:46,920 line:-1
那个洋红色的几何图形正在下落


760
00:44:46,987 --> 00:44:49,656 line:-1
这个几何图形落在了摄像机的视椎外


761
00:44:50,457 --> 00:44:53,327 line:-2
因此你可以看到
随着摄像机穿过街道


762
00:44:53,393 --> 00:44:56,230 line:-1
有不少几何图形都落在了


763
00:44:56,296 --> 00:44:57,297 line:-1
摄像机的视椎外


764
00:44:57,564 --> 00:45:01,802 line:-2
我们的剔除计算分派在GPU上
执行椎剔除


765
00:45:02,169 --> 00:45:05,973 line:-2
它决定这个几何图形
这个有色的几何图形为不可见对象


766
00:45:06,206 --> 00:45:11,178 line:-2
因此在GPU上不会处理或渲染
这个几何图形


767
00:45:11,245 --> 00:45:12,613 line:-1
节约了许多渲染成本


768
00:45:13,847 --> 00:45:15,716 line:-1
让我们再看最后一个视图


769
00:45:17,885 --> 00:45:18,886 line:-1
这是另一个视图


770
00:45:18,952 --> 00:45:21,755 line:-2
在这里我们显示了工作中的
椎剔除和遮挡剔除


771
00:45:22,556 --> 00:45:27,394 line:-2
我们 我们把被遮挡住的几何图形
染成了蓝绿色


772
00:45:27,928 --> 00:45:32,099 line:-1
而洋红色的几何图形处于视椎外


773
00:45:32,599 --> 00:45:34,935 line:-1
你可以看到右边有不少几何图形


774
00:45:35,002 --> 00:45:37,671 line:-2
都被小酒馆遮挡住了
因此它们是蓝绿色的


775
00:45:38,438 --> 00:45:41,008 line:-1
你可以看到这里有许多几何图形


776
00:45:41,074 --> 00:45:43,944 line:-1
无论是在视椎外或是被遮挡住了


777
00:45:44,211 --> 00:45:46,647 line:-1
再一次 我们的剔除计算内核


778
00:45:46,847 --> 00:45:49,816 line:-2
在GPU上既执行椎剔除
又执行遮挡剔除


779
00:45:50,150 --> 00:45:53,020 line:-1
那就决定了这些几何图形是不可见的


780
00:45:53,086 --> 00:45:58,859 line:-2
因此我们不会在GPU上处理或渲染
这个染色的几何图形


781
00:45:58,926 --> 00:46:01,595 line:-1
这节约了许多渲染成本并提升了性能


782
00:46:04,932 --> 00:46:06,266 line:-1
较为简单的GPU家族


783
00:46:06,800 --> 00:46:11,038 line:-2
在我们结束这场演讲之前
我想再给大家介绍一个东西


784
00:46:11,338 --> 00:46:15,909 line:-2
我要讲一下我们如何把
在Metal核上写交叉引用


785
00:46:15,976 --> 00:46:16,977 line:-1
变得比以前更简单了


786
00:46:17,411 --> 00:46:20,480 line:-1
我还要讲一下如何更容易地瞄准


787
00:46:20,547 --> 00:46:23,684 line:-2
iOS、tvOS和
macOS上的特定功能


788
00:46:24,284 --> 00:46:28,188 line:-1
在此之前 先让我们看一下


789
00:46:28,255 --> 00:46:30,591 line:-1
现在各平台上可用的Metal功能


790
00:46:32,726 --> 00:46:35,796 line:-2
现在Metal在iOS和
tvOS平台上有一些新功能


791
00:46:36,597 --> 00:46:40,601 line:-2
在演讲的上半场我们讲了
如何在非直接命令缓冲区中


792
00:46:40,667 --> 00:46:46,073 line:-2
设置管道状态从而帮助你充分利用
GPU驱动的管道


793
00:46:46,640 --> 00:46:51,645 line:-2
我们还讲了非直接范围
如何让你更简单、


794
00:46:51,712 --> 00:46:54,982 line:-1
更有效地打包和执行非直接命令


795
00:46:55,649 --> 00:46:59,386 line:-2
最后我们还向
iOS和tvOS引入了


796
00:46:59,453 --> 00:47:01,255 line:-1
16位深度纹理支持


797
00:47:02,322 --> 00:47:06,193 line:-2
这一直都是一个很流行的请求
可以帮助优化阴影贴图渲染


798
00:47:06,827 --> 00:47:10,330 line:-2
Metal在macOS上
也有一些重要的新功能


799
00:47:11,532 --> 00:47:13,367 line:-2
如果你需要向内存缓冲区中
执行更灵活的输出的话


800
00:47:13,433 --> 00:47:17,171 line:-1
我们现在可以实现不带附件渲染了


801
00:47:17,771 --> 00:47:20,974 line:-2
你可以查询你的命令缓冲器
在GPU上的所花的时间


802
00:47:21,275 --> 00:47:24,244 line:-1
从而可以动态地调整表示区间


803
00:47:24,845 --> 00:47:30,083 line:-2
最后MacOS现在支持sRGB
和非sRGB视图之间的投射


804
00:47:30,417 --> 00:47:33,253 line:-1
从而更好地适应线性和非线性照明


805
00:47:34,521 --> 00:47:38,458 line:-2
现在让我们看一下
新GPU家族API


806
00:47:41,195 --> 00:47:45,332 line:-2
你之前使用Metal功能
根据可用功能和限制


807
00:47:45,399 --> 00:47:48,268 line:-1
设置查询使你的app适应


808
00:47:48,802 --> 00:47:53,440 line:-2
但功能的数量 功能集合增长了
它们当前的数量


809
00:47:53,507 --> 00:47:54,508 line:-1
以打为单位


810
00:47:55,142 --> 00:47:58,979 line:-1
GPU家族查询替换了功能集合


811
00:47:59,046 --> 00:48:00,814 line:-1
使得系统的查询功能更简单了


812
00:48:01,682 --> 00:48:06,353 line:-1
首先我们把它们合并为四个家族


813
00:48:06,420 --> 00:48:07,554 line:-2
并把它们组织起来
简化跨平台开发过程


814
00:48:08,455 --> 00:48:11,491 line:-2
第二 每个家族都支持
一系列等级的功能


815
00:48:11,792 --> 00:48:13,660 line:-1
它们被组织到一个或多个实例中


816
00:48:14,061 --> 00:48:18,131 line:-2
因此支持一个实例意味着
支持所有更早以前的实例


817
00:48:19,066 --> 00:48:23,003 line:-2
第三 新API把Metal
软件版查询独立出来


818
00:48:23,070 --> 00:48:27,574 line:-2
用于追踪指定家族的实例
如何改变软件的提交


819
00:48:28,475 --> 00:48:34,114 line:-2
最后一个GPU家族
定义了一小套设备查询


820
00:48:34,615 --> 00:48:38,085 line:-1
有一些可选功能 并未放到家族中


821
00:48:39,019 --> 00:48:43,323 line:-2
通过这些信息 让我们具体看一下
新的GPU家族定义


822
00:48:45,325 --> 00:48:48,862 line:-2
现在所有iOS和tvOS功能
都被组织到各自的家族中


823
00:48:48,929 --> 00:48:50,964 line:-1
一个家族有五个实例


824
00:48:51,565 --> 00:48:56,170 line:-1
每个实例支持之前实例内的所有功能


825
00:48:56,870 --> 00:48:59,473 line:-1
我不打算在这里列举所有功能


826
00:48:59,540 --> 00:49:04,578 line:-1
但这场演讲的资源部分有一个表


827
00:49:04,645 --> 00:49:06,380 line:-1
表中列出了家族和实例的功能


828
00:49:07,314 --> 00:49:10,851 line:-1
Mac功能只围绕两个实例组织


829
00:49:11,285 --> 00:49:14,888 line:-2
Mac 2支持来自Mac 1的
所有功能


830
00:49:16,123 --> 00:49:19,393 line:-2
现在查询这些功能
这些家族很大程度上简化了


831
00:49:19,459 --> 00:49:23,363 line:-2
扁平的、非特定的代码的书写
但当你想瞄准


832
00:49:23,430 --> 00:49:24,565 line:-1
所有平台时会怎么样？


833
00:49:25,132 --> 00:49:27,601 line:-1
为此我们有新的通用家族


834
00:49:28,535 --> 00:49:32,840 line:-2
通用家族把Metal功能
组织到跨平台等级中


835
00:49:33,574 --> 00:49:37,945 line:-2
所有Metal GPU
都普遍支持通用1


836
00:49:38,011 --> 00:49:40,848 line:-2
对于只稍微使用了Metal的
app来说是个不错的选择


837
00:49:41,915 --> 00:49:46,820 line:-2
通用2提供所有创建优秀游戏开发
必要的building block


838
00:49:46,887 --> 00:49:51,758 line:-2
比如非直接绘制、统计遮挡查询、
曲面细分


839
00:49:51,925 --> 00:49:54,027 line:-1
和Metal性能阴影支持


840
00:49:54,895 --> 00:49:59,299 line:-2
通用3提供高级app所需要的
所有功能


841
00:49:59,366 --> 00:50:03,704 line:-2
比如非直接命令缓冲区、分层渲染、
立方体贴图数组


842
00:50:03,770 --> 00:50:05,172 line:-1
以及漩涡位置不变量


843
00:50:06,106 --> 00:50:12,012 line:-2
最后Metal 3为iPad app提供一个
专用家族 使它们能引入到Mac中


844
00:50:12,513 --> 00:50:15,582 line:-1
也就是为那种体验进行的调整


845
00:50:18,218 --> 00:50:22,422 line:-2
两个iOS Mac实例
支持功能合并


846
00:50:22,489 --> 00:50:24,458 line:-2
这对于在Mac上获得强大性能来说
至关重要


847
00:50:25,225 --> 00:50:26,793 line:-1
特别是它们使得


848
00:50:26,860 --> 00:50:31,565 line:-2
Mac专用的区块压缩像素格式
和管理文本模式可用


849
00:50:31,632 --> 00:50:34,635 line:-2
可以在另外的
完全是iOS的app内使用


850
00:50:35,369 --> 00:50:39,339 line:-2
现在iOS Mac 1
支持通用2的所有功能


851
00:50:39,573 --> 00:50:41,408 line:-1
外加来自通用3的一些功能


852
00:50:41,942 --> 00:50:45,979 line:-1
除了BC像素格式和所管理的纹理


853
00:50:46,246 --> 00:50:51,685 line:-2
它支持立方体纹理数组、读写纹理、
分层渲染、


854
00:50:51,919 --> 00:50:54,254 line:-1
多视图端口渲染和非直接曲面细分


855
00:50:56,023 --> 00:50:59,893 line:-2
iOS Mac 2
支持通用3的全部功能


856
00:51:00,194 --> 00:51:03,797 line:-1
除BC像素格式和所管理的纹理之外


857
00:51:04,531 --> 00:51:06,233 line:-1
那么这就是四个新家族


858
00:51:06,867 --> 00:51:11,371 line:-2
现在让我们看一下
在实践中如何使用新QD API


859
00:51:13,207 --> 00:51:16,710 line:-2
在这个例子中
我们会检查Mac 2功能是否可用


860
00:51:18,445 --> 00:51:22,516 line:-2
我们先检查OS
是否支持新家族API


861
00:51:23,250 --> 00:51:27,254 line:-2
如果新家族API可用
我们就用它来检查


862
00:51:27,321 --> 00:51:29,089 line:-1
Metal 3功能是否可用


863
00:51:29,656 --> 00:51:32,292 line:-2
因为Metal 3是新发布的
你不需要对它进行严格的检查


864
00:51:32,459 --> 00:51:33,794 line:-1
但这是一个很好的做法


865
00:51:35,162 --> 00:51:40,100 line:-2
如果Metal 3可用
我们就检查我们想要使用的家族


866
00:51:40,434 --> 00:51:44,371 line:-2
这里的跨平台app
检查其中一个通用家族


867
00:51:44,805 --> 00:51:47,908 line:-2
以及一个或多个
Apple或Mac专用家族


868
00:51:49,009 --> 00:51:54,047 line:-2
如果API或版本号有一个不可用
我们就返回


869
00:51:54,114 --> 00:51:57,584 line:-2
较老的功能集API
或较老的Metal版本


870
00:51:58,719 --> 00:52:02,923 line:-2
现在让我们看一下
你可以查询的设置选项功能


871
00:52:05,058 --> 00:52:09,029 line:-2
当某家族在家族内指定了
GPU的通用行为后


872
00:52:09,463 --> 00:52:13,534 line:-1
但某些重要的功能和限制在家族内


873
00:52:13,600 --> 00:52:14,601 line:-1
并不是统一地都支持


874
00:52:14,668 --> 00:52:17,471 line:-1
比如深度24模板8像素格式


875
00:52:17,638 --> 00:52:19,640 line:-1
以及一个像素中MSA样本的数量


876
00:52:20,407 --> 00:52:26,079 line:-2
为了处理这些问题
Metal设备提供了一个API


877
00:52:26,146 --> 00:52:27,314 line:-1
可以直接查询其中每一个功能


878
00:52:27,881 --> 00:52:32,252 line:-2
但你可以看到
这个类中并没有太多功能


879
00:52:33,554 --> 00:52:37,624 line:-2
那么要结束这场演讲
让我们看一下目前我们讲过的技巧


880
00:52:37,691 --> 00:52:40,794 line:-1
有多少被新GPU家族所支持


881
00:52:42,963 --> 00:52:46,533 line:-1
经典的延迟着色在所有平台上都支持


882
00:52:46,834 --> 00:52:50,637 line:-2
可编程混合在所有
Apple GPU上都支持


883
00:52:50,771 --> 00:52:53,006 line:-1
它是开发游戏的一个很好的默认选择


884
00:52:53,841 --> 00:52:57,144 line:-2
平铺延迟和前向渲染也通过
Apple专用优化被广泛支持


885
00:52:57,444 --> 00:53:01,715 line:-1
要求有更先进的硬件条件


886
00:53:02,349 --> 00:53:05,185 line:-1
最后可见度缓冲区技巧


887
00:53:05,385 --> 00:53:07,421 line:-1
只由Mac家族支持


888
00:53:08,021 --> 00:53:11,458 line:-1
它恰好有非常苛刻的分辨率要求


889
00:53:12,526 --> 00:53:17,364 line:-2
现在让我们看一下这些家族
如何支持GPU驱动的管道功能


890
00:53:17,431 --> 00:53:18,866 line:-1
然后就结束我们的演讲


891
00:53:21,301 --> 00:53:25,939 line:-2
现在有些功能要求广泛的支持
成为渲染引擎的核心部分


892
00:53:26,306 --> 00:53:29,843 line:-2
我们相信GPU驱动的管道
也要求那种支持


893
00:53:30,544 --> 00:53:34,448 line:-1
因此我们非常高兴地告诉你们


894
00:53:34,515 --> 00:53:37,951 line:-1
现在通用家族2及之后的家族都支持


895
00:53:38,252 --> 00:53:41,054 line:-2
用于图形和计算的参数缓冲区
和非直接命令缓冲区


896
00:53:43,824 --> 00:53:46,360 line:-1
然后我们就要结束这场演讲了


897
00:53:46,426 --> 00:53:47,761 line:-1
用Metal进行现代化渲染


898
00:53:48,395 --> 00:53:52,165 line:-2
我们希望你们可以在你们的游戏
和app中应用所有这些技巧


899
00:53:52,332 --> 00:53:53,567 line:-1
让我们快速回顾一下


900
00:53:55,235 --> 00:53:58,138 line:-2
我同事Jaap讲了
如何用Metal


901
00:53:58,205 --> 00:53:59,473 line:-1
实施更高级的渲染技巧


902
00:53:59,973 --> 00:54:03,177 line:-1
比如延迟着色、平铺前向渲染


903
00:54:03,510 --> 00:54:05,045 line:-1
与iOS非常相配


904
00:54:05,245 --> 00:54:10,851 line:-2
当合并和优化可编程混合
和平铺共享时


905
00:54:11,552 --> 00:54:14,521 line:-2
在Mac上
你可以使用新的中心坐标


906
00:54:14,588 --> 00:54:18,325 line:-2
和查询LOD来实施
可见度缓冲区技巧


907
00:54:18,392 --> 00:54:20,027 line:-1
并以高分辨率进行渲染


908
00:54:20,928 --> 00:54:23,297 line:-1
但无论你选择使用哪种技巧


909
00:54:23,530 --> 00:54:26,633 line:-2
你都可以把整个渲染循环
移到GPU上


910
00:54:27,267 --> 00:54:30,404 line:-1
椎剔除、遮挡剔除、LOD选择


911
00:54:30,470 --> 00:54:34,041 line:-2
都可以在通过参数缓冲区
和非直接命令缓冲区GPU上实现


912
00:54:34,708 --> 00:54:38,378 line:-1
现在你还可以把计算分派编码到


913
00:54:38,846 --> 00:54:41,415 line:-1
GPU上的非直接命令缓冲区中


914
00:54:42,950 --> 00:54:47,421 line:-2
无论你是想瞄准iOS或
macOS上的大范围硬件


915
00:54:47,521 --> 00:54:50,691 line:-1
或想使用一些高级Metal功能


916
00:54:50,958 --> 00:54:54,228 line:-2
你现在都可以使用新的、
重新设计的GPU家族API


917
00:54:54,695 --> 00:54:57,197 line:-1
在运行时检查可用的功能


918
00:54:59,433 --> 00:55:03,837 line:-2
现在请访问我们的演讲网站了解
关于Metal功能


919
00:55:03,904 --> 00:55:05,405 line:-1
和GPU驱动的管道的更多信息


920
00:55:05,806 --> 00:55:08,408 line:-2
我们将发布
我们在这场演讲中使用的示例app


921
00:55:08,976 --> 00:55:11,745 line:-2
你可以探索这些技巧
并把它们整合到你的app


922
00:55:11,812 --> 00:55:14,448 line:-1
和游戏中 请参加我们的演讲


923
00:55:14,515 --> 00:55:16,316 line:-2
事实上这场演讲结束之后
就有一场演讲


924
00:55:18,018 --> 00:55:20,020 line:-2
谢谢 祝你们度过愉快的会议时光
谢谢

