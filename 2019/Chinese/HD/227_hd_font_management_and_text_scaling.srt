1
00:00:06,039 --> 00:00:09,910 line:0
（字体管理和文本大小）


2
00:00:16,015 --> 00:00:18,285 line:-2
早上好 我是
Julio Gonzalez


3
00:00:18,352 --> 00:00:20,087 line:-1
我是键入工程团队的主管


4
00:00:20,320 --> 00:00:22,623 line:-1
今天很高兴能来这里与大家分享


5
00:00:22,756 --> 00:00:27,027 line:-2
我们在iOS中
对文本和字体所做的新改进


6
00:00:28,262 --> 00:00:30,397 line:-1
我们今天的议程很满


7
00:00:31,131 --> 00:00:35,769 line:-2
一开始我要讲用于你app中的一些
新的系统字体


8
00:00:37,504 --> 00:00:40,174 line:-1
然后接着讲如何创建app


9
00:00:40,240 --> 00:00:43,443 line:-1
使字体在全系统内可用


10
00:00:43,744 --> 00:00:47,214 line:-2
以及如何使app访问那些
非常相同的字体


11
00:00:48,215 --> 00:00:52,219 line:-1
然后我们讲app选择字体的新机制


12
00:00:53,253 --> 00:00:57,457 line:-1
最后讲一些文本缩放注意事项


13
00:00:57,824 --> 00:01:01,161 line:-2
你可能会在把你的iPad app
引入Mac时遇到这种情况


14
00:01:02,462 --> 00:01:03,430 line:-1
让我们开始讲吧


15
00:01:04,063 --> 00:01:06,834 line:-1
我们在所有新版本中


16
00:01:07,034 --> 00:01:08,302 line:-1
提供三种新的系统字体


17
00:01:09,102 --> 00:01:11,471 line:-1
第一种是一种圆角系统字体


18
00:01:11,772 --> 00:01:14,007 line:-1
你可以在这里看到


19
00:01:14,074 --> 00:01:17,044 line:-2
Reminders app最顶部
Scheduled标签上有使用


20
00:01:18,679 --> 00:01:21,515 line:-1
还有一种衬线系统字体


21
00:01:21,982 --> 00:01:26,453 line:-2
你可以在这里看到它在
Books app中有多处使用


22
00:01:27,621 --> 00:01:30,524 line:-1
最后还有一种单间距系统字体


23
00:01:30,791 --> 00:01:33,894 line:-2
你之前可能在Swift Playground中
看到有使用


24
00:01:34,494 --> 00:01:37,731 line:-2
我鼓励你参考
Human Interface Guidelines


25
00:01:37,998 --> 00:01:40,734 line:-1
了解如何在你的app UI中


26
00:01:40,901 --> 00:01:42,436 line:-1
最好地使用这些系统字体


27
00:01:43,804 --> 00:01:48,509 line:-2
你可以通过UIFontDescriptor中的
新API获取系统字体


28
00:01:49,209 --> 00:01:51,245 line:-1
我们为你定义了四个新常量


29
00:01:51,745 --> 00:01:55,682 line:-2
第一个也是默认常量
是标准系统无衬线系统字体


30
00:01:55,749 --> 00:01:58,118 line:-1
这些年来你们一直都在用


31
00:01:58,418 --> 00:02:00,087 line:-1
然后我们给每个新添加的系统字体


32
00:02:00,153 --> 00:02:03,123 line:-1
都定义了一个常量


33
00:02:04,124 --> 00:02:07,194 line:-2
你可以通过一个叫做withDesign的
新方法使用这些常量


34
00:02:07,494 --> 00:02:09,395 line:-1
这个新方法用于转换字体描述符


35
00:02:09,463 --> 00:02:12,232 line:-1
从一个设计转换到另一个设计


36
00:02:13,200 --> 00:02:14,401 line:-1
用起来很简单


37
00:02:14,668 --> 00:02:15,903 line:-1
从字体描述符开始


38
00:02:15,969 --> 00:02:17,838 line:-1
在这个例子中 我们从已经实例化的


39
00:02:18,105 --> 00:02:21,542 line:-2
粗体系统字体中
得到了一个字体描述符


40
00:02:22,109 --> 00:02:26,046 line:-2
然后我们要做的就是
获取圆角系统字体


41
00:02:26,246 --> 00:02:30,784 line:-2
我们用圆角常量
调用withDesign


42
00:02:31,084 --> 00:02:35,522 line:-2
如果成功 我们就可以实例化
我们的圆角粗体系统字体


43
00:02:35,889 --> 00:02:40,060 line:-2
请注意 我们使用了高层级的API
实例化系统字体


44
00:02:40,294 --> 00:02:43,564 line:-2
我们没有通过使用它的名称
来实例化系统字体


45
00:02:44,097 --> 00:02:45,699 line:-1
那是我们的下一个话题


46
00:02:46,800 --> 00:02:48,635 line:-1
我们已经注意到许多app


47
00:02:49,203 --> 00:02:52,272 line:-1
至今仍然按名称实例化系统字体


48
00:02:52,906 --> 00:02:56,310 line:-1
我们以前强烈反对你们这样做


49
00:02:56,844 --> 00:02:59,112 line:-1
那么从新版本开始


50
00:02:59,613 --> 00:03:01,949 line:-2
任何诸如此类的字体实例化
均会导致失败


51
00:03:02,216 --> 00:03:05,953 line:-1
你需要使用高层级的系统调用


52
00:03:06,019 --> 00:03:07,955 line:-1
来实例化此种字体


53
00:03:08,355 --> 00:03:11,058 line:-1
你知道你正在按名称实例化系统字体


54
00:03:11,491 --> 00:03:14,428 line:-1
因为如果你看一下你传给它的名称


55
00:03:14,528 --> 00:03:17,497 line:-1
如果它以点为开端 那你就正在使用


56
00:03:17,564 --> 00:03:19,900 line:-1
一个Apple私有名称


57
00:03:20,601 --> 00:03:23,270 line:-2
现在按名称实例化字体
有许多很好的理由


58
00:03:23,770 --> 00:03:26,807 line:-2
这是你如何在app中
访问自定义系统字体的方式


59
00:03:27,241 --> 00:03:30,310 line:-1
以及如果你解析文档 这就是你如何


60
00:03:30,911 --> 00:03:32,846 line:-1
实例化文档所需要的字体的方式


61
00:03:33,447 --> 00:03:35,749 line:-1
现在我们还注意到许多app


62
00:03:36,283 --> 00:03:39,586 line:-2
没有恰当地处理
按名称进行的字体实例化


63
00:03:40,921 --> 00:03:42,623 line:-1
有时候它们会发生崩溃 原因就是


64
00:03:42,689 --> 00:03:46,793 line:-2
因为他们实际上并没有查看
实例化所返回的结果


65
00:03:46,860 --> 00:03:48,629 line:-1
他们假定实例化总是会成功


66
00:03:49,396 --> 00:03:52,366 line:-1
因为我们修改了OS中的某些字体


67
00:03:52,733 --> 00:03:56,570 line:-2
或我们从OS中移除了某些字体
那些 那些字体已不存在了


68
00:03:56,637 --> 00:03:58,772 line:-2
因此 你不能假定
不存在于OS某版本上的字体


69
00:03:59,039 --> 00:04:01,875 line:-1
会在另一个版本上存在


70
00:04:02,342 --> 00:04:05,412 line:-1
你需要注意实例化的结果


71
00:04:05,479 --> 00:04:07,447 line:-1
并在app中采取适当的行动


72
00:04:07,781 --> 00:04:10,150 line:-1
如果必要的话用另一种字体替代


73
00:04:12,186 --> 00:04:15,856 line:-1
那么我想把主题切换到我作为用户


74
00:04:15,923 --> 00:04:18,591 line:-2
和作为字体开发人员
已经期待很久的一些功能上


75
00:04:18,791 --> 00:04:21,428 line:-1
即app可以在OS系统范围内


76
00:04:21,495 --> 00:04:23,564 line:-1
安装字体的能力


77
00:04:25,165 --> 00:04:27,734 line:-2
我们把这些app叫做
字体提供器app


78
00:04:28,168 --> 00:04:31,572 line:-2
从根本上说
它们是你提交到Store中的


79
00:04:31,805 --> 00:04:34,441 line:-2
可以让字体在OS系统范围内
可用的app


80
00:04:34,975 --> 00:04:39,279 line:-2
与那些app一起 我们还创建了
非常简单的UI设置


81
00:04:39,813 --> 00:04:41,682 line:-1
在这些UI设置中用户可以浏览


82
00:04:42,249 --> 00:04:43,817 line:-1
app所安装的字体


83
00:04:44,017 --> 00:04:46,486 line:-1
以及移除他们不再想使用的字体


84
00:04:47,621 --> 00:04:51,291 line:-2
要创建一个这样的app
需要满足两个条件


85
00:04:51,458 --> 00:04:53,160 line:-2
第一 app必须包含
entitlement


86
00:04:53,694 --> 00:04:56,730 line:-2
第二 当app被提交到
Store时


87
00:04:56,897 --> 00:04:59,299 line:-1
它需要同时提交


88
00:04:59,366 --> 00:05:01,635 line:-1
app提供给OS的所有字体


89
00:05:02,102 --> 00:05:05,539 line:-2
这很重要
字体必须是app捆绑包的一部分


90
00:05:05,606 --> 00:05:07,841 line:-1
或是资产目录的一部分


91
00:05:08,642 --> 00:05:13,080 line:-2
关键点在于OS
不会允许字体提供器app


92
00:05:14,014 --> 00:05:16,016 line:-1
安装任何任意的字体


93
00:05:16,517 --> 00:05:19,720 line:-2
因为你把字体提交到
Store用于验证


94
00:05:19,887 --> 00:05:22,723 line:-1
它的验证流程类似于


95
00:05:23,090 --> 00:05:24,758 line:-2
我们在macOS中的
Font Book验证流程


96
00:05:25,025 --> 00:05:26,059 line:-1
我们要做的其中一件事是


97
00:05:26,126 --> 00:05:29,630 line:-1
检查字体的格式的类型


98
00:05:30,030 --> 00:05:35,502 line:-2
我们支持全部现代格式 ttf、
otf、ttc及它所有的现代变体


99
00:05:35,802 --> 00:05:38,639 line:-1
我们不支持旧字体格式


100
00:05:38,705 --> 00:05:40,774 line:-2
比如suitcase字体
或postscript字体


101
00:05:42,943 --> 00:05:45,112 line:-2
获取entitlement
非常简单


102
00:05:45,312 --> 00:05:47,915 line:-2
在Xcode中有一个新功能
叫做Fonts


103
00:05:48,515 --> 00:05:50,918 line:-1
一旦你选择它 你将面临两个选项


104
00:05:52,052 --> 00:05:55,055 line:-1
第一个选项是安装字体


105
00:05:55,489 --> 00:06:00,060 line:-2
那会使app在全系统范围内
提供字体


106
00:06:00,794 --> 00:06:03,864 line:-1
第二个选项是使用已安装的字体


107
00:06:04,264 --> 00:06:05,999 line:-1
我们为什么需要这个选项？


108
00:06:06,333 --> 00:06:11,471 line:-2
嗯 默认情况下app不能访问
用户已安装的字体


109
00:06:11,905 --> 00:06:15,309 line:-2
app需要通过选择
这个功能选择加入


110
00:06:15,576 --> 00:06:17,211 line:-1
从而可以查看那些已安装的字体


111
00:06:18,879 --> 00:06:24,551 line:-2
现在这些app的客户或用户
将有一些期待


112
00:06:24,785 --> 00:06:26,520 line:-1
第一个就是


113
00:06:26,920 --> 00:06:30,357 line:-2
app应该提供一个有意义的UI
用户可以浏览安装的字体


114
00:06:30,958 --> 00:06:32,526 line:-1
并移除字体


115
00:06:32,826 --> 00:06:34,595 line:-1
这很有必要 因为在iOS中


116
00:06:34,661 --> 00:06:37,931 line:-1
OS中没有像macOS中那样的


117
00:06:38,165 --> 00:06:39,466 line:-1
能安装字体的app


118
00:06:41,001 --> 00:06:45,105 line:-2
同时app应该响应系统字体
变更通知


119
00:06:45,539 --> 00:06:46,940 line:-1
原因是


120
00:06:47,007 --> 00:06:50,344 line:-1
用户能从设置app中移除字体


121
00:06:50,677 --> 00:06:54,147 line:-2
app应该注意用户何时移除了字体
并更新它的UI


122
00:06:54,982 --> 00:06:57,217 line:-1
最后如果你有字体提供器app


123
00:06:57,284 --> 00:06:59,987 line:-1
并计划为用户提供一大套字体


124
00:07:00,053 --> 00:07:02,523 line:-1
一大套字体库


125
00:07:03,090 --> 00:07:05,759 line:-1
我们强烈推荐你使用按需资源


126
00:07:05,826 --> 00:07:07,995 line:-1
并把字体打包到一个资产目录中


127
00:07:08,662 --> 00:07:12,232 line:-2
这是提交用户所需字体的一种
有效得多的方法


128
00:07:12,533 --> 00:07:14,501 line:-1
因为用户只能下载


129
00:07:14,568 --> 00:07:16,103 line:-1
他们实际上要使用的字体


130
00:07:16,170 --> 00:07:19,339 line:-1
而不是下载一个巨大的字体库


131
00:07:19,473 --> 00:07:21,475 line:-1
因为他们只使用少量字体


132
00:07:22,676 --> 00:07:27,414 line:-2
让我们去演示机器那给你们演示
这个功能是如何运作的


133
00:07:28,949 --> 00:07:32,252 line:-1
假设用户已经从Store下载了


134
00:07:32,319 --> 00:07:35,522 line:-1
一个浏览文档的app


135
00:07:35,956 --> 00:07:37,691 line:-1
这就是一个浏览文档的app


136
00:07:37,758 --> 00:07:39,359 line:-2
我把它叫做Font
Consumer app


137
00:07:40,060 --> 00:07:43,430 line:-1
在左侧 它有一些能显示的文档


138
00:07:43,697 --> 00:07:46,266 line:-1
在右侧 它仅显示文档内容


139
00:07:46,834 --> 00:07:48,502 line:-1
让我们继续并重新加载这个文档


140
00:07:48,902 --> 00:07:50,204 line:-1
请注意表单出来了


141
00:07:50,404 --> 00:07:52,139 line:-1
这张表单并不是由app打开的


142
00:07:52,406 --> 00:07:53,841 line:-1
而是由OS打开的


143
00:07:54,441 --> 00:07:59,346 line:-2
之所以这样是因为它注意到
这个app正在尝试访问三种字体


144
00:07:59,947 --> 00:08:03,250 line:-1
而这三种字体在这个app上不可用


145
00:08:03,617 --> 00:08:07,821 line:-1
因此这个app替换了字体


146
00:08:07,955 --> 00:08:10,624 line:-2
以Helvetica字体
显示文档内容


147
00:08:11,391 --> 00:08:13,126 line:-1
那么用户所要做的就是


148
00:08:13,193 --> 00:08:15,996 line:-1
尝试找到一个


149
00:08:16,063 --> 00:08:19,132 line:-1
能在OS上使用那些字体的app


150
00:08:19,600 --> 00:08:22,569 line:-2
假如他们已经从Store中
下载了一个这样的app


151
00:08:22,936 --> 00:08:24,471 line:-2
我把它叫做Font
Provider app


152
00:08:24,671 --> 00:08:27,341 line:-1
在左侧 它有一套我可以使用的字体


153
00:08:27,407 --> 00:08:30,410 line:-1
在右侧 它显示了字体的简单的预览


154
00:08:30,611 --> 00:08:32,479 line:-1
让我们继续并注册所有字体


155
00:08:32,779 --> 00:08:34,515 line:-1
请再次注意 这个表单出来了


156
00:08:34,847 --> 00:08:36,149 line:-1
它不是由app打开的


157
00:08:36,216 --> 00:08:37,484 line:-1
它是由OS打开的


158
00:08:37,784 --> 00:08:41,321 line:-2
这很有必要
因为在OS中我们不允许


159
00:08:41,388 --> 00:08:44,825 line:-1
app以用户名义悄悄地安装字体


160
00:08:45,058 --> 00:08:47,227 line:-1
必须经过用户准许


161
00:08:47,461 --> 00:08:49,062 line:-1
这也就是这个对话框的功能


162
00:08:49,496 --> 00:08:51,431 line:-1
那么让我们继续并准许


163
00:08:52,666 --> 00:08:54,134 line:-1
请注意UI


164
00:08:54,201 --> 00:08:56,403 line:-1
所有字体名称从红色变成了黑色


165
00:08:56,537 --> 00:08:59,706 line:-2
app以这种简单的方式来表明
字体已经注册成功


166
00:08:59,940 --> 00:09:01,542 line:-1
让我们确保它们已经注册成功了


167
00:09:01,909 --> 00:09:06,413 line:-2
我现在可以进入设置app
然后General、Fonts


168
00:09:06,547 --> 00:09:07,648 line:-1
在这里有一个新设置


169
00:09:08,282 --> 00:09:11,351 line:-2
有字体提供器app所提供的
全部字体的列表


170
00:09:12,152 --> 00:09:14,721 line:-2
我们看到了Font
Provider app所提供的字体


171
00:09:14,888 --> 00:09:16,290 line:-1
我可以浏览其中一种字体


172
00:09:16,690 --> 00:09:17,724 line:-1
Century Schoolbook


173
00:09:18,392 --> 00:09:20,861 line:-2
你可以在这里查看
不同字体的预览效果


174
00:09:21,528 --> 00:09:25,098 line:-1
我现在就要尝试移除这个字体


175
00:09:26,633 --> 00:09:27,568 line:-1
我要继续并移除它


176
00:09:28,035 --> 00:09:29,803 line:-1
我要移除Century Schoolbook


177
00:09:30,003 --> 00:09:31,805 line:-1
现在它已经从列表中去掉了


178
00:09:31,905 --> 00:09:34,374 line:-1
现在我希望我的app


179
00:09:35,008 --> 00:09:37,144 line:-1
能注意到字体已被移除


180
00:09:37,611 --> 00:09:39,279 line:-1
确实 它现在以红色显示那种字体了


181
00:09:39,346 --> 00:09:42,816 line:-2
因为它监听了字体变更通知
并更新了UI


182
00:09:43,250 --> 00:09:45,786 line:-1
我们继续并注册所有字体


183
00:09:47,521 --> 00:09:50,023 line:-2
我要返回到Font
Consumer app


184
00:09:50,824 --> 00:09:54,595 line:-2
我现在看到文档已经不再
以Helvetica字体显示了


185
00:09:54,795 --> 00:09:57,631 line:-1
它实际上也监听了字体变更通知


186
00:09:57,965 --> 00:10:01,268 line:-1
请注意所有字体现在都可用了


187
00:10:01,935 --> 00:10:05,405 line:-2
如果我查看其它文档 我看到它们
没有使用Helvetica字体


188
00:10:05,506 --> 00:10:09,343 line:-2
它们用Font Provider
app所提供的不同字体


189
00:10:10,511 --> 00:10:12,946 line:-1
现在让我在代码中给你演示


190
00:10:13,413 --> 00:10:15,482 line:-1
如何创建一个这样的app


191
00:10:16,817 --> 00:10:21,355 line:-2
在CoreText中 特别是在
CTFontManager.h中


192
00:10:21,421 --> 00:10:23,590 line:-1
我们引入了一套全新的API


193
00:10:24,057 --> 00:10:26,994 line:-2
所有新引入的API
都在那个页眉文件中有记录


194
00:10:27,561 --> 00:10:29,830 line:-1
注册字体有三种新方式


195
00:10:30,330 --> 00:10:34,835 line:-2
其中一种是通过使用
指向字体文件的FontURLs


196
00:10:35,536 --> 00:10:38,972 line:-2
还有一种方式是你可以通过使用
FontDescriptors注册字体


197
00:10:39,540 --> 00:10:41,842 line:-1
最后一种是你可以注册


198
00:10:42,309 --> 00:10:44,311 line:-1
存在于资产目录中的字体


199
00:10:44,378 --> 00:10:48,115 line:-2
如果你有一大套字体库
你可以采用第三种方式


200
00:10:48,448 --> 00:10:49,750 line:-1
你可以创建一个资产目录


201
00:10:49,816 --> 00:10:52,986 line:-2
并且你可以使用按需资源
向用户提交字体


202
00:10:53,453 --> 00:10:57,591 line:-2
请注意最后一个API在你的种子中
不可用


203
00:10:57,824 --> 00:11:00,294 line:-1
但它在下一个即将到来的种子中可用


204
00:11:02,763 --> 00:11:04,698 line:-1
还有一个新API


205
00:11:04,831 --> 00:11:09,169 line:-2
Font Provider app
可用于访问已注册的字体


206
00:11:10,737 --> 00:11:13,440 line:-2
最后一个API
是任何app都能用于


207
00:11:13,507 --> 00:11:15,876 line:-1
查看用户安装了哪些字体


208
00:11:16,143 --> 00:11:18,111 line:-1
你可以通过选择


209
00:11:18,178 --> 00:11:21,748 line:-2
我之前给你展示过的使用字体的
entitlement来访问这个API


210
00:11:22,683 --> 00:11:26,420 line:-2
那么让我们看看这些API是如何
在两个演示app中使用的


211
00:11:26,486 --> 00:11:27,921 line:-2
让我们从Font
Provider app开始看


212
00:11:28,021 --> 00:11:30,424 line:-2
它是个很简单的app
只有大约20种字体


213
00:11:30,991 --> 00:11:33,760 line:-1
你基本可以按家族注册字体


214
00:11:33,894 --> 00:11:35,929 line:-2
那么我们要做的就是
收集所有字体文件


215
00:11:35,996 --> 00:11:37,664 line:-1
以及指向它们的URL


216
00:11:38,131 --> 00:11:41,768 line:-2
一旦我们准备好了
我们可以调用注册API


217
00:11:42,236 --> 00:11:44,571 line:-1
然后必要时更新UI


218
00:11:45,205 --> 00:11:47,541 line:-1
让我们从查看更新UI的代码开始


219
00:11:48,942 --> 00:11:51,078 line:-2
请注意Font
Consumer app


220
00:11:51,144 --> 00:11:52,246 line:-2
和Font
Provider app


221
00:11:52,412 --> 00:11:55,115 line:-1
都利用了字体通知来更新UI


222
00:11:55,382 --> 00:11:58,218 line:-2
当我们在这个演示中注册字体时
我们要使用同样的技巧


223
00:11:58,819 --> 00:12:02,122 line:-1
要监听这样一条通知非常简单


224
00:12:03,290 --> 00:12:06,093 line:-1
我们告诉通知服务中心


225
00:12:06,159 --> 00:12:10,564 line:-2
观察KCTFontManager注册
注册数量很少


226
00:12:10,631 --> 00:12:12,366 line:-1
RegisterFontsChanged通知


227
00:12:13,634 --> 00:12:17,104 line:-2
一旦我们在选择器中
得到这样一条通知


228
00:12:17,204 --> 00:12:21,241 line:-1
我们要做的就是更新已注册的字体


229
00:12:21,308 --> 00:12:23,076 line:-1
我马上会给你展示相应的代码


230
00:12:23,410 --> 00:12:26,947 line:-2
然后我们更新我们的UI 就像你在
Font Provider app中所看到的那样


231
00:12:27,247 --> 00:12:29,983 line:-2
从根本上说
对于已经注册的字体家族


232
00:12:30,050 --> 00:12:32,753 line:-2
以黑色显示名称
而对于未注册的字体则以红色显示


233
00:12:34,021 --> 00:12:35,122 line:-1
要注册字体


234
00:12:35,422 --> 00:12:40,928 line:-2
我们需要收集代表我们想要注册的
字体家族的字体文件


235
00:12:41,395 --> 00:12:45,165 line:-2
并调用我们的新API
CTFontManagerRegister FontURLs


236
00:12:45,532 --> 00:12:48,769 line:-2
我们传递一个字体URL列表
以及一个范围


237
00:12:48,836 --> 00:12:50,838 line:-2
一个叫做Persistent的
注册范围


238
00:12:50,904 --> 00:12:55,542 line:-2
这是iOS 13中的新功能
它表明了字体在系统范围内可用


239
00:12:56,076 --> 00:12:59,046 line:-1
同时在这个例子中 布尔型标志


240
00:12:59,479 --> 00:13:02,082 line:-1
表示我们希望所有字体在OS上可见


241
00:13:02,816 --> 00:13:04,952 line:-1
API获取一个闭包


242
00:13:05,285 --> 00:13:08,889 line:-2
它需要闭包的原因是
它是个异步API


243
00:13:09,256 --> 00:13:10,691 line:-1
当你注册字体时


244
00:13:11,158 --> 00:13:12,659 line:-1
如果发现报错的话


245
00:13:13,093 --> 00:13:17,931 line:-2
将多次调用你的闭包
这可能是其中一个例子


246
00:13:18,432 --> 00:13:20,133 line:-1
当整个操作完成后


247
00:13:20,534 --> 00:13:22,970 line:-1
闭包中的完成参数就被设为真


248
00:13:23,871 --> 00:13:27,374 line:-2
对于这个演示来说 我在闭包中
要做的唯一一件事就是查找报错


249
00:13:27,474 --> 00:13:28,575 line:-1
我只需要登录进去


250
00:13:28,742 --> 00:13:30,077 line:-1
我不更新我的UI


251
00:13:30,711 --> 00:13:34,114 line:-2
当我更新时 我使用
我依赖于通知机制


252
00:13:34,181 --> 00:13:35,315 line:-1
来更新我的UI


253
00:13:35,782 --> 00:13:39,753 line:-1
一旦我收到通知 我就调用这个方法


254
00:13:39,920 --> 00:13:41,788 line:-1
我会直接调用新API


255
00:13:42,155 --> 00:13:44,658 line:-2
CTFontManagerCopyRegister
FontDescriptors


256
00:13:44,958 --> 00:13:47,561 line:-2
从而了解我的app
提供哪些可用字体


257
00:13:48,128 --> 00:13:49,930 line:-2
一旦我得到了这个信息
接下来就简单了


258
00:13:49,997 --> 00:13:51,965 line:-1
我只需记录字体描述符列表


259
00:13:52,299 --> 00:13:56,303 line:-2
更新我的家族模型
并从那里更新我的UI


260
00:13:57,070 --> 00:13:59,339 line:-1
这个Font Consuming app


261
00:13:59,773 --> 00:14:02,709 line:-2
它是个非常简单的app
功能就是解析文档


262
00:14:03,644 --> 00:14:06,914 line:-1
这种解析文档的app的关键在于


263
00:14:07,781 --> 00:14:09,950 line:-1
随着整个文档的解析


264
00:14:10,017 --> 00:14:12,586 line:-1
你要找出哪些字体可以被实例化


265
00:14:12,653 --> 00:14:16,790 line:-2
并保留一份列表
实际上缺少一个字体流动列表


266
00:14:17,658 --> 00:14:20,727 line:-1
可能会由于用户从未安装过字体


267
00:14:21,261 --> 00:14:24,565 line:-2
或进程中尚不能使用该字体
而导致字体缺失


268
00:14:25,032 --> 00:14:27,334 line:-1
你实际上需要利用新API


269
00:14:27,401 --> 00:14:29,403 line:-1
从OS中请求那些字体


270
00:14:29,970 --> 00:14:33,407 line:-2
一旦拥有了字体 你就可以更新UI
或更新文档了


271
00:14:33,907 --> 00:14:36,543 line:-1
对于一个解析文档的app来说


272
00:14:36,610 --> 00:14:40,214 line:-2
JSON是一种非常简单的
富文本文档压缩格式


273
00:14:41,081 --> 00:14:44,852 line:-2
它的功能是在每次运行时
都尝试实例化一种字体


274
00:14:44,952 --> 00:14:47,321 line:-2
如果它不能实现
它会用Helvetica字体替代


275
00:14:48,288 --> 00:14:49,923 line:-1
但当它替代那种字体时


276
00:14:49,990 --> 00:14:51,992 line:-1
它保留一份它不能执行实例化的


277
00:14:52,059 --> 00:14:53,427 line:-1
所有字体名称的流动标签


278
00:14:54,261 --> 00:14:56,763 line:-2
通过这些 现在我可以创建
使用那些名称的一个列表


279
00:14:56,897 --> 00:14:59,333 line:-1
或一组字体描述符


280
00:14:59,833 --> 00:15:03,036 line:-2
并把那个数组传给
CTFontManagerRequestFont


281
00:15:03,704 --> 00:15:06,707 line:-1
这个API的功能是注意或查看


282
00:15:06,773 --> 00:15:10,644 line:-2
用户是否使用Font
Provider app安装字体


283
00:15:10,777 --> 00:15:14,748 line:-2
如果是 它会让字体
在app上可实例化


284
00:15:15,349 --> 00:15:17,050 line:-1
如果有字体不能进行实例化


285
00:15:17,251 --> 00:15:20,954 line:-2
那些字体将使用你之前看到过的
缺失字体对话框显示


286
00:15:21,989 --> 00:15:23,757 line:-1
API获取一个闭包


287
00:15:24,024 --> 00:15:27,227 line:-1
对于这个app来说 对于可见文档


288
00:15:27,361 --> 00:15:31,899 line:-2
我们只使用任意可用字体
更新所有缺失的字体


289
00:15:32,533 --> 00:15:34,635 line:-1
那么如你所见 对于app来说


290
00:15:34,701 --> 00:15:37,971 line:-2
利用其它app提供的字体
非常直截了当


291
00:15:39,640 --> 00:15:42,442 line:-1
现在我要与你们分享一些注意事项


292
00:15:42,509 --> 00:15:44,678 line:-1
对于字体提供器app来说非常重要


293
00:15:45,846 --> 00:15:51,752 line:-2
首先字体提供器app不能操作
不属于它的字体


294
00:15:52,085 --> 00:15:55,088 line:-1
比如它不能尝试注销


295
00:15:55,155 --> 00:15:57,858 line:-1
其它字体提供器app已注册的字体


296
00:15:58,425 --> 00:16:02,229 line:-1
类似地 字体提供器app不能覆盖


297
00:16:02,663 --> 00:16:05,032 line:-2
其它字体提供器
app使其可用的字体


298
00:16:05,199 --> 00:16:06,867 line:-1
或已安装在系统中的字体


299
00:16:08,168 --> 00:16:11,238 line:-2
OS有关于可以注册
多少种字体的限制


300
00:16:11,738 --> 00:16:13,707 line:-1
并没有固定的数量限制


301
00:16:14,007 --> 00:16:14,908 line:-1
从根本上说


302
00:16:15,242 --> 00:16:17,344 line:-1
取决于由不同的字体提供器


303
00:16:17,411 --> 00:16:18,979 line:-1
所安装的字体类型


304
00:16:19,346 --> 00:16:22,816 line:-1
每种字体都可以使用不同数量的资源


305
00:16:25,285 --> 00:16:28,722 line:-2
以这种方式安装的字体
不参与字体后找


306
00:16:29,590 --> 00:16:33,260 line:-2
从根本上说
它的意思是如果系统确定


307
00:16:33,527 --> 00:16:38,432 line:-1
你的字体是显示指定字体的唯一方法


308
00:16:38,599 --> 00:16:41,735 line:-1
它将不会自动替换并使用


309
00:16:42,169 --> 00:16:44,905 line:-2
实质上唯一方法是指
如果字体按名称引用


310
00:16:44,972 --> 00:16:48,008 line:-1
而使用这些字体的唯一方法


311
00:16:49,109 --> 00:16:53,614 line:-2
最后字体提供器app
拥有它们所安装的字体


312
00:16:54,548 --> 00:16:58,619 line:-2
意思是如果用户删除
安装有字体的app


313
00:16:58,886 --> 00:17:00,921 line:-1
那些字体也会被移除


314
00:17:01,255 --> 00:17:03,123 line:-1
系统确实会警告用户


315
00:17:03,190 --> 00:17:05,959 line:-2
表明他们正在尝试删除
已安装字体的app


316
00:17:06,260 --> 00:17:08,295 line:-1
用户有机会退回


317
00:17:08,896 --> 00:17:11,098 line:-1
这就是我要讲的全部内容


318
00:17:11,365 --> 00:17:13,433 line:-1
但在我离开之前 我想与你们分享


319
00:17:13,500 --> 00:17:15,836 line:-2
下面这个功能
我们对此感到非常激动


320
00:17:16,403 --> 00:17:19,640 line:-1
在OS中安装各种各样字体


321
00:17:19,705 --> 00:17:22,009 line:-2
并且所有app都可以在某个时间点
使用它们


322
00:17:22,309 --> 00:17:25,078 line:-1
这对于创建优质内容来说至关重要


323
00:17:25,145 --> 00:17:26,847 line:-1
通过这个功能


324
00:17:27,181 --> 00:17:30,184 line:-2
我们就可以在平台上解锁
创建优质内容的能力


325
00:17:30,250 --> 00:17:31,718 line:-1
特别是在iPad平台上


326
00:17:32,419 --> 00:17:34,188 line:-1
我要邀请


327
00:17:34,721 --> 00:17:38,091 line:-2
Eric Dudiak上台
他会为大家分享


328
00:17:38,325 --> 00:17:40,360 line:-1
关于在OS中选择字体的一些新技巧


329
00:17:46,867 --> 00:17:48,268 line:-1
大家好 谢谢Julio


330
00:17:48,902 --> 00:17:51,705 line:-2
我是Erik Dudiak
UIKit团队的一名软件工程师


331
00:17:52,606 --> 00:17:55,843 line:-2
我们刚了解了
如何提供和安装自定义字体


332
00:17:56,276 --> 00:17:58,645 line:-1
但你的app可能还想使用那些字体


333
00:17:59,012 --> 00:18:01,281 line:-1
那么让我们看一下如何允许用户


334
00:18:01,548 --> 00:18:04,418 line:-1
选择并使用他们已安装的自定义字体


335
00:18:06,520 --> 00:18:08,555 line:-1
app要做的第一件事可能是


336
00:18:08,622 --> 00:18:11,258 line:-1
尝试在系统上枚举全部可用字体


337
00:18:11,325 --> 00:18:13,227 line:-1
并呈现给用户


338
00:18:13,594 --> 00:18:16,029 line:-1
然后允许用户选择其中一种字体


339
00:18:16,897 --> 00:18:18,999 line:-1
然而在系统上枚举全部字体


340
00:18:19,066 --> 00:18:21,602 line:-1
只能提供内置字体的列表


341
00:18:21,668 --> 00:18:23,904 line:-1
它不能显示任何自定义字体


342
00:18:24,838 --> 00:18:27,474 line:-2
因为这没有考虑到隐私权
所以是不允许显示自定义字体的


343
00:18:29,710 --> 00:18:32,779 line:-1
那么相反 当你的app想允许用户


344
00:18:32,846 --> 00:18:35,249 line:-1
选择他们已安装的其中一种字体时


345
00:18:35,816 --> 00:18:38,252 line:-2
我们在UIKit中提供了一个
新视图控制器


346
00:18:38,385 --> 00:18:41,121 line:-1
即UIFontPickerViewController


347
00:18:43,223 --> 00:18:44,791 line:-1
现在它可以以模态呈现


348
00:18:44,858 --> 00:18:46,760 line:-1
并默认显示


349
00:18:46,827 --> 00:18:48,729 line:-1
你在iOS 13中见过的新表单


350
00:18:49,596 --> 00:18:54,301 line:-2
或者如果是带检查器的
生产力app


351
00:18:54,368 --> 00:18:56,603 line:-1
你可能想把它嵌在侧边栏中


352
00:18:56,670 --> 00:18:58,605 line:-1
字体选择器也支持这个功能


353
00:19:02,376 --> 00:19:04,912 line:-2
那么让我们看一下
UIFontPickerViewController


354
00:19:05,779 --> 00:19:07,047 line:-1
为了安全起见


355
00:19:07,114 --> 00:19:10,050 line:-1
它完全在你的app进程之外运行


356
00:19:11,652 --> 00:19:15,055 line:-1
默认情况下 它还将只显示内置字体


357
00:19:15,389 --> 00:19:19,259 line:-2
你需用一个entitlement
来查看用户所安装的字体


358
00:19:21,495 --> 00:19:24,298 line:-1
用户从字体选择器中选择一种字体后


359
00:19:24,631 --> 00:19:27,301 line:-1
当前app中将可以使用这种字体


360
00:19:27,367 --> 00:19:29,436 line:-1
通过常规的字体API实现


361
00:19:30,671 --> 00:19:35,042 line:-2
然而 只有当用户选择它之后才可用
并且只有用户所选择的字体可用


362
00:19:38,545 --> 00:19:40,714 line:-2
因此 为了方便
所有不同种类的app


363
00:19:40,781 --> 00:19:45,018 line:-2
在UIFontPickerViewController上
有一些很棒的自定义选项


364
00:19:47,454 --> 00:19:51,725 line:-2
比如可能有app
想显示指定faces


365
00:19:52,025 --> 00:19:55,963 line:-2
现在默认情况下
字体选择器将只显示字体家族


366
00:19:56,330 --> 00:19:59,867 line:-2
这类似于比如Mail这样的app
并且许多用户也都熟悉这种方式


367
00:20:00,400 --> 00:20:01,802 line:-1
然而如果你有一个app


368
00:20:01,869 --> 00:20:04,104 line:-1
它有理由显示不同字体的额外比重


369
00:20:04,171 --> 00:20:07,074 line:-1
比如半粗体或中粗体


370
00:20:07,541 --> 00:20:10,744 line:-2
你可以有选择地在字体选择器中
进行配置


371
00:20:11,745 --> 00:20:13,447 line:-1
此外 你的app要选择


372
00:20:13,514 --> 00:20:16,083 line:-2
它是否获得
这里所显示的WYSIWYG呈现


373
00:20:16,517 --> 00:20:18,285 line:-1
或系统字体中所显示的


374
00:20:18,352 --> 00:20:21,321 line:-1
每种字体的更默认的呈现


375
00:20:23,624 --> 00:20:26,226 line:-1
现在 你的app可能还想筛选


376
00:20:26,293 --> 00:20:28,428 line:-1
对用户可用的字体列表


377
00:20:28,996 --> 00:20:30,531 line:-1
你有两种实现方式


378
00:20:31,665 --> 00:20:33,433 line:-1
第一种 你可以按特征筛选


379
00:20:34,501 --> 00:20:37,704 line:-1
如果你的app显示源代码 比如


380
00:20:37,771 --> 00:20:39,239 line:-1
你可能只想查看


381
00:20:39,673 --> 00:20:42,342 line:-1
或只想给用户显示单间距字体


382
00:20:42,543 --> 00:20:45,646 line:-2
因为那样对于查看源代码来说
会更自然


383
00:20:45,979 --> 00:20:49,183 line:-2
在这里我们看到
按特征筛选的筛选条件为仅单间距


384
00:20:52,186 --> 00:20:56,323 line:-2
此外 你的app可能需要让字体
支持特定语种


385
00:20:56,456 --> 00:20:59,793 line:-1
从而在它所使用的情境中能讲得通


386
00:21:00,194 --> 00:21:02,663 line:-2
为此我们提供一个
Filter Predicate API


387
00:21:02,729 --> 00:21:04,464 line:-1
允许你筛选字体所要支持的单一语种


388
00:21:04,531 --> 00:21:06,333 line:-1
或几个语种的组合


389
00:21:06,600 --> 00:21:09,703 line:-1
从而能呈现内容


390
00:21:10,470 --> 00:21:12,539 line:-2
在这个例子中
我们看到字体选择器配置为


391
00:21:12,606 --> 00:21:15,008 line:-1
仅显示支持汉语的字体


392
00:21:19,046 --> 00:21:24,117 line:-2
字体选择器还存在于macOS上
供UIKit app使用


393
00:21:25,419 --> 00:21:27,921 line:-1
如果你只呈现字体选择器


394
00:21:28,222 --> 00:21:30,524 line:-2
而不是我们之前看到过的那个
模态表单呈现


395
00:21:30,791 --> 00:21:32,192 line:-1
你将看到类似这样的东西


396
00:21:32,459 --> 00:21:34,294 line:-1
一个更传统的Mac菜单


397
00:21:36,230 --> 00:21:37,931 line:-1
为了控制


398
00:21:37,998 --> 00:21:40,033 line:-2
这个菜单在你的app中
所呈现的位置


399
00:21:40,100 --> 00:21:42,870 line:-2
因为它应该在用户刚点击过的按钮
上方显示


400
00:21:43,437 --> 00:21:47,407 line:-2
在视图控制器之外使用
UIPopoverPresentationController


401
00:21:47,774 --> 00:21:49,543 line:-1
来选择用于呈现它的视图


402
00:21:51,278 --> 00:21:54,748 line:-1
除此之外 使用菜单的语义学


403
00:21:55,349 --> 00:21:56,817 line:-1
基本类似于视图控制器


404
00:21:59,186 --> 00:22:01,121 line:-1
点击关闭菜单 比如说


405
00:22:01,188 --> 00:22:03,023 line:-1
与遣散视图控制器相同


406
00:22:03,423 --> 00:22:05,826 line:-2
当用户在菜单中
确实选择了一种字体时


407
00:22:06,426 --> 00:22:08,562 line:-1
它将自动发送委托API


408
00:22:08,629 --> 00:22:12,366 line:-2
就像视图控制器通常会做的那样
然后关闭菜单


409
00:22:14,668 --> 00:22:18,472 line:-2
这是在macOS上围绕字体选择
提供一种更传统的体验的方式


410
00:22:18,539 --> 00:22:20,941 line:-1
从而你的app感觉就像是


411
00:22:21,008 --> 00:22:23,177 line:-2
用户期待在常规Mac app上
所期待的app的样子


412
00:22:26,280 --> 00:22:29,616 line:-2
当然 macOS
有额外的字体选择选项


413
00:22:30,350 --> 00:22:33,720 line:-2
以一种macOS
字体面板的形式实现


414
00:22:34,888 --> 00:22:37,925 line:-2
运行在macOS上的
UIKit app支持这种形式


415
00:22:38,325 --> 00:22:41,295 line:-1
它甚至包含在菜单栏的默认选项内


416
00:22:41,562 --> 00:22:43,897 line:-2
因此 用户可以在任意时间
打开或关闭它


417
00:22:44,131 --> 00:22:48,001 line:-2
并在你的app运行的任意时间内
选择不同的字体设置


418
00:22:51,872 --> 00:22:55,876 line:-2
现在你还可以通过程序
控制字体面板的呈现


419
00:22:56,410 --> 00:22:59,847 line:-2
并且你可以通过
UITextFormattingCoordinator访问它


420
00:23:00,314 --> 00:23:02,683 line:-1
你可以在那查看当前是否显示面板


421
00:23:02,950 --> 00:23:05,586 line:-1
并手动打开或关闭它的呈现


422
00:23:08,856 --> 00:23:11,859 line:-1
由于字体面板的非模态本质


423
00:23:12,526 --> 00:23:15,295 line:-1
当你的app在macOS上运行时


424
00:23:15,362 --> 00:23:17,030 line:-1
有一些注意事项


425
00:23:17,865 --> 00:23:21,969 line:-2
来自字体面板的变更
将贯穿响应器链


426
00:23:22,970 --> 00:23:26,707 line:-2
当使用标准UIKit控制时
系统会替你自动处理它


427
00:23:27,641 --> 00:23:30,577 line:-2
通过UITextFormattingCoordinator
实现


428
00:23:31,144 --> 00:23:34,014 line:-2
事实上 共享的
UITextFormattingCoordinator


429
00:23:34,081 --> 00:23:37,885 line:-2
甚至可以被用作我们之前看到过的
字体选择器的委托


430
00:23:38,085 --> 00:23:42,256 line:-2
因此你还可以通过响应器链
为那些变更指明路线


431
00:23:43,724 --> 00:23:46,693 line:-2
然而 如果你的app中
有自定义UI响应器


432
00:23:47,461 --> 00:23:48,295 line:-1
你可能需要采用


433
00:23:48,362 --> 00:23:51,331 line:-2
一些新
UIResponderStandardEditActions


434
00:23:51,431 --> 00:23:53,967 line:-1
协议方法 以便当字体通过字体面板


435
00:23:54,401 --> 00:23:56,670 line:-1
发生变更时收到通知


436
00:23:57,971 --> 00:24:01,842 line:-2
这将允许你的自定义响应器
相应地更新它们的显示


437
00:24:04,912 --> 00:24:07,848 line:-2
现在让我们快速看一个演示
看这些是如何运作的


438
00:24:14,521 --> 00:24:16,790 line:-1
很棒 这是Font Consuming app


439
00:24:17,524 --> 00:24:19,660 line:-2
在这里我们看到
它已经使用了自定义字体


440
00:24:20,294 --> 00:24:21,862 line:-1
但这个app的一个很棒的功能是


441
00:24:21,929 --> 00:24:25,499 line:-1
它还让客户选择他们想看到的字体


442
00:24:25,766 --> 00:24:27,568 line:-1
而不仅仅是显示字体


443
00:24:27,868 --> 00:24:29,603 line:-1
我们可以随时修改文档字体


444
00:24:30,204 --> 00:24:33,207 line:-1
我只需要按这个修改标题按钮即可


445
00:24:34,441 --> 00:24:38,178 line:-2
我按下这个按钮时
我们看到我得到了字体选择器


446
00:24:39,279 --> 00:24:41,849 line:-2
我得到了一个
我最近用过的字体的列表


447
00:24:41,915 --> 00:24:45,285 line:-2
我还可以进行搜索并扫描
从而寻找我想要的那个字体


448
00:24:47,120 --> 00:24:51,525 line:-2
现在我们已经把它自定义为
显示额外的faces


449
00:24:51,859 --> 00:24:54,127 line:-2
因此我可以看到
指定字体的任意faces


450
00:24:54,695 --> 00:24:58,398 line:-1
我要扫描它并找到我想要的那种字体


451
00:24:59,266 --> 00:25:00,167 line:-1
让我们看一下


452
00:25:00,601 --> 00:25:01,602 line:-1
让我们使用Papyrus字体


453
00:25:02,603 --> 00:25:05,138 line:-1
太棒了 我可以像那样修改标题


454
00:25:06,406 --> 00:25:08,475 line:-2
并且你可以在任意app中
实现这个功能


455
00:25:08,542 --> 00:25:12,479 line:-2
提供很棒的标准控制
可以让用户在iOS上变得习惯


456
00:25:13,914 --> 00:25:16,783 line:-2
当然 当然 因为这是一款
iPad app


457
00:25:16,850 --> 00:25:18,585 line:-1
我们还可以把它引入到macOS上


458
00:25:19,753 --> 00:25:20,621 line:-1
在这里我们可以看到


459
00:25:21,021 --> 00:25:24,892 line:-2
这与我刚在iPadOS上展示的
那个app是同一个app


460
00:25:25,158 --> 00:25:26,960 line:-1
现在它运行在macOS上


461
00:25:28,228 --> 00:25:29,930 line:-1
现在因为我们没有太多地自定义


462
00:25:29,997 --> 00:25:34,001 line:-1
如何呈现标题菜单的字体选择器


463
00:25:34,568 --> 00:25:36,870 line:-1
如果我继续并按下同一个按钮


464
00:25:37,104 --> 00:25:39,606 line:-1
而不修改app的任何代码


465
00:25:40,107 --> 00:25:43,410 line:-2
我们可以看到它没有显示
当我在iPadOS上运行时


466
00:25:43,477 --> 00:25:46,747 line:-2
所看到的字体选择器ViewController
而是得到了一个菜单


467
00:25:47,848 --> 00:25:49,983 line:-1
在那个菜单中 我仍能得到许多


468
00:25:50,050 --> 00:25:52,953 line:-2
与iPadOS上运行字体选择器时
得到的功能相同的功能


469
00:25:53,020 --> 00:25:54,321 line:-1
我仍能在顶部看到Recents


470
00:25:54,721 --> 00:25:56,757 line:-1
并且我仍能选择单个face


471
00:25:57,157 --> 00:25:59,493 line:-2
我也仍能得到那个
WYSIWYG呈现


472
00:25:59,560 --> 00:26:02,796 line:-2
从而我能很好地了解我所选择的字体
到底看起来是什么样子


473
00:26:03,530 --> 00:26:05,966 line:-2
在这个例子中 我要继续并选择
Comic Sans


474
00:26:08,735 --> 00:26:10,971 line:-1
现在我们已经在app中实现了


475
00:26:11,271 --> 00:26:12,639 line:-2
当在macOS上运行时的一些
额外自定义


476
00:26:12,973 --> 00:26:15,209 line:-1
因为我们可以使用字体面板了


477
00:26:15,676 --> 00:26:18,312 line:-1
我们可以继续并更新这里的正文


478
00:26:18,679 --> 00:26:19,947 line:-1
从而响应


479
00:26:20,013 --> 00:26:21,915 line:-1
来自字体面板中的任意变更


480
00:26:22,816 --> 00:26:26,186 line:-2
我们实现这个功能之后
我们还可以让修改正文按钮


481
00:26:26,753 --> 00:26:28,422 line:-2
在macOS上运行时
不显示字体选择器


482
00:26:28,655 --> 00:26:31,091 line:-1
而是显示字体面板


483
00:26:32,526 --> 00:26:34,394 line:-1
这可以让我们做一些额外自定义


484
00:26:35,262 --> 00:26:38,198 line:-2
我可以像在字体选择器中所做的那样
修改字体


485
00:26:38,999 --> 00:26:42,135 line:-2
但在macOS上 我还可以在这里
做一些额外的格式修改


486
00:26:42,636 --> 00:26:46,206 line:-2
我可以修改 比如说文本大小
或甚至是文本颜色


487
00:26:48,742 --> 00:26:51,712 line:-2
这在macOS上提供了一种
非常丰富的体验


488
00:26:51,778 --> 00:26:54,481 line:-2
这种体验是多年以来用户所习惯的
Mac app的体验


489
00:26:56,483 --> 00:26:58,018 line:-1
太棒了 这是我们的示例app


490
00:26:58,085 --> 00:27:00,654 line:-2
让我们看一下
我们是如何在代码中实现的


491
00:27:06,426 --> 00:27:08,795 line:-2
首先让我们看一下
如何创建字体选择器


492
00:27:09,196 --> 00:27:12,599 line:-1
首先第一步是给它创建一个配置


493
00:27:13,333 --> 00:27:15,636 line:-1
在这个例子中 我们实例化配置对象


494
00:27:16,103 --> 00:27:19,640 line:-2
并告诉它当我们显示字体选择器时
我们想包含faces


495
00:27:21,775 --> 00:27:23,110 line:-1
设置好配置之后


496
00:27:23,477 --> 00:27:26,613 line:-2
我们现在可以创建字体选择器
并传入那个配置


497
00:27:27,414 --> 00:27:30,217 line:-1
配置将决定字体选择器


498
00:27:30,284 --> 00:27:32,219 line:-1
在它的整个生命周期中的行为


499
00:27:33,554 --> 00:27:36,323 line:-2
我们还把我们自己设为
字体选择器的委托


500
00:27:36,590 --> 00:27:38,959 line:-2
从而当用户选择字体时
我们得到所有的回调


501
00:27:40,961 --> 00:27:43,463 line:-1
最后我们只需要呈现字体选择器即可


502
00:27:43,530 --> 00:27:45,132 line:-1
就像我们呈现其它视图控制器一样


503
00:27:49,036 --> 00:27:50,504 line:-1
现在 在委托回调中


504
00:27:50,838 --> 00:27:53,607 line:-1
我们看到我们可以获得


505
00:27:53,841 --> 00:27:56,443 line:-2
用户直接从字体选择器中
所选择的字体


506
00:27:57,177 --> 00:27:59,913 line:-2
在这里我们看到当用户
确实选择了一种字体时的委托回调


507
00:28:00,681 --> 00:28:01,715 line:-1
在这个例子中


508
00:28:01,782 --> 00:28:04,651 line:-2
我们把用户所选择的字体
从字体选择器中取出来


509
00:28:04,985 --> 00:28:07,988 line:-2
并把它发送给你app中的一个
属性化字符串


510
00:28:09,790 --> 00:28:11,825 line:-1
当然 如果用户取消选择字体


511
00:28:11,892 --> 00:28:13,193 line:-1
我们也会收到通知


512
00:28:13,260 --> 00:28:16,630 line:-2
因此我们可以针对取消
做出恰当和必要的修改


513
00:28:19,666 --> 00:28:21,802 line:-1
最后让我们看一下自定义响应器代码


514
00:28:21,902 --> 00:28:25,172 line:-2
这是当在macOS上运行时
我们处理字体面板的方式


515
00:28:25,706 --> 00:28:28,108 line:-1
在这个例子中 我们实施了一个方法


516
00:28:28,942 --> 00:28:32,980 line:-1
它让我们了解用户何时更改了


517
00:28:33,046 --> 00:28:33,981 line:-1
我们应该使用的属性


518
00:28:34,815 --> 00:28:37,351 line:-2
我们不仅仅是获得
他们所修改的一组属性


519
00:28:37,417 --> 00:28:39,086 line:-1
我们实际上会得到这个便利的闭包


520
00:28:39,620 --> 00:28:42,155 line:-1
它包含我们当前所拥有的一组属性


521
00:28:42,456 --> 00:28:44,358 line:-1
并在用户做出修改之后


522
00:28:44,525 --> 00:28:46,860 line:-1
传出应该传出的一组属性


523
00:28:47,594 --> 00:28:49,830 line:-1
这么做的原因是


524
00:28:49,897 --> 00:28:51,832 line:-1
根据用户所做的修改


525
00:28:51,899 --> 00:28:53,367 line:-2
当前属性可能会保持相同
或可能发生改变


526
00:28:53,867 --> 00:28:56,270 line:-1
比如 如果当前设置了下划线


527
00:28:57,104 --> 00:28:59,940 line:-1
那么用户修改文本的前景颜色


528
00:29:00,207 --> 00:29:01,708 line:-1
不应该改变下划线效果


529
00:29:02,209 --> 00:29:06,547 line:-2
在这个例子中
conversionHandler会替我们实现


530
00:29:10,417 --> 00:29:12,886 line:-1
让我们快速回顾一下字体选择


531
00:29:13,887 --> 00:29:16,356 line:-2
当我们想要显示用户字体时
在iOS、iPadOS


532
00:29:17,157 --> 00:29:21,395 line:-2
甚至macOS上有一个新视图控制器
UIFontPickerViewController


533
00:29:21,595 --> 00:29:26,266 line:-1
而不是在系统上枚举所有的字体


534
00:29:27,334 --> 00:29:31,572 line:-2
此外 在macOS上运行
UIKit app时使用字体面板


535
00:29:32,239 --> 00:29:33,941 line:-1
其中涉及一些额外的注意事项


536
00:29:34,775 --> 00:29:37,578 line:-2
因为自定义响应器可能需要处理
属性变更


537
00:29:37,644 --> 00:29:39,880 line:-2
app运行时
随时可能会发生属性变更


538
00:29:41,248 --> 00:29:43,450 line:-1
标准文本视图将自动处理这个问题


539
00:29:45,452 --> 00:29:47,221 line:-1
现在我想邀请Donna上台来


540
00:29:47,721 --> 00:29:50,858 line:-1
她会讲Apple跨平台文本缩放


541
00:29:55,929 --> 00:29:56,830 line:-1
谢谢Eric


542
00:30:00,167 --> 00:30:02,469 line:-1
文本缩放是我们在iOS 13


543
00:30:02,803 --> 00:30:05,239 line:-2
和macOS Catalina中
引入的一个新概念


544
00:30:05,606 --> 00:30:08,242 line:-1
今天我们要讲如何使用这个新概念


545
00:30:08,308 --> 00:30:10,310 line:-1
来确保app中的文本尺寸


546
00:30:10,477 --> 00:30:11,812 line:-1
处处保持一致


547
00:30:13,714 --> 00:30:15,048 line:-1
现在作为iOS开发人员


548
00:30:15,215 --> 00:30:17,718 line:-1
你很可能非常熟悉人机界面指南


549
00:30:18,452 --> 00:30:21,255 line:-1
这是指南中的一个表


550
00:30:21,321 --> 00:30:22,890 line:-1
它显示了默认动态排版的文本尺寸


551
00:30:23,857 --> 00:30:27,961 line:-2
UIKit app中的大多数文本
都使用正文文本样式 也就是17点


552
00:30:29,863 --> 00:30:31,365 line:-1
在iPad上看起来是这样的


553
00:30:31,765 --> 00:30:32,933 line:-1
读起来很容易 对吗？


554
00:30:35,802 --> 00:30:38,372 line:-2
你再看看Mac上
同样是17点的文本


555
00:30:38,672 --> 00:30:40,107 line:-1
看起来有那么点不一样


556
00:30:42,042 --> 00:30:43,544 line:-1
当你把这两个并排放在一起时


557
00:30:43,777 --> 00:30:45,179 line:-1
你可以看到通过对比


558
00:30:45,445 --> 00:30:48,315 line:-1
Mac上的17点文本看起来大一些


559
00:30:50,884 --> 00:30:52,419 line:-1
那是因为在Mac上


560
00:30:52,753 --> 00:30:54,988 line:-1
我们更习惯于较小的默认文本尺寸


561
00:30:55,289 --> 00:30:56,990 line:-2
接近13点
就像这里显示的这些文本


562
00:30:59,092 --> 00:31:01,261 line:-1
但如果我们把同样的13点文本


563
00:31:01,762 --> 00:31:03,096 line:-1
放在iPad上看


564
00:31:04,831 --> 00:31:07,167 line:-1
它看起来很小 读起来很费劲


565
00:31:07,835 --> 00:31:10,470 line:-1
这种不一致已经存在很长时间了


566
00:31:11,138 --> 00:31:15,709 line:-2
我们选择17点作为iOS中
可视键入缩放的基础尺寸


567
00:31:15,943 --> 00:31:19,780 line:-2
从而使文本易读并易于在触摸屏幕上
进行交互


568
00:31:21,415 --> 00:31:22,449 line:-1
但随着技术的进步


569
00:31:22,749 --> 00:31:25,819 line:-1
跨平台用户体验变得越来越重要了


570
00:31:26,720 --> 00:31:28,689 line:-2
现在你可以把你的iPad app
引入到Mac中了


571
00:31:29,122 --> 00:31:31,158 line:-2
用户一定会注意到
文本尺寸的不同之处


572
00:31:31,258 --> 00:31:33,794 line:-2
当你在Mac上同时运行
iPad app和AppKit app时


573
00:31:34,261 --> 00:31:38,432 line:-2
当在app之间复制和粘贴文本时
以及当并排浏览文档时


574
00:31:40,167 --> 00:31:43,604 line:-2
我们要如何让文本尺寸
处处保持一致呢？


575
00:31:44,238 --> 00:31:48,008 line:-2
理想情况是 如果我们正在浏览
同样字体和尺寸的同一段文本


576
00:31:48,408 --> 00:31:49,843 line:-1
我们希望它看起来类似这样


577
00:31:50,477 --> 00:31:52,613 line:-1
可视缩放适合每个平台


578
00:31:52,980 --> 00:31:55,148 line:-1
这里其实有两种不同的可视缩放


579
00:31:56,750 --> 00:31:59,186 line:-2
一种是用于iOS
和iPadOS上的缩放


580
00:31:59,419 --> 00:32:01,221 line:-1
默认尺寸为17点


581
00:32:01,622 --> 00:32:03,590 line:-1
我们把它叫做iOS文本缩放


582
00:32:05,692 --> 00:32:08,795 line:-2
然后还有用于macOS和其它
非Apple平台上的缩放


583
00:32:09,029 --> 00:32:11,331 line:-1
默认尺寸接近于13点


584
00:32:11,698 --> 00:32:13,333 line:-1
我们把这个叫做标准文本缩放


585
00:32:15,002 --> 00:32:18,639 line:-2
我们希望你们作为开发人员
能了解这两种不同的文本缩放


586
00:32:19,139 --> 00:32:22,676 line:-1
并恰当地使用标准文本缩放


587
00:32:22,910 --> 00:32:24,645 line:-1
如果它能改善跨平台用户体验的话


588
00:32:25,212 --> 00:32:27,281 line:-1
现在让我们看一些例子


589
00:32:29,183 --> 00:32:31,084 line:-1
首先是Mac上的iPad app


590
00:32:33,220 --> 00:32:35,789 line:-1
因为UITextViews是选择


591
00:32:36,123 --> 00:32:37,624 line:-1
显示大量文本的控件


592
00:32:37,925 --> 00:32:39,993 line:-1
你最可能在这里注意到其中的差异


593
00:32:40,894 --> 00:32:43,130 line:-1
我们想为你提供一种简单的解决方式


594
00:32:45,399 --> 00:32:48,402 line:-2
因此在iOS 13中
我们向UITextView中添加了一个新属性


595
00:32:48,735 --> 00:32:50,671 line:-1
叫做usesStandardTextScaling


596
00:32:51,038 --> 00:32:52,105 line:-1
打开它时


597
00:32:52,472 --> 00:32:55,475 line:-1
UIKit将在文本视图内


598
00:32:55,542 --> 00:32:56,510 line:-1
自动调整文本的渲染


599
00:32:56,577 --> 00:32:57,945 line:-1
以匹配标准文本缩放


600
00:32:59,713 --> 00:33:00,881 line:-1
让我们返回到这里的文本


601
00:33:01,515 --> 00:33:03,584 line:-2
我们可以看到缩放看起来稍微
有点偏了 好的


602
00:33:04,484 --> 00:33:07,321 line:-2
让我们看一下打开
usesStandardTextScaling时会发生什么


603
00:33:10,424 --> 00:33:11,792 line:-1
啊 看起来好多了


604
00:33:12,993 --> 00:33:15,829 line:-1
使用这个新属性的确是一个


605
00:33:15,996 --> 00:33:18,565 line:-2
确保文本
以标准文本缩放显示的好方法


606
00:33:20,434 --> 00:33:24,238 line:-2
但请注意usesStandardTextScaling
默认情况下是关闭的


607
00:33:24,838 --> 00:33:27,841 line:-2
那是因为在文本视图上
使用自定义转换的代码


608
00:33:27,908 --> 00:33:30,511 line:-2
可能没有预见到当与这个属性
相结合时所产生的结果


609
00:33:31,311 --> 00:33:33,046 line:-1
因此如果你想使用标准文本缩放


610
00:33:33,146 --> 00:33:35,315 line:-2
请确保你给每个文本视图
都启用了这个功能


611
00:33:37,384 --> 00:33:39,786 line:-1
接下来我们讲复制粘贴的文本缩放


612
00:33:40,787 --> 00:33:42,890 line:-1
现在因为iOS使用独特的文本缩放


613
00:33:43,190 --> 00:33:45,058 line:-1
你可能注意到这个可视尺寸差异了


614
00:33:45,125 --> 00:33:48,161 line:-2
当在UIKit和AppKit app之间
复制和粘贴文本时


615
00:33:48,629 --> 00:33:50,364 line:-1
如果你曾用过通用剪贴板


616
00:33:50,430 --> 00:33:52,065 line:-1
你实际上可能早就注意到这个问题了


617
00:33:53,467 --> 00:33:56,303 line:-2
嗯 好消息是你现在实际上不需要
做任何事就能获得这个功能


618
00:33:57,304 --> 00:33:58,405 line:-1
从最新版OS开始


619
00:33:58,472 --> 00:34:01,341 line:-2
你可以免费使用
视觉效果一致的复制和粘贴功能


620
00:34:02,743 --> 00:34:04,144 line:-1
让我们看一下它是如何运作的


621
00:34:04,578 --> 00:34:05,846 line:-1
这是两个平台


622
00:34:06,146 --> 00:34:08,382 line:-1
左侧是iOS 右侧是macOS


623
00:34:10,117 --> 00:34:11,385 line:-1
在每个平台上


624
00:34:11,685 --> 00:34:15,188 line:-2
复制和粘贴都在系统的两个
不同层级之间移动文本


625
00:34:15,656 --> 00:34:18,058 line:-1
这里的小跑步者代表运行时层


626
00:34:18,458 --> 00:34:20,928 line:-1
而这些磁盘代表持久层


627
00:34:22,963 --> 00:34:26,766 line:-2
运行时层中文本视图中的文本
作为一个属性化的字符串


628
00:34:27,467 --> 00:34:28,668 line:-1
当你复制那段文本时


629
00:34:29,036 --> 00:34:31,271 line:-1
它从运行时层的文本视图中移出来


630
00:34:31,538 --> 00:34:33,172 line:-1
并进入持久层的粘贴板中


631
00:34:33,639 --> 00:34:37,511 line:-2
并且把它序列化为富文本格式或叫做
RTF格式 用于存储在粘贴板上


632
00:34:39,847 --> 00:34:40,947 line:-1
在最新版OS上


633
00:34:41,047 --> 00:34:44,418 line:-2
我们给属性化字符串API添加了
新行为 它会写RTF


634
00:34:44,952 --> 00:34:47,888 line:-2
因此当你从属性化字符串中
创建RTF时


635
00:34:48,121 --> 00:34:51,358 line:-2
它将添加表示它所使用的
文本缩放的元数据


636
00:34:53,193 --> 00:34:55,429 line:-1
现在当在iOS上复制文本时


637
00:34:55,562 --> 00:34:57,865 line:-1
文本会用那个元数据进行自动标记


638
00:34:57,931 --> 00:35:00,234 line:-1
这个表示它使用了iOS文本缩放


639
00:35:03,504 --> 00:35:05,072 line:-1
现在我们还在属性化字符串上


640
00:35:05,138 --> 00:35:07,674 line:-2
给RTF读取API
添加了另一个新行为


641
00:35:08,542 --> 00:35:10,978 line:-2
因此当你从RTF
创建归属性字符串时


642
00:35:11,311 --> 00:35:13,313 line:-1
系统将查找那个文本缩放元数据


643
00:35:13,580 --> 00:35:16,116 line:-1
如果需要 它会替你调整文本尺寸


644
00:35:18,218 --> 00:35:21,221 line:-2
返回到我们的原始文本中
我们在iOS上复制了那段文本


645
00:35:21,655 --> 00:35:22,823 line:-1
当我们把它粘贴到Mac上时


646
00:35:23,090 --> 00:35:26,760 line:-2
系统看到元数据表明
它正在使用iOS文本缩放


647
00:35:27,294 --> 00:35:30,364 line:-2
然后系统会在属性字符串中
调整文本尺寸


648
00:35:30,631 --> 00:35:32,666 line:-1
从而当文本在Mac上显示时


649
00:35:32,933 --> 00:35:36,236 line:-2
它看起来
与iOS中的原始文本尺寸相似


650
00:35:38,505 --> 00:35:41,475 line:-2
最终结果跟之前的这个例子
看起来非常像


651
00:35:42,342 --> 00:35:43,877 line:-1
但字体尺寸不一样


652
00:35:44,945 --> 00:35:48,515 line:-2
我们在iOS上复制的原始文本尺寸
是17点


653
00:35:49,783 --> 00:35:52,986 line:-2
而我们在Mac上粘贴的文本尺寸
是13点


654
00:35:55,088 --> 00:35:57,624 line:-1
两个平台上拥有不同的字体尺寸


655
00:35:57,691 --> 00:35:58,992 line:-1
对于复制和粘贴来说已经没问题了


656
00:35:59,293 --> 00:36:01,228 line:-1
因为字体尺寸信息是临时信息


657
00:36:01,628 --> 00:36:03,297 line:-1
它只存在于运行时层中


658
00:36:04,198 --> 00:36:07,467 line:-1
但RTF也是一种文档格式


659
00:36:07,534 --> 00:36:09,002 line:-2
这对于存储层的持久性来说
并不是个好方案


660
00:36:10,838 --> 00:36:12,406 line:-1
这是我们的最后一种情况


661
00:36:12,673 --> 00:36:14,908 line:-1
用于文档互换的文本缩放


662
00:36:16,643 --> 00:36:19,079 line:-1
我们在这里权衡特殊考虑


663
00:36:19,313 --> 00:36:21,648 line:-1
从而平衡跨平台视觉一致性的渴望


664
00:36:22,783 --> 00:36:24,985 line:-1
与在文档模型完整性的需要


665
00:36:27,354 --> 00:36:29,690 line:-1
为了让文本在不同平台上看起来一样


666
00:36:29,857 --> 00:36:31,959 line:-1
同时也在文档中保持同样的文本尺寸


667
00:36:32,292 --> 00:36:36,163 line:-2
我们所需要的其实就是浏览文档时
使用一种文本缩放


668
00:36:36,663 --> 00:36:38,232 line:-1
并在保存它时使用另一种文本缩放


669
00:36:40,267 --> 00:36:42,269 line:-1
我们有两种不同的实现方式


670
00:36:42,636 --> 00:36:43,971 line:-1
我们可以修改文档模型


671
00:36:44,037 --> 00:36:46,340 line:-1
并对浏览和保存使用不同的文本尺寸


672
00:36:47,007 --> 00:36:50,544 line:-2
或者我们可以通过修改渲染缩放
来修改文档视图


673
00:36:50,878 --> 00:36:52,779 line:-1
并在保存时保持相同的文本尺寸


674
00:36:54,515 --> 00:36:57,117 line:-2
我们实际上对RTF
实施了全部两种方法


675
00:36:57,518 --> 00:37:00,120 line:-1
因为这是我们内部常用的格式


676
00:37:01,021 --> 00:37:02,356 line:-1
我希望与你分享


677
00:37:02,422 --> 00:37:04,424 line:-2
我们为了实现这个功能
所采用的基本技巧


678
00:37:04,691 --> 00:37:06,260 line:-1
从而你可以采用其中一些技巧


679
00:37:06,460 --> 00:37:07,928 line:-1
在你自己的流程和文档格式中


680
00:37:08,061 --> 00:37:10,197 line:-1
创建文本缩放支持


681
00:37:12,099 --> 00:37:14,701 line:-2
我们所做的第一件事是
扩展我们的格式


682
00:37:14,868 --> 00:37:17,037 line:-1
从而用那个文本缩放元数据标记文档


683
00:37:17,638 --> 00:37:20,240 line:-1
文档解析器和浏览器需要这个信息


684
00:37:20,307 --> 00:37:22,809 line:-1
来理解文档正在使用哪种文本缩放


685
00:37:24,811 --> 00:37:27,481 line:-2
因为早已存在的文档
不会拥有这个元数据


686
00:37:27,548 --> 00:37:29,716 line:-2
我们还需要把它们迁移出来
从而让它们使用新格式


687
00:37:30,551 --> 00:37:32,686 line:-1
对于RTF 这个过程是自动发生的


688
00:37:32,786 --> 00:37:34,821 line:-2
当文档在最新版OS上保存时
会自动使用新格式


689
00:37:37,424 --> 00:37:38,992 line:-1
现在我们还需要确保


690
00:37:39,159 --> 00:37:41,962 line:-2
我们的文档拥有与之相匹配的
正确的文本缩放


691
00:37:42,362 --> 00:37:44,865 line:-1
这对于初始迁移来说尤其重要


692
00:37:45,732 --> 00:37:48,035 line:-2
因此 我们引入了一个新的
属性化字符串API


693
00:37:48,101 --> 00:37:50,537 line:-1
以新文档属性形式提供帮助


694
00:37:52,806 --> 00:37:54,975 line:-1
现在你可以使用文本缩放文档属性


695
00:37:55,042 --> 00:37:57,010 line:-1
在保存时设置文档中的元数据


696
00:37:57,477 --> 00:38:00,214 line:-2
使用属性化字符串编写API
比如来自范围的数据


697
00:38:02,049 --> 00:38:04,184 line:-2
如果需要 当你保存文档时
你还可以把文档转化为


698
00:38:04,251 --> 00:38:06,053 line:-1
特定的文本缩放格式


699
00:38:06,653 --> 00:38:09,556 line:-2
你可以通过
同时指定两个新文档属性实现


700
00:38:12,326 --> 00:38:13,560 line:-1
对于基于模型的方法


701
00:38:13,627 --> 00:38:15,329 line:-1
我们需要一种能控制当打开文档时


702
00:38:15,395 --> 00:38:17,431 line:-1
不同文本缩放格式之间的转换的方式


703
00:38:17,998 --> 00:38:21,435 line:-2
为此我们引入了更多的
属性化字符串API


704
00:38:21,835 --> 00:38:24,771 line:-2
还有用于目标和源文本缩放的
新的读取选项


705
00:38:26,440 --> 00:38:28,408 line:-1
并且你可以控制使用哪种文本缩放


706
00:38:28,742 --> 00:38:32,045 line:-2
通过在从RTF文档中
创建属性化字符串时


707
00:38:32,212 --> 00:38:33,313 line:-1
指定这些读取选项实现


708
00:38:35,549 --> 00:38:37,184 line:-1
最后对于基于视图的方法


709
00:38:37,251 --> 00:38:39,353 line:-1
我们推荐使用标准文本缩放


710
00:38:40,187 --> 00:38:43,257 line:-2
现在对于RTF文档
你可以通过结合新API实现


711
00:38:43,624 --> 00:38:45,893 line:-2
当你把RTF读取到一个
属性化字符串中时


712
00:38:45,959 --> 00:38:48,395 line:-1
你首先把目标文本缩放设置为标准


713
00:38:49,596 --> 00:38:52,099 line:-2
然后在文本视图上设置
usesStandardTextScaling


714
00:38:52,165 --> 00:38:54,201 line:-1
它会显示文档


715
00:38:56,370 --> 00:38:57,404 line:-1
哦 好的


716
00:38:57,804 --> 00:38:59,106 line:-1
我们今天讲了很多内容


717
00:38:59,640 --> 00:39:01,275 line:-2
现在作为一个提醒
这是你今天所了解到的内容


718
00:39:01,942 --> 00:39:04,344 line:-2
iOS app现在可以使字体
在系统范围内可用了


719
00:39:05,078 --> 00:39:07,648 line:-1
仅对非系统字体使用名称实例化


720
00:39:08,248 --> 00:39:11,218 line:-1
请记住 名称实例化并不保险


721
00:39:12,219 --> 00:39:14,621 line:-1
请使用按需资源向OS提交字体


722
00:39:14,888 --> 00:39:18,258 line:-2
请使用标准文本缩放
以获取最佳跨平台用户体验


723
00:39:19,860 --> 00:39:22,129 line:-2
请参加几个小时后的
文本和字体演讲


724
00:39:22,262 --> 00:39:24,398 line:-2
你可以了解与我们今天在这里
所讲的话题相关的更多内容


725
00:39:24,898 --> 00:39:27,568 line:-2
你还可以在iPad app
和Mac演讲上找到我们


726
00:39:27,734 --> 00:39:29,436 line:-1
并了解关于文本缩放的更多信息


727
00:39:30,470 --> 00:39:33,307 line:-2
我们真的非常期待你们用这些新功能
创建出什么样的体验


728
00:39:33,640 --> 00:39:35,242 line:-1
谢谢 祝你们享受余下的会议时光

