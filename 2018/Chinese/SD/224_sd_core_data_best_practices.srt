1
00:00:07,016 --> 00:00:15,500
[ 音乐 ]


2
00:00:21,416 --> 00:00:21,976
>> 大家下午好


3
00:00:22,516 --> 00:00:27,406
[ 掌声 ]


4
00:00:27,906 --> 00:00:29,096
欢迎来到


5
00:00:29,096 --> 00:00:29,806
核心数据最佳实践


6
00:00:29,926 --> 00:00:30,886
我叫 Scott Perry


7
00:00:30,886 --> 00:00:32,016
在核心数据工作


8
00:00:32,466 --> 00:00:33,776
一会儿也会请到我的同事


9
00:00:33,776 --> 00:00:35,016
Nick Gillett 加入


10
00:00:36,516 --> 00:00:39,286
今天我们计划 


11
00:00:39,286 --> 00:00:40,886
首先从核心数据是如何


12
00:00:40,886 --> 00:00:41,866
随着时间的推移


13
00:00:41,866 --> 00:00:43,216
进行优化开始讲起


14
00:00:43,956 --> 00:00:45,946
然后我们将讲到一些


15
00:00:45,946 --> 00:00:47,346
通过利用持久化容器


16
00:00:47,346 --> 00:00:48,706
里的扩展点


17
00:00:48,706 --> 00:00:49,886
来更简单地


18
00:00:49,886 --> 00:00:50,836
优化 App 的方法


19
00:00:51,486 --> 00:00:53,556
接着会介绍


20
00:00:53,556 --> 00:00:55,026
当 App 的要求发生变化


21
00:00:55,026 --> 00:00:56,676
以及数据量增大时


22
00:00:56,676 --> 00:00:57,236
该如何优化我们的 App


23
00:00:59,106 --> 00:01:00,666
随后 Nick 将谈到


24
00:01:00,666 --> 00:01:01,946
几种使我们的 App 


25
00:01:01,946 --> 00:01:03,226
保持性能的方法


26
00:01:03,226 --> 00:01:04,726
即使它超过了我们的想象


27
00:01:04,726 --> 00:01:07,666
最后我们将用


28
00:01:08,406 --> 00:01:09,196
转换器


29
00:01:09,196 --> 00:01:11,046
调试和测试来收尾


30
00:01:11,586 --> 00:01:15,976
但是首先 我们先创建一个 App


31
00:01:15,976 --> 00:01:17,716
我很喜欢拍照 我们


32
00:01:17,716 --> 00:01:18,416
创建一个能让我


33
00:01:18,416 --> 00:01:19,486
和朋友们分享照片


34
00:01:19,486 --> 00:01:21,746
并得到反馈的 App


35
00:01:21,746 --> 00:01:22,946
即使只是 Nick 在问


36
00:01:22,946 --> 00:01:25,316
我的幻灯片放得怎么样


37
00:01:26,236 --> 00:01:28,406
我们该如何保留 App 的数据呢


38
00:01:28,586 --> 00:01:30,016
我们可以将它存在网上


39
00:01:30,016 --> 00:01:31,456
但是我通常都


40
00:01:31,456 --> 00:01:32,776
在旅行时拍照


41
00:01:32,776 --> 00:01:33,696
网络连接可能会不稳定


42
00:01:33,696 --> 00:01:35,756
我们需要存在本地


43
00:01:35,756 --> 00:01:37,736
将它整合进存储器里


44
00:01:40,296 --> 00:01:42,596
我们现在有贴文 评论


45
00:01:42,596 --> 00:01:44,006
以及它们的实例 


46
00:01:44,006 --> 00:01:45,606
二者之间的关系形成了一个


47
00:01:45,606 --> 00:01:47,386
对象图


48
00:01:47,386 --> 00:01:48,846
我们决定将它们保存在


49
00:01:48,846 --> 00:01:52,316
磁盘上


50
00:01:52,316 --> 00:01:53,096
这就该核心数据上场了


51
00:01:56,006 --> 00:01:57,236
我们将使用它


52
00:01:57,236 --> 00:01:59,166
将模型转化为


53
00:01:59,216 --> 00:02:01,006
存储器


54
00:02:01,006 --> 00:02:02,606
能够理解的托管项目模型


55
00:02:03,616 --> 00:02:04,276
所有东西都需要字段


56
00:02:04,276 --> 00:02:05,816
比如图片的属性 


57
00:02:05,816 --> 00:02:07,406
比如图像数据


58
00:02:07,406 --> 00:02:08,606
和发布时间


59
00:02:09,076 --> 00:02:11,266
此外我们还需要


60
00:02:11,266 --> 00:02:12,236
贴文和评论间的关系


61
00:02:12,596 --> 00:02:14,066
我们已经定义了


62
00:02:14,066 --> 00:02:15,446
存储器的需求


63
00:02:15,446 --> 00:02:17,366
但是随着时间的推移


64
00:02:17,366 --> 00:02:18,156
数据的维护涉及到很多工作


65
00:02:19,056 --> 00:02:20,386
幸运的是核心数据提供了一个


66
00:02:20,386 --> 00:02:21,956
持久化存储协调器


67
00:02:21,956 --> 00:02:22,546
来进行管理


68
00:02:22,986 --> 00:02:24,836
这个协调器可以处理例如


69
00:02:24,836 --> 00:02:26,246
与存储器的模型版本


70
00:02:26,246 --> 00:02:27,806
对比 App 模型


71
00:02:27,806 --> 00:02:29,276
并随着 App 的优化


72
00:02:29,276 --> 00:02:30,306
进行自动迁移


73
00:02:30,786 --> 00:02:32,916
最终托管对象上下文 会对我们的数据


74
00:02:32,916 --> 00:02:34,436
提供安全快捷


75
00:02:34,436 --> 00:02:35,936
且可预测的访问权限


76
00:02:36,616 --> 00:02:37,826
即便我们


77
00:02:37,826 --> 00:02:39,426
同时使用很多功能


78
00:02:39,426 --> 00:02:40,636
例如查询生成


79
00:02:40,716 --> 00:02:41,896
连接池以及


80
00:02:41,896 --> 00:02:42,376
历史跟踪


81
00:02:44,236 --> 00:02:46,486
设置这些要求


82
00:02:46,566 --> 00:02:47,736
找到模型 进行加载


83
00:02:47,736 --> 00:02:49,236
然后决定如何保存存储器


84
00:02:49,236 --> 00:02:51,186
但是很多错误路径


85
00:02:51,186 --> 00:02:53,026
在你迁移 App 之后


86
00:02:53,026 --> 00:02:54,816
并不会失败


87
00:02:54,816 --> 00:02:56,246
因此核心数据提供了一个容器类型


88
00:02:56,576 --> 00:02:57,716
能极大的降低


89
00:02:57,716 --> 00:02:58,946
你在设置堆栈时所需的样板文件


90
00:02:58,946 --> 00:03:00,736
只需要按名称引用模型


91
00:03:00,736 --> 00:03:03,486
然后持久化容器将


92
00:03:03,486 --> 00:03:05,046
从主束中加载它 并将它


93
00:03:05,046 --> 00:03:06,766
储存在持久化的位置


94
00:03:07,306 --> 00:03:10,386
这种持久化容器类型


95
00:03:10,386 --> 00:03:11,926
囊括了一整个堆栈以及


96
00:03:11,926 --> 00:03:13,526
共享主队列视图上下文的


97
00:03:13,526 --> 00:03:15,256
便利构造函数和


98
00:03:15,806 --> 00:03:17,926
用于生成


99
00:03:18,246 --> 00:03:20,286
背景语上下文的工厂方法


100
00:03:20,286 --> 00:03:21,676
以及执行后台工作


101
00:03:22,426 --> 00:03:23,796
在我们的 App 扩展的同时


102
00:03:23,796 --> 00:03:25,366
它同样易于操作


103
00:03:25,776 --> 00:03:27,706
举个例子 要将我们的


104
00:03:27,706 --> 00:03:29,956
模型层纳入到它自己的框架中


105
00:03:30,836 --> 00:03:31,856
我们可以通过在 Xcode 里


106
00:03:31,856 --> 00:03:33,166
创建一个新的框架目标然后将


107
00:03:33,166 --> 00:03:34,116
我们的代码移动进去


108
00:03:34,446 --> 00:03:36,166
这都非常简单 但是当我们将


109
00:03:36,166 --> 00:03:37,116
我们的模型移动到新的目标时 


110
00:03:37,116 --> 00:03:38,836
在已构建的产品中


111
00:03:38,836 --> 00:03:40,836
目标从 App 移动到了新的框架


112
00:03:40,836 --> 00:03:42,736
本应如此


113
00:03:42,736 --> 00:03:43,806
但是现在


114
00:03:43,806 --> 00:03:45,246
NSPersistentContainer 不知道 


115
00:03:45,436 --> 00:03:46,896
在哪才能找到我们的模型


116
00:03:47,476 --> 00:03:48,566
这是因为 默认下


117
00:03:48,566 --> 00:03:49,846
它只会检查主束


118
00:03:50,416 --> 00:03:51,056
为什么停在那里呢


119
00:03:51,806 --> 00:03:53,296
因为检索 App 里所有束


120
00:03:53,296 --> 00:03:54,826
会非常缓慢


121
00:03:54,826 --> 00:03:56,526
你不会希望每次


122
00:03:56,526 --> 00:03:57,816
加速堆栈的时候


123
00:03:57,816 --> 00:03:58,866
都花好长时间


124
00:04:00,206 --> 00:04:01,506
如何修复呢


125
00:04:02,666 --> 00:04:03,926
我们可以自己


126
00:04:03,926 --> 00:04:05,206
在框架束外恢复这个模型


127
00:04:05,206 --> 00:04:06,766
然后使用


128
00:04:06,766 --> 00:04:07,456
容器的其他初始化 App


129
00:04:07,456 --> 00:04:08,666
比如那个使用


130
00:04:08,736 --> 00:04:10,606
显式托管对象模型的 App


131
00:04:10,606 --> 00:04:12,986
但是事实上 NSPersistentContainer


132
00:04:12,986 --> 00:04:14,486
提供了一种更改


133
00:04:14,486 --> 00:04:16,036
检索对象的方法


134
00:04:17,856 --> 00:04:19,856
看 NSPersistentContainer 知道


135
00:04:19,856 --> 00:04:21,086
它什么时候子类化


136
00:04:21,086 --> 00:04:24,106
然后在搜索模型时 将子类类型


137
00:04:24,106 --> 00:04:24,666
作为提示


138
00:04:25,156 --> 00:04:26,256
我们所要做的就是


139
00:04:26,256 --> 00:04:27,566
利用这个功能


140
00:04:27,566 --> 00:04:28,236
创建一个子类


141
00:04:28,756 --> 00:04:29,826
里面甚至可以


142
00:04:29,826 --> 00:04:30,466
什么都没有


143
00:04:31,916 --> 00:04:33,976
然后 任何通过容器设置


144
00:04:33,976 --> 00:04:35,816
并希望使用我们的模型的代码 


145
00:04:35,816 --> 00:04:37,466
可以采用那个子类


146
00:04:37,466 --> 00:04:38,646
然后持久化容器将


147
00:04:38,646 --> 00:04:40,586
替代它在框架束中检索模型


148
00:04:41,196 --> 00:04:45,856
这很有趣 但是因为我们需要努力


149
00:04:45,856 --> 00:04:47,286
分解我们 App 的资源


150
00:04:47,436 --> 00:04:48,486
如果我们能提升


151
00:04:48,486 --> 00:04:49,696
我们磁盘上数据的组织


152
00:04:49,696 --> 00:04:50,426
不是更好吗


153
00:04:51,146 --> 00:04:53,306
在默认情况下 


154
00:04:53,306 --> 00:04:54,276
新的持久化容器 


155
00:04:54,276 --> 00:04:55,986
带有一个 SQLite 存储的存储描述


156
00:04:56,116 --> 00:04:58,136
它的自动迁移功能在


157
00:04:58,136 --> 00:04:59,926
iOS 系统中存在我们的 App 的


158
00:04:59,926 --> 00:05:00,366
文件目录里


159
00:05:00,796 --> 00:05:02,056
当我们的模型代码是 App 的一部分时


160
00:05:02,056 --> 00:05:04,066
这确实很好


161
00:05:04,066 --> 00:05:04,876
但我们需要避免让我们的


162
00:05:04,876 --> 00:05:06,116
新框架文件与 App


163
00:05:06,116 --> 00:05:07,286
过度混合


164
00:05:08,376 --> 00:05:09,566
既然我们已经将


165
00:05:09,566 --> 00:05:10,976
NSPersistentContainer 子类化


166
00:05:10,976 --> 00:05:12,706
以使搜索模型更加简单


167
00:05:12,706 --> 00:05:14,086
我们在这个基础上进行提升


168
00:05:16,476 --> 00:05:18,456
硬性更改储存位置的方法


169
00:05:18,456 --> 00:05:20,786
是在加载存储之前


170
00:05:20,786 --> 00:05:23,446
就在 persistentStoreDescription 里面


171
00:05:23,446 --> 00:05:26,716
更改 URL 有时候这就是你想要的


172
00:05:26,716 --> 00:05:27,826
我们可以在这里使用这种模式


173
00:05:27,826 --> 00:05:29,406
但是我们不需要这样做


174
00:05:29,716 --> 00:05:31,516
因为 NSPersistentContainer


175
00:05:31,516 --> 00:05:33,996
在创建持久化存储描述文件


176
00:05:33,996 --> 00:05:35,816
时会调用它自己默认的 


177
00:05:35,816 --> 00:05:37,086
目录 URL 方法


178
00:05:37,286 --> 00:05:38,626
它是用来被覆盖的


179
00:05:39,166 --> 00:05:40,516
在这种情况下 


180
00:05:40,516 --> 00:05:42,066
我们可以增加一个路径组件


181
00:05:42,066 --> 00:05:43,076
但是为了缓存


182
00:05:43,076 --> 00:05:45,776
或其他类型的堆栈


183
00:05:45,776 --> 00:05:46,826
比如说你的任务


184
00:05:46,826 --> 00:05:47,926
需要将它们的存储放在不同位置


185
00:05:47,926 --> 00:05:49,756
设置容器也是一种很好的方式


186
00:05:50,306 --> 00:05:53,046
现在我们已经搞清楚了


187
00:05:53,046 --> 00:05:54,256
核心数据的存量


188
00:05:54,386 --> 00:05:55,686
我们来看看我们的 App 以及


189
00:05:55,686 --> 00:05:57,706
一些我们所写的视图控制器


190
00:05:58,376 --> 00:06:00,896
看起来 我们有一些非常特别的


191
00:06:00,896 --> 00:06:01,606
视图控制器


192
00:06:02,296 --> 00:06:03,386
这里有一个可以显示我所有的帖子


193
00:06:03,386 --> 00:06:04,826
另一个可以显示


194
00:06:04,826 --> 00:06:06,746
所有作者发布的所有帖子


195
00:06:07,226 --> 00:06:08,226
甚至连详细评论都被


196
00:06:08,346 --> 00:06:09,166
复制了


197
00:06:09,306 --> 00:06:10,796
看起来


198
00:06:10,796 --> 00:06:13,386
我们只需要写一半的代码


199
00:06:13,776 --> 00:06:15,656
我们真正需要的


200
00:06:15,656 --> 00:06:16,916
是一个用来展示帖子列表的视图控制器 


201
00:06:16,916 --> 00:06:18,556
和另一个显示单个帖子的


202
00:06:18,556 --> 00:06:19,926
视图控制器


203
00:06:20,626 --> 00:06:21,656
我们可以通过


204
00:06:21,656 --> 00:06:23,526
在使用模型对象的 


205
00:06:23,526 --> 00:06:25,516
界面形式里


206
00:06:25,516 --> 00:06:26,916
在视图控制器之间


207
00:06:26,916 --> 00:06:27,786
定义良好边界


208
00:06:29,286 --> 00:06:30,576
每个控制器均由其


209
00:06:30,576 --> 00:06:33,026
模型参数配置


210
00:06:33,026 --> 00:06:34,136
可以基于


211
00:06:34,136 --> 00:06:35,306
是否展示我的帖子


212
00:06:35,306 --> 00:06:36,626
或别人的帖子


213
00:06:36,626 --> 00:06:37,386
来自定义单元格中的视图


214
00:06:37,906 --> 00:06:40,936
当使用核心数据 


215
00:06:40,936 --> 00:06:42,566
草拟视图控制器时


216
00:06:42,566 --> 00:06:44,016
列表视图应获得读取请求


217
00:06:44,016 --> 00:06:45,406
评论详情应获得


218
00:06:45,406 --> 00:06:46,096
托管对象


219
00:06:47,506 --> 00:06:48,776
视图控制器也需要一个


220
00:06:48,776 --> 00:06:50,446
托管对象上下文


221
00:06:50,446 --> 00:06:52,076
容器的评论上下文或者


222
00:06:52,076 --> 00:06:53,886
一些其它的主队列上下文


223
00:06:54,046 --> 00:06:55,536
这个用核心数据来


224
00:06:55,536 --> 00:06:56,806
生成视图控制器的模式


225
00:06:56,806 --> 00:06:58,176
不仅可以为 UI 服务


226
00:06:58,176 --> 00:06:59,596
也能很好地


227
00:06:59,596 --> 00:07:00,836
服务于实用 App 类型


228
00:07:01,806 --> 00:07:02,926
无需传递核心数据类型给演示文稿


229
00:07:02,926 --> 00:07:06,446
我们可以将 URL 或


230
00:07:06,446 --> 00:07:08,106
序列化数据等传递给


231
00:07:08,106 --> 00:07:10,496
后台工作控制器 


232
00:07:10,496 --> 00:07:11,896
然后用后台上下文代替


233
00:07:11,896 --> 00:07:13,446
视图上下文来完成我们的工作 


234
00:07:13,506 --> 00:07:14,876
将它们变为


235
00:07:14,876 --> 00:07:16,476
全新的升级的托管对象


236
00:07:18,016 --> 00:07:19,136
采用这种连接和工具类型


237
00:07:19,136 --> 00:07:20,616
非常简单


238
00:07:20,616 --> 00:07:22,146
因为我们拥有初始化器


239
00:07:22,146 --> 00:07:23,936
我们可以要求参数去创建一个


240
00:07:23,936 --> 00:07:24,466
控制器


241
00:07:24,566 --> 00:07:26,316
但我们如何将


242
00:07:26,316 --> 00:07:27,416
边缘变量放入


243
00:07:27,416 --> 00:07:28,086
视图控制器中呢


244
00:07:28,676 --> 00:07:31,946
如果我们使用 segues


245
00:07:31,946 --> 00:07:33,226
就可以覆盖 prepare method


246
00:07:34,636 --> 00:07:35,706
然后得到一个


247
00:07:35,706 --> 00:07:37,086
对 destinationViewController 的引用


248
00:07:37,086 --> 00:07:38,186
然后在那儿配置它


249
00:07:38,806 --> 00:07:40,636
如果我们使用故事板或者 nibs


250
00:07:40,636 --> 00:07:42,656
那么我们已经有可以汇成


251
00:07:42,656 --> 00:07:43,576
destinationViewController 的代码


252
00:07:43,576 --> 00:07:45,676
我们需要做的是


253
00:07:45,676 --> 00:07:47,976
在演示前设置属性


254
00:07:48,506 --> 00:07:50,586
如果我们在操纵杆


255
00:07:50,586 --> 00:07:51,676
我们可以写一个可以


256
00:07:51,676 --> 00:07:52,826
明确的定义边界条件的初始化 App


257
00:07:52,826 --> 00:07:54,256
就像我们在没有效用类型时


258
00:07:54,256 --> 00:07:55,676
所做的那样


259
00:07:56,276 --> 00:07:59,656
好了 现在我们已经有了一个读取请求


260
00:07:59,656 --> 00:08:01,056
和视图控制器的上下文


261
00:08:01,056 --> 00:08:02,656
但是在我们


262
00:08:02,656 --> 00:08:04,136
混合二者得到结果之前


263
00:08:04,136 --> 00:08:05,486
我们需要对 


264
00:08:05,486 --> 00:08:06,746
读取请求多做一些配置


265
00:08:06,746 --> 00:08:07,986
来确定我们的控制器


266
00:08:07,986 --> 00:08:09,136
会表现不错


267
00:08:10,856 --> 00:08:12,276
有时应该设置读取限制


268
00:08:12,276 --> 00:08:13,806
但按照列表视图的情况


269
00:08:13,806 --> 00:08:15,036
使用批处理更合适


270
00:08:15,036 --> 00:08:16,036
因为我们希望显示所有的数据


271
00:08:16,036 --> 00:08:18,596
我们也知道


272
00:08:18,596 --> 00:08:20,126
我们的视图控制器


273
00:08:20,126 --> 00:08:21,806
一次可以在屏幕上 显示多少个单元格


274
00:08:22,546 --> 00:08:24,306
总的来说 至少这些选项中的一个


275
00:08:24,306 --> 00:08:25,886
需要设置为读取请求


276
00:08:25,886 --> 00:08:27,156
它返回的结果


277
00:08:27,156 --> 00:08:29,276
可能是无限数量


278
00:08:29,956 --> 00:08:32,346
所以这时我们可以


279
00:08:32,346 --> 00:08:33,676
将读取请求更改为对象


280
00:08:33,676 --> 00:08:35,025
然后用返回结果填充列表视图


281
00:08:35,056 --> 00:08:37,196
但是如果我们想要


282
00:08:37,196 --> 00:08:39,155
让 UI 和发生的更改保持一致


283
00:08:39,155 --> 00:08:40,366
该怎么做


284
00:08:41,666 --> 00:08:42,846
我们在这里已经讲到了核心数据


285
00:08:42,846 --> 00:08:44,246
和读取结果控制器


286
00:08:44,726 --> 00:08:46,356
自 Sierra 系统以来
  
00:08:46,356 --> 00:08:47,976
读取结果控制器可用于所有平台


287
00:08:47,976 --> 00:08:49,366
要采用它只要求


288
00:08:49,366 --> 00:08:50,556
在委托协议和它驱动的视图之间


289
00:08:50,556 --> 00:08:52,536
写一个适配器


290
00:08:53,136 --> 00:08:54,556
要创建它 我们只需要


291
00:08:54,556 --> 00:08:55,836
一个读取请求和一个上下文


292
00:08:57,176 --> 00:08:58,136
读取结果控制器


293
00:08:58,136 --> 00:08:59,276
甚至可以支持对类似区段这样的


294
00:08:59,276 --> 00:09:01,316
更加高级的列表视图概念


295
00:09:01,316 --> 00:09:02,026
进行驱动


296
00:09:03,066 --> 00:09:05,066
如果我们希望将帖子


297
00:09:05,066 --> 00:09:06,206
根据发布的日期分成区段


298
00:09:06,206 --> 00:09:07,596
我们可以


299
00:09:07,596 --> 00:09:09,046
通过使用计算属性


300
00:09:09,046 --> 00:09:10,696
将 Xcode 生成的帖子类型进行扩展


301
00:09:10,696 --> 00:09:12,436
然后将它的名称


302
00:09:12,436 --> 00:09:14,436
传递给读取结果控制器的


303
00:09:14,436 --> 00:09:15,076
初始化 App


304
00:09:16,336 --> 00:09:18,156
这样可以运行得很好


305
00:09:18,156 --> 00:09:19,226
但是如果我们有比


306
00:09:19,226 --> 00:09:20,596
仅有一个对象列表 更复杂的视图控制器时


307
00:09:20,596 --> 00:09:21,656
我们该怎么做


308
00:09:21,806 --> 00:09:22,786
如果我们希望


309
00:09:22,786 --> 00:09:24,686
在 App 上显示类似每日发帖图表的东西


310
00:09:24,686 --> 00:09:25,966
该怎么做


311
00:09:27,556 --> 00:09:28,776
我们需要做的第一件事就是


312
00:09:28,776 --> 00:09:31,266
不要低估了读取请求的能力


313
00:09:31,816 --> 00:09:33,126
我只是一个人


314
00:09:33,126 --> 00:09:34,326
所以在上个月


315
00:09:34,326 --> 00:09:36,576
我没能每天发布


316
00:09:36,576 --> 00:09:36,926
多于 40 张的照片


317
00:09:37,706 --> 00:09:39,196
在 30 天内


318
00:09:39,336 --> 00:09:40,646
这仍然是


319
00:09:40,646 --> 00:09:41,706
一次从存储中取出的


320
00:09:41,706 --> 00:09:42,566
合理的数据量


321
00:09:43,446 --> 00:09:45,466
如果我们先前定义的


322
00:09:45,466 --> 00:09:46,856
日期属性是


323
00:09:46,856 --> 00:09:48,236
模型中实体的一部分


324
00:09:48,646 --> 00:09:49,386
我们可以写一个读取请求


325
00:09:49,386 --> 00:09:50,506
能够将帖子数量


326
00:09:50,506 --> 00:09:52,916
根据发布的日期进行分组


327
00:09:53,456 --> 00:09:55,236
这个请求有三部分


328
00:09:55,616 --> 00:09:56,986
第一个是


329
00:09:56,986 --> 00:09:57,426
设置范围


330
00:09:57,596 --> 00:09:58,966
我们希望有


331
00:09:58,966 --> 00:09:59,316
至少 30 天的数据


332
00:09:59,316 --> 00:10:02,316
接下来 我们希望


333
00:10:02,316 --> 00:10:04,536
将所有日期属性的值相同的日期


334
00:10:04,536 --> 00:10:05,716
分到一组


335
00:10:06,316 --> 00:10:07,076
因为我们现在抓取的是


336
00:10:07,076 --> 00:10:08,566
总量而不是单个的对象


337
00:10:08,566 --> 00:10:09,796
我们也需要将结果类型修改得


338
00:10:09,796 --> 00:10:10,876
更加合理


339
00:10:10,876 --> 00:10:13,066
在这里是字典


340
00:10:14,726 --> 00:10:17,346
最后 我们要定义一个


341
00:10:17,346 --> 00:10:19,316
在每个组里代表对象数量的表达式


342
00:10:19,316 --> 00:10:20,976
然后告诉读取请求 


343
00:10:20,976 --> 00:10:23,616
返回它所代表的日期的计数


344
00:10:24,926 --> 00:10:26,996
这个读取请求返回了 30 个结果


345
00:10:26,996 --> 00:10:28,416
它们中的每一个都是


346
00:10:28,416 --> 00:10:29,876
图表中的一个点


347
00:10:31,216 --> 00:10:34,466
如果你进入数据库


348
00:10:34,466 --> 00:10:35,546
这是核心数据从


349
00:10:35,546 --> 00:10:36,686
读取请求里


350
00:10:36,686 --> 00:10:37,186
生成的 SQLite 查询


351
00:10:37,646 --> 00:10:38,846
如果你自己写查询语句


352
00:10:38,846 --> 00:10:39,516
那么这就是


353
00:10:39,516 --> 00:10:40,046
你要做的


354
00:10:40,496 --> 00:10:41,816
核心数据知道如何


355
00:10:41,816 --> 00:10:43,226
将许多表达功能


356
00:10:43,226 --> 00:10:45,196
转换成最佳的数据库查询


357
00:10:45,776 --> 00:10:46,856
一个通过查询得到的组


358
00:10:46,856 --> 00:10:48,066
可以聚合


359
00:10:48,066 --> 00:10:50,076
例如平均 求和 以及标量查询


360
00:10:50,076 --> 00:10:51,736
比如一般的读取请求


361
00:10:51,736 --> 00:10:53,336
可以使用标量计数以及日期功能


362
00:10:53,336 --> 00:10:54,926
就像 abs 之于绝对值


363
00:10:54,926 --> 00:10:57,026
now 之于当前时间一样


364
00:10:57,156 --> 00:10:59,366
如果你想知道


365
00:10:59,366 --> 00:11:00,236
更多的关于 NSExpression 的内容


366
00:11:00,266 --> 00:11:01,306
你可以去了解一下


367
00:11:01,306 --> 00:11:03,286
功能列表的资料


368
00:11:03,356 --> 00:11:04,366
在核心数据里


369
00:11:04,366 --> 00:11:07,336
很多都受到读取请求的支持


370
00:11:08,366 --> 00:11:10,586
所以通过使用表达式


371
00:11:10,586 --> 00:11:12,566
读取请求可以完成很多事


372
00:11:12,566 --> 00:11:14,606
但是 SQLite 仍旧会在


373
00:11:14,606 --> 00:11:16,286
处理图表时


374
00:11:16,286 --> 00:11:18,636
读取每一个帖子


375
00:11:19,126 --> 00:11:20,976
用图表展示


376
00:11:20,976 --> 00:11:23,566
一个人的发帖数量时运行良好


377
00:11:23,566 --> 00:11:24,586
但是如果我们希望


378
00:11:24,586 --> 00:11:25,796
为更庞大的数据


379
00:11:25,796 --> 00:11:26,746
制作图表呢


380
00:11:27,086 --> 00:11:28,676
如果我们想展示一整年的数据


381
00:11:28,676 --> 00:11:30,536
或者我们的 App 


382
00:11:30,536 --> 00:11:32,136
要开始处理


383
00:11:32,136 --> 00:11:33,386
更大数量级的数据呢


384
00:11:34,706 --> 00:11:35,686
现在 读取请求至少可以


385
00:11:35,686 --> 00:11:37,566
一个一个地


386
00:11:37,566 --> 00:11:39,226
计算 50,000 个帖子


387
00:11:39,226 --> 00:11:41,956
只为显示 30 个点 这不够快


388
00:11:42,436 --> 00:11:44,076
视图与模型之间的不协调


389
00:11:44,076 --> 00:11:45,436
已经到了需要我们


390
00:11:45,436 --> 00:11:47,596
做一些 denormalization 了


391
00:11:50,226 --> 00:11:52,266
denormalization 是当我们


392
00:11:52,266 --> 00:11:53,596
增加冗余的数据副本


393
00:11:53,596 --> 00:11:55,266
或者元数据时


394
00:11:55,266 --> 00:11:56,556
以增加簿记为代价


395
00:11:56,556 --> 00:11:57,576
来提升读取性能


396
00:11:58,156 --> 00:11:59,546
数据库索引就是一个


397
00:11:59,546 --> 00:12:00,466
很好的例子


398
00:12:01,396 --> 00:12:02,766
在我们的存储里加入计数元数据


399
00:12:02,766 --> 00:12:04,526
是为了使我们的图表 


400
00:12:04,526 --> 00:12:07,866
能够再次显示 而做出的牺牲


401
00:12:08,666 --> 00:12:10,676
让我们看看 我们的模型


402
00:12:10,676 --> 00:12:12,366
如何将帖子按照发布的


403
00:12:12,366 --> 00:12:12,736
日期分组


404
00:12:13,626 --> 00:12:15,556
我们将需要一个新的实体和两个属性


405
00:12:15,556 --> 00:12:17,246
加上一些额外的维护


406
00:12:17,246 --> 00:12:18,316
以保证其准确性


407
00:12:19,186 --> 00:12:20,796
按照日期分组很大地提升了


408
00:12:20,796 --> 00:12:22,396
读取请求 


409
00:12:22,396 --> 00:12:23,756
使它保证在覆盖好几年的数据时


410
00:12:23,756 --> 00:12:25,386
也能有好的表现


411
00:12:25,766 --> 00:12:26,776
我们只需要创建


412
00:12:26,776 --> 00:12:29,376
与我们向图表视图控制器


413
00:12:29,376 --> 00:12:30,516
传递的同样水平的 denormalization


414
00:12:30,516 --> 00:12:31,496
和读取请求即可


415
00:12:32,386 --> 00:12:33,446
这非常简单


416
00:12:34,416 --> 00:12:35,256
这和我们向其他列表视图


417
00:12:35,256 --> 00:12:36,336
传递的读取请求 


418
00:12:36,336 --> 00:12:37,576
没有多大不同


419
00:12:37,576 --> 00:12:39,386
事实上如果你看得够仔细


420
00:12:39,506 --> 00:12:40,636
会发现它


421
00:12:40,636 --> 00:12:42,176
有点像一种图表视图


422
00:12:43,766 --> 00:12:44,866
但是特殊维护


423
00:12:44,866 --> 00:12:45,396
该如何进行呢


424
00:12:46,186 --> 00:12:47,656
当帖子发布时


425
00:12:47,656 --> 00:12:48,986
我们需要增加计数


426
00:12:48,986 --> 00:12:50,236
当帖子被移除时


427
00:12:50,236 --> 00:12:50,846
我们需要减少计数


428
00:12:51,556 --> 00:12:53,016
我们可以使用


429
00:12:53,016 --> 00:12:54,296
更改帖子对象的相关状态的方法


430
00:12:54,296 --> 00:12:55,836
来实现它


431
00:12:55,836 --> 00:12:56,886
但一个更简单明了的方式是去


432
00:12:56,886 --> 00:12:58,046
根据响应上下文存储


433
00:12:58,046 --> 00:12:58,796
来更新计数


434
00:12:59,356 --> 00:13:04,546
我们可以为


435
00:13:04,976 --> 00:13:07,156
托管对象 contextWillSave 提醒


436
00:13:07,156 --> 00:13:08,866
注册一个功能


437
00:13:09,296 --> 00:13:10,286
使它可以检查所有


438
00:13:10,286 --> 00:13:11,406
添加的帖子


439
00:13:11,696 --> 00:13:13,136
对所有相关的日期增加计数


440
00:13:13,136 --> 00:13:15,626
让另外一个循环


441
00:13:16,066 --> 00:13:18,186
检查所有被删除的对象


442
00:13:18,186 --> 00:13:18,956
为每天减少计数


443
00:13:19,646 --> 00:13:20,656
这样就可以在交付数据库之前


444
00:13:20,656 --> 00:13:22,106
影响上下文状态


445
00:13:22,106 --> 00:13:23,516
最后它们会在


446
00:13:23,516 --> 00:13:25,166
一次交付中完成


447
00:13:25,166 --> 00:13:27,236
这样做 延展性很好


448
00:13:27,236 --> 00:13:28,916
非常有用


449
00:13:28,916 --> 00:13:30,366
因为我的同事 Nick Gilett 将


450
00:13:30,366 --> 00:13:31,676
探讨当我们的 App 扩展到超出想象时


451
00:13:31,676 --> 00:13:33,296
核心数据


452
00:13:33,296 --> 00:13:34,186
将如何帮助我们


453
00:13:34,846 --> 00:13:34,976
Nick


454
00:13:35,271 --> 00:13:37,271
[ 掌声 ]


455
00:13:37,526 --> 00:13:37,976
>> 谢谢 Scott


456
00:13:38,416 --> 00:13:40,416
[ 掌声 ]


457
00:13:40,816 --> 00:13:42,296
就像 Scott 所说


458
00:13:42,296 --> 00:13:43,876
在你的 App 扩张时


459
00:13:43,876 --> 00:13:46,606
它们变得更加复杂


460
00:13:46,606 --> 00:13:48,196
对于核心数据而言


461
00:13:48,196 --> 00:13:50,656
很重要的一点是 你的 App 确实在扩张


462
00:13:50,656 --> 00:13:51,746
事实上 这是我们想要的


463
00:13:51,746 --> 00:13:53,336
这是我们出现


464
00:13:53,426 --> 00:13:54,626
并帮助你管理扩展的全部理由


465
00:13:54,626 --> 00:13:56,166
通过使用它


466
00:13:56,166 --> 00:13:58,026
使你的工作更有效率


467
00:13:58,026 --> 00:13:59,656
帮助你为顾客创造更多的价值


468
00:14:00,306 --> 00:14:03,046
但是这种方式


469
00:14:03,046 --> 00:14:04,936
对你的 App 来说 会非常特别


470
00:14:05,416 --> 00:14:06,976
高度匹配


471
00:14:06,976 --> 00:14:08,696
顾客的体验


472
00:14:08,696 --> 00:14:09,936
或者你希望顾客以何种方式


473
00:14:09,936 --> 00:14:11,266
体验你的 App


474
00:14:12,056 --> 00:14:13,816
不幸的是 


475
00:14:13,816 --> 00:14:15,696
就像所有的复杂系统一样


476
00:14:15,696 --> 00:14:18,516
它也会出现混乱


477
00:14:19,376 --> 00:14:20,716
所有我们今天将


478
00:14:20,716 --> 00:14:22,136
探讨核心数据如何帮助你


479
00:14:22,136 --> 00:14:23,876
管理这些混乱


480
00:14:23,876 --> 00:14:24,896
并且使系统更有条理


481
00:14:25,466 --> 00:14:26,536
我们将讨论构建


482
00:14:26,536 --> 00:14:28,996
可预测的行为


483
00:14:28,996 --> 00:14:30,436
并帮助你构建


484
00:14:30,436 --> 00:14:31,826
可调容器


485
00:14:31,826 --> 00:14:32,976
来与你的经验指标匹配


486
00:14:36,236 --> 00:14:37,346
这是什么意思呢


487
00:14:38,246 --> 00:14:39,996
当我们想到指标时


488
00:14:39,996 --> 00:14:42,946
我们有很多不同的方式去思考它


489
00:14:43,396 --> 00:14:45,696
第一个是 与用户保持一致


490
00:14:46,326 --> 00:14:48,586
我们一般会将它们定义为


491
00:14:48,586 --> 00:14:49,836
用户会体验的东西


492
00:14:49,836 --> 00:14:51,176
比如有持久化用户界面或者


493
00:14:51,176 --> 00:14:53,536
一个响应滚动视图


494
00:14:53,536 --> 00:14:57,786
或者顾客喜悦度


495
00:14:58,486 --> 00:15:01,106
但对于我们工程师来说


496
00:15:01,106 --> 00:15:02,476
这些都很难捕捉


497
00:15:03,256 --> 00:15:04,326
我们将它们


498
00:15:04,326 --> 00:15:06,186
翻译为工程指标


499
00:15:06,296 --> 00:15:08,276
比如运行时的峰值内存


500
00:15:08,276 --> 00:15:09,836
在运行一个任务时电池的消耗


501
00:15:09,836 --> 00:15:12,056
或者在运行一个任务时


502
00:15:12,436 --> 00:15:13,896
所需要的中央处理时间


503
00:15:14,316 --> 00:15:17,906
最后 我们在给予的任务中做了多少 IO


504
00:15:18,806 --> 00:15:19,656
为了让它更具体一些


505
00:15:19,656 --> 00:15:21,626
我们将使用这个 App


506
00:15:22,286 --> 00:15:23,236
你们中的有些人


507
00:15:23,236 --> 00:15:24,736
可能还记得去年的 WWDC


508
00:15:24,836 --> 00:15:26,886
我们介绍的历史演示 App


509
00:15:27,306 --> 00:15:28,536
为了这个演讲


510
00:15:28,536 --> 00:15:29,676
我对它进行了修改


511
00:15:30,506 --> 00:15:32,156
当用户用你的 App 时


512
00:15:32,156 --> 00:15:34,526
这里有一些它们可以做的事


513
00:15:35,036 --> 00:15:36,676
第一个是它们可以


514
00:15:36,676 --> 00:15:38,826
通过敲击 + 键


515
00:15:38,826 --> 00:15:39,746
将单个的帖子添加到你的数据库中去


516
00:15:40,786 --> 00:15:42,256
它们也可以


517
00:15:42,256 --> 00:15:44,546
通过点击下载


518
00:15:44,546 --> 00:15:45,406
从服务器下载未决数据


519
00:15:50,716 --> 00:15:53,966
最终 对那些还没有被上传到服务区的东西


520
00:15:53,966 --> 00:15:55,636
它们可以点击发布全部


521
00:15:56,596 --> 00:16:00,416
现在 这个 App 有少数几个


522
00:16:00,416 --> 00:16:02,366
可供顾客使用的交互


523
00:16:02,366 --> 00:16:04,156
但是当这些功能同时发生时


524
00:16:04,156 --> 00:16:07,516
会产生混乱


525
00:16:08,306 --> 00:16:11,536
我们可以看到


526
00:16:11,536 --> 00:16:12,936
即便是这么少的系列动作


527
00:16:13,596 --> 00:16:14,806
它们同时发生也会导致


528
00:16:14,806 --> 00:16:15,676
很多不同 App 的状态变化


529
00:16:15,676 --> 00:16:18,776
对我们而言最糟糕的是


530
00:16:18,776 --> 00:16:21,826
出现像这样的用户体验


531
00:16:22,696 --> 00:16:25,336
这些部分完整性的概念


532
00:16:25,336 --> 00:16:26,196
对于用户没有意义


533
00:16:26,196 --> 00:16:28,156
事实上 这对我们也没有意义


534
00:16:29,816 --> 00:16:30,836
在这里 核心数据将帮助我们


535
00:16:30,886 --> 00:16:32,676
处理查询生成


536
00:16:33,066 --> 00:16:36,556
在 2016 年的核心数据新品介绍会议上


537
00:16:36,556 --> 00:16:37,656
我们介绍了查询生成


538
00:16:38,116 --> 00:16:39,076
如果你还不了解它


539
00:16:39,076 --> 00:16:40,286
我非常建议你


540
00:16:40,286 --> 00:16:41,516
了解一下那场会议


541
00:16:41,516 --> 00:16:42,806
并获得更多


542
00:16:42,806 --> 00:16:43,356
有关它如何工作的信息


543
00:16:43,996 --> 00:16:45,626
你需要知道的是


544
00:16:45,886 --> 00:16:47,506
它需要预写日志模式


545
00:16:47,606 --> 00:16:48,786
并且只能使用 SQLite


546
00:16:49,906 --> 00:16:51,746
查询生成的目标是


547
00:16:51,746 --> 00:16:53,186
将你的托管对象上下文 


548
00:16:53,186 --> 00:16:54,896
从相互矛盾的工作中隔离出来


549
00:16:55,346 --> 00:16:56,406
它可能直接作用于后台


550
00:16:56,406 --> 00:16:58,566
或者你还没有准备在


551
00:16:58,566 --> 00:17:00,176
给定文本中显示的


552
00:17:00,176 --> 00:17:03,006
用户正在进行的行为


553
00:17:04,026 --> 00:17:05,286
查询生成提供了一个 


554
00:17:05,286 --> 00:17:07,026
数据库的一致而长久的视图


555
00:17:07,026 --> 00:17:08,806
它将向读取返回同样的结果


556
00:17:08,806 --> 00:17:10,435
无论在给定时间内


557
00:17:10,435 --> 00:17:11,606
数据库被写入


558
00:17:11,606 --> 00:17:14,165
何种其它的上下文


559
00:17:17,415 --> 00:17:19,695
最好的是我们可以通过


560
00:17:19,695 --> 00:17:20,816
一行代码来实现它


561
00:17:21,715 --> 00:17:23,116
这里是重新加载一个表格视图的


562
00:17:23,116 --> 00:17:24,256
典型变化


563
00:17:24,675 --> 00:17:26,626
我们可以仅仅对 NSManagedObjectContext


564
00:17:26,626 --> 00:17:28,496
setQueryGenerationFrom


565
00:17:28,496 --> 00:17:31,276
增加一个带有现有查询生成


566
00:17:31,276 --> 00:17:31,966
的调用


567
00:17:33,456 --> 00:17:34,746
需要更新时


568
00:17:34,746 --> 00:17:37,206
我们可以像往常一样


569
00:17:37,206 --> 00:17:40,056
使用 NSMangedObjectContextDidSave 提醒


570
00:17:40,056 --> 00:17:40,766
来进行更新


571
00:17:41,236 --> 00:17:45,806
这使我们可以在对的时间 在 UI 里 


572
00:17:45,806 --> 00:17:48,876
对 App 的数据实现修改


573
00:17:52,096 --> 00:17:53,536
但是如果我们写的数据


574
00:17:53,536 --> 00:17:54,986
和 UI 没有关联呢


575
00:17:55,676 --> 00:17:56,716
例如下载之前


576
00:17:56,716 --> 00:17:58,466
Scott 提到的一些评论


577
00:17:59,556 --> 00:18:02,046
这种情况下


578
00:18:02,046 --> 00:18:03,406
我们不希望数据出现在用户界面里


579
00:18:03,406 --> 00:18:05,716
或者对它产生更改


580
00:18:05,716 --> 00:18:06,776
因为所有的变化对用户


581
00:18:06,776 --> 00:18:07,996
都是不可视的


582
00:18:08,526 --> 00:18:09,876
我们需要通过使用


583
00:18:09,876 --> 00:18:11,976
历史追踪 来过滤掉这些更新


584
00:18:12,786 --> 00:18:14,276
持续历史追踪是


585
00:18:14,276 --> 00:18:17,456
iOS 11 和 macOS 10.13 的新功能


586
00:18:18,206 --> 00:18:19,996
我们在去年的全球开发者大会中的


587
00:18:19,996 --> 00:18:22,036
核心数据的新功能部分


588
00:18:22,116 --> 00:18:23,526
对它进行过介绍


589
00:18:23,526 --> 00:18:24,866
要想了解更多它如何工作


590
00:18:24,866 --> 00:18:26,626
或者它们重点功能是什么的信息


591
00:18:26,626 --> 00:18:27,866
你可以将这个会议


592
00:18:28,516 --> 00:18:29,566
作为参考


593
00:18:31,966 --> 00:18:33,406
持续历史追踪是一个


594
00:18:33,406 --> 00:18:35,526
获得每次与数据库相关的


595
00:18:35,526 --> 00:18:38,926
事务处理的记录的好方式


596
00:18:38,926 --> 00:18:40,026
对我们很有用


597
00:18:40,026 --> 00:18:41,186
有几点原因


598
00:18:41,756 --> 00:18:43,506
为了本次演讲


599
00:18:43,506 --> 00:18:45,626
我们将使用 NSPersistentHistoryChange


600
00:18:45,796 --> 00:18:47,926
它能给我们一个 changedObjectID 


601
00:18:48,576 --> 00:18:52,546
和一组 updatedProperties


602
00:18:53,036 --> 00:18:53,176
还有 NSPersistentHistoryTransaction


603
00:18:53,296 --> 00:18:55,036
它将给我们一组变化


604
00:18:55,686 --> 00:18:59,136
以及一个 objectIDNotification


605
00:19:01,396 --> 00:19:05,176
我们来想一下


606
00:19:05,176 --> 00:19:06,036
接下来的变化


607
00:19:06,776 --> 00:19:08,236
就像你所看到的


608
00:19:08,236 --> 00:19:09,376
有一些帖子被加入到了数据库中


609
00:19:09,376 --> 00:19:12,436
当这件事发生时


610
00:19:12,806 --> 00:19:14,206
用表格视图来说


611
00:19:14,206 --> 00:19:17,046
我们可以通过使用


612
00:19:17,046 --> 00:19:18,346
objectIDNotification


613
00:19:18,346 --> 00:19:19,726
来更新 UI


614
00:19:20,296 --> 00:19:21,356
这和 NSManageObjectContextDidSave 


615
00:19:21,486 --> 00:19:25,076
提醒相似 它可以通过使用同一的 API


616
00:19:25,076 --> 00:19:26,586
来进行合并


617
00:19:29,756 --> 00:19:31,186
如果我们下载了一个


618
00:19:31,186 --> 00:19:33,516
我们不希望在用户更新里显示的


619
00:19:33,516 --> 00:19:35,406
评论列表


620
00:19:35,976 --> 00:19:39,936
我们可以对它进行过滤


621
00:19:40,146 --> 00:19:41,556
用少量的代码


622
00:19:41,616 --> 00:19:42,826
我们可以从给定的事务处理中


623
00:19:42,826 --> 00:19:44,046
将变化过滤出去


624
00:19:44,046 --> 00:19:45,086
以决定它们中是否有与帖子实体有关的变化


625
00:19:45,086 --> 00:19:47,306
这样我们就不需要更新 UI


626
00:19:48,876 --> 00:19:50,916
从而为用户引起


627
00:19:50,916 --> 00:19:53,876
不必要的波动


628
00:19:53,976 --> 00:19:55,276
或断续


629
00:19:56,256 --> 00:19:57,436
就像你在这里看到的


630
00:19:57,436 --> 00:19:58,906
我们使用的是


631
00:19:58,906 --> 00:20:00,496
小部分的帖子内容


632
00:20:01,246 --> 00:20:03,276
事实上 我们只使用了


633
00:20:03,276 --> 00:20:05,906
两个属性 图像和标题属性


634
00:20:07,406 --> 00:20:08,606
我们可以有比


635
00:20:08,606 --> 00:20:10,126
通过实体过滤更好的方式


636
00:20:10,416 --> 00:20:12,216
事实上我们可以通过使用


637
00:20:12,216 --> 00:20:13,606
历史变化来对更新的属性进行过滤


638
00:20:13,606 --> 00:20:17,416
这样 我们就可以针对 


639
00:20:17,416 --> 00:20:19,026
与用户可以看到的变化一致


640
00:20:19,476 --> 00:20:20,666
的用户体验


641
00:20:20,666 --> 00:20:21,916
创建目标性很强的更新


642
00:20:22,546 --> 00:20:27,526
核心数据还可以支持


643
00:20:28,146 --> 00:20:29,846
你与你的用户


644
00:20:29,846 --> 00:20:30,446
进行新的交互


645
00:20:31,336 --> 00:20:32,446
当你的数据逐渐变得


646
00:20:32,446 --> 00:20:35,216
更复杂更庞大


647
00:20:35,216 --> 00:20:36,756
有些编辑操作


648
00:20:36,756 --> 00:20:37,346
会变得更昂贵


649
00:20:37,346 --> 00:20:39,546
例如一个简单的


650
00:20:39,546 --> 00:20:40,466
图片浏览器


651
00:20:41,206 --> 00:20:42,796
一般来说


652
00:20:42,796 --> 00:20:44,386
当我们的 App 扩张时


653
00:20:44,386 --> 00:20:45,976
我们希望引进新的


654
00:20:45,976 --> 00:20:47,276
能让反复作业更加简单的功能


655
00:20:47,276 --> 00:20:50,136
比如 多项选择


656
00:20:50,506 --> 00:20:53,236
核心数据可以通过分批操作


657
00:20:53,266 --> 00:20:54,826
来支持这个功能


658
00:20:55,976 --> 00:20:57,946
事实上 通过几行代码


659
00:20:57,946 --> 00:20:59,436
我们就能对整组图片


660
00:20:59,436 --> 00:21:02,826
标记喜欢或不喜欢


661
00:21:03,596 --> 00:21:05,376
通过一行代码


662
00:21:05,376 --> 00:21:07,046
我们可以使用分批删除


663
00:21:07,046 --> 00:21:09,706
将记录从数据库里清除


664
00:21:09,976 --> 00:21:12,256
这种行为规模


665
00:21:12,256 --> 00:21:14,716
不可能将对象


666
00:21:14,716 --> 00:21:15,096
分解进内存


667
00:21:15,886 --> 00:21:19,556
举个例子 在删除过程中


668
00:21:19,556 --> 00:21:22,306
传统的调用 NSManagedObject.delete 将使


669
00:21:22,446 --> 00:21:24,836
数据库中记录的大小增加


670
00:21:24,906 --> 00:21:26,116
当你删除对象时


671
00:21:26,116 --> 00:21:27,336
你的内存被分解到上下文中


672
00:21:27,336 --> 00:21:29,436
你的数据库越大


673
00:21:29,436 --> 00:21:32,086
它就越贵


674
00:21:32,716 --> 00:21:34,036
但是通过分批操作


675
00:21:34,036 --> 00:21:36,106
我们可以在一小部分内存里


676
00:21:36,106 --> 00:21:37,706
进行同样的变化


677
00:21:38,276 --> 00:21:39,716
它有我们想要的曲线关系


678
00:21:39,716 --> 00:21:42,756
即当数据增加时


679
00:21:42,756 --> 00:21:44,626
数据集越大


680
00:21:44,626 --> 00:21:46,976
我们使用的内存越小


681
00:21:46,976 --> 00:21:48,696
删除 1000 万行


682
00:21:48,696 --> 00:21:50,606
我们只需用到


683
00:21:50,606 --> 00:21:51,156
传统内存的 7%


684
00:21:52,556 --> 00:21:54,076
这是一个


685
00:21:54,076 --> 00:21:55,296
节约你的用户设备内存的


686
00:21:55,296 --> 00:21:57,066
有力方式


687
00:21:57,956 --> 00:21:59,176
但是分批操作的


688
00:21:59,176 --> 00:22:00,976
一个传统问题是


689
00:22:01,596 --> 00:22:02,776
很难操作


690
00:22:02,776 --> 00:22:03,926
因为它不生成


691
00:22:03,926 --> 00:22:05,606
存储提醒


692
00:22:06,376 --> 00:22:07,426
这里就是把历史追踪功能


693
00:22:07,426 --> 00:22:08,176
引回来的部分


694
00:22:09,026 --> 00:22:10,016
使用持续历史追踪


695
00:22:10,016 --> 00:22:11,306
我们可以将


696
00:22:11,306 --> 00:22:12,846
分组删除或者更新的处理


697
00:22:13,286 --> 00:22:14,266
从数据库中分离出来


698
00:22:14,266 --> 00:22:17,156
我们可以使用 objectIDNotification 方法


699
00:22:17,156 --> 00:22:18,996
来生成一个提醒


700
00:22:18,996 --> 00:22:21,676
让它像存储提醒


701
00:22:21,676 --> 00:22:22,866
那样工作


702
00:22:23,386 --> 00:22:24,786
这样 读取结果控制器或者


703
00:22:24,786 --> 00:22:26,666
其他在你的 App 中的上下文就可以


704
00:22:26,666 --> 00:22:29,846
渐增式地更新


705
00:22:29,846 --> 00:22:30,656
这些提醒了


706
00:22:31,226 --> 00:22:35,546
所以这些是你能


707
00:22:35,546 --> 00:22:37,016
管理逐渐增加的数据的方式


708
00:22:37,016 --> 00:22:40,586
但是工作流程自身呢


709
00:22:40,966 --> 00:22:43,396
核心数据可以为开发者和程序员


710
00:22:43,396 --> 00:22:45,426
做些什么


711
00:22:45,426 --> 00:22:46,886
来使构建和测试你的 App 变得


712
00:22:46,886 --> 00:22:47,726
更简单


713
00:22:49,166 --> 00:22:51,136
我们能做的第一件事就是


714
00:22:51,136 --> 00:22:52,286
帮助你感知未来


715
00:22:53,856 --> 00:22:55,576
你可能知道


716
00:22:55,576 --> 00:22:56,326
NSKeyedArchiver 是在变化的


717
00:22:57,056 --> 00:22:58,416
我们在所有平台上


718
00:22:58,416 --> 00:23:00,926
使用安全代码


719
00:23:01,016 --> 00:23:03,146
今年 KeyedArchiver API 


720
00:23:03,146 --> 00:23:04,596
的剧烈变化


721
00:23:04,596 --> 00:23:05,436
也证实了这一点


722
00:23:06,496 --> 00:23:07,786
对于核心数据来说


723
00:23:07,786 --> 00:23:09,586
这意味着数值转换器是变化的


724
00:23:09,586 --> 00:23:11,066
所以如果在你的托管对象模型中


725
00:23:11,066 --> 00:23:13,086
有一个可转换的属性


726
00:23:13,086 --> 00:23:14,916
而你今天没有发送数值转换器


727
00:23:14,916 --> 00:23:16,876
你将与默认的


728
00:23:16,876 --> 00:23:17,836
数值转换器一样


729
00:23:18,036 --> 00:23:20,696
从 DataTransformer 得到


730
00:23:20,936 --> 00:23:22,316
NSKeyedUnarchive


731
00:23:22,916 --> 00:23:25,616
在未来 你将从 DataTransformer 


732
00:23:25,736 --> 00:23:28,196
得到 NSSecureUnarchive


733
00:23:28,196 --> 00:23:29,496
它在内部执行安全代码


734
00:23:29,496 --> 00:23:31,576
各位应该在今天就采用它


735
00:23:32,176 --> 00:23:33,416
今天早上有一场非常棒的演讲


736
00:23:33,416 --> 00:23:35,496
名为可以信赖的数据


737
00:23:36,976 --> 00:23:38,216
我强烈建议各位


738
00:23:38,636 --> 00:23:40,006
看看这个演讲


739
00:23:40,006 --> 00:23:41,666
并对安全代码和


740
00:23:41,666 --> 00:23:43,496
如何将你的 App 的适应力


741
00:23:43,496 --> 00:23:44,706
变得更强


742
00:23:44,706 --> 00:23:45,146
有更多的了解


743
00:23:48,246 --> 00:23:49,356
你可以在数值转换器名称字段里


744
00:23:49,356 --> 00:23:50,266
通过使用


745
00:23:50,266 --> 00:23:52,976
带有可转换属性的模型编辑器


746
00:23:52,976 --> 00:23:54,766
来指定它


747
00:23:55,716 --> 00:23:59,676
今天 我希望各位可以自己执行它


748
00:24:00,146 --> 00:24:01,566
在未来的版本中


749
00:24:01,566 --> 00:24:03,506
它将成为默认项


750
00:24:03,506 --> 00:24:04,986
在未来的 Xcode 版本中


751
00:24:04,986 --> 00:24:06,266
它也将向使用


752
00:24:06,266 --> 00:24:07,886
默认转换器名称的用户


753
00:24:07,886 --> 00:24:08,706
发出警示


754
00:24:10,036 --> 00:24:10,956
如果你在用代码


755
00:24:10,956 --> 00:24:13,056
构建模型 你可以通过使用 NSAttribute


756
00:24:13,056 --> 00:24:15,996
介绍上的 valueTransformerName 属性


757
00:24:15,996 --> 00:24:16,416
来对它进行设置


758
00:24:17,726 --> 00:24:19,046
如果你不是在编码自定义类类型


759
00:24:19,046 --> 00:24:21,176
那么这对你来说


760
00:24:21,176 --> 00:24:22,256
是很显而易见的


761
00:24:22,296 --> 00:24:23,926
对于 plist 类型


762
00:24:23,926 --> 00:24:24,306
这是一个无指令操作


763
00:24:24,756 --> 00:24:25,806
你只需要简单的更改


764
00:24:25,806 --> 00:24:27,336
数值转换器名称


765
00:24:27,336 --> 00:24:28,726
就能得到新的安全编码行为


766
00:24:29,286 --> 00:24:30,856
但如果你使用了自定义类


767
00:24:30,856 --> 00:24:32,456
这些类则需要采用安全代码


768
00:24:32,456 --> 00:24:34,786
你可以到实验室来


769
00:24:34,846 --> 00:24:37,616
向我们寻求帮助


770
00:24:38,296 --> 00:24:40,486
但我们其实可以帮你更多


771
00:24:41,286 --> 00:24:42,866
在核心数据里


772
00:24:43,066 --> 00:24:44,726
多年来我们花时间


773
00:24:45,026 --> 00:24:46,566
构建新的调试工具


774
00:24:46,566 --> 00:24:47,796
能够帮助你理解


775
00:24:47,796 --> 00:24:48,236
在堆栈下发生的事


776
00:24:49,026 --> 00:24:52,536
这是我们更喜欢的 默认方案配置


777
00:24:52,866 --> 00:24:54,686
我们有一些过程参数


778
00:24:54,686 --> 00:24:56,396
能帮助你获得更多关于 SQLite 的


779
00:24:56,396 --> 00:24:57,386
调试信息


780
00:24:57,386 --> 00:25:00,746
但是 有一个你需要永远记得运行的


781
00:25:00,746 --> 00:25:02,566
是 com.Apple.Core 


782
00:25:02,566 --> 00:25:04,066
和 Data.ConcurrencyDebug.


783
00:25:04,616 --> 00:25:06,266
它将抓取你的 App 中


784
00:25:06,266 --> 00:25:07,746
任何的队列异常
 
00:25:07,746 --> 00:25:09,396
从主队列和后台队列上下文之间


785
00:25:09,396 --> 00:25:10,766
你可能进行


786
00:25:10,766 --> 00:25:14,066
传输的地方 或者


787
00:25:14,066 --> 00:25:15,566
不遵循托管对象的


788
00:25:15,566 --> 00:25:18,666
真实上下文的地方


789
00:25:18,746 --> 00:25:20,466
SQLite 也有很多


790
00:25:20,466 --> 00:25:21,506
有趣的环境变量


791
00:25:21,506 --> 00:25:23,206
所以它们的线程和


792
00:25:23,206 --> 00:25:24,756
文件的断言函数


793
00:25:24,756 --> 00:25:25,836
能很好地


794
00:25:25,836 --> 00:25:27,286
保证你的 App 中


795
00:25:27,286 --> 00:25:29,746
的 API 以及文件系统的正确率


796
00:25:30,576 --> 00:25:32,386
自动追踪是一种使你


797
00:25:32,386 --> 00:25:33,496
看到内部发生了什么的好方法


798
00:25:33,496 --> 00:25:34,826
是一个对调试日志的


799
00:25:34,826 --> 00:25:36,046
追加行程


800
00:25:36,856 --> 00:25:39,646
com.Apple.CoreData.SQLDebug


801
00:25:39,646 --> 00:25:40,676
有四个层级


802
00:25:41,106 --> 00:25:43,206
第一层级是最有趣的


803
00:25:43,206 --> 00:25:44,636
也是系统还原备份


804
00:25:44,636 --> 00:25:45,466
最少的


805
00:25:45,466 --> 00:25:47,826
第四层是最冗长的


806
00:25:47,826 --> 00:25:49,126
但是在运行过程中


807
00:25:49,126 --> 00:25:51,006
产生大量的


808
00:25:51,006 --> 00:25:53,726
系统还原备份


809
00:25:53,996 --> 00:25:55,696
当你启用 SQL 调试


810
00:25:55,806 --> 00:25:57,146
和多线程断言时


811
00:25:57,146 --> 00:25:58,476
你会在控制台中看到


812
00:25:58,506 --> 00:26:00,456
几个运行记录


813
00:26:00,456 --> 00:26:01,356
它们象征着


814
00:26:01,356 --> 00:26:02,526
断言函数能够


815
00:26:02,526 --> 00:26:03,366
正确运行


816
00:26:04,636 --> 00:26:06,076
当我们使用 SQL debugging 时


817
00:26:06,076 --> 00:26:07,456
你将可以看到例如


818
00:26:07,456 --> 00:26:08,656
读取请求的选择语句


819
00:26:08,656 --> 00:26:10,866
以及它需要花费多长时间


820
00:26:11,706 --> 00:26:13,016
如果你被设置为第四级


821
00:26:13,016 --> 00:26:14,766
你甚至会得到 explain


822
00:26:15,026 --> 00:26:16,056
向你展示


823
00:26:16,056 --> 00:26:17,836
给定的选择语句的


824
00:26:18,186 --> 00:26:19,016
查询计划


825
00:26:19,586 --> 00:26:20,936
在这里我们能看到


826
00:26:20,936 --> 00:26:23,786
我们的表格视图通过 


827
00:26:23,786 --> 00:26:25,856
表扫描进行筛选


828
00:26:25,856 --> 00:26:27,866
然后按照时间戳的顺序


829
00:26:27,866 --> 00:26:29,646
使用内存中的 B 树


830
00:26:30,536 --> 00:26:31,876
这是个潜在的性能问题


831
00:26:31,876 --> 00:26:33,766
当你在运行你的 App 时


832
00:26:33,766 --> 00:26:35,006
你可以使用这样的


833
00:26:35,006 --> 00:26:37,116
信息来看


834
00:26:37,116 --> 00:26:38,506
你是否做了比你所需要的做的


835
00:26:38,506 --> 00:26:39,086
更多的工作


836
00:26:40,346 --> 00:26:41,496
所以 我们该怎么修正它


837
00:26:42,946 --> 00:26:45,816
事实上我们发现 


838
00:26:45,816 --> 00:26:46,776
SQLite3 可以告诉我们


839
00:26:47,476 --> 00:26:49,166
如果我们打开一个数据库


840
00:26:49,166 --> 00:26:50,696
将我们的 SQL 日志里的选择查询传递给它


841
00:26:50,696 --> 00:26:52,926
我们就能够启动一个


842
00:26:52,926 --> 00:26:54,616
成为 Expert 的模式


843
00:26:54,616 --> 00:26:56,396
它能够对队列进行分析


844
00:26:56,436 --> 00:26:58,616
然后通过创建覆盖索引


845
00:26:58,616 --> 00:27:00,366
给出合适的优化方案


846
00:27:01,366 --> 00:27:02,606
如果我们能通过


847
00:27:02,606 --> 00:27:05,256
对发布实体增加读取索引


848
00:27:05,576 --> 00:27:06,416
来在模型编辑器里做这件事


849
00:27:07,066 --> 00:27:10,216
这里我已经将它配置在时间戳上


850
00:27:10,216 --> 00:27:12,676
将它们以递减的顺序调出


851
00:27:12,676 --> 00:27:13,786
我们将最近的帖子


852
00:27:13,786 --> 00:27:15,526
展示在表格视图的最上端


853
00:27:17,676 --> 00:27:19,106
当我们再次运行 App 时


854
00:27:19,106 --> 00:27:20,976
我们会看到同样的选择日志


855
00:27:24,386 --> 00:27:26,546
除了这一次


856
00:27:26,546 --> 00:27:27,876
我们看到选择查询 


857
00:27:27,876 --> 00:27:29,616
在查询中达到了覆盖索引


858
00:27:30,126 --> 00:27:31,726
解释命令告诉我们


859
00:27:31,726 --> 00:27:38,296
查询将使用覆盖索引进行排序


860
00:27:38,536 --> 00:27:39,966
核心数据支持很多类型的索引


861
00:27:39,966 --> 00:27:43,356
包括使用 R 树的符合索引


862
00:27:43,906 --> 00:27:45,646
这对创建


863
00:27:45,646 --> 00:27:47,346
任何类型的查询


864
00:27:47,346 --> 00:27:49,806
或者在选择语句里 


865
00:27:50,406 --> 00:27:51,536
使用边界框的优化查询都很有用


866
00:27:52,196 --> 00:27:53,386
最常见的用途是为了定位


867
00:27:53,426 --> 00:27:55,216
我们可以通过向发布实体


868
00:27:55,216 --> 00:27:57,396
增加另一个索引来对它进行设置


869
00:27:57,396 --> 00:27:58,876
为了展示这张幻灯片


870
00:27:58,876 --> 00:28:00,396
我添加了


871
00:28:00,396 --> 00:28:02,536
经纬度属性


872
00:28:04,816 --> 00:28:06,836
我们通过选择 R 树


873
00:28:06,836 --> 00:28:08,246
更改了盒子里的查询类型


874
00:28:08,796 --> 00:28:10,836
我们可以在读取请求上


875
00:28:10,836 --> 00:28:12,556
设置谓词


876
00:28:13,206 --> 00:28:14,906
然后获得所有


877
00:28:14,906 --> 00:28:16,516
在中国大陆境内发布的帖子


878
00:28:18,406 --> 00:28:20,186
这种谓词比较高级


879
00:28:20,186 --> 00:28:21,656
因为它使用


880
00:28:21,716 --> 00:28:24,306
实际选择语句里的功能


881
00:28:24,306 --> 00:28:26,256
来找到 


882
00:28:26,256 --> 00:28:27,676
我们在托管对象模型里


883
00:28:27,676 --> 00:28:28,676
创建的索引


884
00:28:31,556 --> 00:28:33,266
我们在没有这个索引和谓词的情况下


885
00:28:33,266 --> 00:28:35,016
运行 App


886
00:28:35,016 --> 00:28:36,596
可以看到和我们之前


887
00:28:36,596 --> 00:28:38,266
仅使用时间戳索引


888
00:28:38,726 --> 00:28:41,826
得到的结果是相同的


889
00:28:42,366 --> 00:28:44,956
但是当我们在没有


890
00:28:44,956 --> 00:28:47,196
新的索引和谓词的情况下运行时


891
00:28:47,196 --> 00:28:48,956
SQLite 会使用索引来


892
00:28:48,956 --> 00:28:51,626
为两个语句


893
00:28:51,626 --> 00:28:53,056
生成更快速的结果


894
00:28:55,026 --> 00:28:56,806
不幸的是


895
00:28:56,806 --> 00:28:58,446
我们的时间戳索引没有


896
00:28:58,446 --> 00:28:59,656
任何的复合谓词


897
00:28:59,976 --> 00:29:01,566
SQLite 不能用它


898
00:29:01,566 --> 00:29:02,006
来进行排序


899
00:29:02,556 --> 00:29:04,776
我们在这里选择的优化


900
00:29:04,776 --> 00:29:07,216
是使用复合索引


901
00:29:07,216 --> 00:29:08,636
首先过滤掉更小的对象组


902
00:29:08,636 --> 00:29:11,676
然后用内存中的 B 树


903
00:29:11,676 --> 00:29:13,736
来进行排序


904
00:29:14,336 --> 00:29:18,536
就像各位看到的


905
00:29:18,536 --> 00:29:20,186
这个索引将我们的读取性能


906
00:29:20,186 --> 00:29:22,286
提高了 25%


907
00:29:23,986 --> 00:29:25,256
这种情况下


908
00:29:25,256 --> 00:29:27,066
性能测试是运行大概 100,000 行


909
00:29:27,066 --> 00:29:29,726
我们看到


910
00:29:29,726 --> 00:29:31,616
仅对于读取函数而言


911
00:29:31,616 --> 00:29:33,036
就有了 130 毫秒的提高


912
00:29:34,476 --> 00:29:35,876
这就引出了我的下一个话题


913
00:29:36,196 --> 00:29:37,466
核心数据的测试


914
00:29:38,646 --> 00:29:40,716
正如各位所知


915
00:29:40,716 --> 00:29:41,086
我们非常喜欢测试


916
00:29:41,656 --> 00:29:42,476
测试很棒


917
00:29:43,026 --> 00:29:45,156
在核心数据里


918
00:29:45,156 --> 00:29:46,686
我们在内部既使用它们检测正确性


919
00:29:46,686 --> 00:29:48,476
又使用它们学习


920
00:29:48,906 --> 00:29:49,826
核心数据的功能


921
00:29:49,826 --> 00:29:51,026
以及 API 


922
00:29:51,026 --> 00:29:54,406
在给定的条件下的行为


923
00:29:55,316 --> 00:29:56,326
同时也能很好地


924
00:29:56,326 --> 00:29:58,876
验证你关于核心数据的工作


925
00:29:58,986 --> 00:30:00,806
以及它将如何在你的 App 中


926
00:30:00,806 --> 00:30:02,916
帮助你的顾客获得


927
00:30:02,916 --> 00:30:03,716
更好的体验


928
00:30:04,266 --> 00:30:05,316
就像各位在前一个例子中看到的


929
00:30:05,316 --> 00:30:06,916
我们能够验证


930
00:30:06,916 --> 00:30:08,966
R 树索引可以


931
00:30:08,966 --> 00:30:10,456
优化性能


932
00:30:10,456 --> 00:30:11,466
虽然它使用的是内存里的


933
00:30:11,466 --> 00:30:12,186
B 树排序


934
00:30:14,276 --> 00:30:16,136
但同样能捕捉到你的产品需求


935
00:30:16,136 --> 00:30:17,686
在核心数据里


936
00:30:17,686 --> 00:30:19,456
这对我们十分重要


937
00:30:19,456 --> 00:30:20,896
因为它能帮助我们


938
00:30:20,896 --> 00:30:22,296
与你的期望沟通


939
00:30:22,786 --> 00:30:24,026
通过测试


940
00:30:24,026 --> 00:30:25,566
我们可以看到你在用代码做什么


941
00:30:25,566 --> 00:30:27,296
以及你希望这些代码


942
00:30:27,296 --> 00:30:28,546
如何服务你的顾客


943
00:30:29,686 --> 00:30:30,816
你可以设置一些重要的东西


944
00:30:30,816 --> 00:30:31,976
使你的工作更容易一些


945
00:30:31,976 --> 00:30:36,196
比如 能够生成持久化容器的


946
00:30:36,196 --> 00:30:37,236
基础类别


947
00:30:38,406 --> 00:30:39,926
屏幕上的基础类别


948
00:30:39,926 --> 00:30:41,856
为持久化存储使用了


949
00:30:41,856 --> 00:30:43,426
/dev/null 的文件 URL


950
00:30:43,426 --> 00:30:45,316
这是一种很好的测试方式


951
00:30:45,316 --> 00:30:48,506
它对一小部分的托管对象起作用


952
00:30:48,506 --> 00:30:50,446
且运行十分迅速


953
00:30:50,446 --> 00:30:52,076
因为它们将在整个内存里运行


954
00:30:52,776 --> 00:30:54,726
当你这样做时


955
00:30:54,726 --> 00:30:56,306
SQLite 实现了一个内存中的存储


956
00:30:56,306 --> 00:30:57,866
非常高效


957
00:30:57,866 --> 00:30:59,596
但是因为是在内存里


958
00:30:59,596 --> 00:31:00,756
如果你有很多数据


959
00:31:00,756 --> 00:31:03,536
会导致你的测试套件中


960
00:31:03,976 --> 00:31:04,146
内存大量增长


961
00:31:07,616 --> 00:31:11,676
不过 你需要完成至少一次测试


962
00:31:11,676 --> 00:31:13,506
在磁盘上将存储文件具体化


963
00:31:14,026 --> 00:31:15,746
这是因为


964
00:31:15,746 --> 00:31:16,806
如果不能为了


965
00:31:16,806 --> 00:31:18,316
你的测试打开存储


966
00:31:18,316 --> 00:31:19,436
那你的顾客也打不开


967
00:31:21,076 --> 00:31:22,546
如果持久化容器


968
00:31:22,546 --> 00:31:24,156
在 App 代理里


969
00:31:24,156 --> 00:31:25,506
你会有一个测试基类


970
00:31:25,506 --> 00:31:26,866
能将容器取出


971
00:31:26,866 --> 00:31:28,506
然后直接写入内存


972
00:31:29,296 --> 00:31:31,496
不过当你这样做时


973
00:31:31,496 --> 00:31:33,086
我必须提醒你


974
00:31:33,086 --> 00:31:34,106
因为这意味着


975
00:31:34,106 --> 00:31:35,566
你在写入一个


976
00:31:35,566 --> 00:31:37,776
被 App 使用的内存文件


977
00:31:37,776 --> 00:31:38,916
所以如果你在个人设备上


978
00:31:38,916 --> 00:31:40,646
运行测试


979
00:31:40,646 --> 00:31:42,006
你将在下次打开 App 的时候


980
00:31:42,006 --> 00:31:47,316
看到你单元测试的结果


981
00:31:47,536 --> 00:31:48,446
如果我告诉你


982
00:31:48,446 --> 00:31:50,316
我能用 7 行代码


983
00:31:50,316 --> 00:31:51,236
添加 100,000 个记录呢


984
00:31:53,806 --> 00:31:55,036
其实有一点作弊


985
00:31:55,036 --> 00:31:56,356
我会把这个当做


986
00:31:56,356 --> 00:31:58,556
留给观众的练习


987
00:31:58,556 --> 00:31:59,946
但是这种方式的支架代码


988
00:31:59,946 --> 00:32:01,306
可以帮助你构建一个


989
00:32:01,306 --> 00:32:02,556
测试套件


990
00:32:02,556 --> 00:32:04,016
来评估你的数据的不变性


991
00:32:04,976 --> 00:32:06,386
通过提前构建这些方法


992
00:32:06,386 --> 00:32:08,496
当你的数据变化 或者你意识到 


993
00:32:08,496 --> 00:32:09,876
你的 App 的新用例时


994
00:32:09,876 --> 00:32:11,626
你可以通过迭代


995
00:32:11,626 --> 00:32:13,486
来构建新的边界情况


996
00:32:13,486 --> 00:32:14,756
来为对象图


997
00:32:14,756 --> 00:32:15,826
构建新的结构


998
00:32:15,826 --> 00:32:17,946
或者在内部


999
00:32:17,946 --> 00:32:19,186
评估一些特定功能的行为


1000
00:32:19,186 --> 00:32:21,776
例如性能


1001
00:32:22,146 --> 00:32:25,606
这是我用来为


1002
00:32:25,606 --> 00:32:26,566
R 树查询


1003
00:32:26,566 --> 00:32:28,466
构建性能测试的单元测试支架


1004
00:32:29,176 --> 00:32:30,496
仅仅在几行代码中


1005
00:32:30,496 --> 00:32:32,456
我们可以对 


1006
00:32:32,456 --> 00:32:33,886
读取性能很有信心


1007
00:32:34,836 --> 00:32:36,286
这些类型的测试


1008
00:32:36,286 --> 00:32:37,466
信息量很大


1009
00:32:37,466 --> 00:32:38,996
当你尝试去评估


1010
00:32:38,996 --> 00:32:40,386
核心数据里


1011
00:32:40,386 --> 00:32:44,896
不一样的功能之间的权衡


1012
00:32:45,316 --> 00:32:46,576
这三行代码


1013
00:32:46,576 --> 00:32:47,936
生成了新的托管对象上下文


1014
00:32:47,936 --> 00:32:49,976
以及一个容器


1015
00:32:49,976 --> 00:32:50,946
供我们的测试使用


1016
00:32:51,756 --> 00:32:54,206
现在这点很重要


1017
00:32:54,206 --> 00:32:55,606
主要是因为在测试中


1018
00:32:55,606 --> 00:32:57,786
setup 和 teardown 方法的逻辑可以


1019
00:32:57,786 --> 00:32:59,066
对性能表现产生影响


1020
00:32:59,696 --> 00:33:01,196
所以需要注意分析


1021
00:33:01,196 --> 00:33:02,836
你是否真的在测试


1022
00:33:02,836 --> 00:33:04,226
setup 方法


1023
00:33:04,226 --> 00:33:05,256
还是 teardown 方法


1024
00:33:05,256 --> 00:33:06,946
还是你在评估


1025
00:33:06,946 --> 00:33:08,216
查询命令的


1026
00:33:08,216 --> 00:33:09,626
实际运行性能


1027
00:33:10,556 --> 00:33:11,546
在你运行测试之后


1028
00:33:11,546 --> 00:33:14,046
你可以提交好的错误报告


1029
00:33:15,526 --> 00:33:17,346
我们喜欢错误


1030
00:33:17,346 --> 00:33:18,546
特别是从你们这里反馈的错误


1031
00:33:18,546 --> 00:33:19,796
因为我们在构建一个产品


1032
00:33:19,796 --> 00:33:20,606
希望它能帮助你构建你的 App 


1033
00:33:21,206 --> 00:33:26,486
但是 没有测试或示例 App


1034
00:33:26,486 --> 00:33:28,126
对我们而言是很难理解的


1035
00:33:28,126 --> 00:33:29,906
就像我前面提到的


1036
00:33:29,906 --> 00:33:30,696
它们不会


1037
00:33:30,696 --> 00:33:33,046
像结构良好的测试那样


1038
00:33:33,046 --> 00:33:35,206
捕捉你的产品需求和期待


1039
00:33:35,206 --> 00:33:37,366
事实上


1040
00:33:37,956 --> 00:33:39,716
一个连接到 Radar 的 App


1041
00:33:39,716 --> 00:33:41,756
如果有测试套装


1042
00:33:41,756 --> 00:33:43,526
哪怕是一个空的


1043
00:33:44,086 --> 00:33:46,186
带有一些 UI 的示例 App


1044
00:33:46,406 --> 00:33:48,436
能向我们解释你的问题


1045
00:33:48,436 --> 00:33:50,076
我们也能更快回复你


1046
00:33:50,236 --> 00:33:52,706
并告诉你该怎么做


1047
00:33:53,596 --> 00:33:55,106
它们同样能帮助我们分辨


1048
00:33:55,106 --> 00:33:56,616
我们后续修复的准确性


1049
00:33:57,066 --> 00:33:58,226
所以 如果你要填写一份错误报告


1050
00:33:58,226 --> 00:34:00,806
请花一点时间


1051
00:34:00,806 --> 00:34:02,266
写一个测试给我们


1052
00:34:04,296 --> 00:34:05,476
这就是我今天要讲的所有内容


1053
00:34:05,956 --> 00:34:08,156
大家明天可以到实验室来找我们


1054
00:34:08,335 --> 00:34:10,946
我们会从下午 1:30 开始


1055
00:34:10,946 --> 00:34:13,315
在 7 号技术实验室


1056
00:34:13,315 --> 00:34:14,286
我也强烈建议大家


1057
00:34:14,286 --> 00:34:15,826
了解一下明天下午 3:20 在大厅 2 


1058
00:34:15,826 --> 00:34:17,585
举行的测试技巧与诀窍会议


1059
00:34:18,896 --> 00:34:19,906
谢谢


1060
00:34:20,507 --> 00:34:22,507
[ 掌声 ]

