1
00:00:01,176 --> 00:00:04,500
[音乐]


2
00:00:11,516 --> 00:00:16,676
[掌声]


3
00:00:17,176 --> 00:00:18,086
>> 大家下午好


4
00:00:18,366 --> 00:00:19,926
我是 Frank Doepke 


5
00:00:19,926 --> 00:00:21,226
我将要探讨的是


6
00:00:21,226 --> 00:00:22,956
Vision 框架中的文本识别


7
00:00:23,506 --> 00:00:28,236
如今 熟悉 Vision 的人


8
00:00:28,236 --> 00:00:29,446
都知道我们已经有了


9
00:00:29,446 --> 00:00:32,735
VNDetectRectangleRequest


10
00:00:32,735 --> 00:00:34,796
它可以告诉你图像中的文本在哪里


11
00:00:36,176 --> 00:00:38,286
出于某些原因


12
00:00:38,286 --> 00:00:40,176
我们总会遇到一个问题


13
00:00:40,176 --> 00:00:41,086
文本是什么


14
00:00:41,806 --> 00:00:43,496
所以我们需要一些


15
00:00:43,696 --> 00:00:44,946
额外的代码来解答


16
00:00:45,156 --> 00:00:46,776
它将你的结果以数组存放


17
00:00:47,916 --> 00:00:50,206
然后你需要训练


18
00:00:50,206 --> 00:00:52,456
实际上可以读取这些内容的 


19
00:00:52,456 --> 00:00:53,606
Core ML 模型


20
00:00:55,076 --> 00:00:57,636
接下来运行 Core ML 模型


21
00:00:58,376 --> 00:01:01,256
滤除不好的特征


22
00:01:02,086 --> 00:01:03,156
你把所有这些字符


23
00:01:03,156 --> 00:01:05,336
放到一个字符串中


24
00:01:05,336 --> 00:01:06,646
然后想出一些


25
00:01:07,056 --> 00:01:08,926
启发性的方法并从中真正


26
00:01:08,926 --> 00:01:10,536
形成句子和单词


27
00:01:11,926 --> 00:01:12,956
所以现在你明白


28
00:01:12,956 --> 00:01:14,366
为什么我们需要一个完整的会议


29
00:01:14,366 --> 00:01:14,906
来讨论文本识别


30
00:01:15,436 --> 00:01:18,506
但今天我想让这更容易些


31
00:01:19,756 --> 00:01:21,536
我们带来了一些新东西


32
00:01:21,536 --> 00:01:23,606
那就是 VNRecognizedTextRequest


33
00:01:24,136 --> 00:01:26,556
也就是你在这里


34
00:01:26,556 --> 00:01:30,006
看到的一小段文本 [掌声]


35
00:01:30,886 --> 00:01:34,466
它让你从这样的图像中


36
00:01:34,466 --> 00:01:37,946
进入这样的可识别文本


37
00:01:38,036 --> 00:01:40,036
[掌声]


38
00:01:40,056 --> 00:01:46,436
谢谢 好的 那么今天


39
00:01:46,436 --> 00:01:49,256
我们要介绍什么呢 首先我们来谈一谈


40
00:01:49,256 --> 00:01:51,636
文本识别的工作原理


41
00:01:53,056 --> 00:01:54,266
我们有许多示例 App


42
00:01:54,266 --> 00:01:56,126
它们也都


43
00:01:56,126 --> 00:01:57,356
添加到了会议资料中


44
00:01:57,356 --> 00:01:58,696
因此你可以下载示例代码


45
00:02:00,156 --> 00:02:01,986
最后我们将介绍一些关于


46
00:02:02,046 --> 00:02:03,756
如何在 Vision 中使用文本识别技术


47
00:02:03,756 --> 00:02:04,296
来工作的最佳实践


48
00:02:04,866 --> 00:02:07,746
那么 文本识别是如何在 Vision 中实现的呢


49
00:02:08,446 --> 00:02:11,156
我们有两条路可供选择


50
00:02:11,246 --> 00:02:15,626
快速路径和精确路径


51
00:02:18,216 --> 00:02:21,446
快速路径实际上


52
00:02:21,446 --> 00:02:22,626
是通过查找字符来实现


53
00:02:22,626 --> 00:02:24,896
文本检测器之前所做的工作


54
00:02:25,626 --> 00:02:28,686
然后推进一个小型机器学习模型


55
00:02:28,686 --> 00:02:30,336
来实际地识别


56
00:02:30,336 --> 00:02:31,556
这些字符


57
00:02:31,896 --> 00:02:33,856
逐个识别


58
00:02:35,176 --> 00:02:36,796
而精确路径


59
00:02:36,796 --> 00:02:38,716
则使用最先进的


60
00:02:39,336 --> 00:02:41,976
神经网络


61
00:02:42,466 --> 00:02:44,056
通过首先以字符串和整行


62
00:02:44,056 --> 00:02:45,646
来识别文本


63
00:02:46,656 --> 00:02:49,646
然后将其识别为


64
00:02:49,866 --> 00:02:50,696
单词和句子


65
00:02:52,586 --> 00:02:54,826
因此它要求一个


66
00:02:54,826 --> 00:02:56,966
深度学习模型


67
00:02:56,966 --> 00:02:58,766
这要花费更多时间来计算


68
00:02:58,766 --> 00:03:00,536
但它读得更多


69
00:03:00,576 --> 00:03:01,716
就像我们实际阅读文本


70
00:03:02,936 --> 00:03:04,626
我们不逐字阅读


71
00:03:04,626 --> 00:03:05,456
我们以单词为单位阅读


72
00:03:05,456 --> 00:03:08,106
这有助于我们了解


73
00:03:08,106 --> 00:03:10,156
你也知道某些字符可能有点


74
00:03:10,156 --> 00:03:12,506
难以阅读


75
00:03:12,506 --> 00:03:13,726
这也是为什么


76
00:03:13,726 --> 00:03:15,076
当我们试图校对我们的文本时


77
00:03:15,076 --> 00:03:17,146
我们看不到错别字


78
00:03:17,326 --> 00:03:18,876
因为我们的大脑


79
00:03:18,876 --> 00:03:20,126
会对这些错误进行插补


80
00:03:20,506 --> 00:03:21,646
所以我们在精确路径中


81
00:03:21,646 --> 00:03:23,426
使用相同类型的技术


82
00:03:23,426 --> 00:03:24,996
来帮助我们克服


83
00:03:25,036 --> 00:03:26,466
一些识别错误


84
00:03:28,056 --> 00:03:30,716
之后的两个阶段


85
00:03:30,716 --> 00:03:32,126
实际上都会经历一个


86
00:03:32,126 --> 00:03:33,786
语言矫正阶段


87
00:03:33,836 --> 00:03:35,116
这有助于我们再次


88
00:03:35,116 --> 00:03:36,246
消除一些典型的误读


89
00:03:37,536 --> 00:03:39,426
我们得到了结果


90
00:03:40,066 --> 00:03:43,446
你可能认为这是一个复杂的机器


91
00:03:44,226 --> 00:03:47,066
但这一切都发生在设备上


92
00:03:48,516 --> 00:03:52,500
[掌声]


93
00:03:55,096 --> 00:03:56,286
下面我们一起来看一下


94
00:03:56,286 --> 00:03:57,976
快速路径与精确路径的区别


95
00:04:00,296 --> 00:04:01,526
我做了一个


96
00:04:01,526 --> 00:04:03,406
阅读这个文件的屏幕录制


97
00:04:04,286 --> 00:04:05,976
因为我是在一个相对较旧的 


98
00:04:05,976 --> 00:04:06,816
MacBook Pro 上做的


99
00:04:06,816 --> 00:04:07,856
所以你看到的时间


100
00:04:07,856 --> 00:04:09,286
不一定具有代表性


101
00:04:09,386 --> 00:04:11,466
不过我想给你一个直观感觉


102
00:04:11,466 --> 00:04:13,876
接下来我们看看快速路径有多快


103
00:04:15,696 --> 00:04:18,206
已经完成了


104
00:04:18,416 --> 00:04:19,716
下面再来看看


105
00:04:19,716 --> 00:04:20,426
精确路径需要多长时间


106
00:04:21,245 --> 00:04:22,856
你看到了过程吗


107
00:04:22,856 --> 00:04:24,766
它花的时间更长一点


108
00:04:25,346 --> 00:04:26,486
正如我所说 


109
00:04:26,486 --> 00:04:28,236
这些数字并不能说明一切 


110
00:04:28,306 --> 00:04:29,196
但它能给你一个直观感受


111
00:04:30,466 --> 00:04:31,846
另外你还可以看到


112
00:04:32,726 --> 00:04:34,356
在阅读整篇文章方面


113
00:04:34,406 --> 00:04:35,766
精确路径的效果更棒


114
00:04:35,936 --> 00:04:37,246
快速路径顶部的


115
00:04:37,246 --> 00:04:39,836
程式化字体有一点问题


116
00:04:40,956 --> 00:04:42,146
因此在这两条路径之间


117
00:04:42,146 --> 00:04:45,736
有一些方面需要权衡


118
00:04:45,736 --> 00:04:48,686
让我们来看看这些权衡


119
00:04:48,756 --> 00:04:50,726
快速路径是为了


120
00:04:50,726 --> 00:04:52,366
实时阅读


121
00:04:52,366 --> 00:04:53,366
并为此进行了优化


122
00:04:53,366 --> 00:04:55,106
但是精确路径


123
00:04:55,166 --> 00:04:56,676
更有可能以一种


124
00:04:56,676 --> 00:04:57,656
异步方式使用


125
00:04:58,236 --> 00:05:01,416
在内存预算方面


126
00:05:01,776 --> 00:05:03,866
快速路径使用较少的内存


127
00:05:03,866 --> 00:05:05,976
因为它不需要运行大型神经网络


128
00:05:09,426 --> 00:05:11,236
但是当涉及到


129
00:05:11,236 --> 00:05:13,696
旋转文本或透视错位文本时


130
00:05:13,696 --> 00:05:16,336
精确路径会为你


131
00:05:16,336 --> 00:05:17,546
提供更广泛的支持


132
00:05:19,136 --> 00:05:21,256
当涉及到样式或字体时


133
00:05:21,336 --> 00:05:23,556
就如同你在示例中


134
00:05:23,556 --> 00:05:25,426
看到的那样


135
00:05:25,426 --> 00:05:26,736
当涉及到样式化文本时


136
00:05:26,736 --> 00:05:28,026
精确路径再次提供


137
00:05:28,026 --> 00:05:29,306
更广泛的支持


138
00:05:30,576 --> 00:05:34,306
最后 当涉及到自然语言的


139
00:05:34,306 --> 00:05:36,646
真实阅读时


140
00:05:36,646 --> 00:05:37,816
我们会推荐精确路径


141
00:05:37,816 --> 00:05:40,026
因为它在该部分


142
00:05:41,716 --> 00:05:41,856
表现最好


143
00:05:42,046 --> 00:05:44,046
那么你如何在这两者之间做出选择呢


144
00:05:45,266 --> 00:05:46,926
你所拥有的用例


145
00:05:47,556 --> 00:05:48,766
是实际驱动你


146
00:05:48,766 --> 00:05:50,256
想要如何使用请求的


147
00:05:50,256 --> 00:05:51,366
重要部分


148
00:05:52,516 --> 00:05:54,226
你还需要考虑一些事情


149
00:05:54,866 --> 00:05:55,796
比如我的输入是什么


150
00:05:56,216 --> 00:05:57,686
我是在使用相机


151
00:05:57,686 --> 00:06:00,096
还是已经在照片库中


152
00:06:00,096 --> 00:06:01,506
得到了要处理的图像


153
00:06:03,726 --> 00:06:05,376
我的处理限制是什么


154
00:06:05,876 --> 00:06:08,076
我可以在这个请求上花费多少时间


155
00:06:08,266 --> 00:06:10,086
我有多少可用的内存


156
00:06:10,586 --> 00:06:11,966
一些进程可能会


157
00:06:11,966 --> 00:06:15,216
受到内存限制以及最后


158
00:06:15,216 --> 00:06:16,366
我将如何处理这些结果


159
00:06:16,876 --> 00:06:18,506
用它们来转录吗


160
00:06:18,796 --> 00:06:19,666
还是用来搜索呢


161
00:06:20,006 --> 00:06:22,156
或者只是根据我


162
00:06:22,156 --> 00:06:23,256
通过相机读取的内容执行操作


163
00:06:23,256 --> 00:06:26,956
下面我们再来谈谈


164
00:06:26,956 --> 00:06:28,406
相机捕捉的细节


165
00:06:29,916 --> 00:06:31,376
相机捕捉技术


166
00:06:31,376 --> 00:06:32,206
可以用作实时捕捉


167
00:06:32,236 --> 00:06:33,836
所以你现在实际上


168
00:06:33,836 --> 00:06:36,146
想要使用字符串读取


169
00:06:36,146 --> 00:06:37,076
并保持帧速率


170
00:06:37,366 --> 00:06:38,946
在这种情况下


171
00:06:38,946 --> 00:06:39,966
快速路径最有可能是


172
00:06:39,966 --> 00:06:40,446
你想要使用的路径


173
00:06:40,946 --> 00:06:43,796
不过这里也存在着


174
00:06:43,796 --> 00:06:44,916
机会性捕捉


175
00:06:45,256 --> 00:06:47,036
我的意思是 例如


176
00:06:47,036 --> 00:06:48,486
你拍了一张照片


177
00:06:48,486 --> 00:06:49,366
照片中的某个地方有文本


178
00:06:49,366 --> 00:06:50,316
你想处理它


179
00:06:50,316 --> 00:06:51,596
你不需要跟上


180
00:06:51,596 --> 00:06:52,586
相机的帧速率


181
00:06:52,586 --> 00:06:54,286
但你事实上希望


182
00:06:54,286 --> 00:06:55,626
使用它来读取文本


183
00:06:55,626 --> 00:06:56,936
因此精确路径


184
00:06:56,936 --> 00:06:58,236
最有可能提供更好的结果


185
00:06:59,856 --> 00:07:01,346
当我们谈论相机时


186
00:07:01,346 --> 00:07:03,876
还有一件事要考虑


187
00:07:03,876 --> 00:07:06,246
我需要在我的 App 中


188
00:07:06,246 --> 00:07:07,326
设计使用哪种分辨率


189
00:07:07,326 --> 00:07:09,516
而文本大小


190
00:07:09,576 --> 00:07:11,626
实际上会驱动这个问题


191
00:07:11,626 --> 00:07:12,846
如果出于某种原因


192
00:07:12,846 --> 00:07:14,006
你想阅读


193
00:07:14,006 --> 00:07:15,756
法律文件的细则


194
00:07:15,756 --> 00:07:17,046
你可能真的需要


195
00:07:17,046 --> 00:07:18,336
增加相机的分辨率


196
00:07:18,636 --> 00:07:20,356
或者当你阅读


197
00:07:20,356 --> 00:07:22,016
带有大文字的广告牌时


198
00:07:22,016 --> 00:07:23,006
你实际上可以降低分辨率


199
00:07:23,006 --> 00:07:24,256
用更少的内存工作


200
00:07:24,256 --> 00:07:25,906
且速度实际上也会更快


201
00:07:28,256 --> 00:07:29,596
现在涉及到后期处理


202
00:07:29,596 --> 00:07:30,986
我们已经在一个文件中


203
00:07:31,036 --> 00:07:32,836
保存了图像


204
00:07:34,196 --> 00:07:35,276
你最有可能选用精确路径


205
00:07:35,276 --> 00:07:36,796
因为这样你可以


206
00:07:36,796 --> 00:07:38,856
实际使用更好的准确性


207
00:07:38,856 --> 00:07:40,976
而速度显得并不那么重要


208
00:07:44,396 --> 00:07:46,416
接下来 我们来谈谈语言处理


209
00:07:46,686 --> 00:07:47,946
正如我提到的


210
00:07:47,946 --> 00:07:49,166
语言处理


211
00:07:49,166 --> 00:07:50,426
是文本识别中


212
00:07:50,426 --> 00:07:51,086
可以使用的阶段之一


213
00:07:52,576 --> 00:07:54,106
它有利于帮助我们


214
00:07:54,106 --> 00:07:56,026
克服一些在阅读文本时


215
00:07:56,026 --> 00:07:57,446
可能会发生的典型误读


216
00:07:57,446 --> 00:08:00,066
但另一方面


217
00:08:00,066 --> 00:08:00,456
它也会产生阻碍


218
00:08:01,216 --> 00:08:02,956
当我想读取


219
00:08:02,956 --> 00:08:04,276
代码或序列号时


220
00:08:04,276 --> 00:08:07,356
像 C001 这样的序列号


221
00:08:07,356 --> 00:08:08,976
它很容易被误认为是 Cool


222
00:08:12,126 --> 00:08:13,326
此外这种语言修正


223
00:08:13,326 --> 00:08:14,416
不是免费的


224
00:08:14,416 --> 00:08:15,636
它确实需要一些处理时间


225
00:08:15,636 --> 00:08:17,826
并且需要使用一点点内存


226
00:08:20,306 --> 00:08:21,226
现在我们已经掌握了


227
00:08:21,226 --> 00:08:22,626
一些基本的方法 


228
00:08:22,626 --> 00:08:25,126
接下来我们就来谈谈


229
00:08:25,126 --> 00:08:27,186
如何执行文本识别


230
00:08:28,896 --> 00:08:32,086
Vision 中的所有内容


231
00:08:32,086 --> 00:08:33,226
都从 ImageRequestHandler 开始 


232
00:08:34,586 --> 00:08:35,996
下面我创建我的请求


233
00:08:36,066 --> 00:08:39,506
我在上面设置了 completionHandler 


234
00:08:39,506 --> 00:08:40,746
这就是我


235
00:08:40,746 --> 00:08:41,586
处理结果的地方


236
00:08:41,586 --> 00:08:45,266
然后设置 recognitionLevel


237
00:08:45,526 --> 00:08:47,086
如我所说


238
00:08:47,086 --> 00:08:48,976
我可以在快速和精确之间切换


239
00:08:51,366 --> 00:08:53,516
接下来


240
00:08:53,516 --> 00:08:54,576
我建议你实际设置 revision


241
00:08:55,136 --> 00:08:58,736
当然这里只有一个修订版


242
00:08:58,736 --> 00:08:59,876
但是接下来我们将


243
00:08:59,876 --> 00:09:01,666
推出改进的版本


244
00:09:01,736 --> 00:09:03,436
你可能已经将算法


245
00:09:03,436 --> 00:09:05,576
调到了我们拥有的特定行为


246
00:09:05,716 --> 00:09:06,976
如果不指定修订版


247
00:09:06,976 --> 00:09:08,256
你将始终获得最新版本


248
00:09:08,256 --> 00:09:10,076
这样的话


249
00:09:10,076 --> 00:09:11,726
可能会出现一些意外


250
00:09:12,796 --> 00:09:14,686
所以


251
00:09:14,686 --> 00:09:15,706
我建议你们


252
00:09:15,706 --> 00:09:16,096
了解如何使用修订版


253
00:09:16,506 --> 00:09:18,836
最后


254
00:09:18,836 --> 00:09:22,436
我可以打开和关闭语言修正


255
00:09:22,436 --> 00:09:23,926
当然我还需要


256
00:09:23,926 --> 00:09:25,446
执行我的请求


257
00:09:27,556 --> 00:09:31,856
当执行请求时 我们会得到结果 这些结果作为


258
00:09:31,856 --> 00:09:34,076
VNRecognizedTextObservation 返回


259
00:09:34,316 --> 00:09:35,656
我们得到的基本上


260
00:09:35,656 --> 00:09:37,606
就是我们要找的行和字符串


261
00:09:38,616 --> 00:09:40,576
因此我们需要迭代这些结果


262
00:09:40,876 --> 00:09:44,426
然后我们想要得出文本


263
00:09:44,426 --> 00:09:46,656
实际上我们有多种候选


264
00:09:46,656 --> 00:09:47,646
稍后我会谈一下


265
00:09:47,646 --> 00:09:48,746
其中一些候选


266
00:09:49,016 --> 00:09:50,466
为了简单起见


267
00:09:50,466 --> 00:09:52,646
我只得到了我的最佳候选 并且得到了自己的文本


268
00:09:52,996 --> 00:09:55,226
我可以获取边界框


269
00:09:55,226 --> 00:09:56,536
这帮助我


270
00:09:56,536 --> 00:09:58,326
把所有的文本


271
00:09:58,646 --> 00:10:01,756
放在屏幕上或屏幕上的图像中


272
00:10:03,616 --> 00:10:04,956
但现在当我想使用搜索时


273
00:10:04,956 --> 00:10:06,446
例如用户键入


274
00:10:06,446 --> 00:10:08,676
在文档中读到的单词


275
00:10:08,976 --> 00:10:10,126
我们想在图像中


276
00:10:10,126 --> 00:10:11,796
再次找到


277
00:10:11,796 --> 00:10:13,706
这个单词的实际位置时


278
00:10:13,706 --> 00:10:15,936
我可以向候选询问


279
00:10:16,116 --> 00:10:17,486
我在结果中实际看到的


280
00:10:17,486 --> 00:10:19,156
这个字符串的


281
00:10:19,456 --> 00:10:20,796
边界框在哪里


282
00:10:24,066 --> 00:10:25,446
现在了解完整个理论


283
00:10:25,446 --> 00:10:26,836
我们来看一些例子


284
00:10:26,836 --> 00:10:28,836
做一些实时的文本识别


285
00:10:29,446 --> 00:10:31,596
这就是我们想要使用


286
00:10:31,596 --> 00:10:32,856
快速路径的时候


287
00:10:33,636 --> 00:10:36,096
这里使用的例子是


288
00:10:36,096 --> 00:10:37,046
我想读取序列号


289
00:10:37,046 --> 00:10:38,206
或代码之类的东西


290
00:10:39,096 --> 00:10:40,416
我在这里使用的序列号


291
00:10:40,416 --> 00:10:41,526
实际上是一个电话号码


292
00:10:41,526 --> 00:10:42,466
因为它对每个人来说


293
00:10:42,466 --> 00:10:44,086
都是最容易理解的


294
00:10:44,086 --> 00:10:45,516
我真的想


295
00:10:45,516 --> 00:10:46,716
像读条形码一样读它们


296
00:10:47,126 --> 00:10:49,836
有了这个


297
00:10:49,836 --> 00:10:50,986
我就可以限制相机


298
00:10:50,986 --> 00:10:53,756
如何实际地查找文本


299
00:10:53,756 --> 00:10:56,886
不过交互性是关键 因为它应该是活跃的


300
00:10:56,886 --> 00:10:57,846
它也应该很快


301
00:10:57,846 --> 00:10:59,956
以便可以引导用户 并立即读取文本


302
00:11:02,576 --> 00:11:04,756
所以这就是我为什么


303
00:11:04,756 --> 00:11:05,376
在这里选择快速路径


304
00:11:05,376 --> 00:11:07,936
然后我们来看看演示


305
00:11:16,596 --> 00:11:20,136
好了 我这里的示例代码


306
00:11:20,136 --> 00:11:21,306
就像我之前说的


307
00:11:21,306 --> 00:11:24,156
也附在这个会议资料中


308
00:11:24,156 --> 00:11:25,436
允许我读取电话号码


309
00:11:25,536 --> 00:11:27,126
所以当我扫描这个文本时


310
00:11:27,126 --> 00:11:28,926
你会看到一个小白框


311
00:11:28,926 --> 00:11:30,856
这意味着我找到了文本


312
00:11:30,856 --> 00:11:32,456
但我没有读它


313
00:11:32,456 --> 00:11:33,026
因为它不是电话号码


314
00:11:33,026 --> 00:11:34,576
甚至不是邮政编码


315
00:11:36,156 --> 00:11:37,336
但一旦我找到一个电话号码


316
00:11:37,336 --> 00:11:39,346
它就会读出来并停止扫描


317
00:11:39,346 --> 00:11:41,556
我再展示一次


318
00:11:42,516 --> 00:11:45,556
[掌声]


319
00:11:46,056 --> 00:11:47,466
它给人以互动感


320
00:11:47,466 --> 00:11:48,926
作为一个用户


321
00:11:48,926 --> 00:11:50,176
我很容易使用它


322
00:11:50,176 --> 00:11:52,516
即使我的手在颤抖


323
00:11:53,756 --> 00:11:55,376
那么这在代码中


324
00:11:55,376 --> 00:11:56,596
看起来如何呢


325
00:11:56,596 --> 00:11:57,496
因为这是真正有趣的部分


326
00:11:59,316 --> 00:12:01,796
所以我从创建文本请求开始


327
00:12:04,176 --> 00:12:06,076
正如我所说


328
00:12:06,076 --> 00:12:08,396
我将在这里使用快速路径


329
00:12:08,396 --> 00:12:09,296
我禁用了语言修正


330
00:12:09,326 --> 00:12:11,346
因为我知道 我正在寻找代码


331
00:12:11,346 --> 00:12:12,806
而不是在找自然文本


332
00:12:12,956 --> 00:12:16,466
然后我使用 regionOfInterest


333
00:12:16,466 --> 00:12:17,376
这是一个设想的概念


334
00:12:17,376 --> 00:12:18,706
并且普遍可用


335
00:12:19,176 --> 00:12:21,206
你会注意到


336
00:12:21,206 --> 00:12:22,476
在我的 App 中有一个小方框


337
00:12:22,476 --> 00:12:23,866
可以指导用户


338
00:12:23,866 --> 00:12:25,206
在想要的位置构建文本


339
00:12:25,206 --> 00:12:27,386
但是我也可以将这个区域


340
00:12:27,386 --> 00:12:29,546
作为兴趣区域


341
00:12:29,546 --> 00:12:31,126
这会使 Vision 


342
00:12:31,126 --> 00:12:32,256
只针对该特定对象


343
00:12:32,356 --> 00:12:36,276
这有助于我消除周围的所有噪音


344
00:12:36,276 --> 00:12:39,916
因为它需要处理的数据更少


345
00:12:39,916 --> 00:12:41,196
提高了性能


346
00:12:41,786 --> 00:12:44,756
现在我有我的请求


347
00:12:44,756 --> 00:12:46,356
我在这里使用 AVCapture 会话


348
00:12:47,576 --> 00:12:48,926
关于捕捉输出


349
00:12:48,926 --> 00:12:51,186
我所要做的就是


350
00:12:51,186 --> 00:12:53,316
从会话中获取我的图像


351
00:12:53,316 --> 00:12:57,166
创建 RequestHandler 并执行请求


352
00:12:57,166 --> 00:13:00,616
然后 这主要是框的绘制


353
00:13:00,616 --> 00:13:01,876
那还不是有趣的部分


354
00:13:03,026 --> 00:13:04,676
有趣的部分发生在


355
00:13:04,676 --> 00:13:05,556
我们的字符串工具中


356
00:13:05,666 --> 00:13:09,116
就像我说的


357
00:13:09,116 --> 00:13:10,536
我们关闭了语言修正


358
00:13:11,256 --> 00:13:13,686
我现在只能自己去修正其中的一些结果


359
00:13:13,686 --> 00:13:15,556
不过我能做好这一点


360
00:13:15,556 --> 00:13:16,766
因为我对这里


361
00:13:16,806 --> 00:13:19,206
需要解决的内容有内在的了解


362
00:13:19,206 --> 00:13:24,426
我知道我正在寻找电话号码


363
00:13:24,426 --> 00:13:25,826
而不是找其他字符


364
00:13:25,826 --> 00:13:28,266
我只是在寻找数字路径


365
00:13:28,266 --> 00:13:29,826
所以我可以简单地说


366
00:13:29,826 --> 00:13:31,936
如果它读取的内容类似于 S


367
00:13:31,936 --> 00:13:33,926
这将是一个 5


368
00:13:33,926 --> 00:13:35,576
或者如果我得到一个 L


369
00:13:35,576 --> 00:13:36,876
这应该是 1


370
00:13:36,876 --> 00:13:37,886
我使用我的领域知识


371
00:13:37,886 --> 00:13:38,956
来修正一些可能发生的典型错误


372
00:13:41,176 --> 00:13:42,846
因此这个方式


373
00:13:42,846 --> 00:13:44,556
帮助我们


374
00:13:44,606 --> 00:13:46,206
不让任何字母通过


375
00:13:46,206 --> 00:13:49,366
接下来是下一部分 我是如何区分


376
00:13:49,366 --> 00:13:50,546
邮政编码和电话号码的呢


377
00:13:50,646 --> 00:13:51,886
我知道其结构


378
00:13:52,546 --> 00:13:53,646
美国电话号码的结构


379
00:13:53,646 --> 00:13:55,586
非常简单


380
00:13:55,626 --> 00:13:57,236
我再次利用这些知识


381
00:13:57,386 --> 00:13:58,976
来过滤掉我不想要的结果


382
00:14:00,896 --> 00:14:03,816
最后是字符串跟踪器


383
00:14:03,816 --> 00:14:06,036
让我发现了这一点


384
00:14:06,036 --> 00:14:08,076
现在我在这里使用一个小技巧


385
00:14:08,646 --> 00:14:09,936
如果你曾经处理过


386
00:14:09,936 --> 00:14:11,206
从相机输入中读取的东西


387
00:14:11,206 --> 00:14:12,656
你会意识到


388
00:14:12,656 --> 00:14:14,406
从一帧到另一帧


389
00:14:14,406 --> 00:14:15,276
你会得到不同的结果


390
00:14:15,406 --> 00:14:16,816
由于噪音 灯光等原因


391
00:14:16,816 --> 00:14:19,086
它们略有波动


392
00:14:20,036 --> 00:14:21,696
但是如果我拨错了电话号码


393
00:14:21,696 --> 00:14:23,306
那就太糟糕了


394
00:14:23,776 --> 00:14:25,736
因此我会尽量避免


395
00:14:25,736 --> 00:14:27,186
显示错误结果


396
00:14:27,856 --> 00:14:29,166
我在这里使用了一种技术


397
00:14:29,166 --> 00:14:31,056
在其中我可实际查看


398
00:14:31,056 --> 00:14:32,596
多个帧并随着时间的推移


399
00:14:32,596 --> 00:14:33,716
建立证据


400
00:14:34,356 --> 00:14:35,526
随着时间的推移


401
00:14:35,526 --> 00:14:37,136
这种证据的建立意味着


402
00:14:37,136 --> 00:14:39,656
我只需存储电话号码


403
00:14:39,656 --> 00:14:41,406
最后 我所做的都非常简单


404
00:14:42,106 --> 00:14:43,906
如果相同的数字


405
00:14:43,906 --> 00:14:45,906
出现在 10 个连续的帧中


406
00:14:45,906 --> 00:14:47,246
我就知道我已经读过它


407
00:14:47,286 --> 00:14:48,496
并实际传播给了用户


408
00:14:49,116 --> 00:14:50,746
现在我们选择 10 


409
00:14:50,746 --> 00:14:52,646
作为实验数字


410
00:14:52,646 --> 00:14:53,416
它对我们来说非常有效


411
00:14:53,576 --> 00:14:56,776
有了这个


412
00:14:56,776 --> 00:14:58,666
我基本上过滤掉了


413
00:14:58,666 --> 00:15:00,226
所有的噪音


414
00:15:01,016 --> 00:15:02,636
这就是我们进行演示


415
00:15:02,636 --> 00:15:04,446
运行中需要做的


416
00:15:04,446 --> 00:15:05,916
现在我们回到幻灯片


417
00:15:10,336 --> 00:15:11,556
我们来快速回顾一下


418
00:15:11,556 --> 00:15:14,936
我使用快速路径


419
00:15:15,566 --> 00:15:17,216
来保持相机的帧速率


420
00:15:17,216 --> 00:15:20,376
我能够指导用户


421
00:15:20,376 --> 00:15:21,296
如何使用相机


422
00:15:22,216 --> 00:15:23,776
我通过感兴趣的区域


423
00:15:23,776 --> 00:15:25,326
裁剪出我真正


424
00:15:25,326 --> 00:15:26,756
想阅读的内容


425
00:15:26,756 --> 00:15:29,986
以消除周围的噪音并提高性能


426
00:15:30,736 --> 00:15:31,586
我关掉了语言修正


427
00:15:31,646 --> 00:15:32,776
因为我知道


428
00:15:32,776 --> 00:15:33,916
现在正在读代码


429
00:15:33,916 --> 00:15:36,486
我使用自己的领域知识


430
00:15:36,486 --> 00:15:37,566
来正确地读取它们


431
00:15:37,566 --> 00:15:38,636
这就像你和 App 开发人员


432
00:15:38,636 --> 00:15:40,336
对这个电话号码


433
00:15:40,336 --> 00:15:42,396
所做的一样


434
00:15:42,396 --> 00:15:46,626
最后 随着时间的推移


435
00:15:46,626 --> 00:15:48,976
我使用这些证据 来实际帮助减少一些噪音


436
00:15:52,386 --> 00:15:53,916
接下来我想介绍一下


437
00:15:54,056 --> 00:15:55,746
扫描文稿相机


438
00:15:57,476 --> 00:16:01,316
两年前 备忘录已经介绍了


439
00:16:01,316 --> 00:16:01,786
扫描文稿相机


440
00:16:02,066 --> 00:16:04,686
当你不需要 使用实时流捕捉它时


441
00:16:04,686 --> 00:16:07,006
它是一个非常好的伙伴


442
00:16:07,696 --> 00:16:08,956
今年你已经在


443
00:16:08,956 --> 00:16:11,356
备忘录邮箱文件


444
00:16:11,356 --> 00:16:11,916
和信息中看到过它


445
00:16:12,296 --> 00:16:15,836
它已经非常适合 阅读文档


446
00:16:16,066 --> 00:16:17,776
因为正如你在这里看到的


447
00:16:17,776 --> 00:16:19,826
它可以找到文档


448
00:16:19,826 --> 00:16:21,626
裁剪出来


449
00:16:21,626 --> 00:16:24,346
现在我可以简单地将其输入到我的文本识别请求中


450
00:16:25,096 --> 00:16:26,516
它是一个很好的伙伴


451
00:16:26,516 --> 00:16:28,716
因为它所做的


452
00:16:28,716 --> 00:16:30,166
只是对这些扫描的


453
00:16:30,166 --> 00:16:32,226
一个前瞻性的修正


454
00:16:32,226 --> 00:16:34,136
它均匀地照亮了图像


455
00:16:34,876 --> 00:16:36,116
这使得后续处理


456
00:16:36,116 --> 00:16:37,736
变得更加容易


457
00:16:39,036 --> 00:16:42,356
那么这在代码中看起来如何


458
00:16:42,556 --> 00:16:43,746
首先，我需要引入 VisionKit


459
00:16:43,746 --> 00:16:44,796
这是一个新的框架


460
00:16:44,796 --> 00:16:46,506
然后我创建了


461
00:16:46,506 --> 00:16:48,386
VNDocumentCameraViewController


462
00:16:49,366 --> 00:16:51,546
我把它呈现在屏幕上


463
00:16:51,546 --> 00:16:52,536
我的相机正在运行


464
00:16:54,046 --> 00:16:56,006
一旦用户完成了任务


465
00:16:56,006 --> 00:16:58,976
我将在我的 Delegate 中得到结果


466
00:16:58,976 --> 00:17:00,436
现在有一件事要记住


467
00:17:01,196 --> 00:17:04,185
我们实际上可以


468
00:17:04,185 --> 00:17:05,546
一次扫描多个文档


469
00:17:05,546 --> 00:17:06,396
它们会以页面形式返回


470
00:17:08,036 --> 00:17:09,715
从每一个图像中


471
00:17:09,715 --> 00:17:12,256
我只需把我的 CG 图像


472
00:17:12,256 --> 00:17:14,465
输入到我的 Vision 请求中


473
00:17:14,465 --> 00:17:15,266
就可以得到相应结果


474
00:17:15,695 --> 00:17:18,185
下面


475
00:17:18,185 --> 00:17:19,556
关于一些最佳实践


476
00:17:19,556 --> 00:17:20,906
就由我的同事  


477
00:17:20,906 --> 00:17:22,215
Cedric Bray


478
00:17:22,215 --> 00:17:23,906
向大家介绍更多有关的详细信息 谢谢


479
00:17:24,516 --> 00:17:27,406
[掌声]


480
00:17:27,906 --> 00:17:29,466
>> 谢谢 Frank


481
00:17:30,166 --> 00:17:32,766
我很高兴我们今年


482
00:17:32,856 --> 00:17:34,426
能将文本识别


483
00:17:34,426 --> 00:17:35,636
纳入 Vision 框架当中 


484
00:17:35,636 --> 00:17:38,016
为了帮助你


485
00:17:38,016 --> 00:17:39,656
充分利用这个新 API


486
00:17:39,656 --> 00:17:41,946
我们将讨论最佳实践


487
00:17:44,696 --> 00:17:47,346
因此在本节中


488
00:17:47,346 --> 00:17:49,426
你将学习到语言知识


489
00:17:49,506 --> 00:17:50,466
以及如何利用


490
00:17:50,466 --> 00:17:52,416
语言知识获得最佳结果


491
00:17:53,016 --> 00:17:54,476
你还将学习


492
00:17:54,476 --> 00:17:56,466
如何在 App 中调优


493
00:17:56,466 --> 00:17:57,126
以获得更好的性能


494
00:17:57,596 --> 00:17:59,626
你将学习更多


495
00:17:59,626 --> 00:18:00,946
关于如何以最有效的方式


496
00:18:00,946 --> 00:18:02,276
处理结果的知识


497
00:18:03,366 --> 00:18:07,746
所以你正在


498
00:18:07,746 --> 00:18:10,146
处理的图像


499
00:18:10,146 --> 00:18:11,486
可能使用了你


500
00:18:11,486 --> 00:18:12,196
已经识别的语言


501
00:18:12,856 --> 00:18:14,046
如果在这个


502
00:18:14,046 --> 00:18:15,486
特定的语言中存在


503
00:18:15,486 --> 00:18:17,326
那么你会想要利用这个信息


504
00:18:17,916 --> 00:18:20,456
为此你需要启用


505
00:18:20,456 --> 00:18:21,716
基于语言的集合


506
00:18:22,516 --> 00:18:23,786
首先你必须


507
00:18:23,786 --> 00:18:25,116
设定目标语言


508
00:18:25,466 --> 00:18:27,436
这里 我们支持英语


509
00:18:28,116 --> 00:18:31,146
一旦启用基于语言的校正 


510
00:18:31,146 --> 00:18:33,026
它将使用设备上的


511
00:18:33,026 --> 00:18:35,416
语言模型


512
00:18:35,416 --> 00:18:36,406
来改进结果的转录


513
00:18:36,856 --> 00:18:38,656
设备上的语言模型很棒


514
00:18:38,656 --> 00:18:40,196
它们有很大的


515
00:18:40,396 --> 00:18:41,066
通用覆盖范围


516
00:18:42,046 --> 00:18:44,416
但文档中可能会出现


517
00:18:44,556 --> 00:18:45,786
特定于域的单词


518
00:18:45,786 --> 00:18:49,456
特定于域的词汇表


519
00:18:49,986 --> 00:18:52,026
如医学术语


520
00:18:52,026 --> 00:18:53,556
或特定于业务的代码


521
00:18:53,556 --> 00:18:54,176
或文档中出现的引用


522
00:18:54,626 --> 00:18:58,526
我们可以通过


523
00:18:58,526 --> 00:19:00,306
将自定义词典


524
00:19:00,376 --> 00:19:03,336
传递给文本识别请求


525
00:19:03,736 --> 00:19:06,736
来指定此信息


526
00:19:06,736 --> 00:19:07,206
即此词汇表


527
00:19:08,486 --> 00:19:10,696
当这样做时


528
00:19:10,696 --> 00:19:13,166
这个自定义词汇表


529
00:19:13,166 --> 00:19:14,226
将补充基于语言的校正


530
00:19:14,766 --> 00:19:15,766
以便为你提供


531
00:19:16,006 --> 00:19:18,566
正确的转录


532
00:19:18,566 --> 00:19:20,286
即使在图像更具挑战性的情况下也是如此


533
00:19:21,596 --> 00:19:23,966
接下来让我们看看代码中的情况


534
00:19:25,446 --> 00:19:28,016
首先作为前提条件


535
00:19:28,016 --> 00:19:29,766
你需要检查


536
00:19:29,876 --> 00:19:31,586
基于语言的更正所支持的语言


537
00:19:32,796 --> 00:19:35,186
因此此受支持语言列表


538
00:19:35,186 --> 00:19:38,546
是针对识别级别


539
00:19:38,546 --> 00:19:40,956
和你要定位的


540
00:19:40,956 --> 00:19:45,116
API 版本的组合定义的


541
00:19:46,786 --> 00:19:49,756
启用基于语言的校正很简单


542
00:19:50,016 --> 00:19:51,626
只需在文本识别请求中


543
00:19:51,626 --> 00:19:54,436
将相应的属性设置为 true


544
00:19:55,126 --> 00:19:56,376
初始化自定义单词


545
00:19:56,806 --> 00:19:58,696
可以将此单词列表


546
00:19:58,696 --> 00:20:01,636
指定为字符串数组


547
00:20:02,316 --> 00:20:03,746
并在文本识别请求时


548
00:20:03,746 --> 00:20:06,726
传递给自定义单词属性


549
00:20:08,696 --> 00:20:12,996
因此这对于


550
00:20:12,996 --> 00:20:15,826
优化准确性 转录准确性非常有用


551
00:20:15,826 --> 00:20:17,496
但是性能呢


552
00:20:17,906 --> 00:20:20,206
还有一个很常见的情况


553
00:20:20,206 --> 00:20:22,286
你可能对


554
00:20:22,286 --> 00:20:24,586
图像中的较小文本不感兴趣


555
00:20:26,136 --> 00:20:28,876
对于这种情况


556
00:20:28,876 --> 00:20:30,976
我们建议你调整 minimumTextHeight


557
00:20:31,466 --> 00:20:34,496
它的工作方式是


558
00:20:34,496 --> 00:20:37,216
当设置这些 minimumTextHeight 时


559
00:20:37,216 --> 00:20:39,096
所有小于指定高度的文本


560
00:20:39,096 --> 00:20:40,836
都将被忽略


561
00:20:40,946 --> 00:20:42,156
它不会被处理


562
00:20:42,496 --> 00:20:44,436
不会成为结果的一部分


563
00:20:44,986 --> 00:20:46,736
输入图像会缩小


564
00:20:46,736 --> 00:20:51,906
执行时间也会缩短


565
00:20:51,906 --> 00:20:53,496
识别速度会更快


566
00:20:53,496 --> 00:20:55,976
内存使用率也会下降


567
00:20:57,456 --> 00:20:59,156
关于这个属性


568
00:20:59,706 --> 00:21:03,216
一个重要注意事项是


569
00:21:03,556 --> 00:21:06,926
它表示为图像高度的一部分


570
00:21:07,436 --> 00:21:08,736
正如你在示例中看到的那样


571
00:21:08,736 --> 00:21:12,576
如果我说 0.5 


572
00:21:12,616 --> 00:21:15,086
则表示将返回大于


573
00:21:15,086 --> 00:21:16,886
或等于图像高度


574
00:21:16,966 --> 00:21:18,886
一半的文本


575
00:21:19,626 --> 00:21:22,486
当你想更快识别文本时


576
00:21:22,486 --> 00:21:24,006
就会出现这种情况


577
00:21:26,256 --> 00:21:28,256
但是如果文本识别


578
00:21:28,256 --> 00:21:30,756
不是 App 中最高优先级的任务呢


579
00:21:31,706 --> 00:21:33,056
也许你还有其他


580
00:21:33,056 --> 00:21:36,066
更高优先级的任务要运行


581
00:21:36,066 --> 00:21:38,276
例如在前景中运行的


582
00:21:38,986 --> 00:21:40,156
ARKit 视图可能是你 App 中的最高优先级


583
00:21:41,066 --> 00:21:43,676
或者例如你正在运行


584
00:21:44,056 --> 00:21:49,466
和实时处理的相机 AR 帧也可能是


585
00:21:49,676 --> 00:21:51,706
那么在后台任务的情况下


586
00:21:51,736 --> 00:21:56,396
我们只允许你


587
00:21:56,396 --> 00:21:59,026
在 CPU 上运行文本识别


588
00:21:59,026 --> 00:22:01,656
这样你可以将 GPU 资源


589
00:22:01,656 --> 00:22:03,726
和可选的神经引擎


590
00:22:03,726 --> 00:22:06,196
保留给 App 的更高优先级任务


591
00:22:08,186 --> 00:22:09,476
你可以使用


592
00:22:09,476 --> 00:22:10,996
useCPUOnly 属性执行此操作


593
00:22:10,996 --> 00:22:12,246
它是一个可用于


594
00:22:12,246 --> 00:22:14,866
其他 VN 请求的属性


595
00:22:14,866 --> 00:22:16,916
也适用于所有


596
00:22:17,186 --> 00:22:18,646
其他 VN 请求和文本识别支持


597
00:22:19,996 --> 00:22:21,086
当你故意让文本识别


598
00:22:21,086 --> 00:22:22,256
运行得更慢的时候


599
00:22:22,256 --> 00:22:25,256
就会出现这种情况


600
00:22:25,406 --> 00:22:28,166
但也有一些情况下


601
00:22:28,166 --> 00:22:29,796
图像非常大


602
00:22:29,796 --> 00:22:32,206
文本和文本识别会很多


603
00:22:32,206 --> 00:22:34,346
需要的时间更长


604
00:22:34,346 --> 00:22:36,756
除非你提供进度管理


605
00:22:36,756 --> 00:22:41,046
否则用户会感到困惑


606
00:22:41,716 --> 00:22:44,076
我们强烈建议你


607
00:22:45,416 --> 00:22:47,946
在 App 中关注进度管理


608
00:22:48,826 --> 00:22:54,056
这是今年 Vision 的一个新概念


609
00:22:54,056 --> 00:22:55,436
文本识别完全实现了这一概念


610
00:22:56,056 --> 00:22:57,186
它有两种方式


611
00:22:58,086 --> 00:23:00,456
第一种你可以


612
00:23:00,526 --> 00:23:02,466
根据请求设置 ProgressHandler


613
00:23:03,886 --> 00:23:08,356
这样做时你将获得进度比率


614
00:23:08,356 --> 00:23:10,776
它是作为 ProgressHandler 的参数


615
00:23:12,336 --> 00:23:15,616
另外你也可以在 App 中支持取消


616
00:23:16,506 --> 00:23:17,836
例如如果向用户


617
00:23:17,836 --> 00:23:19,746
提供按钮


618
00:23:19,746 --> 00:23:21,746
则可以取消


619
00:23:21,746 --> 00:23:23,316
在其前面运行的文本识别


620
00:23:24,226 --> 00:23:26,586
所以这是一系列概念


621
00:23:26,586 --> 00:23:29,016
为了解释它们


622
00:23:29,016 --> 00:23:32,776
我想向你们


623
00:23:32,776 --> 00:23:34,166
展示一个示例 App 的演示


624
00:23:34,166 --> 00:23:35,896
我们也在会议资料中提供它


625
00:23:36,716 --> 00:23:38,866
我将它称为 My First Image Reade


626
00:23:39,566 --> 00:23:42,956
下面我们一起来看看这个 App


627
00:23:51,826 --> 00:23:53,836
所以正如你将看到的


628
00:23:53,836 --> 00:23:56,086
这个示例代码


629
00:23:56,086 --> 00:23:58,386
My First Image Reader


630
00:23:59,206 --> 00:24:01,396
作为主窗口


631
00:24:01,786 --> 00:24:02,866
以及一个转录面板


632
00:24:03,616 --> 00:24:04,836
主窗口将显示


633
00:24:04,926 --> 00:24:07,346
图像和结果的几何图形


634
00:24:08,016 --> 00:24:12,166
转录窗口将显示文本


635
00:24:13,036 --> 00:24:16,036
如果仔细看窗口顶部


636
00:24:17,406 --> 00:24:18,756
在工具栏上


637
00:24:18,826 --> 00:24:20,686
你会发现可以在精确


638
00:24:20,686 --> 00:24:23,046
和快速之间进行选择


639
00:24:23,526 --> 00:24:24,836
所以这真是一个非常好的


640
00:24:24,886 --> 00:24:26,276
简单的 App


641
00:24:26,346 --> 00:24:29,066
下面我们一起来看看 还有我们刚才


642
00:24:29,066 --> 00:24:31,186
提到的其他设置


643
00:24:32,086 --> 00:24:33,766
性能设置 最小文本高度


644
00:24:33,766 --> 00:24:35,076
稍后我会再回过头来看


645
00:24:35,076 --> 00:24:38,786
在此视图中


646
00:24:38,786 --> 00:24:40,696
你还可以


647
00:24:40,746 --> 00:24:43,576
访问语言设置


648
00:24:43,796 --> 00:24:45,776
启用语言模型


649
00:24:46,316 --> 00:24:48,106
以及自定义单词


650
00:24:48,796 --> 00:24:51,526
现在我用一个


651
00:24:52,566 --> 00:24:55,246
精心设计的示例快速向你展示


652
00:24:56,516 --> 00:24:59,646
假设我拿出一张


653
00:24:59,646 --> 00:25:02,606
我拍摄的图片


654
00:25:02,636 --> 00:25:04,776
并说这是一本书的封面


655
00:25:04,826 --> 00:25:07,876
上面有非常小的文本 恰好是我的名字


656
00:25:09,466 --> 00:25:12,196
你能发现你得到的文本非常小


657
00:25:12,236 --> 00:25:15,576
我的名字在这里被找到


658
00:25:15,576 --> 00:25:16,166
并被识别出来


659
00:25:16,166 --> 00:25:18,716
显然对于非常大的文本 亦是如此


660
00:25:19,826 --> 00:25:21,046
现在假设


661
00:25:21,046 --> 00:25:23,396
我有一堆这样的图片


662
00:25:23,706 --> 00:25:25,886
我只想索引这些图片的标题


663
00:25:26,386 --> 00:25:27,326
我不太关心小字体


664
00:25:27,326 --> 00:25:29,006
特别是我的名字


665
00:25:29,266 --> 00:25:31,346
因此我将调整


666
00:25:31,346 --> 00:25:33,486
最小文本高度


667
00:25:33,486 --> 00:25:34,896
以使识别运行更快


668
00:25:35,556 --> 00:25:39,756
你可以将其设置为 0.1 


669
00:25:40,436 --> 00:25:44,756
那么文本必须


670
00:25:44,756 --> 00:25:46,276
至少为图像高度的 90％


671
00:25:47,046 --> 00:25:50,256
这就是大文本 Desert Dunes 的情况


672
00:25:50,946 --> 00:25:54,346
下面将这些设回 0 


673
00:25:55,626 --> 00:25:57,396
我来向你展示语言设置


674
00:25:57,456 --> 00:26:00,786
特别是自定义单词的影响


675
00:26:03,736 --> 00:26:06,736
如果我把这个传单拖到这里


676
00:26:06,736 --> 00:26:08,616
这个项目名为 Hill Side


677
00:26:08,756 --> 00:26:10,496
它也有一个可能的数字


678
00:26:11,066 --> 00:26:12,546
一个参考数字


679
00:26:12,796 --> 00:26:16,406
碰巧是 HI11


680
00:26:17,116 --> 00:26:18,816
所以这里可能存在混淆


681
00:26:18,956 --> 00:26:21,196
现在我来给你看转录结果


682
00:26:23,066 --> 00:26:25,926
可以看到参考数字实际上


683
00:26:26,046 --> 00:26:27,226
在这里被误识别了


684
00:26:28,606 --> 00:26:29,526
所以我们要不断改进


685
00:26:30,456 --> 00:26:38,106
如果因为 HI11 是


686
00:26:38,106 --> 00:26:39,366
已知的引用的一部分


687
00:26:39,366 --> 00:26:42,526
我将其指定为自定义单词


688
00:26:42,526 --> 00:26:43,936
那么我们通过修正


689
00:26:43,936 --> 00:26:45,166
完成了自定义


690
00:26:45,166 --> 00:26:46,466
尤其是自定义单词列表


691
00:26:46,596 --> 00:26:48,126
并为我们


692
00:26:48,276 --> 00:26:52,296
提供了正确的转录 回到幻灯片


693
00:26:53,016 --> 00:26:54,096
[掌声]


694
00:26:54,096 --> 00:26:58,500
谢谢 [掌声]


695
00:27:01,686 --> 00:27:02,886
快速回顾一下


696
00:27:05,356 --> 00:27:06,696
你需要选择


697
00:27:06,696 --> 00:27:08,996
最适合你 App 


698
00:27:08,996 --> 00:27:11,066
用例的识别级别


699
00:27:11,296 --> 00:27:13,516
快速 准确


700
00:27:13,516 --> 00:27:14,006
找到对的那个


701
00:27:14,976 --> 00:27:17,276
语言设置方面 


702
00:27:17,276 --> 00:27:19,616
我们建议你


703
00:27:19,616 --> 00:27:21,686
根据所拥有的文档类型进行检查


704
00:27:21,746 --> 00:27:22,806
如果存在明显的语言


705
00:27:22,956 --> 00:27:24,376
相邻语言修正


706
00:27:24,376 --> 00:27:26,956
如果你具有特定于域的词汇表


707
00:27:27,546 --> 00:27:29,766
请启用自定义词


708
00:27:29,766 --> 00:27:30,526
指定自定义词


709
00:27:31,616 --> 00:27:33,836
此外非常重要的是


710
00:27:33,836 --> 00:27:36,156
你需要在 App 中


711
00:27:36,156 --> 00:27:38,476
支持进度更新


712
00:27:38,476 --> 00:27:39,726
以获得最佳用户体验


713
00:27:41,086 --> 00:27:44,086
现在就算你


714
00:27:44,086 --> 00:27:46,926
遵循这个建议


715
00:27:46,926 --> 00:27:49,446
仍然有一个非常重要的方面


716
00:27:49,446 --> 00:27:49,906
需要去注意


717
00:27:51,546 --> 00:27:54,876
那就是你需要处理结果


718
00:27:56,136 --> 00:27:57,516
你还需要提供一个方法


719
00:27:57,516 --> 00:28:00,326
用自己的方法


720
00:28:00,356 --> 00:28:02,236
来向你的用户展示结果


721
00:28:03,186 --> 00:28:04,846
不过这个方法


722
00:28:05,956 --> 00:28:07,776
可能并不与字母相关


723
00:28:09,126 --> 00:28:11,346
我的意思是


724
00:28:11,346 --> 00:28:13,366
为了获得最佳用户体验


725
00:28:13,366 --> 00:28:18,376
你需要以最有效的方式处理结果


726
00:28:19,376 --> 00:28:24,506
那么我们来看看怎么做


727
00:28:25,706 --> 00:28:28,306
首先要声明很重要的一点


728
00:28:29,236 --> 00:28:32,686
你应该预料到输入中存在歧义


729
00:28:34,086 --> 00:28:35,126
这就是计算机视觉


730
00:28:35,596 --> 00:28:36,856
这是一个开放式问题


731
00:28:37,526 --> 00:28:40,886
我们的参数术语将影响你


732
00:28:41,146 --> 00:28:43,956
正在处理的图像的内容


733
00:28:43,986 --> 00:28:47,036
事实上


734
00:28:47,036 --> 00:28:48,576
这里的门牌号是很有趣的


735
00:28:49,606 --> 00:28:52,106
因为其中的一些非常风格化


736
00:28:53,016 --> 00:28:54,036
当你对它们运行


737
00:28:54,076 --> 00:28:55,786
生成文本识别器时 


738
00:28:55,846 --> 00:28:57,936
它们并不知道自己应该成为数字 对吗


739
00:28:57,936 --> 00:29:02,156
你得到的不是 101


740
00:29:02,856 --> 00:29:05,576
而是 lol 


741
00:29:05,816 --> 00:29:09,646
或者你可能得到文本表情


742
00:29:09,776 --> 00:29:14,566
一个快乐的人举起手 在那种情况下


743
00:29:14,566 --> 00:29:16,576
不知道你有没有听过


744
00:29:16,806 --> 00:29:19,946
但我们坚持认为


745
00:29:19,946 --> 00:29:21,826
从观察结果来看


746
00:29:21,856 --> 00:29:23,306
你需要利用候选名单


747
00:29:23,936 --> 00:29:25,996
拥有的最佳候选名单


748
00:29:26,616 --> 00:29:28,766
请参考此候选列表


749
00:29:28,766 --> 00:29:31,176
如果它适用于你的 App


750
00:29:31,346 --> 00:29:32,806
请查看前一个 前两个


751
00:29:32,806 --> 00:29:33,806
前三个或更多结果


752
00:29:33,806 --> 00:29:36,006
有一个典型的例子


753
00:29:36,006 --> 00:29:38,106
比如你想要


754
00:29:38,106 --> 00:29:40,416
索引图像的内容


755
00:29:40,416 --> 00:29:42,216
如果你想增加召回率


756
00:29:42,216 --> 00:29:44,716
你可以为每个结果


757
00:29:44,716 --> 00:29:45,396
索引更多的候选对象


758
00:29:45,686 --> 00:29:48,076
当然 以精度为代价


759
00:29:48,886 --> 00:29:52,856
对吗 所以这个候选名单


760
00:29:52,856 --> 00:29:54,826
我们需要深入研究


761
00:29:54,826 --> 00:29:56,286
但这只是一个维度


762
00:29:56,286 --> 00:30:00,306
这是预测置信规模


763
00:30:00,656 --> 00:30:02,156
其他维度怎么样呢


764
00:30:02,636 --> 00:30:05,056
那么图像空间呢


765
00:30:06,046 --> 00:30:08,916
我们建议你


766
00:30:09,876 --> 00:30:12,136
评估并重新考虑


767
00:30:12,136 --> 00:30:14,546
使用几何图形来映射结果


768
00:30:15,586 --> 00:30:18,126
你有边界框


769
00:30:18,576 --> 00:30:20,176
它为你提供空间信息


770
00:30:20,726 --> 00:30:22,056
你可以使用


771
00:30:22,056 --> 00:30:24,246
结果的位置 比例


772
00:30:24,246 --> 00:30:26,506
以及旋转


773
00:30:26,506 --> 00:30:27,116
将这些结果映射到一起


774
00:30:27,346 --> 00:30:29,366
我们在这里


775
00:30:29,366 --> 00:30:32,006
显示的示例


776
00:30:32,006 --> 00:30:34,346
如果是收据


777
00:30:34,346 --> 00:30:38,326
你可以将项目名称


778
00:30:39,156 --> 00:30:40,746
映射到价格


779
00:30:42,896 --> 00:30:45,146
这是几何的


780
00:30:45,816 --> 00:30:47,356
但是对于


781
00:30:47,356 --> 00:30:49,256
每个孤立的结果


782
00:30:49,306 --> 00:30:52,096
你还有机会


783
00:30:52,096 --> 00:30:53,286
使用解析器并尝试


784
00:30:53,286 --> 00:30:54,476
理解每个结果


785
00:30:54,476 --> 00:30:58,096
在这种情况下


786
00:30:58,096 --> 00:31:00,596
数据检测是你最好的朋友


787
00:31:00,596 --> 00:31:02,536
它会为你感兴趣的类型


788
00:31:02,536 --> 00:31:03,896
启动 NSDataDetectorr


789
00:31:04,266 --> 00:31:05,296
你也可能明白


790
00:31:05,296 --> 00:31:08,236
它支持地址 URL


791
00:31:08,336 --> 00:31:09,106
日期和电话号码


792
00:31:10,516 --> 00:31:11,746
在我的名片示例中


793
00:31:11,746 --> 00:31:14,186
我可以使用它


794
00:31:14,186 --> 00:31:15,916
来理解一些结果


795
00:31:16,526 --> 00:31:19,806
但是如果这还不够


796
00:31:20,186 --> 00:31:22,136
你可以使用自己的


797
00:31:22,866 --> 00:31:24,446
特定于域的功能


798
00:31:24,446 --> 00:31:26,316
拥有自己的词汇表


799
00:31:26,316 --> 00:31:27,726
来匹配字符串


800
00:31:28,146 --> 00:31:29,776
或者使用自己的正则表达式


801
00:31:32,856 --> 00:31:34,216
为了说明这些原则


802
00:31:34,276 --> 00:31:36,106
我们有另一个示例 App 


803
00:31:36,106 --> 00:31:37,866
这次是一个 iOS App 


804
00:31:37,906 --> 00:31:39,946
名为 Business Companion


805
00:31:43,256 --> 00:31:45,776
假设你因为想要


806
00:31:45,776 --> 00:31:47,396
收据扫描仪


807
00:31:47,396 --> 00:31:49,966
坐在房间里


808
00:31:50,506 --> 00:31:51,446
有人是这么想的吗


809
00:31:51,956 --> 00:31:56,436
也许吧 亦或是一台名片读卡器


810
00:31:57,226 --> 00:31:58,306
也可能是对名片感兴趣的人


811
00:31:59,736 --> 00:32:03,356
那么这个 App


812
00:32:03,546 --> 00:32:05,476
就是你真正要看的东西


813
00:32:06,006 --> 00:32:09,896
因为它将两个流混合到同一个 App 流中


814
00:32:09,896 --> 00:32:13,036
我来教你怎么做


815
00:32:14,916 --> 00:32:18,346
首先它有文档类别选择器


816
00:32:18,346 --> 00:32:19,866
很快就会看到它是如何工作的


817
00:32:20,126 --> 00:32:22,036
这只是第一个屏


818
00:32:22,036 --> 00:32:23,106
这样就可以选择


819
00:32:23,106 --> 00:32:24,166
你感兴趣的文档类型


820
00:32:24,906 --> 00:32:27,606
从那里进入你之前听说过的


821
00:32:27,606 --> 00:32:28,646
文稿扫描相机


822
00:32:28,646 --> 00:32:31,166
从文稿扫描相机那里


823
00:32:31,266 --> 00:32:34,026
我们运行文本识别


824
00:32:34,026 --> 00:32:35,326
从识别的结果中


825
00:32:35,966 --> 00:32:37,366
我们执行一些分析


826
00:32:37,366 --> 00:32:38,496
来理解这些结果


827
00:32:38,496 --> 00:32:39,696
这才是真正重要的


828
00:32:40,366 --> 00:32:42,476
因为基于这种分析


829
00:32:42,896 --> 00:32:44,106
我们将能获得一些


830
00:32:44,106 --> 00:32:46,246
收据名片的数据模型


831
00:32:46,246 --> 00:32:47,626
在本例中


832
00:32:47,626 --> 00:32:49,406
我们对文档类型进行了分析


833
00:32:50,326 --> 00:32:52,146
从这个结果分析中


834
00:32:52,146 --> 00:32:54,076
假设你了解数据


835
00:32:54,076 --> 00:32:57,536
在表格视图中


836
00:32:57,536 --> 00:32:59,346
显示收据的情况下


837
00:32:59,346 --> 00:33:00,626
你还可以更适当地


838
00:33:00,626 --> 00:33:01,746
将结果可视化


839
00:33:02,216 --> 00:33:03,976
如果我们有名片


840
00:33:04,076 --> 00:33:07,256
会显示联系人名片


841
00:33:07,456 --> 00:33:09,956
下面我来展示这个 App


842
00:33:18,436 --> 00:33:20,936
在这里切换到 iOS 设备


843
00:33:22,236 --> 00:33:24,336
所以这是 Business Companion


844
00:33:24,836 --> 00:33:26,746
正如我告诉你的


845
00:33:26,746 --> 00:33:29,136
我们可以在收据


846
00:33:29,136 --> 00:33:30,756
卡片和其他类型的文件


847
00:33:30,756 --> 00:33:31,216
之间进行选择


848
00:33:31,546 --> 00:33:33,386
我们从收据开始


849
00:33:33,696 --> 00:33:37,556
首先是扫描文稿相机


850
00:33:37,556 --> 00:33:39,736
我们在这里有一些挑战性的亮点


851
00:33:45,536 --> 00:33:48,166
当文档被捕捉和处理时


852
00:33:48,166 --> 00:33:53,966
是的 我们的结果


853
00:33:54,026 --> 00:33:56,026
是结构化的


854
00:33:56,086 --> 00:33:57,226
你可以看到项目名称


855
00:33:57,696 --> 00:33:59,416
你可以看到每个部分的


856
00:33:59,946 --> 00:34:01,826
类别名称和值


857
00:34:02,656 --> 00:34:08,126
现在假设我看一张名片
 
00:34:14,456 --> 00:34:18,686
同样我会分析


858
00:34:18,856 --> 00:34:20,206
名片的每个字段


859
00:34:20,206 --> 00:34:21,596
[掌声] 这就是我的迷你名片


860
00:34:21,596 --> 00:34:22,775
谢谢大家


861
00:34:26,255 --> 00:34:27,516
就像我说的这很好


862
00:34:27,516 --> 00:34:29,346
但看看这个前面的屏


863
00:34:29,346 --> 00:34:30,966
仍然需要你


864
00:34:30,966 --> 00:34:33,036
手动选择文档类型


865
00:34:33,906 --> 00:34:34,766
它并不是真的无缝


866
00:34:34,766 --> 00:34:37,065
你可以使它更加无缝


867
00:34:37,286 --> 00:34:39,686
对吧 实际上我们已经做到了


868
00:34:39,686 --> 00:34:42,096
现在我来展示


869
00:34:42,096 --> 00:34:43,996
这个 App 的进阶版本


870
00:34:43,996 --> 00:34:45,565
它被称为


871
00:34:45,606 --> 00:34:46,036
Better Business Companion


872
00:34:46,156 --> 00:34:50,775
其实我们所做的


873
00:34:50,775 --> 00:34:53,525
就是我们使用 Create ML 


874
00:34:53,525 --> 00:34:56,446
训练了一个分类器模型


875
00:34:56,446 --> 00:34:58,846
我们将这个分类器


876
00:34:58,846 --> 00:35:00,186
作为第一步


877
00:35:00,186 --> 00:35:01,366
这样就不必指定文档类型了


878
00:35:01,956 --> 00:35:04,076
它将自动选中


879
00:35:04,076 --> 00:35:04,976
说得差不多了 我来演示一下


880
00:35:07,566 --> 00:35:11,506
很明显 第一个按钮从大按钮


881
00:35:11,506 --> 00:35:11,826
变成非常小的按钮


882
00:35:14,516 --> 00:35:16,136
这里只有 Scan 按钮


883
00:35:16,196 --> 00:35:18,096
我这里有收据


884
00:35:18,096 --> 00:35:21,856
你同样可以看到


885
00:35:26,856 --> 00:35:29,666
无需用户指定文档类型


886
00:35:31,296 --> 00:35:32,256
[掌声] 即可作为


887
00:35:32,306 --> 00:35:36,886
收据处理


888
00:35:38,086 --> 00:35:39,466
为了向你展示


889
00:35:39,466 --> 00:35:40,536
它如何与名片一起使用


890
00:35:40,536 --> 00:35:42,846
再次用我名片举例


891
00:35:47,506 --> 00:35:50,976
好的 我们正确处理了名片


892
00:35:51,516 --> 00:35:54,616
[掌声]


893
00:35:55,116 --> 00:35:56,656
我说过我们为这个


894
00:35:56,656 --> 00:35:58,376
集成了 Core ML 模型


895
00:35:58,506 --> 00:35:59,456
我想向你展示一下


896
00:36:06,156 --> 00:36:09,836
我们在这里进入 Xcode


897
00:36:10,296 --> 00:36:12,716
这是代码


898
00:36:12,776 --> 00:36:14,566
实际上这是我们


899
00:36:14,776 --> 00:36:18,586
从 Business Companion 修改的代码


900
00:36:18,586 --> 00:36:21,826
我们添加了一个插入


901
00:36:21,826 --> 00:36:24,026
Core ML 模型


902
00:36:24,986 --> 00:36:32,246
在这里 我们插入此 Core ML 模型


903
00:36:32,246 --> 00:36:34,826
以使用 completionHandler 


904
00:36:35,276 --> 00:36:36,776
设置请求


905
00:36:36,776 --> 00:36:40,666
作为处理程序的一部分


906
00:36:40,666 --> 00:36:42,146
你可以看到


907
00:36:42,146 --> 00:36:46,196
我们处理了 topObservation


908
00:36:46,196 --> 00:36:48,436
和标识符的日期 抱歉 topObservation 的标识符


909
00:36:48,436 --> 00:36:52,266
我们为 App 设置扫描模式


910
00:36:52,266 --> 00:36:53,966
以确定该 App 


911
00:36:53,966 --> 00:36:56,906
其余部分的流
 
00:36:56,906 --> 00:36:58,916
因此我们鼓励你


912
00:36:58,916 --> 00:37:00,396
思考如何使用文本识别


913
00:37:00,396 --> 00:37:02,286
来改进 App 流


914
00:37:02,286 --> 00:37:03,916
以及如何适当地


915
00:37:03,916 --> 00:37:05,056
处理结果


916
00:37:05,056 --> 00:37:12,016
同时利用像这样的 ML 模型


917
00:37:12,206 --> 00:37:14,696
好 再次回到幻灯片


918
00:37:15,206 --> 00:37:18,306
简单回顾一下


919
00:37:19,796 --> 00:37:22,396
正如我所提到的


920
00:37:22,396 --> 00:37:24,296
我们鼓励在有意义的时候


921
00:37:24,296 --> 00:37:25,026
使用几何信息


922
00:37:25,866 --> 00:37:27,796
通过使用数据检测器


923
00:37:27,796 --> 00:37:29,576
或自己的解析器


924
00:37:29,576 --> 00:37:30,646
来解析理解结果


925
00:37:31,456 --> 00:37:34,266
最重要的是 你要明白自己在创建什么


926
00:37:34,456 --> 00:37:35,736
你知道需要查看


927
00:37:35,736 --> 00:37:36,966
哪种类型的数据


928
00:37:36,966 --> 00:37:39,326
因此我们建议


929
00:37:39,326 --> 00:37:40,926
利用你的领域知识


930
00:37:40,926 --> 00:37:42,706
获得最佳用户体验


931
00:37:45,676 --> 00:37:48,096
我们也希望这能


932
00:37:48,096 --> 00:37:49,376
给你提供一个很好的参考


933
00:37:49,376 --> 00:37:50,656
帮助你将文本识别集成到


934
00:37:50,656 --> 00:37:51,656
你的 App 中


935
00:37:51,656 --> 00:37:53,336
我已迫不及待想看到


936
00:37:53,696 --> 00:37:54,826
你将用这项技术创建的


937
00:37:54,826 --> 00:37:56,686
所有精彩的 App


938
00:37:56,896 --> 00:37:59,716
如果你还有疑问


939
00:37:59,716 --> 00:38:01,056
可以访问机器学习实验室


940
00:38:01,056 --> 00:38:02,326
明天还有一场


941
00:38:02,326 --> 00:38:03,976
谢谢大家


942
00:38:04,508 --> 00:38:06,508
[掌声]

