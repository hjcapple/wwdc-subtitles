1
00:00:06,516 --> 00:00:14,500
[ 音乐 ]


2
00:00:18,516 --> 00:00:24,456
[ 掌声 ]


3
00:00:24,956 --> 00:00:25,896
>> 早上好


4
00:00:26,406 --> 00:00:28,416
感谢你们今天


5
00:00:28,706 --> 00:00:30,316
来到这里了解


6
00:00:30,516 --> 00:00:32,195
Cocoa Touch 的新功能


7
00:00:33,456 --> 00:00:34,816
一般情况下


8
00:00:34,816 --> 00:00:35,816
Eliza 之后会上台讲解


9
00:00:35,816 --> 00:00:37,556
不过今年


10
00:00:37,556 --> 00:00:38,846
只有我为大家进行讲解


11
00:00:39,386 --> 00:00:41,216
她在未来的几年里会回来的


12
00:00:41,216 --> 00:00:42,626
别担心


13
00:00:43,046 --> 00:00:44,236
今天我们主要


14
00:00:44,556 --> 00:00:46,046
从三个类别


15
00:00:46,046 --> 00:00:46,596
进行讨论


16
00:00:47,656 --> 00:00:50,436
首先是框架更新


17
00:00:50,436 --> 00:00:52,556
比如性能和安全


18
00:00:52,556 --> 00:00:56,476
然后是在 SDK（软件开发包）中


19
00:00:56,476 --> 00:00:57,876
不同 API 的


20
00:00:57,876 --> 00:01:00,056
API 功能增强


21
00:01:00,056 --> 00:01:01,566
包括通知和信息


22
00:01:02,566 --> 00:01:05,086
最后是 Siri 捷径


23
00:01:05,816 --> 00:01:07,126
那我们开始


24
00:01:07,196 --> 00:01:09,776
第一个话题性能更新


25
00:01:11,106 --> 00:01:12,716
我们要讨论


26
00:01:12,716 --> 00:01:14,506
三个领域的性能


27
00:01:14,506 --> 00:01:18,546
滚动 内存和自动布局


28
00:01:19,786 --> 00:01:21,726
开始之前


29
00:01:21,726 --> 00:01:23,106
很重要的是


30
00:01:23,106 --> 00:01:24,146
记住一点关于滚动的


31
00:01:24,146 --> 00:01:25,496
背景信息


32
00:01:27,796 --> 00:01:30,076
iOS 里的滚动


33
00:01:30,156 --> 00:01:31,836
大多遵从一个


34
00:01:31,876 --> 00:01:32,236
固定模式


35
00:01:32,876 --> 00:01:34,536
我们加载内容


36
00:01:34,536 --> 00:01:36,336
显示在视图里


37
00:01:36,336 --> 00:01:38,096
然后移动这些内容


38
00:01:38,846 --> 00:01:39,666
当我们滑动的时候


39
00:01:39,666 --> 00:01:41,546
大多数帧


40
00:01:41,546 --> 00:01:43,036
都很容易生成


41
00:01:43,036 --> 00:01:44,376
因为我们不用加载任何


42
00:01:44,376 --> 00:01:44,656
新的东西


43
00:01:45,656 --> 00:01:47,226
但是偶尔


44
00:01:47,226 --> 00:01:49,506
当打开一个新的视图时


45
00:01:49,506 --> 00:01:53,206
第一帧相对于其他


46
00:01:53,206 --> 00:01:54,816
容易生成的帧


47
00:01:54,816 --> 00:01:55,776
生成更高耗


48
00:01:56,286 --> 00:02:00,476
当然一旦第一帧生成


49
00:02:00,526 --> 00:02:02,246
我们再滑动内容


50
00:02:02,246 --> 00:02:03,696
这时 CPU 的工作量
 
00:02:03,696 --> 00:02:05,236
又变小了


51
00:02:05,236 --> 00:02:06,806
和一般滑动差不多


52
00:02:07,386 --> 00:02:11,676
为什么那个第一帧


53
00:02:11,676 --> 00:02:14,116
会比别的帧更高耗


54
00:02:14,776 --> 00:02:18,096
让我们从 UITableView 的角度看一下


55
00:02:18,096 --> 00:02:22,066
但其实这个和 UICollectionView   


56
00:02:22,066 --> 00:02:23,226
或者其他相似的


57
00:02:23,226 --> 00:02:24,786
自定义视图


58
00:02:24,786 --> 00:02:25,156
都是一样的


59
00:02:25,866 --> 00:02:28,706
这一帧的工作


60
00:02:28,756 --> 00:02:30,386
开始于当你


61
00:02:30,386 --> 00:02:32,296
在 TableView 执行


62
00:02:32,396 --> 00:02:33,616
cellForRowAt IndexPath


63
00:02:33,676 --> 00:02:34,306
的委托方法时


64
00:02:34,906 --> 00:02:39,316
首先选择想显示的 Cell


65
00:02:39,746 --> 00:02:40,786
我们要试着让它


66
00:02:40,856 --> 00:02:44,666
从重复使用序列中脱离出来


67
00:02:44,666 --> 00:02:45,966
如果它本身不在序列中


68
00:02:45,966 --> 00:02:46,936
我们需要


69
00:02:46,936 --> 00:02:48,326
做一些内存分配


70
00:02:48,326 --> 00:02:50,176
来做好准备


71
00:02:51,036 --> 00:02:52,196
有了 Cell 之后 我们


72
00:02:52,196 --> 00:02:53,446
会用你的模型数据


73
00:02:53,446 --> 00:02:54,316
来填充这个 Cell


74
00:02:54,916 --> 00:02:56,496
这一步有多高耗


75
00:02:56,496 --> 00:02:59,496
取决于你的 App


76
00:02:59,496 --> 00:03:01,476
但可能包含很多


77
00:03:01,476 --> 00:03:02,856
高耗的操作


78
00:03:02,896 --> 00:03:05,416
比如读取文件


79
00:03:05,416 --> 00:03:06,916
从数据库加载数据


80
00:03:06,916 --> 00:03:07,516
或其他类似的事情


81
00:03:07,936 --> 00:03:09,056
所以你应该


82
00:03:09,056 --> 00:03:10,536
看一下你的 App 里


83
00:03:10,536 --> 00:03:13,396
在这一方面的消耗


84
00:03:13,396 --> 00:03:14,616
一般来说很大一部分


85
00:03:14,926 --> 00:03:15,686
会在这里


86
00:03:17,276 --> 00:03:18,956
看到这里


87
00:03:18,956 --> 00:03:19,936
你可能以为


88
00:03:19,936 --> 00:03:21,766
高耗工作就此结束


89
00:03:21,766 --> 00:03:23,006
但是当你从这个方法返回


90
00:03:23,006 --> 00:03:24,316
为了让 Cell


91
00:03:24,376 --> 00:03:25,956
显示在屏幕上


92
00:03:25,956 --> 00:03:27,506
其实有更多的工作要做


93
00:03:28,206 --> 00:03:29,786
所以 接下来


94
00:03:29,786 --> 00:03:31,306
我们要把所有内容


95
00:03:31,306 --> 00:03:31,836
布局到 Cell 中


96
00:03:32,336 --> 00:03:33,936
我们要调整视图大小


97
00:03:33,936 --> 00:03:35,686
并把它们放到正确的位置


98
00:03:36,086 --> 00:03:37,276
这一步可能会


99
00:03:37,276 --> 00:03:38,476
消耗我们的


100
00:03:38,476 --> 00:03:39,736
很多时间


101
00:03:39,736 --> 00:03:41,176
因为它包含一些


102
00:03:41,176 --> 00:03:42,946
其他的高耗操作


103
00:03:43,036 --> 00:03:44,666
比如 测量文本


104
00:03:45,296 --> 00:03:46,886
当大小和位置


105
00:03:46,886 --> 00:03:48,666
都调整好之后


106
00:03:48,666 --> 00:03:50,736
就要使用绘制命令


107
00:03:50,736 --> 00:03:52,276
来生成所有


108
00:03:52,276 --> 00:03:54,116
需要被绘制的内容


109
00:03:54,116 --> 00:03:55,606
我们要调用这个 Cell 里


110
00:03:55,606 --> 00:03:57,746
所有的子视图的 draw Rect


111
00:03:58,276 --> 00:03:59,816
重申一下


112
00:03:59,816 --> 00:04:01,216
这一步可能很费时


113
00:04:01,216 --> 00:04:03,036
因为我们需要做


114
00:04:03,036 --> 00:04:04,426
像绘制文本这样的工作


115
00:04:05,536 --> 00:04:08,506
总体而言 在整个代码中


116
00:04:08,646 --> 00:04:11,436
有很多要做的工作


117
00:04:11,436 --> 00:04:13,696
而且都需要在短时间里完成


118
00:04:14,126 --> 00:04:15,656
在我们 60 赫兹的设备上


119
00:04:15,656 --> 00:04:17,565
你只有 16 毫秒


120
00:04:17,565 --> 00:04:19,046
来完成所有的工作


121
00:04:19,046 --> 00:04:20,726
确保不会丢帧


122
00:04:20,726 --> 00:04:22,296
并流畅滑动


123
00:04:23,056 --> 00:04:25,346
在 120 赫兹的 iPad


124
00:04:25,346 --> 00:04:27,836
iPad Pro 上


125
00:04:27,836 --> 00:04:29,696
你只有 8 毫秒来完成所有工作


126
00:04:30,166 --> 00:04:31,736
所以真的是


127
00:04:31,816 --> 00:04:32,956
越快越好


128
00:04:34,226 --> 00:04:36,126
为此在 iOS 10 里


129
00:04:36,326 --> 00:04:37,796
我们引入了


130
00:04:37,836 --> 00:04:40,096
Cell 预读取 API


131
00:04:40,096 --> 00:04:42,186
这个预读取 API


132
00:04:42,256 --> 00:04:43,906
就是帮助做一些工作


133
00:04:43,906 --> 00:04:45,756
用模型数据生成 Cell


134
00:04:45,826 --> 00:04:47,086
并把需要在


135
00:04:47,086 --> 00:04:48,746
短时间里做到的


136
00:04:48,746 --> 00:04:50,916
这个部分的内容


137
00:04:50,916 --> 00:04:52,646
更早地开始


138
00:04:52,646 --> 00:04:53,796
并在后台线程做


139
00:04:53,796 --> 00:04:55,386
这样可以和其他工作


140
00:04:55,386 --> 00:04:57,036
异步进行


141
00:04:57,036 --> 00:04:58,656
尤其是我们提到过的


142
00:04:58,656 --> 00:04:59,286
低耗滚动帧


143
00:05:00,586 --> 00:05:02,296
采用这个 API


144
00:05:02,296 --> 00:05:02,676
很容易 只是一个


145
00:05:03,076 --> 00:05:04,736
UITableViewDataSourcePrefetching


146
00:05:04,736 --> 00:05:06,976
protocol 


147
00:05:06,976 --> 00:05:08,786
只有两个方法


148
00:05:08,786 --> 00:05:10,346
其实只有其中一个是必须的


149
00:05:10,916 --> 00:05:12,196
主要目的是


150
00:05:12,236 --> 00:05:13,536
把一些高耗工作


151
00:05:13,536 --> 00:05:14,956
例如从文件中加载内容


152
00:05:14,956 --> 00:05:17,626
或者读取数据库 放在这里


153
00:05:17,626 --> 00:05:19,416
这样你就不用主动操作了


154
00:05:19,636 --> 00:05:21,436
当你的 Cell 要显示时


155
00:05:21,596 --> 00:05:22,956
你的数据已经准备就绪


156
00:05:23,126 --> 00:05:28,346
大多数情况下


157
00:05:28,406 --> 00:05:31,346
它都很有帮助


158
00:05:31,346 --> 00:05:34,546
但在一些运行 iOS 12 的 App 里


159
00:05:34,546 --> 00:05:36,456
我们发现


160
00:05:36,516 --> 00:05:38,546
它造成了一些问题 而不是提供帮助


161
00:05:39,146 --> 00:05:40,236
让我们来看一看


162
00:05:40,236 --> 00:05:42,846
是什么情况


163
00:05:43,126 --> 00:05:45,476
这个例子是 我们记录的


164
00:05:45,476 --> 00:05:47,156
在 iPhone 6 Plus 上


165
00:05:47,156 --> 00:05:48,236
滑动的情况


166
00:05:49,176 --> 00:05:50,986
上面的竖线


167
00:05:51,046 --> 00:05:53,166
代表我们希望


168
00:05:53,166 --> 00:05:54,166
显示的帧


169
00:05:55,006 --> 00:05:56,506
下面交替的深蓝和浅蓝


170
00:05:56,586 --> 00:05:58,246
代表我们为了让


171
00:05:58,246 --> 00:05:59,896
显示变化而


172
00:05:59,936 --> 00:06:01,096
替换的帧


173
00:06:01,096 --> 00:06:03,556
那个两格的浅蓝色区域


174
00:06:03,556 --> 00:06:08,386
就表示 我们在两帧时间中


175
00:06:08,436 --> 00:06:09,196
绘制了同一帧


176
00:06:09,946 --> 00:06:11,306
在个性化定制的设备上


177
00:06:11,306 --> 00:06:12,556
一但这种情况发生


178
00:06:12,556 --> 00:06:14,156
看起来就像丢帧


179
00:06:14,246 --> 00:06:15,456
或者滚动故障


180
00:06:15,456 --> 00:06:16,916
这当然是我们试图避免的


181
00:06:18,276 --> 00:06:19,386
那么到底发生什么了呢


182
00:06:20,276 --> 00:06:22,296
这个红色部分


183
00:06:22,426 --> 00:06:23,996
表示我们花费在


184
00:06:23,996 --> 00:06:24,716
刚刚提到的


185
00:06:24,716 --> 00:06:26,126
临界区域上的时间


186
00:06:26,126 --> 00:06:29,646
所有的索引路径 布局和绘制


187
00:06:30,206 --> 00:06:31,396
绘制这一帧


188
00:06:31,396 --> 00:06:33,166
实际花费时间


189
00:06:33,166 --> 00:06:34,206
比 16 毫秒要长


190
00:06:34,946 --> 00:06:36,456
因为这个设备


191
00:06:36,456 --> 00:06:39,216
只能在固定时间内


192
00:06:39,216 --> 00:06:41,966
把新的一帧替换到屏幕上


193
00:06:41,966 --> 00:06:43,376
一旦错过截止时间


194
00:06:43,376 --> 00:06:45,196
我们只能把同一帧


195
00:06:45,196 --> 00:06:46,776
显示两帧的时长


196
00:06:46,776 --> 00:06:47,526
这可不太好


197
00:06:48,206 --> 00:06:49,746
为什么会这样呢


198
00:06:49,746 --> 00:06:50,696
在这个例子中


199
00:06:50,696 --> 00:06:52,136
我们已经安装了


200
00:06:52,136 --> 00:06:53,706
Cell 预读取方法


201
00:06:53,706 --> 00:06:55,106
因此我们的数据应该


202
00:06:55,106 --> 00:06:55,606
已经准备好了


203
00:06:55,806 --> 00:06:56,956
理想状态下 这一步应该


204
00:06:56,956 --> 00:06:57,466
完成得更快才对


205
00:06:58,346 --> 00:06:59,256
如果我们再仔细


206
00:06:59,256 --> 00:07:00,286
看一下这个记录


207
00:07:00,286 --> 00:07:01,066
就会发现问题所在


208
00:07:01,866 --> 00:07:05,536
这个 Cell 预读取 API 和请求


209
00:07:05,536 --> 00:07:06,826
当前 Cell 的指令


210
00:07:06,826 --> 00:07:07,496
同时被调用


211
00:07:08,056 --> 00:07:09,326
调用的数据


212
00:07:09,326 --> 00:07:10,626
不是为了现有 Cell 的


213
00:07:10,626 --> 00:07:12,976
而是为了之后可能需要的 Cell


214
00:07:12,976 --> 00:07:14,706
但是它们


215
00:07:14,736 --> 00:07:15,606
被同时运行


216
00:07:15,976 --> 00:07:19,616
所以现在 CPU 出现了冲突


217
00:07:19,616 --> 00:07:21,766
是加载当前帧


218
00:07:21,766 --> 00:07:23,146
还是加载现在并不需要


219
00:07:23,146 --> 00:07:24,276
但以后需要的帧


220
00:07:25,736 --> 00:07:27,006
因为这个冲突


221
00:07:27,006 --> 00:07:29,996
两个任务都会花费更多时间


222
00:07:30,666 --> 00:07:33,126
在 iOS 12 里


223
00:07:33,126 --> 00:07:35,226
我们在安排


224
00:07:35,956 --> 00:07:37,166
这些后台预读取操作时


225
00:07:37,166 --> 00:07:39,046
更加智能


226
00:07:39,096 --> 00:07:40,226
这两个步骤会接连发生


227
00:07:40,286 --> 00:07:42,056
而不是同时发生


228
00:07:42,386 --> 00:07:43,776
并产生冲突


229
00:07:44,136 --> 00:07:45,176
这可以缩短


230
00:07:45,176 --> 00:07:47,626
加载当前帧的时间


231
00:07:47,626 --> 00:07:50,886
并且防止丢帧的出现


232
00:07:52,516 --> 00:07:56,456
[ 掌声 ]


233
00:07:56,956 --> 00:07:58,016
这个问题解决之后


234
00:07:58,016 --> 00:08:00,086
我们继续测试 App


235
00:08:00,086 --> 00:08:01,846
会发现另外一个


236
00:08:01,846 --> 00:08:02,756
比较意外的


237
00:08:02,756 --> 00:08:04,676
引起丢帧的问题


238
00:08:05,336 --> 00:08:09,096
我们发现 当设备没有在加载


239
00:08:09,396 --> 00:08:10,276
没有任何后台活动时


240
00:08:10,276 --> 00:08:12,016
我们只是在


241
00:08:12,016 --> 00:08:13,726
前台 App 滑动


242
00:08:14,346 --> 00:08:15,916
奇怪的是


243
00:08:15,916 --> 00:08:18,336
这时可能


244
00:08:18,336 --> 00:08:19,896
比起后台有少量工作时


245
00:08:19,896 --> 00:08:21,766
丢失的帧更多


246
00:08:22,396 --> 00:08:23,866
看起来并不合理


247
00:08:24,366 --> 00:08:25,636
为了弄清这个问题


248
00:08:25,636 --> 00:08:27,306
我们要再深挖一层


249
00:08:27,306 --> 00:08:33,096
看一下 CPU 安排工作负荷时的行为


250
00:08:33,096 --> 00:08:35,196
让我看一下另一个记录


251
00:08:36,306 --> 00:08:37,836
这里有同样的问题


252
00:08:38,206 --> 00:08:39,836
双格蓝色部分


253
00:08:39,836 --> 00:08:42,746
让我们丢失一帧 或者就是丢失帧


254
00:08:43,506 --> 00:08:45,326
这个表格显示


255
00:08:45,326 --> 00:08:47,086
时段里 CPU 的性能


256
00:08:47,686 --> 00:08:49,176
大部分低耗帧时


257
00:08:49,256 --> 00:08:50,876
CPU 性能都维持在


258
00:08:50,876 --> 00:08:52,116
比较低的水平


259
00:08:52,366 --> 00:08:53,806
没有后台任务运行


260
00:08:53,806 --> 00:08:55,256
我们只是在单纯的滚动


261
00:08:55,256 --> 00:08:56,896
这正是我们希望的


262
00:08:56,896 --> 00:08:58,416
因为当我们


263
00:08:58,416 --> 00:08:59,976
不在做高耗工作时


264
00:08:59,976 --> 00:09:01,556
我们希望尽量


265
00:09:01,606 --> 00:09:05,186
让 CPU 保持在低水平来节省电量


266
00:09:05,526 --> 00:09:08,566
这很好 但不太好的是


267
00:09:08,646 --> 00:09:11,226
在性能提升前需要一点时间


268
00:09:11,426 --> 00:09:12,716
昨天的演讲中


269
00:09:12,816 --> 00:09:14,566
也提到过这个


270
00:09:14,726 --> 00:09:17,396
等性能提升后


271
00:09:17,396 --> 00:09:18,876
再加载我们


272
00:09:18,876 --> 00:09:20,126
想显示的 Cell


273
00:09:20,126 --> 00:09:21,606
已经太晚了


274
00:09:21,676 --> 00:09:24,016
所以还是丢失了这一帧


275
00:09:24,806 --> 00:09:26,446
现在 因为我们拥有


276
00:09:26,446 --> 00:09:27,616
整个软件栈


277
00:09:27,616 --> 00:09:29,976
在 iOS 12 里


278
00:09:29,976 --> 00:09:33,606
我们把在高级别 UIKit 框架里


279
00:09:33,676 --> 00:09:36,446
滚动时或当临界区域发生时


280
00:09:36,446 --> 00:09:38,016
的所有信息


281
00:09:38,016 --> 00:09:41,296
传递到低级别 CPU 性能控制器


282
00:09:41,326 --> 00:09:42,996
这样就可以


283
00:09:43,116 --> 00:09:45,116
更智能地分析


284
00:09:45,336 --> 00:09:46,546
现有任务


285
00:09:46,756 --> 00:09:50,346
并预测这些高峰何时出现


286
00:09:50,346 --> 00:09:51,926
以及需要多少 CPU 性能


287
00:09:52,006 --> 00:09:53,626
来赶上你 App


288
00:09:53,626 --> 00:09:55,596
历史需求的截止时间


289
00:09:56,486 --> 00:09:58,136
经过这个改变


290
00:09:58,716 --> 00:10:00,346
当加载开始


291
00:10:00,346 --> 00:10:02,066
我们就可以发现


292
00:10:02,066 --> 00:10:03,676
我们更频繁更快地


293
00:10:03,676 --> 00:10:05,746
让 CPU 提升到


294
00:10:05,806 --> 00:10:07,206
需要的程度


295
00:10:07,206 --> 00:10:08,736
来赶上截止时间


296
00:10:08,736 --> 00:10:10,976
以防丢帧出现


297
00:10:12,286 --> 00:10:14,976
这一改变让很多 iOS 的


298
00:10:14,976 --> 00:10:16,226
滚动场景


299
00:10:16,226 --> 00:10:16,976
得到了极大提升


300
00:10:20,956 --> 00:10:24,086
你所有的 App


301
00:10:24,086 --> 00:10:27,146
都可以免费得到提升


302
00:10:27,146 --> 00:10:28,526
而且你不需要


303
00:10:28,526 --> 00:10:29,686
进行任何更多操作


304
00:10:30,156 --> 00:10:31,266
但是还有几件事情


305
00:10:31,266 --> 00:10:32,466
你可以做 来确保


306
00:10:32,466 --> 00:10:34,136
你充分利用了这些特性


307
00:10:34,996 --> 00:10:37,666
首先如果你还没有采用这个


308
00:10:37,666 --> 00:10:39,116
tableView Cell 预读取 API


309
00:10:39,116 --> 00:10:40,596
或者 CollectionView 的 API


310
00:10:40,596 --> 00:10:42,096
一定要先做这个


311
00:10:42,096 --> 00:10:43,336
因为预先准备好数据


312
00:10:43,336 --> 00:10:44,596
是能确保尽快


313
00:10:44,596 --> 00:10:46,836
加载 Cell 的重要步骤


314
00:10:47,406 --> 00:10:50,506
当然 分析


315
00:10:50,506 --> 00:10:51,856
加载 Cell 的


316
00:10:51,856 --> 00:10:53,116
整个临界区域


317
00:10:53,116 --> 00:10:55,186
并尽量减少需求


318
00:10:55,186 --> 00:10:56,076
也是很重要的


319
00:10:56,076 --> 00:10:58,966
iOS 12 会尽力


320
00:10:58,966 --> 00:11:00,416
让 CPU 性能在此期间匹配


321
00:11:00,416 --> 00:11:01,546
你的 App 的需求


322
00:11:01,616 --> 00:11:03,396
但是你最应该做的


323
00:11:03,396 --> 00:11:04,996
就是保持


324
00:11:04,996 --> 00:11:06,016
减少所需的工作量


325
00:11:06,016 --> 00:11:09,076
以确保给你的客户带来


326
00:11:09,146 --> 00:11:10,336
流畅的滚动体验


327
00:11:11,676 --> 00:11:13,416
这就是 iOS 12 里的滚动部分


328
00:11:14,396 --> 00:11:16,056
接下来让我们关注


329
00:11:16,096 --> 00:11:18,416
下一个性能话题内存


330
00:11:19,626 --> 00:11:21,166
你也许会想


331
00:11:21,166 --> 00:11:22,206
为什么内存会成为


332
00:11:22,206 --> 00:11:23,176
性能讨论中的话题


333
00:11:23,226 --> 00:11:25,726
但是我保证


334
00:11:25,726 --> 00:11:26,966
这其实很必要


335
00:11:26,966 --> 00:11:30,816
实际上是因为内存


336
00:11:30,816 --> 00:11:32,026
就相当于性能


337
00:11:32,746 --> 00:11:34,106
你的 App 使用的


338
00:11:34,196 --> 00:11:36,066
内存越多


339
00:11:36,066 --> 00:11:38,896
对 App 性能的影响越大


340
00:11:39,626 --> 00:11:41,756
要理解这一点


341
00:11:41,756 --> 00:11:43,756
让我们在较高层面


342
00:11:43,756 --> 00:11:45,326
来看一下


343
00:11:45,326 --> 00:11:46,996
通常情况下


344
00:11:46,996 --> 00:11:48,296
系统内存是什么样的


345
00:11:49,136 --> 00:11:50,576
你可以看到


346
00:11:50,576 --> 00:11:52,186
系统的内存


347
00:11:52,186 --> 00:11:54,536
很大部分被其他 App


348
00:11:54,536 --> 00:11:55,666
和系统本身占用


349
00:11:56,276 --> 00:11:57,706
你的 App 现在


350
00:11:57,736 --> 00:11:58,246
占用了一部分


351
00:11:58,676 --> 00:11:59,906
还有一部分


352
00:11:59,906 --> 00:12:02,136
空闲出来


353
00:12:02,136 --> 00:12:03,876
应对新的分配请求


354
00:12:04,546 --> 00:12:05,896
其实那里的很大一部分


355
00:12:05,896 --> 00:12:07,666
都不是真正空闲的


356
00:12:07,666 --> 00:12:08,946
它包含很多东西


357
00:12:08,946 --> 00:12:11,006
比如缓存 或者其他


358
00:12:11,006 --> 00:12:12,426
很快可以被丢弃的内容


359
00:12:12,426 --> 00:12:13,276
以确保内存


360
00:12:13,276 --> 00:12:15,276
可以很快满足需求


361
00:12:15,486 --> 00:12:17,856
但是一般而言


362
00:12:17,856 --> 00:12:19,056
它可能正在被占用


363
00:12:19,056 --> 00:12:21,626
但随时可用


364
00:12:22,546 --> 00:12:23,556
让我们看一下


365
00:12:23,556 --> 00:12:25,276
当你的 App 需要内存时会发生什么


366
00:12:25,906 --> 00:12:29,116
如果你只提出较少的需求


367
00:12:29,156 --> 00:12:31,956
是现有的空闲空间就可以满足的


368
00:12:32,466 --> 00:12:33,516
如果是这样的话


369
00:12:33,516 --> 00:12:35,526
很快就能返回到你的 App


370
00:12:35,526 --> 00:12:36,826
然后你就可以继续


371
00:12:36,826 --> 00:12:37,966
你的工作


372
00:12:39,256 --> 00:12:40,526
但是如果


373
00:12:40,526 --> 00:12:42,136
你的 App 提出了


374
00:12:42,136 --> 00:12:44,326
较大的需求


375
00:12:44,326 --> 00:12:45,756
可能并不需要占用很久


376
00:12:45,756 --> 00:12:47,886
所以你也觉得不用担心


377
00:12:48,246 --> 00:12:49,316
也许你只是需要


378
00:12:49,316 --> 00:12:52,656
从磁盘里加载一个图像并解压


379
00:12:52,656 --> 00:12:54,056
在一些像素上做简单处理


380
00:12:54,056 --> 00:12:55,536
然后就可以丢弃


381
00:12:55,876 --> 00:12:56,926
看起来只是一个


382
00:12:56,926 --> 00:12:57,976
不需要操心的


383
00:12:57,976 --> 00:12:58,806
很快速的操作


384
00:12:59,506 --> 00:13:00,406
我们如果


385
00:13:00,406 --> 00:13:02,826
提出这个需求


386
00:13:02,826 --> 00:13:04,556
需要的内存大于


387
00:13:04,556 --> 00:13:05,916
现在系统可提供的


388
00:13:06,176 --> 00:13:09,156
系统无法立刻满足


389
00:13:09,156 --> 00:13:10,566
那么 我们需要从别的地方


390
00:13:10,636 --> 00:13:11,216
得到这些内存


391
00:13:12,206 --> 00:13:13,596
最可能获取的地方


392
00:13:13,596 --> 00:13:15,436
就是别的 App


393
00:13:15,436 --> 00:13:18,756
或者系统内部


394
00:13:18,876 --> 00:13:20,156
你可能并不怎么担心


395
00:13:20,156 --> 00:13:21,106
因为你只是


396
00:13:21,106 --> 00:13:22,106
为你的 App 申请更多内存


397
00:13:22,106 --> 00:13:23,386
所以并不关注


398
00:13:23,386 --> 00:13:24,906
别的地方发生了什么


399
00:13:25,536 --> 00:13:29,356
但实际上这会影响


400
00:13:29,436 --> 00:13:30,696
你的客户接下来


401
00:13:30,696 --> 00:13:32,066
会遇到的事情


402
00:13:32,636 --> 00:13:33,906
更此刻重要的是


403
00:13:33,906 --> 00:13:35,496
它也会对你的 App


404
00:13:35,496 --> 00:13:37,146
产生影响


405
00:13:37,146 --> 00:13:39,106
因为系统需要


406
00:13:39,106 --> 00:13:41,126
为你获取这些内存


407
00:13:41,366 --> 00:13:42,666
因为内存现在无法提供


408
00:13:42,666 --> 00:13:44,776
所以内核需要


409
00:13:44,776 --> 00:13:46,936
从别处获取


410
00:13:46,936 --> 00:13:49,446
并运作 CPU


411
00:13:49,446 --> 00:13:50,216
来满足需求


412
00:13:50,726 --> 00:13:53,386
而为此花费的时间


413
00:13:53,416 --> 00:13:54,796
其实可以更好的


414
00:13:54,796 --> 00:13:56,466
花在你的 App 上


415
00:13:57,126 --> 00:13:58,656
所以找到


416
00:13:58,686 --> 00:14:00,036
分解这些大块需求


417
00:14:00,036 --> 00:14:01,376
或者减少整体需求高峰


418
00:14:01,376 --> 00:14:03,376
的方法 实际上


419
00:14:03,496 --> 00:14:05,186
对提升你的 App 的性能


420
00:14:05,186 --> 00:14:07,236
以及客户接下来


421
00:14:07,236 --> 00:14:08,816
使用其他 App 的体验


422
00:14:08,816 --> 00:14:10,716
都有很大影响


423
00:14:12,716 --> 00:14:14,006
有很多方法


424
00:14:14,006 --> 00:14:17,806
可以减少 APP 内存使用量


425
00:14:17,806 --> 00:14:19,146
其中一个很好的方法


426
00:14:19,146 --> 00:14:20,326
就是用 profile 和 instruments


427
00:14:20,746 --> 00:14:21,886
不过今天上午 


428
00:14:21,886 --> 00:14:23,496
我们要了解一个


429
00:14:23,496 --> 00:14:25,306
iOS 12 里


430
00:14:25,306 --> 00:14:29,216
帮助减少 App 使用内存的新技术


431
00:14:29,216 --> 00:14:30,786
这就是 Automatic Backing Stores


432
00:14:31,856 --> 00:14:32,966
打个比方


433
00:14:32,966 --> 00:14:34,616
我们要在 iPhone X 里


434
00:14:34,656 --> 00:14:36,356
让这个土拨鼠变成肖像模式


435
00:14:37,266 --> 00:14:38,893
这会是多大呢？


436
00:14:39,436 --> 00:14:41,666
iPhone X 的肖像模式


437
00:14:41,736 --> 00:14:43,376
宽 375 点


438
00:14:43,376 --> 00:14:45,346
为保持相同比例


439
00:14:45,346 --> 00:14:46,176
就是 250 点高


440
00:14:46,706 --> 00:14:48,646
这样会占用


441
00:14:48,646 --> 00:14:48,896
多少内存呢


442
00:14:49,536 --> 00:14:54,956
375 乘 250 乘 @3x


443
00:14:54,956 --> 00:14:56,346
再乘上 64 位每像素


444
00:14:56,346 --> 00:14:58,226
因为这是一个色深设备


445
00:14:58,226 --> 00:15:00,406
等于 2.2 M


446
00:15:00,406 --> 00:15:00,976
这是绘制一只土拨鼠需要的内存量


447
00:15:02,096 --> 00:15:03,426
这个数据看起来很合理


448
00:15:03,426 --> 00:15:05,186
这是当内存


449
00:15:05,186 --> 00:15:06,966
很好地配置时的情况


450
00:15:07,216 --> 00:15:08,306
我们想要保留这个


451
00:15:08,306 --> 00:15:10,226
保真度很好的图像


452
00:15:10,226 --> 00:15:11,816
这就是把图像


453
00:15:11,816 --> 00:15:13,116
放在缓存里


454
00:15:13,116 --> 00:15:13,736
所需要的内存量


455
00:15:14,086 --> 00:15:15,576
这是在预料之中的


456
00:15:16,376 --> 00:15:20,266
但是如果我们要绘制一个


457
00:15:20,266 --> 00:15:21,316
低保真度版本的土拨鼠


458
00:15:21,626 --> 00:15:23,416
比如用 Apple Pencil 和 iPad


459
00:15:23,416 --> 00:15:27,666
绘制出的黑白色的简单图形


460
00:15:28,196 --> 00:15:29,456
就像这样


461
00:15:30,496 --> 00:15:32,636
这个低保真度版本的土拨鼠


462
00:15:32,866 --> 00:15:34,606
又需要占用多少内存呢


463
00:15:35,506 --> 00:15:37,556
其实占用的内存量


464
00:15:37,556 --> 00:15:38,766
是一样多的


465
00:15:39,266 --> 00:15:41,286
这显然没有


466
00:15:41,286 --> 00:15:42,236
很好的利用内存


467
00:15:42,236 --> 00:15:43,306
全都是灰度图


468
00:15:43,796 --> 00:15:45,236
所有的色深信息


469
00:15:45,646 --> 00:15:47,436
在这个图像中


470
00:15:47,436 --> 00:15:48,736
都没有被使用


471
00:15:49,196 --> 00:15:50,416
我们希望找到更好的方法


472
00:15:50,466 --> 00:15:53,456
而 iOS 12 中引入的


473
00:15:53,456 --> 00:15:54,906
Automatic Backing Store 上支持


474
00:15:54,906 --> 00:15:57,686
正好做到了这一点


475
00:15:58,766 --> 00:16:00,866
所有安装了


476
00:16:00,866 --> 00:16:02,176
draw Rect 的视图


477
00:16:02,296 --> 00:16:04,826
它们的 Backing Stores


478
00:16:04,826 --> 00:16:06,126
都会由被写入内容的


479
00:16:06,126 --> 00:16:06,986
深度来决定


480
00:16:07,376 --> 00:16:08,366
因此 当我们用


481
00:16:08,366 --> 00:16:09,796
Core Graphics 来绘制


482
00:16:09,796 --> 00:16:11,906
只有灰度的内容时


483
00:16:11,906 --> 00:16:15,186
会自动使用 8 位的 Backing Stores


484
00:16:15,366 --> 00:16:17,436
而不是 64 位的


485
00:16:17,946 --> 00:16:19,466
对内存的需求量


486
00:16:19,466 --> 00:16:21,226
成量级减少


487
00:16:21,226 --> 00:16:26,216
从 2.2 M 降低成 275 K


488
00:16:26,216 --> 00:16:28,806
这对于很多 App 来说


489
00:16:28,806 --> 00:16:29,956
都是很大的改进


490
00:16:29,956 --> 00:16:30,966
对于你们的 App 和我们的都是


491
00:16:31,516 --> 00:16:36,356
[ 掌声 ]


492
00:16:36,856 --> 00:16:38,266
用 iOS 12 SDK


493
00:16:38,266 --> 00:16:40,206
创建的所有 App


494
00:16:40,266 --> 00:16:41,646
都可以采用 Automatic Backing Stores


495
00:16:42,586 --> 00:16:44,806
所有在 UIView 上


496
00:16:44,806 --> 00:16:46,316
安装了 draw Rect 的


497
00:16:46,396 --> 00:16:48,476
都会自动采用


498
00:16:48,476 --> 00:16:49,856
用 UIGraphicsImageRenderer


499
00:16:49,856 --> 00:16:52,316
绘制到离屏位图的内容也一样


500
00:16:53,156 --> 00:16:54,436
用 UIGraphicsImageRenderer 时


501
00:16:54,436 --> 00:16:55,856
我们并不知道


502
00:16:55,856 --> 00:16:58,896
你打算把你获取的图片


503
00:16:58,896 --> 00:17:00,086
用来做什么


504
00:17:00,606 --> 00:17:02,516
所以 如果你知道


505
00:17:02,516 --> 00:17:03,866
这个自动行为


506
00:17:03,866 --> 00:17:05,675
并不是你想要的


507
00:17:05,675 --> 00:17:07,146
你可以在 ImageRenderer


508
00:17:07,146 --> 00:17:09,106
制定某个你想要的


509
00:17:09,106 --> 00:17:10,636
特定的 Backing Stores 模式


510
00:17:10,636 --> 00:17:12,386
比如用 newRange API


511
00:17:12,715 --> 00:17:13,915
来定制你想要的


512
00:17:13,915 --> 00:17:15,306
扩充域图像


513
00:17:15,866 --> 00:17:17,626
更多关于这个


514
00:17:18,006 --> 00:17:20,306
和其他有关 UI Image 的技术


515
00:17:20,306 --> 00:17:22,205
你可以在这周的


516
00:17:22,205 --> 00:17:24,455
图像和图形的最佳实践会议中了解到


517
00:17:24,915 --> 00:17:27,656
这就是关于性能的第二个主题


518
00:17:28,425 --> 00:17:30,636
接下来 让我们聊一聊自动布局


519
00:17:31,756 --> 00:17:34,766
现在 iOS 10 中的自动布局


520
00:17:34,986 --> 00:17:36,386
有一些很大的进步


521
00:17:36,866 --> 00:17:37,946
我们团队很努力地


522
00:17:37,946 --> 00:17:40,076
为你的 App


523
00:17:40,076 --> 00:17:42,076
尽可能优化自动布局


524
00:17:42,676 --> 00:17:44,726
所以你会发现


525
00:17:44,726 --> 00:17:47,146
自动布局在 iOS 12 中默认更快了


526
00:17:47,556 --> 00:17:49,096
我们会讲到在好几种情况下都是这样的


527
00:17:49,996 --> 00:17:52,016
当团队在分析和优化


528
00:17:52,016 --> 00:17:53,406
自动布局时


529
00:17:53,406 --> 00:17:54,866
他们在系统中


530
00:17:54,946 --> 00:17:56,476
看了很多我们自己的 App


531
00:17:56,476 --> 00:17:57,896
如何使用自动布局的情况


532
00:17:57,896 --> 00:17:59,686
然后发现了一些


533
00:17:59,686 --> 00:18:00,726
不同的 App


534
00:18:00,726 --> 00:18:02,496
可能遇到的


535
00:18:02,566 --> 00:18:03,546
比较普遍的陷阱


536
00:18:04,026 --> 00:18:05,086
所以我们会


537
00:18:05,156 --> 00:18:06,406
向你们展示一些简单的方法


538
00:18:06,406 --> 00:18:08,376
让你们可以


539
00:18:08,376 --> 00:18:09,486
优化你们的 App


540
00:18:10,796 --> 00:18:11,766
今天 让我们先了解一下


541
00:18:11,816 --> 00:18:13,466
自动布局在 iOS 12 中     


542
00:18:13,466 --> 00:18:16,306
怎样能做到更快 


543
00:18:16,386 --> 00:18:17,976
我们首先要知道


544
00:18:18,016 --> 00:18:20,996
当我们在普遍用户场景中


545
00:18:20,996 --> 00:18:23,336
添加更多视图时


546
00:18:23,446 --> 00:18:24,296
自动布局的渐近行为


547
00:18:25,646 --> 00:18:26,346
这样做的原因是


548
00:18:26,346 --> 00:18:28,196
讨论渐近性


549
00:18:28,196 --> 00:18:29,476
是想了解


550
00:18:29,476 --> 00:18:31,056
如果我们大量增加视图


551
00:18:31,056 --> 00:18:31,956
会发生什么


552
00:18:32,366 --> 00:18:33,776
如果我们一下增加


553
00:18:33,776 --> 00:18:35,486
非常多的视图


554
00:18:35,486 --> 00:18:37,216
可以很快地让


555
00:18:37,216 --> 00:18:38,356
性能问题显现


556
00:18:38,866 --> 00:18:40,186
这样可以帮助我们看清楚


557
00:18:40,406 --> 00:18:41,776
这次优化


558
00:18:41,776 --> 00:18:43,316
即使对少量视窗


559
00:18:43,316 --> 00:18:44,906
也有提速作用


560
00:18:45,366 --> 00:18:46,506
让我们从普通模式开始


561
00:18:46,506 --> 00:18:48,366
最简单的


562
00:18:48,366 --> 00:18:50,246
一个容器里的


563
00:18:50,246 --> 00:18:52,576
Independent Sibling Views


564
00:18:53,006 --> 00:18:54,156
这些视图的位置


565
00:18:54,156 --> 00:18:55,386
受到容器


566
00:18:55,386 --> 00:18:57,596
或者其他视图的约束


567
00:18:57,596 --> 00:18:58,536
但彼此之间并没有约束


568
00:18:58,666 --> 00:18:59,876
它们相互独立


569
00:19:00,636 --> 00:19:02,846
在 iOS 11 里


570
00:19:02,846 --> 00:19:06,246
添加这些 Independent Siblings 的成本


571
00:19:06,246 --> 00:19:06,816
线性上升


572
00:19:07,526 --> 00:19:08,996
这很棒


573
00:19:08,996 --> 00:19:10,536
这应该正是


574
00:19:10,536 --> 00:19:11,906
你所预料到的


575
00:19:12,306 --> 00:19:13,706
也就是说


576
00:19:13,706 --> 00:19:15,116
每添加一个


577
00:19:15,116 --> 00:19:17,046
独立于其他视图的层级的


578
00:19:17,046 --> 00:19:18,326
新的视图


579
00:19:18,326 --> 00:19:19,876
增加的成本


580
00:19:19,876 --> 00:19:21,336
都是固定的


581
00:19:22,516 --> 00:19:23,406
因为这已经


582
00:19:23,506 --> 00:19:24,896
和我们期待的


583
00:19:24,896 --> 00:19:26,746
增长指数一样


584
00:19:26,746 --> 00:19:28,976
所以在 iOS 12 里依旧如此


585
00:19:29,096 --> 00:19:30,966
但是我们的团队很努力地


586
00:19:30,966 --> 00:19:33,386
想减少这个固定成本


587
00:19:33,386 --> 00:19:34,956
希望使添加视图变得


588
00:19:35,146 --> 00:19:36,076
更加容易


589
00:19:37,376 --> 00:19:38,326
让我们来看一个


590
00:19:38,326 --> 00:19:39,596
更有趣的例子


591
00:19:39,986 --> 00:19:42,236
这次让我们看一下


592
00:19:42,236 --> 00:19:42,846
Dependent Siblings


593
00:19:43,326 --> 00:19:46,826
这里有好几个子视图


594
00:19:46,826 --> 00:19:47,676
它们彼此之间


595
00:19:47,726 --> 00:19:49,296
相互约束


596
00:19:49,296 --> 00:19:51,616
他们的布局相互影响


597
00:19:52,666 --> 00:19:54,536
在 iOS 11 里


598
00:19:54,896 --> 00:19:56,226
渐近性的表现


599
00:19:56,226 --> 00:19:58,206
并不很好


600
00:19:58,206 --> 00:20:00,316
实际上是以指数级增长的


601
00:20:00,686 --> 00:20:03,186
随着视图的增加


602
00:20:03,186 --> 00:20:04,786
添加新的视图


603
00:20:04,786 --> 00:20:05,976
会使成本大幅度增加


604
00:20:07,826 --> 00:20:09,146
我们团队


605
00:20:09,146 --> 00:20:10,396
努力地识别出


606
00:20:10,396 --> 00:20:12,796
这一指数级增长的原因


607
00:20:12,796 --> 00:20:14,436
并修正了算法


608
00:20:14,436 --> 00:20:14,826
解决这一问题


609
00:20:15,386 --> 00:20:17,976
在 iOS 12 中它们也以线性增长了


610
00:20:18,516 --> 00:20:23,396
[ 掌声 ]


611
00:20:23,896 --> 00:20:24,866
同时 我们团队


612
00:20:24,866 --> 00:20:25,956
也在努力的减少


613
00:20:25,956 --> 00:20:28,016
这些固定成本


614
00:20:29,096 --> 00:20:31,366
现在除了 Dependent Siblings


615
00:20:31,366 --> 00:20:32,506
还有一种其他的布局类型


616
00:20:32,506 --> 00:20:34,056
Nested Views


617
00:20:34,056 --> 00:20:35,656
当一个视图在另一个视图里


618
00:20:35,726 --> 00:20:37,706
并且被外面的视图所限制


619
00:20:38,136 --> 00:20:39,506
这是你的 App 里


620
00:20:39,586 --> 00:20:41,586
一个很常见的模式


621
00:20:41,586 --> 00:20:42,866
然而在 iOS 11 里


622
00:20:42,956 --> 00:20:44,566
我们遇到相同的


623
00:20:44,566 --> 00:20:45,286
指数级增长


624
00:20:45,966 --> 00:20:47,456
又一个好消息


625
00:20:47,456 --> 00:20:48,726
在 iOS 12 里


626
00:20:48,796 --> 00:20:49,836
这个也变成线性的了


627
00:20:50,516 --> 00:20:54,546
[ 掌声 ]


628
00:20:55,046 --> 00:20:56,566
iOS 12 的自动布局


629
00:20:56,566 --> 00:20:58,226
有很多改进


630
00:20:58,226 --> 00:21:00,256
你只要用 iOS 12


631
00:21:00,256 --> 00:21:01,346
运行你的 App


632
00:21:01,346 --> 00:21:02,406
就能发现这些


633
00:21:02,406 --> 00:21:03,936
改进的地方


634
00:21:04,646 --> 00:21:06,296
如果想获取更多内容


635
00:21:06,956 --> 00:21:08,886
想了解更多


636
00:21:08,976 --> 00:21:11,016
获得更好的直觉


637
00:21:11,586 --> 00:21:13,346
了解关于不同布局的性能


638
00:21:13,346 --> 00:21:15,446
以及一些


639
00:21:15,446 --> 00:21:16,846
我刚才提到的


640
00:21:16,846 --> 00:21:18,596
普遍的陷阱


641
00:21:18,896 --> 00:21:19,996
请一定关注


642
00:21:19,996 --> 00:21:21,326
这周晚些时候的


643
00:21:21,436 --> 00:21:22,726
高性能自动布局会议


644
00:21:23,636 --> 00:21:26,156
最后的主题是框架更新


645
00:21:26,156 --> 00:21:28,216
让我们了解一下


646
00:21:28,216 --> 00:21:29,106
Swiftification
 
00:21:29,676 --> 00:21:32,906
你应该听说了 iOS 12 引入了


647
00:21:32,986 --> 00:21:34,136
Swift 4.2


648
00:21:34,586 --> 00:21:36,116
在 Swift 4.2 里


649
00:21:36,116 --> 00:21:38,326
我们希望确保


650
00:21:38,406 --> 00:21:40,596
UIKit 在你的 App 里


651
00:21:40,596 --> 00:21:42,676
用 Swift 时能有很好的体验


652
00:21:43,026 --> 00:21:44,376
尤其是当它和


653
00:21:44,376 --> 00:21:45,726
其他 Swift Standard Library


654
00:21:45,726 --> 00:21:48,786
或者和 Swift 有相同模式的地方互动时


655
00:21:49,606 --> 00:21:51,906
所以我们测试了所有的 UIKit 


656
00:21:51,906 --> 00:21:53,376
并确保一切


657
00:21:53,376 --> 00:21:54,936
都很合适


658
00:21:55,636 --> 00:21:56,936
而且 我们还让


659
00:21:56,936 --> 00:21:58,226
我们对 UIKit


660
00:21:58,226 --> 00:22:00,096
做出的改变


661
00:22:00,096 --> 00:22:01,706
都能够自动迁移 


662
00:22:01,706 --> 00:22:03,966
这样你不用做任何更多的操作


663
00:22:03,966 --> 00:22:04,536
就能得到这些更新


664
00:22:05,746 --> 00:22:07,536
有关这些更新


665
00:22:07,536 --> 00:22:08,766
我们今天上午主要讨论


666
00:22:08,766 --> 00:22:09,736
三个方面


667
00:22:10,016 --> 00:22:11,756
其实如果你看一下 SDK


668
00:22:11,756 --> 00:22:13,856
就会发现


669
00:22:13,856 --> 00:22:15,816
有非常多一致性的改进


670
00:22:16,566 --> 00:22:17,326
但是今天我们只讨论


671
00:22:17,326 --> 00:22:19,586
嵌套类型 常量和函数


672
00:22:19,656 --> 00:22:22,636
首先是嵌套类型


673
00:22:23,516 --> 00:22:25,476
在 Swift 4 中


674
00:22:25,476 --> 00:22:26,776
全局命名空间中


675
00:22:26,776 --> 00:22:28,766
有很多不同类型


676
00:22:28,806 --> 00:22:30,006
比如 UIApplicationState


677
00:22:30,666 --> 00:22:32,916
像这样跟其他的类


678
00:22:32,966 --> 00:22:35,096
有很强的联系的类型


679
00:22:35,096 --> 00:22:37,276
我们让它们直接


680
00:22:37,276 --> 00:22:38,016
嵌套进这一类


681
00:22:38,796 --> 00:22:39,746
所以现在所有的


682
00:22:39,746 --> 00:22:42,156
枚举和其他


683
00:22:42,206 --> 00:22:43,796
这类的全局类型


684
00:22:43,796 --> 00:22:46,576
现在变成了相关类的子类型


685
00:22:46,906 --> 00:22:47,576
现在变成了


686
00:22:47,576 --> 00:22:49,326
UIApplication.State


687
00:22:49,796 --> 00:22:51,536
这样更清晰地


688
00:22:51,536 --> 00:22:52,786
表明两者之间的关系


689
00:22:52,786 --> 00:22:54,216
并且让它们


690
00:22:54,216 --> 00:22:55,276
更容易找到


691
00:22:56,046 --> 00:22:57,546
很多情况下


692
00:22:57,546 --> 00:23:00,286
这样可以帮助理解


693
00:23:00,286 --> 00:23:02,246
减少混淆


694
00:23:02,696 --> 00:23:03,546
让我们看一下


695
00:23:03,546 --> 00:23:05,016
UITabBarItemPositioning


696
00:23:05,626 --> 00:23:06,216
你觉得这应该是


697
00:23:06,306 --> 00:23:09,086
UITabBar ItemPositioning


698
00:23:09,226 --> 00:23:10,896
还是 UITabBarItem Positioning


699
00:23:10,896 --> 00:23:12,586
两者都有可能


700
00:23:12,836 --> 00:23:13,906
两个类都是


701
00:23:14,406 --> 00:23:16,546
在 Swift 4.2 里


702
00:23:16,616 --> 00:23:17,726
现在变得非常清楚


703
00:23:17,726 --> 00:23:20,066
实际是 UITabBar ItemPositioning


704
00:23:20,646 --> 00:23:23,226
除了嵌套类型


705
00:23:23,546 --> 00:23:25,666
我们还嵌套了很多常量


706
00:23:26,106 --> 00:23:27,486
在 Swift 4 里
 
00:23:27,486 --> 00:23:29,926
NSNotifications


707
00:23:29,926 --> 00:23:30,636
都在 NSNotification.Name 的


708
00:23:30,706 --> 00:23:32,796
全局命名空间


709
00:23:33,206 --> 00:23:34,616
他们相关的


710
00:23:34,616 --> 00:23:35,956
UserInfoKey


711
00:23:35,956 --> 00:23:37,386
其实只是在外面的全局常量


712
00:23:38,026 --> 00:23:39,676
为了和 AppKit 保持一致


713
00:23:39,676 --> 00:23:41,146
更容易找到


714
00:23:41,146 --> 00:23:42,656
并且把这些类型联系在一起


715
00:23:42,706 --> 00:23:44,196
它们现在都被


716
00:23:44,196 --> 00:23:46,026
嵌套在他们使用的类之下


717
00:23:46,456 --> 00:23:49,006
所以 didChangeStatusBarOrientation


718
00:23:49,316 --> 00:23:51,336
现在是在 UIApplication 下的 didChange


719
00:23:51,336 --> 00:23:52,346
StatusBarOrientationNotification


720
00:23:52,346 --> 00:23:54,106
它的 UserInfoKey


721
00:23:54,106 --> 00:23:55,436
和它在一块儿


722
00:23:55,436 --> 00:23:56,486
位于相同位置


723
00:23:57,126 --> 00:23:59,656
我们检查了


724
00:23:59,656 --> 00:24:01,326
所有其他 UIKit


725
00:24:01,326 --> 00:24:03,806
里的全局常量


726
00:24:03,806 --> 00:24:05,006
并把它们嵌套在该有的位置


727
00:24:05,346 --> 00:24:06,486
所以像 UIFloatRangeZero


728
00:24:06,486 --> 00:24:08,536
和 UIFloatRangeInfinite


729
00:24:08,536 --> 00:24:10,216
现在都变成


730
00:24:10,216 --> 00:24:12,396
UIFloatRange 的属性


731
00:24:12,396 --> 00:24:14,786
这样就更容易找到和使用


732
00:24:15,096 --> 00:24:16,686
在需要 UIFloatRange 的地方


733
00:24:16,686 --> 00:24:18,096
你可以输入


734
00:24:18,206 --> 00:24:20,386
.zero 或者 .infinite


735
00:24:20,616 --> 00:24:21,656
因为它们现在是属性了


736
00:24:21,906 --> 00:24:23,226
Xcode 可以帮你


737
00:24:23,226 --> 00:24:24,866
自动完成


738
00:24:24,866 --> 00:24:26,666
放置在应该的位置上


739
00:24:27,776 --> 00:24:29,046
除了常量


740
00:24:29,046 --> 00:24:30,316
我们也测试了


741
00:24:30,316 --> 00:24:31,056
所有的全局函数


742
00:24:31,536 --> 00:24:32,776
UIEdgeInserts


743
00:24:32,776 --> 00:24:36,206
和 UIImage


744
00:24:36,206 --> 00:24:37,376
为了在不同的类型上运行


745
00:24:37,376 --> 00:24:38,076
有一些全局函数


746
00:24:38,556 --> 00:24:40,326
在 Swift 4.2 里


747
00:24:40,326 --> 00:24:43,796
这些变成了类型的方法


748
00:24:44,576 --> 00:24:46,286
所以现在要 insetRect


749
00:24:46,326 --> 00:24:48,196
或者从图像里提取


750
00:24:48,196 --> 00:24:51,046
pngData 都可以很容易


751
00:24:52,516 --> 00:24:57,166
[ 掌声 ]


752
00:24:57,666 --> 00:24:59,176
接下来 今天上午还有


753
00:24:59,176 --> 00:25:00,286
我还想要聊一聊


754
00:25:00,286 --> 00:25:01,236
另外一大类函数


755
00:25:01,236 --> 00:25:02,446
就是所有的


756
00:25:02,446 --> 00:25:03,956
String Conversion 函数


757
00:25:03,956 --> 00:25:05,306
UIKit 里面的所有类型


758
00:25:05,776 --> 00:25:07,206
CGPoint CGRect CGSize CGVector


759
00:25:07,346 --> 00:25:09,706
所有的这些


760
00:25:09,706 --> 00:25:11,726
有很多 既可以是转换到字符串


761
00:25:11,726 --> 00:25:12,106
也可以反过来


762
00:25:12,516 --> 00:25:14,676
当我们想决定


763
00:25:14,676 --> 00:25:15,386
它们应该放在哪里时


764
00:25:15,386 --> 00:25:16,836
就会发现


765
00:25:16,836 --> 00:25:19,086
它们其实有两种用途


766
00:25:19,386 --> 00:25:21,216
一个是编码和解码


767
00:25:21,676 --> 00:25:24,276
另一个是它们总用来 print


768
00:25:24,466 --> 00:25:25,296
当你想得到


769
00:25:25,296 --> 00:25:26,276
debug 描述时


770
00:25:26,826 --> 00:25:28,586
这两个用途很不一样


771
00:25:28,586 --> 00:25:30,886
但其实 Swift 对 


772
00:25:30,946 --> 00:25:33,166
这两种用途 都有一级支持


773
00:25:33,626 --> 00:25:34,846
我们现在可以确保


774
00:25:34,846 --> 00:25:36,166
所有的类型


775
00:25:36,166 --> 00:25:37,436
和 Swift 的内置支持


776
00:25:37,436 --> 00:25:38,156
都可以和谐共处


777
00:25:38,776 --> 00:25:40,706
在 Swift 4.2 里


778
00:25:40,786 --> 00:25:42,436
所有的类型都变得可编码


779
00:25:42,706 --> 00:25:44,526
这样你可以很容易的


780
00:25:44,526 --> 00:25:46,146
给这些类型


781
00:25:46,146 --> 00:25:47,896
编码和解码 JSON 


782
00:25:48,516 --> 00:25:53,656
[ 掌声 ]


783
00:25:54,156 --> 00:25:55,236
在 Swift 里 debug printing


784
00:25:55,306 --> 00:25:56,766
其实比在


785
00:25:56,766 --> 00:25:58,296
Objective-C 更容易


786
00:25:58,296 --> 00:26:00,106
因为你不需要


787
00:26:00,106 --> 00:26:00,706
其他额外转换


788
00:26:01,276 --> 00:26:03,246
这些类型的内省


789
00:26:03,246 --> 00:26:04,916
可以让你直接 print 它们


790
00:26:05,226 --> 00:26:06,396
在 Swift 4.2 里


791
00:26:06,396 --> 00:26:07,486
你可以直接把这些类型


792
00:26:07,486 --> 00:26:08,726
传输到 print 函数


793
00:26:09,146 --> 00:26:10,416
如果你希望为了 debug 把它们 print 出来


794
00:26:10,446 --> 00:26:12,056
或者 log 它们


795
00:26:12,916 --> 00:26:15,786
最后如果你已经有一个代码


796
00:26:15,786 --> 00:26:17,196
用的是旧的


797
00:26:17,196 --> 00:26:18,826
string conversion 函数


798
00:26:18,826 --> 00:26:20,986
并且需要一个兼容函数


799
00:26:20,986 --> 00:26:22,766
来继续进行


800
00:26:23,366 --> 00:26:24,346
我们已经


801
00:26:24,346 --> 00:26:25,476
把它们都重命名


802
00:26:25,476 --> 00:26:28,126
并变成 NSCoder 里的属性


803
00:26:28,526 --> 00:26:29,826
这可以帮助


804
00:26:29,826 --> 00:26:30,926
用来强调这些方法


805
00:26:30,926 --> 00:26:32,516
的目的是


806
00:26:32,516 --> 00:26:34,276
编码和解码


807
00:26:34,276 --> 00:26:36,066
这样把它们放过去就很自然


808
00:26:37,966 --> 00:26:39,476
这只是一部分


809
00:26:39,476 --> 00:26:40,666
你会在 iOS 12


810
00:26:40,666 --> 00:26:43,106
Swift 4.2 的 SDK 里


811
00:26:43,806 --> 00:26:46,946
发现改进的地方


812
00:26:46,946 --> 00:26:48,056
但其实还有更多


813
00:26:49,476 --> 00:26:51,176
说到编码和解码


814
00:26:51,176 --> 00:26:54,246
NSSecureCoding


815
00:26:55,096 --> 00:26:57,566
在 iOS 12 里


816
00:26:57,566 --> 00:26:59,456
有新的默认安全


817
00:26:59,456 --> 00:26:59,856
编码解码 API


818
00:27:01,246 --> 00:27:02,846
为所有在 NSKeyedArchiver 上的编码需求


819
00:27:02,846 --> 00:27:04,546
采用 NSSecureCoding


820
00:27:04,586 --> 00:27:07,056
是非常重要的


821
00:27:07,056 --> 00:27:08,186
以防止你的客户


822
00:27:08,186 --> 00:27:11,646
受到恶意和损坏数据的影响


823
00:27:12,606 --> 00:27:13,876
你会发现


824
00:27:13,876 --> 00:27:15,856
旧的不安全的 API 没有被弃用


825
00:27:16,776 --> 00:27:18,396
更多的内容


826
00:27:18,396 --> 00:27:20,066
以及相关细节


827
00:27:20,156 --> 00:27:21,346
你可以在周四 9 点的


828
00:27:21,346 --> 00:27:23,266
可信任的数据会议了解到


829
00:27:23,826 --> 00:27:25,996
这就是关于框架更新的内容


830
00:27:26,946 --> 00:27:28,496
下面 让我们了解一下


831
00:27:28,586 --> 00:27:32,486
对一些现有 API 的增强


832
00:27:32,486 --> 00:27:33,466
首先是通知


833
00:27:34,256 --> 00:27:36,096
在 iOS 12 里


834
00:27:36,096 --> 00:27:37,756
通知有很多新的改进


835
00:27:37,756 --> 00:27:39,296
但是今天


836
00:27:39,296 --> 00:27:40,436
我们主要关注三点


837
00:27:41,176 --> 00:27:42,496
自定义通知内的交互


838
00:27:42,496 --> 00:27:44,376
通知分组


839
00:27:44,376 --> 00:27:46,326
和在你的 App 里


840
00:27:46,326 --> 00:27:47,866
如何访问


841
00:27:47,866 --> 00:27:48,696
通知设置


842
00:27:50,206 --> 00:27:51,606
首先是交互


843
00:27:52,286 --> 00:27:56,486
现在个性化通知允许你


844
00:27:56,486 --> 00:28:00,686
为通知定义一组预先行为


845
00:28:01,246 --> 00:28:03,436
在 iOS 12 里 这些行为


846
00:28:03,436 --> 00:28:04,756
不再是静态的


847
00:28:05,136 --> 00:28:05,856
它可以以编程方式定义


848
00:28:05,906 --> 00:28:07,506
你也可以在运行时 


849
00:28:07,506 --> 00:28:09,406
改变它们


850
00:28:09,536 --> 00:28:11,916
除了这些行为


851
00:28:12,296 --> 00:28:13,956
更棒的是


852
00:28:13,956 --> 00:28:16,226
通知本身也可以


853
00:28:16,226 --> 00:28:17,616
变成交互的


854
00:28:18,156 --> 00:28:21,286
比如说这里信息允许你


855
00:28:21,366 --> 00:28:23,266
直接在通知中


856
00:28:23,466 --> 00:28:26,046
快速进行回复


857
00:28:28,066 --> 00:28:29,266
除了交互


858
00:28:29,596 --> 00:28:32,026
iOS 12 还可以


859
00:28:32,026 --> 00:28:33,796
默认通知分组


860
00:28:33,796 --> 00:28:34,846
这个默认行为


861
00:28:34,886 --> 00:28:36,536
可以把某个


862
00:28:36,536 --> 00:28:38,816
特定 App 的通知分为一组


863
00:28:39,246 --> 00:28:42,296
当然你的 App 可能需要


864
00:28:42,296 --> 00:28:44,256
更细化的分组


865
00:28:44,256 --> 00:28:46,036
比如 iMessage  


866
00:28:46,036 --> 00:28:47,296
可以把某一个对话的信息


867
00:28:47,296 --> 00:28:49,046
分为一组


868
00:28:49,116 --> 00:28:50,556
和别的从同一 App 来的通知


869
00:28:50,596 --> 00:28:51,836
分离开来


870
00:28:53,116 --> 00:28:54,536
现在你的 App 也可以这样


871
00:28:54,536 --> 00:28:56,716
你只要用一个


872
00:28:56,716 --> 00:28:58,706
特定的 thread identifier


873
00:28:58,806 --> 00:29:00,526
来标记你的通知


874
00:29:00,526 --> 00:29:01,776
那么那个 thread identifier


875
00:29:01,856 --> 00:29:03,976
下的所有通知


876
00:29:03,976 --> 00:29:04,586
都会成为单独一组


877
00:29:05,106 --> 00:29:08,106
iOS 12 里


878
00:29:08,106 --> 00:29:10,746
通知的 UI 更新


879
00:29:10,746 --> 00:29:13,246
也能够让用户


880
00:29:13,246 --> 00:29:16,026
个性化设置


881
00:29:16,026 --> 00:29:17,526
通知的推送


882
00:29:18,436 --> 00:29:21,436
当然你的 App 可能也包含


883
00:29:21,436 --> 00:29:22,996
一些对通知管理的


884
00:29:22,996 --> 00:29:25,876
更细化的控制


885
00:29:26,436 --> 00:29:28,316
iOS 12 有一个新的 API


886
00:29:28,536 --> 00:29:29,686
能够让你的用户


887
00:29:29,686 --> 00:29:31,546
直接进入到


888
00:29:31,546 --> 00:29:33,336
通知设置 UI


889
00:29:33,336 --> 00:29:35,056
这正是他们想寻找的


890
00:29:35,056 --> 00:29:37,096
细化控制的地方


891
00:29:37,096 --> 00:29:39,836
你可以了解更多


892
00:29:39,836 --> 00:29:41,576
关于通知的内容


893
00:29:41,576 --> 00:29:43,266
在通知的新功能会议


894
00:29:43,476 --> 00:29:45,076
和使用分组通知会议


895
00:29:45,226 --> 00:29:45,866
它们会在这周晚些时候


896
00:29:46,906 --> 00:29:48,086
这就是关于通知的内容


897
00:29:49,006 --> 00:29:52,516
下面是信息


898
00:29:52,586 --> 00:29:54,856
iOS 12 里的信息


899
00:29:54,856 --> 00:29:56,336
加入了一些很有意思的


900
00:29:56,336 --> 00:29:57,396
相机的新特点


901
00:29:58,166 --> 00:29:59,426
你也可以把


902
00:29:59,426 --> 00:30:01,126
iMessage 里的表情包


903
00:30:01,126 --> 00:30:02,316
直接导入相机


904
00:30:02,916 --> 00:30:04,006
如果你在用


905
00:30:04,046 --> 00:30:05,696
Xcode 表情包模板


906
00:30:05,696 --> 00:30:07,196
这会默认自动发生


907
00:30:07,196 --> 00:30:07,976
你不用再做什么


908
00:30:08,116 --> 00:30:11,776
但是如果你想用


909
00:30:11,776 --> 00:30:14,336
MSMessagesAppView 控制器


910
00:30:14,376 --> 00:30:15,376
创建一个更加个性化的表情包体验


911
00:30:15,376 --> 00:30:17,726
就需要做一些
 
00:30:17,726 --> 00:30:18,846
简单的调试


912
00:30:18,846 --> 00:30:21,076
有一个新的 API


913
00:30:21,116 --> 00:30:22,786
MSMessagesSupportedPresentationContexts 


914
00:30:22,786 --> 00:30:25,166
你可以添加到你的


915
00:30:25,166 --> 00:30:27,436
用户 info.plist


916
00:30:27,436 --> 00:30:28,786
指定同时在


917
00:30:28,786 --> 00:30:30,446
信息语境和


918
00:30:30,446 --> 00:30:31,326
媒体语境显示


919
00:30:32,076 --> 00:30:33,506
完成之后


920
00:30:33,506 --> 00:30:34,706
你的 App 会显示在


921
00:30:34,706 --> 00:30:38,176
AppStrip 和相机里


922
00:30:39,046 --> 00:30:40,696
如果在运行时


923
00:30:40,696 --> 00:30:41,956
你想要知道


924
00:30:41,956 --> 00:30:43,596
你在哪个语境下


925
00:30:43,596 --> 00:30:45,076
以便你能够定制


926
00:30:45,076 --> 00:30:46,646
你的表情包


927
00:30:46,646 --> 00:30:48,036
有一个新的 API 可以做到


928
00:30:48,676 --> 00:30:51,316
通过查看


929
00:30:51,316 --> 00:30:52,586
PresentationContext


930
00:30:52,586 --> 00:30:54,246
你可以很快知道你在


931
00:30:55,176 --> 00:30:56,026
信息还是相机


932
00:30:56,176 --> 00:30:57,526
除了这些 


933
00:30:57,526 --> 00:31:01,456
iOS 12 还给信息 App


934
00:31:01,456 --> 00:31:02,396
新的交互方式


935
00:31:02,906 --> 00:31:05,746
在紧凑模式下


936
00:31:05,906 --> 00:31:07,506
之前把信息 App


937
00:31:07,506 --> 00:31:09,106
水平往下滑


938
00:31:09,156 --> 00:31:10,066
就会在 App 间切换


939
00:31:10,746 --> 00:31:13,146
在 iOS 12


940
00:31:13,206 --> 00:31:14,416
这些水平滑动


941
00:31:14,416 --> 00:31:15,576
以及水平移动的互动


942
00:31:15,576 --> 00:31:17,136
可以直接


943
00:31:17,206 --> 00:31:19,106
在你的 App 里使用


944
00:31:19,206 --> 00:31:20,506
所以就会和你的 App 互动


945
00:31:20,506 --> 00:31:22,286
而不是换成其他 App


946
00:31:23,106 --> 00:31:24,196
这就是关于信息的内容


947
00:31:25,096 --> 00:31:27,196
接下来是


948
00:31:27,246 --> 00:31:29,526
自动填入密码和安全码


949
00:31:30,596 --> 00:31:33,936
iOS 11 首先引入


950
00:31:34,296 --> 00:31:39,176
为 App 自动填入密码


951
00:31:39,176 --> 00:31:40,796
在 iOS 12 里


952
00:31:40,796 --> 00:31:42,186
我们又进了一步


953
00:31:42,786 --> 00:31:45,296
让我们暂时


954
00:31:45,296 --> 00:31:46,436
先回到开头


955
00:31:46,436 --> 00:31:48,586
看一下整个体验


956
00:31:49,146 --> 00:31:51,996
如果用户把密码


957
00:31:51,996 --> 00:31:54,186
储存在 iCloud Keychain


958
00:31:54,266 --> 00:31:55,726
从 iOS 11 开始


959
00:31:55,726 --> 00:31:56,796
这些密码就可以


960
00:31:56,866 --> 00:31:58,556
自动填入到你的 App 的


961
00:31:58,556 --> 00:31:59,406
登录流程


962
00:32:00,146 --> 00:32:02,206
在 iOS 12 里


963
00:32:02,206 --> 00:32:04,596
这些密码可以通过两种形式


964
00:32:04,686 --> 00:32:06,506
储存到 iCloud Keychain


965
00:32:06,506 --> 00:32:09,006
从登录窗口流程


966
00:32:09,006 --> 00:32:10,926
和改变密码请求 UI


967
00:32:10,926 --> 00:32:12,086
都可以


968
00:32:13,296 --> 00:32:14,666
当用户登录后


969
00:32:14,956 --> 00:32:16,156
会弹出提示


970
00:32:16,156 --> 00:32:17,626
储存密码到 iCloud Keychain


971
00:32:18,436 --> 00:32:20,226
在 iOS 12 里可以


972
00:32:20,226 --> 00:32:22,146
在新帐户流程


973
00:32:22,486 --> 00:32:25,026
和改密码流程


974
00:32:25,026 --> 00:32:26,496
自动生成密码


975
00:32:26,896 --> 00:32:28,536
这个很容易采用


976
00:32:28,896 --> 00:32:29,886
你只需要确保


977
00:32:29,936 --> 00:32:31,996
你的密码字段标记了


978
00:32:32,116 --> 00:32:33,856
要么是密码文本内容类型


979
00:32:33,856 --> 00:32:35,906
如果是登录字段


980
00:32:35,906 --> 00:32:37,726
要么是新密码文本内容类型


981
00:32:37,726 --> 00:32:39,146
如果是新帐户


982
00:32:39,146 --> 00:32:40,696
或者是更改密码字段


983
00:32:41,336 --> 00:32:45,226
如果你对密码


984
00:32:45,226 --> 00:32:47,166
有特别的要求


985
00:32:47,166 --> 00:32:49,056
比如有必须出现


986
00:32:49,096 --> 00:32:51,226
或者不能出现的字符


987
00:32:51,226 --> 00:32:55,026
又或者对重复字符


988
00:32:55,026 --> 00:32:56,586
有上限要求


989
00:32:56,586 --> 00:32:58,026
你也可以标明这些规则


990
00:32:58,026 --> 00:33:00,526
这样自动生成的密码


991
00:33:00,526 --> 00:33:02,256
就可以满足


992
00:33:02,256 --> 00:33:03,426
你所有的要求


993
00:33:04,146 --> 00:33:06,946
登录的时候


994
00:33:06,946 --> 00:33:07,896
也许会遇到的


995
00:33:07,896 --> 00:33:09,706
另外一个小麻烦就是


996
00:33:09,706 --> 00:33:10,716
当你需要把验证码


997
00:33:10,716 --> 00:33:12,426
从信息里复制出来


998
00:33:12,426 --> 00:33:15,226
然后放入 App


999
00:33:15,226 --> 00:33:17,496
IOS 12 让这一步变得非常容易


1000
00:33:17,496 --> 00:33:19,046
它会自动识别


1001
00:33:19,046 --> 00:33:21,216
这类通知


1002
00:33:21,326 --> 00:33:23,176
记录里面的安全码


1003
00:33:23,176 --> 00:33:24,416
然后显示在


1004
00:33:24,416 --> 00:33:25,796
快速键入候选栏里


1005
00:33:25,836 --> 00:33:27,156
这样很容易就可以


1006
00:33:27,186 --> 00:33:27,656
输入进 App


1007
00:33:28,506 --> 00:33:29,466
为了让这个特性可行


1008
00:33:29,526 --> 00:33:30,726
你唯一需要做的


1009
00:33:30,726 --> 00:33:32,086
就是确保


1010
00:33:32,086 --> 00:33:34,126
你使用的是标准的


1011
00:33:34,126 --> 00:33:37,126
iOS text interaction API


1012
00:33:37,196 --> 00:33:40,786
来接收这些内容


1013
00:33:40,866 --> 00:33:42,126
这些新特性


1014
00:33:42,316 --> 00:33:44,196
使得 iOS 12 可以让你


1015
00:33:44,286 --> 00:33:47,456
使用每项服务


1016
00:33:47,686 --> 00:33:49,546
都可以有更安全又独特的密码


1017
00:33:49,626 --> 00:33:51,426
而你完全不需要


1018
00:33:51,426 --> 00:33:52,996
记住或者打出来


1019
00:33:52,996 --> 00:33:55,636
更多的内容


1020
00:33:55,636 --> 00:33:57,036
在这周晚些时候的


1021
00:33:57,176 --> 00:33:58,426
自动增强密码和自动填入安全码会议


1022
00:33:58,426 --> 00:34:01,096
会有介绍


1023
00:34:01,576 --> 00:34:04,286
最后的 API 改进话题


1024
00:34:04,286 --> 00:34:05,826
其实有一点回顾性质


1025
00:34:05,826 --> 00:34:08,366
但是我们添加了一些内容


1026
00:34:09,505 --> 00:34:11,356
在 iOS 11 里 我们引入了


1027
00:34:11,356 --> 00:34:12,176
安全区域嵌入


1028
00:34:12,766 --> 00:34:14,666
安全区域嵌入能够


1029
00:34:14,775 --> 00:34:16,716
很好地用来


1030
00:34:16,716 --> 00:34:19,446
确保你的内容不会和


1031
00:34:19,596 --> 00:34:21,525
其他用户界面的部分重叠


1032
00:34:21,525 --> 00:34:24,576
例如屏幕顶端和下部的栏


1033
00:34:25,906 --> 00:34:27,755
在 iPhone 这个很好用


1034
00:34:27,755 --> 00:34:28,726
因为栏都比较


1035
00:34:28,726 --> 00:34:30,886
简单 但其实


1036
00:34:30,976 --> 00:34:31,936
它也很强大


1037
00:34:32,565 --> 00:34:34,005
安全区域嵌入


1038
00:34:34,076 --> 00:34:35,426
为你 App 的


1039
00:34:35,426 --> 00:34:37,596
任何本地坐标空间


1040
00:34:37,596 --> 00:34:39,795
提供安全区域坐标


1041
00:34:39,795 --> 00:34:41,266
所以可以应用于


1042
00:34:41,266 --> 00:34:43,646
更复杂的界面


1043
00:34:43,646 --> 00:34:45,466
比如 iPad 分屏视图


1044
00:34:45,755 --> 00:34:48,346
分屏视图的主视图和


1045
00:34:48,346 --> 00:34:49,706
细节部分


1046
00:34:49,706 --> 00:34:50,186
包含不同高度的栏


1047
00:34:50,735 --> 00:34:54,116
安全区域嵌入确保


1048
00:34:54,116 --> 00:34:55,326
在任何视图下的


1049
00:34:55,326 --> 00:34:56,426
所在分屏内


1050
00:34:56,426 --> 00:34:59,156
都不会被这些栏覆盖


1051
00:35:01,156 --> 00:35:02,606
所以在长方形屏幕的设备上


1052
00:35:02,606 --> 00:35:04,366
这个很好用


1053
00:35:04,866 --> 00:35:06,906
但是在非长方形屏幕


1054
00:35:06,906 --> 00:35:07,946
比如 iPhone X 上


1055
00:35:08,126 --> 00:35:10,286
它也同样强大


1056
00:35:11,676 --> 00:35:12,986
跟有 home 键的设备相比


1057
00:35:12,986 --> 00:35:14,916
我们可以看到


1058
00:35:14,916 --> 00:35:16,236
顶部和底部的栏


1059
00:35:16,236 --> 00:35:17,066
都比较大


1060
00:35:17,686 --> 00:35:19,956
显然安全区域嵌入


1061
00:35:19,956 --> 00:35:21,286
适应了这个尺寸


1062
00:35:21,946 --> 00:35:23,796
iPhone X 特殊的是


1063
00:35:23,846 --> 00:35:25,746
没有栏显示的时候


1064
00:35:25,746 --> 00:35:27,226
安全区域嵌入依然存在


1065
00:35:27,296 --> 00:35:29,586
这同样适用于


1066
00:35:29,586 --> 00:35:31,806
横屏模式


1067
00:35:31,806 --> 00:35:32,826
这样可以确保 


1068
00:35:32,826 --> 00:35:34,596
你可以有一个长方形区域


1069
00:35:34,596 --> 00:35:36,426
来显示内容


1070
00:35:36,426 --> 00:35:40,846
而不会被截出去


1071
00:35:41,036 --> 00:35:43,426
所以我想感谢


1072
00:35:43,426 --> 00:35:44,856
所有采用


1073
00:35:44,956 --> 00:35:46,256
安全区域嵌入


1074
00:35:46,256 --> 00:35:48,306
和为 iPhone X 更新 App 的各位


1075
00:35:48,536 --> 00:35:49,806
过去的几年里


1076
00:35:49,806 --> 00:35:51,076
都有很好的体验


1077
00:35:51,146 --> 00:35:52,326
而且我相信你们大多数


1078
00:35:52,326 --> 00:35:52,996
已经这么做了


1079
00:35:53,536 --> 00:35:55,206
如果还没有


1080
00:35:55,206 --> 00:35:56,176
现在是个好时机


1081
00:35:56,836 --> 00:35:57,986
你们的用户


1082
00:35:57,986 --> 00:35:59,466
一定更喜欢与时俱进的 App


1083
00:35:59,466 --> 00:36:01,716
配合 iPhone X 更新


1084
00:36:01,756 --> 00:36:03,256
能够很好的


1085
00:36:03,256 --> 00:36:04,596
体现这一点


1086
00:36:05,166 --> 00:36:06,606
所以如果还没有


1087
00:36:06,606 --> 00:36:07,126
赶紧去更新吧


1088
00:36:07,126 --> 00:36:08,626
为了确保


1089
00:36:08,626 --> 00:36:10,136
你能够得到所有需要的信息


1090
00:36:10,136 --> 00:36:13,526
请关注这周晚些时候的


1091
00:36:13,526 --> 00:36:15,226
适用所有大小和形状的 UIKit App 会议


1092
00:36:15,446 --> 00:36:16,616
这个课程会给你讲


1093
00:36:16,616 --> 00:36:18,486
安全区域嵌入


1094
00:36:18,486 --> 00:36:22,336
和其他相关的嵌入 API 的内容


1095
00:36:22,336 --> 00:36:23,616
确保你的 App


1096
00:36:23,676 --> 00:36:27,836
能够适应所有的大小和形状


1097
00:36:28,086 --> 00:36:29,186
这就是关于框架更新


1098
00:36:29,816 --> 00:36:31,686
和 API 改进的所有内容


1099
00:36:31,986 --> 00:36:33,606
接下来 我们再说一下


1100
00:36:33,606 --> 00:36:34,296
Siri 捷径


1101
00:36:34,986 --> 00:36:37,056
Siri 捷径是


1102
00:36:37,056 --> 00:36:39,316
iOS 12 里的一个很棒的新 API


1103
00:36:41,516 --> 00:36:42,886
Siri 捷径


1104
00:36:42,886 --> 00:36:44,716
可以让 App 的常用操作


1105
00:36:45,416 --> 00:36:48,096
通过 Siri 很容易地调用


1106
00:36:49,526 --> 00:36:50,726
Siri 捷径


1107
00:36:50,726 --> 00:36:52,646
可以在封面


1108
00:36:52,646 --> 00:36:54,286
预先显示


1109
00:36:54,416 --> 00:36:55,466
以便在你希望的


1110
00:36:55,466 --> 00:36:57,426
时间和地点


1111
00:36:57,426 --> 00:37:00,436
访问常用操作


1112
00:37:00,606 --> 00:37:01,866
他们还可以


1113
00:37:01,866 --> 00:37:03,456
显示在 Apple Watch 的


1114
00:37:03,456 --> 00:37:05,126
Siri watch face 上


1115
00:37:06,696 --> 00:37:08,246
Siri 操作不光可以


1116
00:37:08,276 --> 00:37:09,916
预先显示


1117
00:37:09,916 --> 00:37:11,236
还可以设置成


1118
00:37:11,236 --> 00:37:13,596
用个性化声音短语执行


1119
00:37:17,256 --> 00:37:19,296
给你的 App 添加


1120
00:37:19,296 --> 00:37:21,786
Siri 行为支持非常容易


1121
00:37:21,786 --> 00:37:22,946
有两个 API 可以用


1122
00:37:23,266 --> 00:37:24,826
NSUserActivity


1123
00:37:24,826 --> 00:37:26,306
你可能已经为了支持


1124
00:37:26,306 --> 00:37:28,916
接力和聚焦整合


1125
00:37:28,916 --> 00:37:29,886
开始使用它了


1126
00:37:30,356 --> 00:37:32,016
还有一个 Siri Intents 支持


1127
00:37:32,016 --> 00:37:33,346
为了应对更复杂的情况


1128
00:37:33,396 --> 00:37:35,316
例如有更多的


1129
00:37:35,316 --> 00:37:36,246
个性化互动时


1130
00:37:36,816 --> 00:37:38,156
我们先看一下


1131
00:37:38,156 --> 00:37:38,606
NSUserActivity


1132
00:37:39,406 --> 00:37:40,466
我刚才说过


1133
00:37:40,466 --> 00:37:42,056
NSUserActivity 对接力和聚焦


1134
00:37:42,056 --> 00:37:43,856
是一个常见的 API


1135
00:37:43,856 --> 00:37:45,116
当你的 Siri 捷径


1136
00:37:45,116 --> 00:37:46,826
需要把你的用户


1137
00:37:46,826 --> 00:37:48,416
转回 App 中一个特定位置时


1138
00:37:48,466 --> 00:37:50,116
这个 API 也很有用


1139
00:37:50,316 --> 00:37:51,516
比如加载一个特定的


1140
00:37:51,516 --> 00:37:54,226
信息或者文件


1141
00:37:54,226 --> 00:37:55,056
这跟你切换到


1142
00:37:55,056 --> 00:37:56,516
另一个设备时是一样的


1143
00:37:57,176 --> 00:37:58,706
如果你已经这么做了


1144
00:37:58,806 --> 00:38:00,336
为 Siri 捷径添加支持


1145
00:38:00,336 --> 00:38:01,256
非常容易


1146
00:38:01,516 --> 00:38:02,696
只需要把 EligibleforPrediction


1147
00:38:02,696 --> 00:38:03,686
设置为 true


1148
00:38:04,096 --> 00:38:05,116
要是你还没有这么做


1149
00:38:05,116 --> 00:38:06,596
如果你的捷径


1150
00:38:06,776 --> 00:38:07,816
符合这几个类别


1151
00:38:07,816 --> 00:38:08,486
那这样做或很好


1152
00:38:09,836 --> 00:38:11,846
如果你的 App 有


1153
00:38:11,846 --> 00:38:13,426
更多的个性化需求


1154
00:38:13,426 --> 00:38:14,886
或者你就是想要更好地控制


1155
00:38:14,886 --> 00:38:16,856
你可以采用 SiriKit Intents API


1156
00:38:17,836 --> 00:38:18,986
SiriKit Intents 提供  


1157
00:38:18,986 --> 00:38:20,636
很多预先设定的 Intent


1158
00:38:20,796 --> 00:38:22,966
你可以很简单地采用


1159
00:38:23,036 --> 00:38:24,456
这跟前几年的


1160
00:38:24,456 --> 00:38:25,866
SiriKit Intents 是一样的


1161
00:38:26,666 --> 00:38:27,696
如果你的 App 有


1162
00:38:27,896 --> 00:38:29,396
更多的个性化行为


1163
00:38:29,396 --> 00:38:30,966
在 iOS 12 你可以定义


1164
00:38:30,966 --> 00:38:32,936
你自己的个性化 Intent


1165
00:38:33,736 --> 00:38:35,176
个性化 Intent


1166
00:38:35,216 --> 00:38:36,696
可以很灵活


1167
00:38:36,696 --> 00:38:37,336
满足你的要求


1168
00:38:37,846 --> 00:38:38,956
这里 我创建了一个


1169
00:38:38,956 --> 00:38:40,526
来帮助我做明年的


1170
00:38:40,526 --> 00:38:41,296
WWDC 幻灯片


1171
00:38:42,436 --> 00:38:45,066
放置你的 Intent 的类别


1172
00:38:45,066 --> 00:38:45,966
其实非常广泛


1173
00:38:46,236 --> 00:38:48,236
这里我用的是创建类别


1174
00:38:48,766 --> 00:38:50,306
但是如果你的 Intent


1175
00:38:50,306 --> 00:38:51,866
比这个还宽泛


1176
00:38:51,866 --> 00:38:53,046
有更加宽泛的选择


1177
00:38:53,046 --> 00:38:56,336
比如运行和开始


1178
00:38:57,776 --> 00:38:59,266
创建好你的 Intent 之后


1179
00:38:59,266 --> 00:39:01,586
你还希望你的用户可以


1180
00:39:01,586 --> 00:39:02,916
很容易地创建


1181
00:39:02,916 --> 00:39:03,426
个性化捷径


1182
00:39:03,926 --> 00:39:05,526
现在你的 App 里


1183
00:39:05,526 --> 00:39:06,796
有一个 API 可以让


1184
00:39:06,796 --> 00:39:08,396
你的用户创建


1185
00:39:08,466 --> 00:39:09,466
个性化声音捷径


1186
00:39:09,876 --> 00:39:10,816
这个按键可以


1187
00:39:10,816 --> 00:39:12,066
打开一个新的面板


1188
00:39:12,326 --> 00:39:14,336
操作完之后


1189
00:39:14,336 --> 00:39:15,956
可以在我的 App 里


1190
00:39:16,036 --> 00:39:17,346
创建一个新的捷径


1191
00:39:17,936 --> 00:39:18,666
所以如果你在


1192
00:39:18,666 --> 00:39:19,716
早上点咖啡


1193
00:39:19,716 --> 00:39:21,326
然后你觉得这是


1194
00:39:22,086 --> 00:39:23,756
以后可能会重复的事情


1195
00:39:23,756 --> 00:39:25,176
这是个很好的机会


1196
00:39:25,176 --> 00:39:27,186
来创建一个


1197
00:39:27,266 --> 00:39:28,736
Siri 捷径 以便下次使用


1198
00:39:29,616 --> 00:39:30,596
你还可以


1199
00:39:30,596 --> 00:39:32,066
把这些捷径结合在一起


1200
00:39:32,066 --> 00:39:35,196
用 App Store 里的捷径 App


1201
00:39:35,696 --> 00:39:37,176
所有这些


1202
00:39:37,176 --> 00:39:38,056
和更多内容


1203
00:39:38,056 --> 00:39:40,326
会在这周晚些时候的


1204
00:39:40,856 --> 00:39:41,776
Siri 捷径介绍


1205
00:39:41,776 --> 00:39:44,006
创建声音 Siri 捷径


1206
00:39:44,006 --> 00:39:45,326
和 Siri Watch Face 上的 Siri 捷径


1207
00:39:45,526 --> 00:39:45,976
会议了解到


1208
00:39:46,136 --> 00:39:48,886
今天我们说了很多


1209
00:39:48,886 --> 00:39:50,376
iOS 12 的新功能


1210
00:39:50,466 --> 00:39:52,796
不过还有一些会议


1211
00:39:52,796 --> 00:39:54,076
很值得一提


1212
00:39:54,076 --> 00:39:56,286
虽然可能讲的不是新功能


1213
00:39:56,886 --> 00:39:58,386
如果你刚开始


1214
00:39:58,386 --> 00:40:00,386
为 iOS 创建 App


1215
00:40:00,386 --> 00:40:01,296
有一个很好的会议叫


1216
00:40:01,296 --> 00:40:03,556
我有一个关于 App 的想法


1217
00:40:03,796 --> 00:40:05,366
一定要去


1218
00:40:06,426 --> 00:40:07,516
如果你已经有一个 App 了


1219
00:40:07,516 --> 00:40:08,636
只是想更加完善


1220
00:40:08,636 --> 00:40:10,106
也有一些很好的


1221
00:40:10,106 --> 00:40:11,776
会议推荐


1222
00:40:11,776 --> 00:40:13,646
UI Collection View 介绍


1223
00:40:13,646 --> 00:40:14,996
和为你的 iOS App 添加乐趣


1224
00:40:15,846 --> 00:40:17,516
非常感谢


1225
00:40:17,516 --> 00:40:18,946
你们今天来到这里


1226
00:40:19,406 --> 00:40:20,266
希望在实验室再次看到你们


1227
00:40:20,266 --> 00:40:21,766
祝你们拥有


1228
00:40:21,846 --> 00:40:22,576
愉快的一周 谢谢


1229
00:40:23,516 --> 00:40:30,570
[ 掌声 ]

